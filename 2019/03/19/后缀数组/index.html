
<!DOCTYPE html>
<html lang="en">


  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#202020" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

    
      <meta name="keywords" content="提高算法,字符串,后缀数组," />
      

          
              <meta name="description"
                content="后缀数组" />
              

                <link rel="icon" type="image/x-icon" href="/logo.ico">
                <title>
                  后缀数组lyh&#39;s blog
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/xoxo.css">
                    
                      
  <meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <span class="title">
      lyh&#39;s blog
    </span>
  </a>

  <ul class="pure-menu-list clearfix">
    
      
          <li class="pure-menu-item"><a href="/" class="pure-menu-link">
              Home
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">
              Archives
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">
              Tags
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/search" class="pure-menu-link">
              Search
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/about" class="pure-menu-link">
              About
            </a></li>
          
            
  </ul>

</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        后缀数组
      </h1>
      <span>
        
          <time class="time" datetime="2019-03-19T08:37:35.000Z">
            2019-03-19
          </time>
          
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
        <span class="post-tags">
          <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" rel="tag">后缀数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8F%90%E9%AB%98%E7%AE%97%E6%B3%95/" rel="tag">提高算法</a></li></ul>
        </span>
      </span>
      <!-- <span class="slash">/</span> -->
      <!-- <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span> -->
      <span class="slash">/</span>
      <span class="read">阅读耗时 93 分钟</span>
    </header>

    <div class="post-content">
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后缀数组是一类应用在字符串中的算法。本文改自<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zwfymqz/p/8413523.html">这篇博客</a>，下面的代码基于<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3809">这个题目</a>。<br><span id="more"></span></p>
<h3 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在KMP匹配算法中已经提及。对于字符串abcde，它的后缀为abcde、bcde、…、de、e，这里的后缀是可以含本身的。</p>
<h3 id="后缀字典序"><a href="#后缀字典序" class="headerlink" title="后缀字典序"></a>后缀字典序</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字典序排列是两个字符串之间进行排列比较的手段，它的做法是从左到右依次比较两个字符串的对应位置，ascii码较小的一个字典序更小。如果到某一个字符串已经比较到结尾，则长度较小的一个字典序更小。例如ab&lt;ac，ab&lt;abc。</p>
<h3 id="后缀数组及其求法"><a href="#后缀数组及其求法" class="headerlink" title="后缀数组及其求法"></a>后缀数组及其求法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是后缀数组。对于一个字符串的所有后缀，我们将它们按照字典序从小到大排列，并开一个数组sa使得sa[i]为排名为i的后缀在原字符串中的起始位置（为简便起见，在下文中称为位置。排名从1开始，原字符串下标也从1开始），这个sa数组就称为后缀数组（Suffix Array ，SA）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于后缀的长度各不相同，它们的字典序序号必然各不相同。此时构造一个数组rk为sa数组的反射，即rk[i]表示位置为i的后缀的排名。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨后缀数组的构造方法，这里只介绍倍增方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种简单粗暴的方法就是直接快排，时间复杂度为$O(n^2logn)$，显然不可行，倍增算法可以将其优化到$O(nlogn)$复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倍增的思想：将字符串看成两部分：前半部分和后半部分。这样字符串就成为了一个二元组，前半部分为第一关键字，后半部分为第二关键字。如果我们已经求出第一关键字的排名，并求出了第二关键字的相对位置，那么总的排序序列就可以被求出了。之后再将前后两部分看成一个整体，作为下一次运算的前半部分，依次递归进行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，采用数组tp来当做第二关键字，它的作用与sa类似：tp[i]表示第二关键字排名为i的后缀的位置。第一关键字用rk数组来充当。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先第一步：将每一个后缀按首位字符排序，第一关键字为首字符ascii码，第二关键字为首字符的下标。这里的第二关键字就是tp数组，事实上只要tp数组构成{1..n}-&gt;{1..n}的双射即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i] - <span class="string">&#x27;0&#x27;</span>, tp[i] = n - i + <span class="number">1</span>;<span class="comment">//op是原字符串</span></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面进行排序，<strong>排序即是根据rk和tp数组对sa数组进行修改</strong>。对于排序的详细操作留在文末，继续看倍增操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里sa中已经记录了按照首字符排列的序列信息，下面考虑倍增。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n;w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w是指目前已经按照w大小进行排序（比如一开始只按首字符排序，故w=1），p暂且不用管它。每一次循环之后都需要w自乘2。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面是循环体中的第一部分代码，这里p用来记录排名。这三行代码的作用是求出第二关键字的相对排名，根据倍增思想，充当第二关键字的字符串长度也应为w。对于一个后缀，我们已经求出了它前w的字符作为关键字的排名，现在要求再向后w个字符的相对排名。这时可以发现有些后缀是没有第二关键字的，比如位置为n、n-1、…、n-w+1的后缀就没有第二关键字。这里的没有是指完全没有，部分没有的后缀不计入其中。对于这些没有第二关键字的后缀，根据字典序的定义，它们在按照第二关键字排序时应该排到前面，因次第一个for循环将末尾那些不存在第二关键字的后缀首先进行了排名。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步是很精妙的操作。容易发现位置为i的后缀的第二关键字恰好就是位置为i+w的后缀的第一关键字，而后者的相对位置已经确定，那么不妨就根据这个关系更新第二关键字的相对位置。第二个for循环中，从排名第1的后缀开始遍历，凡是满足sa[i]&gt;w的后缀（sa[i]&gt;w表示这个后缀的前面必有一个第二关键字与它第一关键字相同的后缀），更新它的第二关键字排名。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样第二关键字的tp数组也被求出，在利用已经求出的rk数组，可以再进行一步排序来更新sa，排序的详细步骤仍然留到最后。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是下一次倍增中需要rk数组，rk数组还没有更新，因此下面需要更新rk数组。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面已经提到，rk数组是sa数组的反射，其实这种说法并不准确。在整个过程结束后，rk数组确实是sa数组的反射，但在求解过程中并不是。sa数组储存排名为i的后缀的位置，这是一个从排名到后缀的双射。也就是说，对于我们目前的排序关键字，可能存在“完全相同”的两个后缀，它们在sa数组中是得不到体现的（虽然排名一定靠着），在更新rk数组时要留意这一点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>更新rk数组时需要留意相同的后缀，并给它们相同的排名</strong>，即两个后缀的rk值可能相同。容易发现，当所有后缀的rk值两两不同时，说明后缀数组构造完毕，此时结束循环，这也是判断后缀数组构造完成的指标。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定两个后缀相同可以用如下方法判定：第一关键字排名（rk）值相同并且第二关键字排名（rk）值相同，这样就可以判定它们第一关键字和第二关键字都相同，两个后缀在当前关键字下便相同。这里需要上一次的rk数组，但同时又要更新rk数组，为了防止混淆，我们将rk数组复制到tp中，此时tp数组已经没用了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是更新rk的核心代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里p的意义是记录互不相同的排名数量，当p=n时所有后缀排名互不相同，结束循环，这也是上文中for循环的终止条件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的for循环利用相同后缀排名必相同的性质，将每一个后缀都与前一个后缀进行比较，如果第一关键字排名相同并且第二关键字排名相同则与上一个后缀的排名相同，否则分配一个新排名。这里的第二关键字排名仍然用上文所说的性质。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在可以来探讨排序的方法，这里采用基数排序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tax是基数排序用的桶，<strong>M是第一关键字的最大取值</strong>，由于第一关键字是排名信息，可以设置成1e6+5（按照题目条件）。第一个for循环将桶清空。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个for循环将第一关键字的信息放入桶中，统计数目。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个for循环求前缀和，这是为了方便求排名。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四个for循环较难理解。倒序遍历后缀，由于已经求了前缀和，这时的tax值就是排名，之后用自减一的方式将其从桶中取出。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外这里有一处优化。M由于是第一关键字的最大值，因此可以根据每一次循环的p值来修改M，以降低时间复杂度。注意一开始第一关键字的最大值是’z’-‘0’。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就得到了求后缀数组的完整步骤，下面给出模板题代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000000+20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M;</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>, tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; sa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; op + <span class="number">1</span>;</span><br><span class="line">    n = <span class="built_in">strlen</span>(op + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>UPD：如果需要在一个程序中多次使用该算法，需要清空tp数组。</strong></p>
<h3 id="height数组"><a href="#height数组" class="headerlink" title="height数组"></a>height数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height数组是应用后缀数组的利器。首先定义最长公共前缀lcp(i,j)：位置为i和位置为j的后缀的最长公共前缀长度。于是有height数组：</p>
<script type="math/tex; mode=display">height[i]=lcp(sa[i],sa[i-1])</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，height[i]表示排名为i和排名为i-1的后缀的最长公共前缀长度。规定height[1]=0。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求height数组？这需要利用一个重要性质（证明略）：</p>
<script type="math/tex; mode=display">height[rk[i]]\geq height[rk[i-1]]-1</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以此递推，不难写出代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="后缀数组的应用"><a href="#后缀数组的应用" class="headerlink" title="后缀数组的应用"></a>后缀数组的应用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对后缀进行字典序排序实质上是利用了排序后相邻后缀差异尽可能小的性质，利用这个性质可以解决很多问题。</p>
<h4 id="两个后缀的最大公共前缀"><a href="#两个后缀的最大公共前缀" class="headerlink" title="两个后缀的最大公共前缀"></a>两个后缀的最大公共前缀</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于位置为i、j的两个后缀，其最大公共前缀长度为：</p>
<script type="math/tex; mode=display">\min\{height[rk[i]+1],height[rk[i]+2],...,height[rk[j]]\},rk[i]<rk[j]</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用ST表去维护。</p>
<h4 id="可重叠最长重复子串"><a href="#可重叠最长重复子串" class="headerlink" title="可重叠最长重复子串"></a>可重叠最长重复子串</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果子串p在主串s中出现多次，则称p为重复子串，如果两个p可以有所重叠，在此基础上可以得到最长重复子串。该长度就是height数组的最大值。</p>
<h4 id="不可重叠最长重复子串"><a href="#不可重叠最长重复子串" class="headerlink" title="不可重叠最长重复子串"></a>不可重叠最长重复子串</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑二分答案。对于答案k，可以将排序后的后缀分成若干组，其中每一组相邻的后缀间height都不小于k。这里的后缀分组必定是连续的分组。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知道可以使答案可行的后缀必存在与同一组中，但还要满足不重叠的性质。此时遍历每一个组，找到该组中最大的sa值和最小的sa值，如果存在一组最大值最小值的差不小于k，则k可行，否则不可行。时间复杂度$O(nlogn)$。</p>
<h4 id="本质不相同的子串数量"><a href="#本质不相同的子串数量" class="headerlink" title="本质不相同的子串数量"></a>本质不相同的子串数量</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个字符串有很多子串，求它们其中本质不同的子串数目可以用后缀数组轻松解决。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个子串必然是某个后缀的前缀，因此问题等价于所有后缀的本质不同的前缀数量。按字典序从小到大遍历所有后缀，这个后缀对答案的贡献为$len-sa[i]+1-height[i]$。这里$len-sa[i]+1$是这个后缀的所有前缀数目，减去height是减去重复的公共前缀数量。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在来通过一些例题来加深对后缀数组的认识。以下题目不涉及题面，可点开标题自查。</p>
<h4 id="Musical-Theme"><a href="#Musical-Theme" class="headerlink" title="Musical Theme"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=1743">Musical Theme</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;楼教主男人八题之一。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题意是给一个字符串，找其中长度至少为5，不重叠的最长相似子串。这里的相似是指两个串长度相同且对应各位的差相同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑差分。在原串中，我们求每一位与前一位的差，存入一个新串，易知新串中相同的两个串就对应原串中相似的串。那么问题转化成求新串中不可重叠最长重复子串的长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与朴素的不可重叠最长重复子串不同的是，本题还需要这两个串相差至少一个单位的距离，为什么这样请读者自行思考。但是由于本题数据过水，即使用最朴素的做法也是可以AC的。hack数据：9 1 1 1 1 1 1 1 1 1，答案为0，错误答案5。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意特判n=1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40000+20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N];</span><br><span class="line"><span class="type">int</span> op[N], op2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i] + <span class="number">88</span>, tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0x3f3f3f3f</span>, maxn = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minn == <span class="number">0x3f3f3f3f</span> || maxn == <span class="number">-0x3f3f3f3f</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maxn - minn &gt; x)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//这里不是&gt;=!!</span></span><br><span class="line">            minn = sa[i], maxn = sa[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> minn = <span class="built_in">min</span>(minn, sa[i]), maxn = <span class="built_in">max</span>(maxn, sa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minn != <span class="number">0x3f3f3f3f</span> &amp;&amp; maxn != <span class="number">-0x3f3f3f3f</span> &amp;&amp; maxn - minn &gt; x;<span class="comment">//还有这里不是&gt;=!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, op2 + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)op[i] = op2[i + <span class="number">1</span>] - op2[i];<span class="comment">//求差分</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;<span class="comment">//特判1</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --n, <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();<span class="comment">//求后缀数组以及height数组</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n + <span class="number">1</span>, mid;<span class="comment">//二分答案</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;<span class="comment">//[,)</span></span><br><span class="line">            <span class="keyword">if</span> (r == l + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= <span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid))l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Milk-Patterns"><a href="#Milk-Patterns" class="headerlink" title="Milk Patterns"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3261">Milk Patterns</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本质上是找最长k可重叠子串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分一个答案，然后将height分组，若某一个组中有不少于k个后缀，则答案可行。数据太大可以先离散化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40000+20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], op[N], k, op2[N], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">20005</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= k)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//不少于k个，答案可行</span></span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>)num = <span class="number">2</span>;<span class="comment">//这一个和上一个</span></span><br><span class="line">        <span class="keyword">else</span> ++num;<span class="comment">//加上当前的一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, op2 + i), op[i] = op2[i];</span><br><span class="line">    <span class="built_in">sort</span>(op2 + <span class="number">1</span>, op2 + n + <span class="number">1</span>), m = <span class="built_in">unique</span>(op2 + <span class="number">1</span>, op2 + n + <span class="number">1</span>) - op2 - <span class="number">1</span>;<span class="comment">//离散化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)op[i] = <span class="built_in">lower_bound</span>(op2 + <span class="number">1</span>, op2 + m + <span class="number">1</span>, op[i]) - op2;</span><br><span class="line">    <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == l + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, l);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="New-Distinct-Substrings"><a href="#New-Distinct-Substrings" class="headerlink" title="New Distinct Substrings"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/SPOJ-SUBST1">New Distinct Substrings</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是求本质不同的子串数量，在上文应用中已经提及做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50000+200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N];</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + <span class="number">1</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(op + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="built_in">getHeight</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)ans += n - sa[i] + <span class="number">1</span> - h[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Palindrome"><a href="#Palindrome" class="headerlink" title="Palindrome"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/URAL-1297">Palindrome</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找最长的回文子串串，并输出第一个。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实可以用Manacher算法直接水过去，这里提一下后缀数组做法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将原串的翻转串接到串的后面，中间加一个特殊字符相隔。问题转化求两个后缀的lcp，而求两个后缀的lcp可以用ST表维护，然后再分奇偶讨论一波即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000+200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], ST[N][<span class="number">20</span>], bin[<span class="number">20</span>], lg[N];</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getMin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rk[l] &gt; rk[r])<span class="built_in">swap</span>(l, r);</span><br><span class="line">    l = rk[l] + <span class="number">1</span>, r = rk[r];</span><br><span class="line">    <span class="type">int</span> t = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ST[l][t], ST[r - bin[t] + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), op[n + <span class="number">1</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)op[n + <span class="number">1</span> + i] = op[n - i + <span class="number">1</span>];<span class="comment">//拼接字符串</span></span><br><span class="line">    n = n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)ST[i][<span class="number">0</span>] = h[i];<span class="comment">//建立ST表</span></span><br><span class="line">    lg[<span class="number">0</span>] = <span class="number">-1</span>, bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++)bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + bin[i] - <span class="number">1</span> &lt;= n)ST[j][i] = <span class="built_in">min</span>(ST[j][i - <span class="number">1</span>], ST[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">max</span>((<span class="built_in">getMin</span>(i, n + <span class="number">1</span> - i) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, <span class="built_in">getMin</span>(i, n + <span class="number">2</span> - i) &lt;&lt; <span class="number">1</span>);<span class="comment">//前者是奇数情况，后者偶数</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; ans)ans = s, pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans % <span class="number">2</span>)<span class="keyword">for</span> (<span class="type">int</span> i = pos - ((ans + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>; i &lt; (pos + ((ans + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)); i++)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, op[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> i = pos - (ans &gt;&gt; <span class="number">1</span>); i &lt; (pos + (ans &gt;&gt; <span class="number">1</span>)); i++)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, op[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Power-Strings"><a href="#Power-Strings" class="headerlink" title="Power Strings"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2406">Power Strings</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个用SA也是能做的，但是用倍增会T，应该用DC3算法（然而我不会），于是这里就先说说kmp做法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对串求next数组，然后可以发现最后一个next就是整个串的最长相同前后缀长度，如果$n-next[n]$能够将$n$整除，那么答案就是$\frac {n} {n-next[x]}$，否则为1。真的是很巧妙的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> nxt[<span class="number">1000005</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>] = nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[j] == str[i - <span class="number">1</span>])nxt[i++] = ++j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)nxt[i++] = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> j = nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = <span class="built_in">strlen</span>(str), <span class="built_in">findNext</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % (n - nxt[n]) == <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n / (n - nxt[n]));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="Maximum-repetition-substring"><a href="#Maximum-repetition-substring" class="headerlink" title="Maximum repetition substring"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3693">Maximum repetition substring</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求重复指数最大的子串，并输出字典序最小的一个。重复指数的意义和上题相同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举重复的子串长度，这里只考虑出现两次及以上的情况。易知如果一个子串是有长度为$l$的串重复拼接得到的，那么它必定包含字符$str[1]、str[1+l]、str[1+2l]…$这些字符中相邻的两个，并且它们是相同的。求出$height$并用$RMQ$找出$lcp(i,i+l)$，重复次数就是$lcp(i,i+l)/l+1$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样会使答案偏小，这是因为在$i$之前这个串的重复可能就已经开始了。考虑求$lcp(i,i+l)\%l$，若这个值为0，则易知向前挪一段位置也不会使答案增加，故这种情况不用考虑。当其不为0时，向前挪动$i$，使其到达$i-lcp(i,i+l)\%l$的位置，根据挪动后的$lcp(i,i+l)$来更新答案。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么不往前挪动更多距离？这样就是上一个$i$所做的了，对于当前的$i$，最多挪动$l-1$，否则没有意义。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，就可以在$O(nlogn)$的复杂度内找到最大的重复次数以及其子串长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，从$sa[1]$开始枚举，找到第一个符合条件的串，得到的一定是字典序最小的那一个。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意特判$n=1$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000+200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], ST[N][<span class="number">20</span>], bin[<span class="number">20</span>], lg[N];</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; ssp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lcp</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rk[l] &gt; rk[r])<span class="built_in">swap</span>(l, r);</span><br><span class="line">    l = rk[l] + <span class="number">1</span>, r = rk[r];</span><br><span class="line">    <span class="type">int</span> t = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ST[l][t], ST[r - bin[t] + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>(), lg[<span class="number">0</span>] = <span class="number">-1</span>, bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %c\n&quot;</span>, t++, op[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++)bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)ST[i][<span class="number">0</span>] = h[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + bin[i] - <span class="number">1</span> &lt;= n)ST[j][i] = <span class="built_in">min</span>(ST[j][i - <span class="number">1</span>], ST[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + i &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="type">int</span> l = <span class="built_in">lcp</span>(j, j + i), m = l / i + <span class="number">1</span>, q = l % i;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="number">0</span>) &#123;</span><br><span class="line">                    q = j - q;<span class="comment">//向前挪动</span></span><br><span class="line">                    <span class="keyword">if</span> (q &gt;= <span class="number">1</span>)<span class="keyword">if</span> (<span class="built_in">lcp</span>(q, q + i) &gt;= l)++m;<span class="comment">//答案加一</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= ans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m &gt; ans)ssp.<span class="built_in">clear</span>();</span><br><span class="line">                    ssp.<span class="built_in">insert</span>(i), ans = m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = ssp.<span class="built_in">begin</span>(); it != ssp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">                <span class="type">int</span> p = <span class="built_in">lcp</span>(sa[i], sa[i] + *it);</span><br><span class="line">                <span class="keyword">if</span> (p &gt;= (ans - <span class="number">1</span>) * *it) &#123;<span class="comment">//可行判定</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>, t++);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = sa[i]; j &lt; sa[i] + ans * *it; j++)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, op[j]);</span><br><span class="line">                    <span class="keyword">goto</span> to;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        to:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Long-Long-Message"><a href="#Long-Long-Message" class="headerlink" title="Long Long Message"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2774">Long Long Message</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题意就是求两个字符串的最长公共子串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将第二个字符串拼接到第一个字符串的后面，中间用一个特殊字符分隔，然后二分答案，根据两个后缀位置分别在两个串内来判别答案正确性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (200000+200)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], len;</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0x3f3f3f3f</span>, maxn = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minn == <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (minn &lt;= len &amp;&amp; maxn &gt; len + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            minn = <span class="number">0x3f3f3f3f</span>, maxn = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minn == <span class="number">0x3f3f3f3f</span>)minn = <span class="built_in">min</span>(sa[i - <span class="number">1</span>], sa[i]), maxn = <span class="built_in">max</span>(sa[i - <span class="number">1</span>], sa[i]);</span><br><span class="line">        <span class="keyword">else</span> minn = <span class="built_in">min</span>(minn, sa[i]), maxn = <span class="built_in">max</span>(maxn, sa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minn &lt;= len &amp;&amp; maxn &gt; len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + <span class="number">1</span>), len = n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), op[n + <span class="number">1</span>] = <span class="string">&#x27;$&#x27;</span>, <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + n + <span class="number">2</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;<span class="comment">//[,)</span></span><br><span class="line">        <span class="keyword">if</span> (r == l + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, l);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Common-Substrings"><a href="#Common-Substrings" class="headerlink" title="Common Substrings"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3415">Common Substrings</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题真的不简单啊啊啊啊啊啊。题意是求两个字符串长度至少为k的重复子串数目。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将两个字符串拼起来，中间用一个特殊字符相连，然后求后缀数组以及height数组。下一步就可以枚举两个串的后缀，然后判其$lcp$，若$lcp\geq k$，则答案加上$lcp-k+1$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样枚举的复杂度是$O(n^2)$，不是什么好做法，一种优化思路是使用单调栈。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先弄清楚我们要做什么：枚举串$A$的所有后缀，然后枚举串$B$的所有后缀，求它们的$lcp$然后计入答案。这样的话，其实可以将此过程分为两个子过程。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从小到大枚举$height$数组的每一个值，若这个值对应的后缀来自串$A$，则计入其前面出现的所有$B$串的答案。然后再从小到大枚举$height$数组，对于来自串$B$的后缀，计入其前面出现过的所有串$A$的答案。容易知道经过这两次扫描，和枚举两个串的所有后缀效果是相同的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<del>（复杂度还是$O(n^2)$，有什么卵用）</del><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的话，就可以利用单调性了。注意到两个后缀的$lcp$就是它们之间$height$的最小值。那么我们维护一个严格单调上升的栈，这里以第一个过程为例。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先栈中只能存放$B$串的信息，其次它是单调的（根据height值）。我们用一个变量tot维护栈中所有$B$串后缀的贡献。当枚举到一个新的后缀时，我们需要适时弹栈。当该后缀的$height$不大于栈首对应$height$时，说明之前的$height$过大，$lcp$会因这个新加入的后缀缩小，故将所有不小于新后缀$height$的$B$串后缀弹出来，然后更新tot。不断重复这个过程就可以做到$O(n)$的复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些被弹出的元素虽然已经被弹出了，但是它们仍然可能对后来的后缀产生贡献，这里在栈元素中再记录一个数量，维护这些被弹出元素的信息就可以了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (200000+200)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], len, k, sta[N][<span class="number">2</span>], top;</span><br><span class="line"><span class="comment">//这里手写栈（sta）保存两个信息：sta[x][0]为height值，sta[x][1]为数量</span></span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sa[x] &gt; len + <span class="number">1</span>)sta[++top][<span class="number">0</span>] = inf, sta[top][<span class="number">1</span>] = <span class="number">1</span>, tot = inf - k + <span class="number">1</span>;<span class="comment">//新加入的元素都是无穷大的贡献，因为没有限制它的因素</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sa[x] &gt; len + <span class="number">1</span>)tot += inf - k + <span class="number">1</span>;<span class="comment">//先加上待加入元素的贡献</span></span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; sta[top][<span class="number">0</span>] &gt;= h[x])tot -= sta[top][<span class="number">1</span>] * (sta[top][<span class="number">0</span>] - h[x]), ss += sta[top][<span class="number">1</span>], top--;<span class="comment">//弹栈，去除多余贡献</span></span><br><span class="line">    <span class="keyword">if</span> (sa[x] &lt;= len)ans += tot;<span class="comment">//计入答案</span></span><br><span class="line">    <span class="keyword">if</span> (ss)sta[++top][<span class="number">0</span>] = h[x], sta[top][<span class="number">1</span>] = ss;<span class="comment">//被弹出的元素压缩</span></span><br><span class="line">    <span class="keyword">if</span> (sa[x] &gt; len + <span class="number">1</span>)sta[++top][<span class="number">0</span>] = inf, sta[top][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//弹入待入栈元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//和add相似，只不过串A与串B反过来</span></span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sa[x] &lt;= len)sta[++top][<span class="number">0</span>] = inf, sta[top][<span class="number">1</span>] = <span class="number">1</span>, tot = inf - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sa[x] &lt;= len)tot += inf - k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; sta[top][<span class="number">0</span>] &gt;= h[x])tot -= sta[top][<span class="number">1</span>] * (sta[top][<span class="number">0</span>] - h[x]), ss += sta[top][<span class="number">1</span>], top--;</span><br><span class="line">    <span class="keyword">if</span> (sa[x] &gt; len + <span class="number">1</span>)ans += tot;</span><br><span class="line">    <span class="keyword">if</span> (ss)sta[++top][<span class="number">0</span>] = h[x], sta[top][<span class="number">1</span>] = ss;</span><br><span class="line">    <span class="keyword">if</span> (sa[x] &lt;= len)sta[++top][<span class="number">0</span>] = inf, sta[top][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + <span class="number">1</span>), len = n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), op[n + <span class="number">1</span>] = <span class="string">&#x27;$&#x27;</span>, <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + n + <span class="number">2</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>(), ans = tot = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//两次扫描</span></span><br><span class="line">            <span class="keyword">if</span> (h[i] &lt; k) tot = top = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">add</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        tot = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[i] &lt; k)tot = top = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">add2</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Life-Forms"><a href="#Life-Forms" class="headerlink" title="Life Forms"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3294">Life Forms</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求若干个字符串中，在多于一半的字符串中出现过的最长子串，并按照字典序输出。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仍然将这些字符串拼接起来，用特殊字符连接，但是<strong>这些特殊字符必须互不相同</strong>，然后求后缀数组以及height数组。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分答案，对答案判定时维护这些串的来源，只要多于一半，答案可行。注意保存这些字符串的下标位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (100000+500)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], len, k;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> op[N], id[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; ssp;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vvp;</span><br><span class="line"><span class="type">char</span> op2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ssp.<span class="built_in">clear</span>(), vvp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ssp.<span class="built_in">size</span>() &gt;= ((k &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>))vvp.<span class="built_in">push_back</span>(sa[i - <span class="number">1</span>]), flag = <span class="literal">true</span>;</span><br><span class="line">            ssp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ssp.<span class="built_in">empty</span>())ssp.<span class="built_in">insert</span>(id[sa[i]]), ssp.<span class="built_in">insert</span>(id[sa[i - <span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">else</span> ssp.<span class="built_in">insert</span>(id[sa[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    freopen(&quot;text.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock)<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> lock = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(id, <span class="number">0</span>, <span class="built_in">sizeof</span>(id)), <span class="built_in">memset</span>(tp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, now = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op2 + <span class="number">1</span>), len = <span class="built_in">strlen</span>(op2 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; j++)op[j + now] = op2[j], id[j + now] = i;</span><br><span class="line">            op[now + len + <span class="number">1</span>] = <span class="number">200</span> + i, now += len + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == k)n = now - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == l + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l == <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;?\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">check</span>(l);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vvp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = vvp[i]; j &lt; vvp[i] + l; j++)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, op[j]);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid))l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Relevant-Phrases-of-Annihilation"><a href="#Relevant-Phrases-of-Annihilation" class="headerlink" title="Relevant Phrases of Annihilation"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/SPOJ-PHRASES">Relevant Phrases of Annihilation</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是找在一堆字符串中都出现过至少两次并且不重叠的最长子串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还是拼接字符串，然后二分答案，记录这一组中每一个后缀的来源，判定它们是否重叠即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (100000+500)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], len, k;</span><br><span class="line"><span class="type">int</span> maxn[<span class="number">15</span>], minn[<span class="number">15</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> op[N], id[N];</span><br><span class="line"><span class="type">char</span> op2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)minn[i] = <span class="number">0x3f3f3f3f</span>, maxn[i] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; x) &#123;</span><br><span class="line">            <span class="type">bool</span> lk = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minn[j] == <span class="number">0x3f3f3f3f</span>)lk = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (maxn[j] - minn[j] &lt; x)lk = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lk)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)minn[j] = <span class="number">0x3f3f3f3f</span>, maxn[j] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            minn[id[sa[i - <span class="number">1</span>]]] = <span class="built_in">min</span>(minn[id[sa[i - <span class="number">1</span>]]], sa[i - <span class="number">1</span>]);</span><br><span class="line">            maxn[id[sa[i - <span class="number">1</span>]]] = <span class="built_in">max</span>(maxn[id[sa[i - <span class="number">1</span>]]], sa[i - <span class="number">1</span>]);</span><br><span class="line">            minn[id[sa[i]]] = <span class="built_in">min</span>(minn[id[sa[i]]], sa[i]);</span><br><span class="line">            maxn[id[sa[i]]] = <span class="built_in">max</span>(maxn[id[sa[i]]], sa[i]);</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> minn[id[sa[i]]] = <span class="built_in">min</span>(minn[id[sa[i]]], sa[i]), maxn[id[sa[i]]] = <span class="built_in">max</span>(maxn[id[sa[i]]], sa[i]), ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(id, <span class="number">0</span>, <span class="built_in">sizeof</span>(id)), <span class="built_in">memset</span>(tp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, now = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op2 + <span class="number">1</span>), len = <span class="built_in">strlen</span>(op2 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; j++)op[j + now] = op2[j], id[j + now] = i;</span><br><span class="line">            op[now + len + <span class="number">1</span>] = <span class="number">200</span> + i, now += len + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == k)n = now - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == l + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid))l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Alice’s-Classified-Message"><a href="#Alice’s-Classified-Message" class="headerlink" title="Alice’s Classified Message"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=5558">Alice’s Classified Message</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询后缀与后缀的最长公共前缀。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造SA，然后求height，在这一个后缀的位置向前向后暴力找就可以了。复杂度虽然比较高，但是题目中说明了每一次跳转最长公共前缀这么长的位置，一定程度上降了复杂度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000+200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N], now;</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>, T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n-1 %d\n&quot;</span>, t++, op[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(tp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tp)), n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>(), now = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (now &lt;= n) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>, minn = <span class="number">0x7fffffff</span>, pos = <span class="number">0x7fffffff</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = rk[now] - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                minn = <span class="built_in">min</span>(minn, h[i + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (minn &lt; k)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &lt; now)pos = <span class="built_in">min</span>(pos, sa[i]), k = minn;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = <span class="number">0x7fffffff</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = rk[now] + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                minn = <span class="built_in">min</span>(minn, h[i]);</span><br><span class="line">                <span class="keyword">if</span> (minn &lt; k)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &lt; now) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (minn &gt; k)k = minn, pos = sa[i];</span><br><span class="line">                    <span class="keyword">else</span> pos = <span class="built_in">min</span>(pos, sa[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;-1 %d\n&quot;</span>, op[now++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, k, pos - <span class="number">1</span>), now += k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="The-Number-of-Palindromes"><a href="#The-Number-of-Palindromes" class="headerlink" title="The Number of Palindromes"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=3948">The Number of Palindromes</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本质不同的回文串数量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先改造原串，一遍Manacher算出每一个字符的最长回文半径，然后用后缀数组去重。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去重的时候，我们从小到大遍历sa，记录上一个被计入的回文串长度，用height数组求出与其的lcp，根据lcp减去被重复计入的回文串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> op[N], op2[N];</span><br><span class="line"><span class="type">int</span> n, sa[N], h[N], tp[N], rk[N], M, tax[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i] - <span class="string">&#x27;#&#x27;</span> + <span class="number">1</span>, tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>, T, l;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op2 + <span class="number">1</span>), n = <span class="built_in">strlen</span>(op2 + <span class="number">1</span>), <span class="built_in">memset</span>(tp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; k ^= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!k)op[j++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> op[j++] = op2[i++];</span><br><span class="line">            l = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>, r = <span class="number">1</span>, ans = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        op[n = l] = <span class="string">&#x27;#&#x27;</span>, p[<span class="number">0</span>] = <span class="number">1</span>, <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)op2[i - <span class="number">1</span>] = op[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; r)p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * pos - i], r - i);</span><br><span class="line">            <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i - p[i] &gt;= <span class="number">0</span> &amp;&amp; i + p[i] &lt;n &amp;&amp; op2[i - p[i]] == op2[i + p[i]]; ++p[i]);</span><br><span class="line">            <span class="keyword">if</span> (p[i] + i &gt; r)r = p[i] + i, pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)p[i] = p[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = sa[i];</span><br><span class="line">            tmp = <span class="built_in">min</span>(tmp, h[i]);<span class="comment">//tmp是上一次计入的长度，与lcs取较小值</span></span><br><span class="line">            <span class="keyword">if</span> (p[x] &lt;= tmp)<span class="keyword">continue</span>;<span class="comment">//回文串本身就短，一定全部都算过了，不再计入</span></span><br><span class="line">            ans += (p[x] - tmp) / <span class="number">2</span>;<span class="comment">//由于加入了#字符，故需要除以2</span></span><br><span class="line">            tmp = p[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, t++, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Boring-String-Problem"><a href="#Boring-String-Problem" class="headerlink" title="Boring String Problem"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=5008">Boring String Problem</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找第k小的子串，不重复计入重数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理出每一个后缀特有的子串数量，易知这些子串就是按照字典序排列的，只需要二分出第k小的那一个即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于需要左端点最小，因此还需要向后枚举找到最小的左端点，这里需要根据lcp来判断。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200000+20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], M, h[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N];</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;text.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op + <span class="number">1</span>) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tp)), n = <span class="built_in">strlen</span>(op + <span class="number">1</span>), <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)f[i] = n - sa[i] + <span class="number">1</span> - h[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> q, l = <span class="number">0</span>, r = <span class="number">0</span>, L, R, mid, k, len;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k), k = (l ^ r ^ k) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; f[n]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, l = <span class="number">0</span>, r = <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            L = <span class="number">1</span>, R = n;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">                <span class="keyword">if</span> (L == R)<span class="keyword">break</span>;</span><br><span class="line">                mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (f[mid] &lt; k)L = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> R = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            l = sa[L], r = sa[L] + h[L] + k - f[L - <span class="number">1</span>] - <span class="number">1</span>, len = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = L + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (h[i] &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sa[i] &lt; l)l = sa[i], r = l + len - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="SCOI2012-喵星球上的点名"><a href="#SCOI2012-喵星球上的点名" class="headerlink" title="[SCOI2012]喵星球上的点名"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P2336">[SCOI2012]喵星球上的点名</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好题啊，这个问题可以用很多种方法去解决。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将所有名和姓以及点名串连起来，中间用特殊字符连接，然后构造SA以及height数组。找到点名串所处的后缀，向前向后延伸，找到一段区间，问题转化为这一段区间内的颜色种数（第一问），第二问即是求每一种颜色被包含的区间数量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问是经典的莫队问题，离线后用莫队解决。第二问在第一问进行时就可以统计出来，方法是差分。某一种颜色被计入时，加上查询的剩余次数，当某一种串被移去时，删除查询的剩余次数，最后就能统计出答案。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题第二问的差分统计思想很重要。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000000+200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sa[N], tp[N], rk[N], tax[N], m, M, h[N], ST[N][<span class="number">25</span>], bin[<span class="number">25</span>], lg[N], ID = <span class="number">10000</span>, ct;</span><br><span class="line"><span class="type">int</span> fid[N], to[<span class="number">200005</span>], op[N], L[<span class="number">200005</span>], be[N], num[<span class="number">200005</span>], sum[<span class="number">200005</span>], nn, id[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, rk, ans;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Q q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (be[l] != be[q.l])<span class="keyword">return</span> be[l] &lt; be[q.l];</span><br><span class="line">        <span class="keyword">return</span> be[r] &lt; be[q.r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; i++)tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M = <span class="number">500005</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)rk[i] = op[i], tp[i] = i;</span><br><span class="line">    <span class="built_in">mySort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; M = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">mySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - <span class="number">1</span>]] == tp[sa[i]] &amp;&amp; tp[sa[i - <span class="number">1</span>] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>)h[rk[i]] = k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)k--;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lcp</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    ++l;</span><br><span class="line">    <span class="type">int</span> t = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ST[l][t], ST[r - bin[t] + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Q a, Q b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.rk &lt; b.rk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;nn, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l; i &lt;= nn; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= l; j++)++ct, <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, op + ct), fid[ct] = i;</span><br><span class="line">        op[++ct] = ++ID;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= l; j++)++ct, <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, op + ct), fid[ct] = i;</span><br><span class="line">        op[++ct] = ++ID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l), to[i] = ct + <span class="number">1</span>, L[i] = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= l; j++)++ct, <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, op + ct);</span><br><span class="line">        op[++ct] = ++ID;</span><br><span class="line">    &#125;</span><br><span class="line">    n = ct, <span class="built_in">solve</span>(), <span class="built_in">getHeight</span>(), lg[<span class="number">0</span>] = <span class="number">-1</span>, bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">25</span>; i++)bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)ST[i][<span class="number">0</span>] = h[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + bin[i] - <span class="number">1</span> &lt;= n)ST[j][i] = <span class="built_in">min</span>(ST[j][i - <span class="number">1</span>], ST[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p = rk[to[i]], l = <span class="number">0</span>, r = p - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;<span class="comment">//(,]</span></span><br><span class="line">            <span class="keyword">if</span> (r == l + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">lcp</span>(r, p) == L[i])q[i].l = r;</span><br><span class="line">                <span class="keyword">else</span> q[i].l = p;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(mid, p) &gt;= L[i])r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        l = p + <span class="number">1</span>, r = n + <span class="number">1</span>, q[i].rk = i;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;<span class="comment">//[,)</span></span><br><span class="line">            <span class="keyword">if</span> (r == l + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">lcp</span>(p, l) == L[i])q[i].r = l;</span><br><span class="line">                <span class="keyword">else</span> q[i].r = p;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(p, mid) &gt;= L[i])l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)id[i] = fid[sa[i]];</span><br><span class="line">    <span class="type">int</span> base = <span class="built_in">sqrt</span>(n), l = <span class="number">1</span>, r = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)be[i] = (i - <span class="number">1</span>) / base + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">1</span>] != <span class="number">0</span>)++num[id[<span class="number">1</span>]], ++ans, sum[id[<span class="number">1</span>]] += m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) &#123;</span><br><span class="line">            --num[id[l]];</span><br><span class="line">            <span class="keyword">if</span> (id[l] != <span class="number">0</span> &amp;&amp; num[id[l]] == <span class="number">0</span>)--ans, sum[id[l]] -= m - i + <span class="number">1</span>;</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) &#123;</span><br><span class="line">            ++num[id[l - <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span> (id[l - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; num[id[l - <span class="number">1</span>]] == <span class="number">1</span>)++ans, sum[id[l - <span class="number">1</span>]] += m - i + <span class="number">1</span>;</span><br><span class="line">            --l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) &#123;</span><br><span class="line">            ++num[id[r + <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span> (id[r + <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; num[id[r + <span class="number">1</span>]] == <span class="number">1</span>)++ans, sum[id[r + <span class="number">1</span>]] += m - i + <span class="number">1</span>;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) &#123;</span><br><span class="line">            --num[id[r]];</span><br><span class="line">            <span class="keyword">if</span> (id[r] != <span class="number">0</span> &amp;&amp; num[id[r]] == <span class="number">0</span>)--ans, sum[id[r]] -= m - i + <span class="number">1</span>;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].ans = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q[i].ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nn; i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sum[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="NOI2016-优秀的拆分"><a href="#NOI2016-优秀的拆分" class="headerlink" title="[NOI2016]优秀的拆分"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P1117">[NOI2016]优秀的拆分</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们能求两个数组$suf[x]$和$pre[x]$分别表示以$x$开始的AA串数量，以$x$结尾的AA串数量，那么答案就是：</p>
<script type="math/tex; mode=display">\sum_{i=1}^{len-1}pre[i]suf[i+1]</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在就要求这两个数组。首先可以ST+SA然后$O(n^2)$去求，但这样显然不是什么好做法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的问题（具体来说，是Maximum repetition substring这个题）中，曾用到一个巧妙的做法：枚举长度然后打关键点。这种做法基于一个事实：一个某种长度的AA串，必然会经过两个相邻的关键点。严格地说，<strong>是对于长度为$2l$的AA串，必然会唯一地经过一个相邻的关键点对</strong>。这样我们对于一个长度，遍历所有关键点，就可以找到所有AA串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设现在长度为$l$，关键点是$x$和$x+l$，考虑如何找对应的AA串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先找$x$和$x+l$的$lcp$以及$x-1$和$x+l-1$的$lcs$，易知如果它们的和不到$l$，即$lcs+lcp&lt;l$，那么必然不会有一个长为$2l$的AA串经过这两个点。否则一定会有。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最普通的情况是$lcp+lcs=l$，这样对应一个唯一的串。事实上，在求出$lcs$和$lcp$后，这会对应$lcs+lcp-l+1$个长度为$2l$的AA串。但是这些AA串不一定都经过这两个点，需要进行裁剪，裁剪后，我们就可以得到一些区间，然后我们根据这些区间更新$suf$和$pre$数组，就可以得到这两个数组。这里的更新可以用差分实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">#define N 100000+200</span><br><span class="line">using namespace std;</span><br><span class="line">int n, sa[N], tp[N], rk[N], tax[N], M, h[N], ST[N][20], bin[20], lg[N], rk2[N];</span><br><span class="line">int pre[N], suf[N], ST2[N][20];</span><br><span class="line">char op[N];</span><br><span class="line"></span><br><span class="line">inline void mySort() &#123;</span><br><span class="line">    for (int i = 0; i &lt;= M; i++)tax[i] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)tax[rk[i]]++;</span><br><span class="line">    for (int i = 1; i &lt;= M; i++)tax[i] += tax[i - 1];</span><br><span class="line">    for (int i = n; i &gt;= 1; i--)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void solve() &#123;</span><br><span class="line">    M = 50;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)rk[i] = op[i] - &#x27;a&#x27; + 1, tp[i] = i;</span><br><span class="line">    mySort();</span><br><span class="line">    for (int w = 1, p = 0; p &lt; n; M = p, w &lt;&lt;= 1) &#123;</span><br><span class="line">        p = 0;</span><br><span class="line">        for (int i = 1; i &lt;= w; i++)tp[++p] = n - w + i;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)if (sa[i] &gt; w)tp[++p] = sa[i] - w;</span><br><span class="line">        mySort();</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)tp[i] = rk[i];</span><br><span class="line">        rk[sa[1]] = p = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void getHeight() &#123;</span><br><span class="line">    int k = 0, j;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (rk[i] == 1)h[rk[i]] = k = 0;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (k)k--;</span><br><span class="line">            j = sa[rk[i] - 1];</span><br><span class="line">            while (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int lcp(int l, int r) &#123;</span><br><span class="line">    if (rk2[l] &gt; rk2[r])swap(l, r);</span><br><span class="line">    l = rk2[l] + 1, r = rk2[r];</span><br><span class="line">    int t = lg[r - l + 1];</span><br><span class="line">    return min(ST[l][t], ST[r - bin[t] + 1][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int lcs(int l, int r) &#123;</span><br><span class="line">    if (l &lt; 1 || r &lt; 0)return 0;</span><br><span class="line">    l = n - l + 1, r = n - r + 1;</span><br><span class="line">    if (rk[l] &gt; rk[r])swap(l, r);</span><br><span class="line">    l = rk[l] + 1, r = rk[r];</span><br><span class="line">    int t = lg[r - l + 1];</span><br><span class="line">    return min(ST2[l][t], ST2[r - bin[t] + 1][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        memset(tp, 0, sizeof(tp)), memset(pre, 0, sizeof(pre)), memset(suf, 0, sizeof(suf));</span><br><span class="line">        scanf(&quot;%s&quot;, op + 1), n = strlen(op + 1), solve(), getHeight();</span><br><span class="line">        lg[0] = -1, bin[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)lg[i] = lg[i &gt;&gt; 1] + 1;</span><br><span class="line">        for (int i = 1; i &lt; 20; i++)bin[i] = bin[i - 1] &lt;&lt; 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)ST[i][0] = h[i];</span><br><span class="line">        for (int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                if (j + bin[i] - 1 &lt;= n)ST[j][i] = min(ST[j][i - 1], ST[j + bin[i - 1]][i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)rk2[i] = rk[i];</span><br><span class="line">        reverse(op + 1, op + n + 1), solve(), getHeight();</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)ST2[i][0] = h[i];</span><br><span class="line">        for (int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                if (j + bin[i] - 1 &lt;= n)ST2[j][i] = min(ST2[j][i - 1], ST2[j + bin[i - 1]][i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j + i &lt;= n; j += i) &#123;</span><br><span class="line">                int cs = min(lcs(j - 1, j + i - 1), i - 1), cp = min(lcp(j, j + i), i);</span><br><span class="line">                if (cs + cp &gt;= i) &#123;</span><br><span class="line">                    ++suf[j - cs], --suf[j - cs + (cp + cs - i + 1)];</span><br><span class="line">                    ++pre[j + i + cp - (cp + cs - i + 1)], --pre[j + i + cp];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)suf[i] += suf[i - 1], pre[i] += pre[i - 1];</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i++)ans += pre[i] * suf[i + 1];</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80"><span class="toc-text">后缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E5%AD%97%E5%85%B8%E5%BA%8F"><span class="toc-text">后缀字典序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6%E6%B1%82%E6%B3%95"><span class="toc-text">后缀数组及其求法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#height%E6%95%B0%E7%BB%84"><span class="toc-text">height数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">后缀数组的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%90%8E%E7%BC%80%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-text">两个后缀的最大公共前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%8F%A0%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-text">可重叠最长重复子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%8F%A0%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-text">不可重叠最长重复子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8D%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0%E9%87%8F"><span class="toc-text">本质不相同的子串数量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Musical-Theme"><span class="toc-text">Musical Theme</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Milk-Patterns"><span class="toc-text">Milk Patterns</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#New-Distinct-Substrings"><span class="toc-text">New Distinct Substrings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Palindrome"><span class="toc-text">Palindrome</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Power-Strings"><span class="toc-text">Power Strings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Maximum-repetition-substring"><span class="toc-text">Maximum repetition substring</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Long-Long-Message"><span class="toc-text">Long Long Message</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Common-Substrings"><span class="toc-text">Common Substrings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Life-Forms"><span class="toc-text">Life Forms</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Relevant-Phrases-of-Annihilation"><span class="toc-text">Relevant Phrases of Annihilation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Alice%E2%80%99s-Classified-Message"><span class="toc-text">Alice’s Classified Message</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Number-of-Palindromes"><span class="toc-text">The Number of Palindromes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boring-String-Problem"><span class="toc-text">Boring String Problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCOI2012-%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D"><span class="toc-text">[SCOI2012]喵星球上的点名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NOI2016-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86"><span class="toc-text">[NOI2016]优秀的拆分</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
  
      
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/03/13/%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95/" rel="next" title="倍增算法">
          倍增算法
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/03/19/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/" rel="prev" title="单调栈与最大矩形面积">
            单调栈与最大矩形面积
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
      
    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://twifor.github.io">首页</a> |
        <a class="bottom-item" href="https://twifor.github.io/index_original.html" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/Twifor" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        },
        showMathMenu: false,
        "HTML-CSS": {
            preferredFont: "TeX", 
            availableFonts: ["STIX","TeX"],
            showMathMenuMSIE: false
        },
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
