
<!DOCTYPE html>
<html lang="en">


  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#202020" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

    
      <meta name="keywords" content="提高算法,字符串," />
      

          
              <meta name="description"
                content="AC自动机" />
              

                <link rel="icon" type="image/x-icon" href="/logo.ico">
                <title>
                  AC自动机lyh&#39;s blog
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/xoxo.css">
                    
                      
  <meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <span class="title">
      lyh&#39;s blog
    </span>
  </a>

  <ul class="pure-menu-list clearfix">
    
      
          <li class="pure-menu-item"><a href="/" class="pure-menu-link">
              Home
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">
              Archives
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">
              Tags
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/search" class="pure-menu-link">
              Search
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/about" class="pure-menu-link">
              About
            </a></li>
          
            
  </ul>

</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        AC自动机
      </h1>
      <span>
        
        <time class="time" datetime="2019-03-22T06:39:53.000Z">
        2019-03-22
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8F%90%E9%AB%98%E7%AE%97%E6%B3%95/" rel="tag">提高算法</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 28 分钟</span>
    </header>

    <div class="post-content">
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文探讨AC自动机的相关内容，<del>注意AC自动机并不能自动让你AC。</del><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UPD：更新两道例题。<br><span id="more"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机在1975年诞生于贝尔实验室的多模匹配算法。之前的文章曾介绍过<a href="https://twifor.github.io/2019/02/21/KMP%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">KMP匹配算法</a>，它用于单模式串匹配。对于多模式串匹配，我们当然可以多次用KMP匹配算法去解决，但那样时间复杂度为$O(m+kn))$，k为模式串数量，比较低效。而在多模匹配中应用AC自动机可以达到$O(m+n)$，m为所有模式串长度之和。</p>
<h3 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里只粗略地谈谈自动机这个东西。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在有限状态自动机（Deterministic finite automation, DFA）中，状态有有限个，它们彼此用有向边连接，表示状态的转移。当一个动作发生时，自动机会从一个状态转移到另一个状态，并做出相应的反应，这里的AC自动机便是一种有限状态自动机。</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机的结构是一棵trie树，如下图所示：<br><img src="/2019/03/22/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ph1.bmp" class=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trie树又称字典树，常用于快速求字典序。在trie树中，根结点不记录字符串信息，所有的字符串信息只记录在子结点中。上图所示的trie树表示记录了he、is、she、shr四个字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要同时记录she和sh两个字符串怎么办？trie树上每一个结点都拥有一个指标变量，它记录这个结点对应的字符是否表示有个字符串的结尾，这样在相应结点处打上标记就可以同时表示she和sh。</p>
<h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍AC自动机进行的过程。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要将所有模式串加入trie树，并做每一个串到对应结点的标记。如果字符串中只有小写字母，那么我们可以这样建立trie树：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], ct = <span class="number">1</span>;<span class="comment">//N是结点预估数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">int</span> j)</span> </span>&#123;<span class="comment">//将编号为j的模式串p加入到trie树中</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>] = ++ct;<span class="comment">//没有就新建</span></span><br><span class="line">        now = tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>], i++;<span class="comment">//有就继续向下走</span></span><br><span class="line">    &#125;</span><br><span class="line">    to[j] = now;<span class="comment">//记录末尾编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建完trie树后，我们可以这样理解trie树：树上的每一个结点都对应一种状态，它表示到根结点的字符均匹配，这样trie树可以看成是一个状态机的雏形。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如当前匹配到了某个结点，它表示的字符为’a’，并且下一个字符需要匹配’b’，而该结点正好有对应’b’的子结点，那此时状态直接转移到对应’b’的子结点即可。但是如果不存在对应’b’的子结点呢？如何转移？这就需要引入失配指针的概念。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当某个结点发生失配时（指它不存在满足匹配的子结点），应该由这个状态转移至另一个状态，描述这个失配转移关系的指针称为失配指针，它是AC自动机中的重要概念。和KMP算法类似，失配指针应该指向与它目前匹配子串拥有最长相同前后缀的子串的末尾结点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先考虑在根结点如何转移。对于一个字符，如果根结点存在对应这个字符的结点，转移到该结点即可；而对于根结点不存在对应子结点的情况（比如上文图中根结点不存在表示’a’的子结点），也应该规定一个转移方向，这时应当转移至根，因为没有可以匹配的模式串。这一步的示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;<span class="comment">//规定1号结点为根</span></span><br><span class="line">        <span class="keyword">if</span> (tree[<span class="number">1</span>][i])fail[tree[<span class="number">1</span>][i]] = <span class="number">1</span>, que.<span class="built_in">push</span>(tree[<span class="number">1</span>][i]);<span class="comment">//fail记录失配指向编号,que是队列</span></span><br><span class="line">        <span class="keyword">else</span> tree[<span class="number">1</span>][i] = <span class="number">1</span>;<span class="comment">//转移到根，直接记在trie树上</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)tree[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里将结点加入队列，以进行之后的求失配指针的过程。在这里，我们不断从队列中取点，然后遍历它的所有子结点，对于它存在的子结点，子结点的失配指针指向为其父结点（就是当前取出的结点）失配指针指向结点相对应的子结点；对于不存在的结点，转移方向也是父结点失配指针指向结点相对应的子结点。这个过程可以感性地理解一下，它其实是对父结点失配后子串的延伸。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> p = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[p][i])fail[tree[p][i]] = tree[fail[p]][i], que.<span class="built_in">push</span>(tree[p][i]);</span><br><span class="line">            <span class="keyword">else</span> tree[p][i] = tree[fail[p]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后就是匹配的过程，十分简洁，不断转移状态即可。途中需要记录每一个状态被访问到的次数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>; str[i]; ++i)now = tree[now][str[i] - <span class="string">&#x27;a&#x27;</span>], ++vis[now];<span class="comment">//str是主串，vis记录次数</span></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那现在如何求每一个模式串匹配的次数呢？这就需要fail树。</p>
<h3 id="fail树"><a href="#fail树" class="headerlink" title="fail树"></a>fail树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于trie树上的每一个非根结点，单独建立一张fail[x]-&gt;x的图，容易证明这个图是一棵树，称为fail树。fail树满足一个性质：对于fail树的一个子树，若其子树上某一个结点的状态成立，则子树根结点状态必成立。这样建立fail树，然后进行一遍DFS，求出子树上状态vis的值之和即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们需要在一种更高的角度去理解fail树。在fail树上，以某个结点为根的子树，其上的结点都有什么特点？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>fail树上的任何一个结点都代表着一个前缀，对于任何一个结点，其一定是其子树上所有结点的公共后缀。</strong>由于子串就是前缀的后缀，故<strong>在fail树上，以某个结点为根的子树上的结点就是包含这个结点对应前缀的所有字符串前缀。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = edge[i].next)<span class="built_in">DFS</span>(edge[i].to), vis[x] += vis[edge[i].to];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;洛谷上三道模板题。</p>
<h4 id="模板一"><a href="#模板一" class="headerlink" title="模板一"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3808">模板一</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很水，直接计数判是否为0即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str[<span class="number">1000005</span>], op[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1000005</span>], to[<span class="number">1000005</span>], ct = <span class="number">1</span>, fail[<span class="number">1000005</span>], tr[<span class="number">1000005</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> next, to;</span><br><span class="line">&#125; edge[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>] = ++ct;</span><br><span class="line">        now = tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>], i++;</span><br><span class="line">    &#125;</span><br><span class="line">    to[j] = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = edge[i].next)<span class="built_in">DFS</span>(edge[i].to), vis[x] += vis[edge[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op), <span class="built_in">insert</span>(op, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)tr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> p = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[p][i])fail[tr[p][i]] = tr[fail[p]][i], que.<span class="built_in">push</span>(tr[p][i]);</span><br><span class="line">            <span class="keyword">else</span> tr[p][i] = tr[fail[p]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>; str[i]; ++i)now = tr[now][str[i] - <span class="string">&#x27;a&#x27;</span>], ++vis[now];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= ct; i++)<span class="built_in">add</span>(fail[i], i);</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)ans += vis[to[i]] &gt; <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3796">模板二</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据匹配次数输出最大的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str[<span class="number">1000005</span>], op[<span class="number">151</span>][<span class="number">80</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1000005</span>], to[<span class="number">1000005</span>], ct = <span class="number">1</span>, fail[<span class="number">1000005</span>], tr[<span class="number">1000005</span>][<span class="number">26</span>], cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> next, to;</span><br><span class="line">&#125; edge[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>] = ++ct;</span><br><span class="line">        now = tr[now][p[i] - <span class="string">&#x27;a&#x27;</span>], i++;</span><br><span class="line">    &#125;</span><br><span class="line">    to[j] = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = edge[i].next)<span class="built_in">DFS</span>(edge[i].to), vis[x] += vis[edge[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cnt = ct = <span class="number">1</span>, <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="built_in">sizeof</span>(tr)), <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)), <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="built_in">sizeof</span>(fail));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op[i]), <span class="built_in">insert</span>(op[i], i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)tr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> p = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[p][i])fail[tr[p][i]] = tr[fail[p]][i], que.<span class="built_in">push</span>(tr[p][i]);</span><br><span class="line">                <span class="keyword">else</span> tr[p][i] = tr[fail[p]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>; str[i]; ++i)now = tr[now][str[i] - <span class="string">&#x27;a&#x27;</span>], ++vis[now];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ct; i++)head[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= ct; i++)<span class="built_in">add</span>(fail[i], i);</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)maxn = <span class="built_in">max</span>(maxn, vis[to[i]]);</span><br><span class="line">        cout &lt;&lt; maxn &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">if</span> (vis[to[i]] == maxn)cout &lt;&lt; op[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模板三"><a href="#模板三" class="headerlink" title="模板三"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P5357">模板三</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出匹配数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str[<span class="number">2000010</span>], op[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">500000</span>], to[<span class="number">200005</span>], ct = <span class="number">1</span>, fail[<span class="number">500000</span>], tree[<span class="number">500000</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> next, to;</span><br><span class="line">&#125; edge[<span class="number">500000</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[now][p[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)tree[now][p[i] - <span class="string">&#x27;a&#x27;</span>] = ++ct;</span><br><span class="line">        now = tree[now][p[i] - <span class="string">&#x27;a&#x27;</span>], i++;</span><br><span class="line">    &#125;</span><br><span class="line">    to[j] = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = edge[i].next)<span class="built_in">DFS</span>(edge[i].to), vis[x] += vis[edge[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op), <span class="built_in">insert</span>(op, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[<span class="number">1</span>][i])fail[tree[<span class="number">1</span>][i]] = <span class="number">1</span>, que.<span class="built_in">push</span>(tree[<span class="number">1</span>][i]);</span><br><span class="line">        <span class="keyword">else</span> tree[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> p = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[p][i])fail[tree[p][i]] = tree[fail[p]][i], que.<span class="built_in">push</span>(tree[p][i]);</span><br><span class="line">            <span class="keyword">else</span> tree[p][i] = tree[fail[p]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>; str[i]; ++i)now = tree[now][str[i] - <span class="string">&#x27;a&#x27;</span>], ++vis[now];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= ct; i++)<span class="built_in">add</span>(fail[i], i);</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cout &lt;&lt; vis[to[i]] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了加深对AC自动机的理解，这里介绍几道例题。以下题目不涉及题面，可点开标题自查。</p>
<h4 id="NOI2011-阿狸的打字机"><a href="#NOI2011-阿狸的打字机" class="headerlink" title="[NOI2011]阿狸的打字机"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P2414">[NOI2011]阿狸的打字机</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机的好题，强烈建议一做。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将所有字符串放入AC自动机，然后求出fail树。由上面我们关于fail树性质的讨论，可以发现，<strong>要求串x在串y中出现多少次，就是求Trie树中属于串y的结点在以x为根的fail子树上有多少个。</strong>现在问题变得十分清晰明了了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题当然可以离线做，这里我们用在线做法（能在线绝不离线）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先一遍DFS将树上问题转化为区间问题。然后将某一个串y的Trie树上的结点打上标记，用线段树求和就可以求出所有关于串y的询问。对于所有的串都开一个线段树就可以在线了，但是这样显然很费空间，考虑可持久化线段树。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到Trie树上的结点，其进行修改时仅修改一个值（只给它自己这一个结点打上标记），那么这里就可以用树上主席树的方法建立可持久化线段树，然后就可以将空间复杂度降到$O(nlogn)$。对于某一个询问，只需要调出所需的线段树，然后区间求和即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"><span class="type">int</span> ct = <span class="number">1</span>, to[N], fail[N], head[N], DFN[N], ID = <span class="number">1</span>, size[N], root[N], ps;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">28</span>], fa;</span><br><span class="line">&#125; trie[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> next, to;</span><br><span class="line">&#125; edge[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, v;</span><br><span class="line">&#125; nd[N &lt;&lt; <span class="number">6</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].next = head[x], edge[cnt].to = y, head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//DFS序转化</span></span><br><span class="line">    size[x] = <span class="number">1</span>, DFN[x] = ID++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = edge[i].next)<span class="built_in">DFS</span>(edge[i].to), size[x] += size[edge[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newTree</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> pre, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = ID - <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v = ++ps;</span><br><span class="line">    nd[v] = nd[pre], ++nd[v].v;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= mid)nd[v].l = <span class="built_in">newTree</span>(s, nd[pre].l, l, mid);</span><br><span class="line">        <span class="keyword">else</span> nd[v].r = <span class="built_in">newTree</span>(s, nd[pre].r, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//建立主席树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trie[trie[x].next[i]].fa == x)</span><br><span class="line">            root[trie[x].next[i]] = <span class="built_in">newTree</span>(DFN[trie[x].next[i]], root[x]), <span class="built_in">DFS2</span>(trie[x].next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = ID - <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = ++ps;</span><br><span class="line">    <span class="keyword">if</span> (l != r)nd[s].l = <span class="built_in">build</span>(l, (l + r) &gt;&gt; <span class="number">1</span>), nd[s].r = <span class="built_in">build</span>(((l + r) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L = <span class="number">1</span>, <span class="type">int</span> R = ID - <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= l &amp;&amp; R &lt;= r)<span class="keyword">return</span> nd[rt].v;</span><br><span class="line">    <span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid)<span class="keyword">return</span> <span class="built_in">query</span>(nd[rt].r, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= mid)<span class="keyword">return</span> <span class="built_in">query</span>(nd[rt].l, l, r, L, mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(nd[rt].l, l, mid, L, mid) + <span class="built_in">query</span>(nd[rt].r, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">1</span>, s = <span class="number">0</span>; op[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;P&#x27;</span>)to[++s] = now;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; now != <span class="number">1</span>)now = trie[now].fa;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (trie[now].next[op[i] - <span class="string">&#x27;a&#x27;</span>])now = trie[now].next[op[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> trie[now].next[op[i] - <span class="string">&#x27;a&#x27;</span>] = ++ct, trie[ct].fa = now, now = ct;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trie[<span class="number">1</span>].next[i])fail[trie[<span class="number">1</span>].next[i]] = <span class="number">1</span>, que.<span class="built_in">push</span>(trie[<span class="number">1</span>].next[i]);</span><br><span class="line">        <span class="keyword">else</span> trie[<span class="number">1</span>].next[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;<span class="comment">//建立AC自动机</span></span><br><span class="line">        <span class="type">int</span> f = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trie[f].next[i])fail[trie[f].next[i]] = trie[fail[f]].next[i], que.<span class="built_in">push</span>(trie[f].next[i]);</span><br><span class="line">            <span class="keyword">else</span> trie[f].next[i] = trie[fail[f]].next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= ct; i++)<span class="built_in">add</span>(fail[i], i);</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>), root[<span class="number">1</span>] = <span class="built_in">build</span>(), <span class="built_in">DFS2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(root[to[y]], DFN[to[x]], DFN[to[x]] + size[to[x]] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POI2000-病毒"><a href="#POI2000-病毒" class="headerlink" title="[POI2000]病毒"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P2444">[POI2000]病毒</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把字符串存到AC自动机里，然后建fail树，再将不能走的点打上标记，重建状态转移图，再来一步拓扑排序判环即可。本题比较容易。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, next;</span><br><span class="line">&#125; edge[N], edge2[N];</span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">2</span>], fail[N], ct = <span class="number">1</span>, n, to[N], head[N], mark[N], head2[N], vis[N];</span><br><span class="line"><span class="type">int</span> m, in[N], ans;</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trie[now][s[i] - <span class="string">&#x27;0&#x27;</span>] == <span class="number">0</span>)now = trie[now][s[i] - <span class="string">&#x27;0&#x27;</span>] = ++ct;</span><br><span class="line">        <span class="keyword">else</span> now = trie[now][s[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    to[p] = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    ++in[y], edge2[cnt].to = y, edge2[cnt].next = head2[x], head2[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    mark[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = edge[i].next)<span class="built_in">DFS</span>(edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[trie[x][i]]) &#123;</span><br><span class="line">            <span class="built_in">add2</span>(x, trie[x][i]);</span><br><span class="line">            <span class="keyword">if</span> (!vis[trie[x][i]])vis[trie[x][i]] = <span class="number">1</span>, <span class="built_in">DFS2</span>(trie[x][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op), <span class="built_in">insert</span>(op, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trie[<span class="number">1</span>][i])fail[trie[<span class="number">1</span>][i]] = <span class="number">1</span>, que.<span class="built_in">push</span>(trie[<span class="number">1</span>][i]);</span><br><span class="line">        <span class="keyword">else</span> trie[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> f = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trie[f][i])fail[trie[f][i]] = trie[fail[f]][i], que.<span class="built_in">push</span>(trie[f][i]);</span><br><span class="line">            <span class="keyword">else</span> trie[f][i] = trie[fail[f]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= ct; i++)<span class="built_in">add</span>(fail[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">DFS</span>(to[i]);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>, <span class="built_in">DFS2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ct; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) &#123;</span><br><span class="line">            ++m;</span><br><span class="line">            <span class="keyword">if</span> (!in[i])que.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> f = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>(), ++ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head2[f]; i; i = edge2[i].next) &#123;</span><br><span class="line">            --in[edge2[i].to];</span><br><span class="line">            <span class="keyword">if</span> (!in[edge2[i].to])que.<span class="built_in">push</span>(edge2[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == m)cout &lt;&lt; <span class="string">&quot;NIE&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;TAK&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">有限状态自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-text">Trie树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">AC自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail%E6%A0%91"><span class="toc-text">fail树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">代码模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%80"><span class="toc-text">模板一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%BA%8C"><span class="toc-text">模板二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%89"><span class="toc-text">模板三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NOI2011-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA"><span class="toc-text">[NOI2011]阿狸的打字机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POI2000-%E7%97%85%E6%AF%92"><span class="toc-text">[POI2000]病毒</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/03/19/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/" rel="next" title="单调栈与最大矩形面积">
          单调栈与最大矩形面积
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/03/24/Manacher%E7%AE%97%E6%B3%95/" rel="prev" title="Manacher算法">
            Manacher算法
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://twifor.github.io">首页</a> |
        <a class="bottom-item" href="https://twifor.github.io/index_original.html" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/Twifor" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        },
        showMathMenu: false,
        "HTML-CSS": {
            preferredFont: "TeX", 
            availableFonts: ["STIX","TeX"],
            showMathMenuMSIE: false
        },
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
