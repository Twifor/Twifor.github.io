<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://twifor.github.io"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有必要整理一下网络流模型了，本文长期更新。以下题目许多出自网络流24题专题，点击标题可跳转。前缀知识：网络流。">
<meta name="keywords" content="提高算法,图论,网络流">
<meta property="og:type" content="article">
<meta property="og:title" content="网络流应用专题">
<meta property="og:url" content="https://twifor.github.io/2019/05/26/网络流应用专题/index.html">
<meta property="og:site_name" content="Twifor~Liyh">
<meta property="og:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有必要整理一下网络流模型了，本文长期更新。以下题目许多出自网络流24题专题，点击标题可跳转。前缀知识：网络流。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-18T08:52:58.807Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络流应用专题">
<meta name="twitter:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有必要整理一下网络流模型了，本文长期更新。以下题目许多出自网络流24题专题，点击标题可跳转。前缀知识：网络流。">






  <link rel="canonical" href="https://twifor.github.io/2019/05/26/网络流应用专题/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>网络流应用专题 | Twifor~Liyh</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">


  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/Twifor" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Twifor~Liyh</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>
    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://twifor.github.io/2019/05/26/网络流应用专题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Twifor">
      <meta itemprop="description" content="一个打OI的弱鸡">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Twifor~Liyh">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">网络流应用专题

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-26 19:14:09" itemprop="dateCreated datePublished" datetime="2019-05-26T19:14:09+08:00">2019-05-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-18 16:52:58" itemprop="dateModified" datetime="2019-07-18T16:52:58+08:00">2019-07-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法与OI/" itemprop="url" rel="index"><span itemprop="name">算法与OI</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/26/网络流应用专题/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/网络流应用专题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有必要整理一下网络流模型了，本文长期更新。以下题目许多出自网络流24题专题，点击标题可跳转。前缀知识：<a href="https://twifor.github.io/2019/02/22/%E7%BD%91%E7%BB%9C%E6%B5%81/">网络流</a>。<br><a id="more"></a></p>
<h3 id="负载平衡问题"><a href="#负载平衡问题" class="headerlink" title="负载平衡问题"></a><a href="https://www.luogu.org/problemnew/show/P4016" target="_blank" rel="noopener">负载平衡问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络流只要建出图来就好说。本题中可以这样建图：设出源点和汇点，从源点开始向每一个点引一条边，容量限制为对应点的初始值，每一个再向汇点引一条边，容量限制为所有点权之和除以点数（就是最后平衡时的点权）。这些边的费用均为0。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后再考虑点之间的转化。对于相邻的点，向这两个点引两条边，容量限制无穷大，费用为1（就是流量代价）。在这个图上跑费用流即可，答案就是最小费用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个网络流模型可以这样理解：源点对点进行初始化，汇点限制末状态，中间边代表转移，费用代表代价。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPFA+EK算法费用流</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, price;</span><br><span class="line">&#125; edge[<span class="number">20005</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">205</span>], cnt, op[<span class="number">105</span>], n, sum, vis[<span class="number">105</span>], ans, pre[<span class="number">105</span>], flow[<span class="number">105</span>], dict[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].price = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].price = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)dict[i] = <span class="number">0x7fffffff</span>, vis[<span class="number">0</span>] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    que.push(<span class="number">0</span>), vis[<span class="number">0</span>] = <span class="number">1</span>, dict[<span class="number">0</span>] = <span class="number">0</span>, flow[<span class="number">0</span>] = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].price) &#123;</span><br><span class="line">                dict[edge[i].to] = dict[f] + edge[i].price, pre[edge[i].to] = i;</span><br><span class="line">                flow[edge[i].to] = min(flow[f], edge[i].v);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[n + <span class="number">1</span>] == <span class="number">-1</span> ? <span class="number">-1</span> : flow[n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op[i], head[i] = <span class="number">-1</span>;</span><br><span class="line">        sum += op[i];</span><br><span class="line">    &#125;</span><br><span class="line">    head[<span class="number">0</span>] = head[n + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)add(<span class="number">0</span>, i, op[i], <span class="number">0</span>), add(i, n + <span class="number">1</span>, sum / n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//建图过程</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="number">1</span>), add(<span class="number">1</span>, n, <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n)add(n, n - <span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="number">1</span>), add(n, <span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> add(i, i - <span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="number">1</span>), add(i, i + <span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> increase;</span><br><span class="line">    <span class="keyword">while</span> ((increase = SPFA()) != <span class="number">-1</span>) &#123;<span class="comment">//费用流算法</span></span><br><span class="line">        <span class="keyword">int</span> p = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">0</span>)edge[pre[p]].v -= increase, edge[pre[p] ^ <span class="number">1</span>].v += increase, p = edge[pre[p] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += increase * dict[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最小路径覆盖问题（模板）"><a href="#最小路径覆盖问题（模板）" class="headerlink" title="最小路径覆盖问题（模板）"></a><a href="https://www.luogu.org/problemnew/show/P2764" target="_blank" rel="noopener">最小路径覆盖问题（模板）</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个重要模型。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于DAG上的最小路径覆盖，我们可以这样理解：起初，可以将所有的点视为一个个独立的集合，这样集合数量为n（n为点数），这个值很可能不是最小的；这时注意到两个路径之间可以合并，且对于每一个点只能合并一次，每合并一个就意味着答案减去1。这样建图方法就可以推知了。首先将每一个点分为$x$,$y$，从源点开始向每一个点的$x$点引一条边，容量为1，再从每一个点的$y$开始，向汇点引一条边，容量为1。对于原DAG上的每一条边$(a,b)$，在网络流上建立边$(x_a,y_b)$，容量为1。这样做可以使每一个点仅能使用一次，最后的流量就是合并的次数。在图上跑最大流算法，求出最大流$flow$，答案就是$n-flow$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dinic算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v;</span><br><span class="line">&#125; edge[<span class="number">20005</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">500</span>], cnt, n, m, d[<span class="number">500</span>], cur[<span class="number">500</span>], vis[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) || limit == <span class="number">0</span>)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[x] = i;<span class="comment">//当前弧优化</span></span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[x] + <span class="number">1</span> &amp;&amp; (f = DFS(edge[i].to, min(edge[i].v, limit)))) &#123;</span><br><span class="line">            edge[i].v -= f, edge[i ^ <span class="number">1</span>].v += f, limit -= f, flow += f;</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); i++)d[i] = <span class="number">0x7fffffff</span>, cur[i] = head[i];</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>, que.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (f == (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[edge[i].to] == <span class="number">0x7fffffff</span> &amp;&amp; edge[i].v &gt; <span class="number">0</span>)d[edge[i].to] = d[f] + <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//递归找答案</span></span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].to &gt; n &amp;&amp; edge[i].to &lt;= (n &lt;&lt; <span class="number">1</span>) &amp;&amp; edge[i].v == <span class="number">0</span>) &#123;<span class="comment">//流出点为邻接点</span></span><br><span class="line">            solve(edge[i].to - n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        add(x, y + n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)add(<span class="number">0</span>, i, <span class="number">1</span>), add(i + n, n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS())ans += DFS(<span class="number">0</span>, <span class="number">0x7fffffff</span>);</span><br><span class="line">    ans = n - ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[j + n]; ~e; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge[e].to == (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp;&amp; edge[e].v == <span class="number">1</span>) &#123;<span class="comment">//没有流，说明是起点</span></span><br><span class="line">                    solve(j);</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有环的有向图，可以先tarjan缩点，再跑网络流。</p>
<h3 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a><a href="https://www.luogu.org/problemnew/show/P2765" target="_blank" rel="noopener">魔术球问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个在上面模板的基础上就很好理解。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到每一个柱子上的数必然是递增的，并且每一个柱子都可以看成是一个路径（结合模板）。可以从小到大枚举答案，建图跑最大流，然后更新答案。这里根据答案单调性，可以用二分优化。下面代码是朴素的方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v;</span><br><span class="line">&#125; edge[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">5005</span>], cnt, sp, d[<span class="number">5005</span>], cur[<span class="number">5005</span>], vis[<span class="number">5005</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == (N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) || limit == <span class="number">0</span>)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[x] = i;<span class="comment">//当前弧优化</span></span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[x] + <span class="number">1</span> &amp;&amp; (f = DFS(edge[i].to, min(edge[i].v, limit)))) &#123;</span><br><span class="line">            edge[i].v -= f, edge[i ^ <span class="number">1</span>].v += f, limit -= f, flow += f;</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); i++)d[i] = <span class="number">0x7fffffff</span>, cur[i] = head[i];</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>, que.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (f == (N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[edge[i].to] == <span class="number">0x7fffffff</span> &amp;&amp; edge[i].v &gt; <span class="number">0</span>)d[edge[i].to] = d[f] + <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].to &gt; N &amp;&amp; edge[i].to &lt;= N + ans &amp;&amp; edge[i].v == <span class="number">0</span>) &#123;</span><br><span class="line">            solve(edge[i].to - N);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; sp;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), add(<span class="number">1</span> + N, N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">1</span>), add(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>), add(<span class="number">2</span> + N, N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//先加入1和2这两个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">3</span>; now &lt;= N; now++) &#123;</span><br><span class="line">        add(<span class="number">0</span>, now, <span class="number">1</span>), add(now + N, N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//加入新边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; now; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sp = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(i + now);</span><br><span class="line">            <span class="keyword">if</span> (sp * sp == i + now)add(i, now + N, <span class="number">1</span>);<span class="comment">//加入新边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (BFS())flow += DFS(<span class="number">0</span>, <span class="number">0x7fffffff</span>);<span class="comment">//跑Dinic最大流，这里不用清图，在上一个的基础上跑算法即可</span></span><br><span class="line">        <span class="keyword">if</span> (now - flow &lt;= sp)ans = now;</span><br><span class="line">        <span class="keyword">if</span> (now - flow &gt; sp)<span class="keyword">break</span>;<span class="comment">//提前结束，相当于剪枝</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sp; i++) &#123;<span class="comment">//这里和模板的处理方式基本相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ans; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[j + N]; ~e; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge[e].to == (N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp;&amp; edge[e].v == <span class="number">1</span>) &#123;</span><br><span class="line">                    solve(j);</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="试题库问题"><a href="#试题库问题" class="headerlink" title="试题库问题"></a><a href="https://www.luogu.org/problemnew/show/P2763" target="_blank" rel="noopener">试题库问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题比较简单。考虑到每一个题只能用一次，而且它只能对一个类型做出贡献。建立源点到每一个点的边，容量为1，然后对于一个题目的类型，从该点出发向类型建立边，容量为1，最后从每个类型开始，向汇点建立边，容量为规定的题目数量。在这个图上跑最大流即可。如果最大流不足m，则无解。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v;</span><br><span class="line">&#125; edge[<span class="number">50000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">5000</span>], cnt, k, n, kp[<span class="number">25</span>], d[<span class="number">5000</span>], cur[<span class="number">5005</span>], sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) || limit == <span class="number">0</span>)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[x] + <span class="number">1</span> &amp;&amp; (f = DFS(edge[i].to, min(edge[i].v, limit)))) &#123;</span><br><span class="line">            edge[i].v -= f, edge[i ^ <span class="number">1</span>].v += f, limit -= f, flow += f;</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); i++)d[i] = <span class="number">0x7fffffff</span>, cur[i] = head[i];</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>, que.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (f == (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[edge[i].to] == <span class="number">0x7fffffff</span> &amp;&amp; edge[i].v &gt; <span class="number">0</span>)d[edge[i].to] = d[f] + <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; kp[i];</span><br><span class="line">        add(i + n, n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, kp[i]), sum += kp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        add(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">        <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(i, x + n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS())ans += DFS(<span class="number">0</span>, <span class="number">0x7fffffff</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans != sum)<span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution!"</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[i + n]; ~e; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge[e].to &gt;= <span class="number">1</span> &amp;&amp; edge[e].to &lt;= n &amp;&amp; edge[e].v == <span class="number">1</span>)<span class="built_in">cout</span> &lt;&lt; edge[e].to &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方格取数问题"><a href="#方格取数问题" class="headerlink" title="方格取数问题"></a><a href="https://www.luogu.org/problemnew/show/P2774" target="_blank" rel="noopener">方格取数问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对棋盘上的点进行黑白染色，可以得到一个二分图。现在需要在上面选几个点，使得它们两两不相邻，可以这样建图：从源点引边指向黑点，容量限制为黑点的值，从白点引边指向汇点，容量限制为白点的值；对于相邻的黑点和白点，从黑点开始引边指向相应的白点，容量限制为无穷大。建完图之后，在这个图上求最小割。可以这样理解：对网络流的割就是断开某些边使源点汇点不连通且边权最小，由于黑白点之间边权为无穷大，故它们必然不会被割，这样只能割与源点和汇点相连的边，一条边被割便意味着与之对应的点不选。对于一个合理的选点情况，将它们放到图中，源点和汇点应该是不连通的。我们在图上求最小割，本质上是删点的过程，它使得源点汇点不连通，这样剩下的点就是我们需要选的点，并保证了被删去的点点权尽可能小，从而得到最大的答案。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是答案就是所有数的和与最小割的差。由于某种原因，本题代码用python给出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n, m</span><br><span class="line">    <span class="keyword">return</span> m * x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    next = <span class="number">0</span></span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    to = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addEdge</span><span class="params">(x, y, zt)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cnt, edge, head</span><br><span class="line">    edge.append(Edge())</span><br><span class="line">    edge.append(Edge())</span><br><span class="line">    edge[cnt].to = y</span><br><span class="line">    edge[cnt].next = head[x]</span><br><span class="line">    edge[cnt].v = zt</span><br><span class="line">    head[x] = cnt</span><br><span class="line">    cnt = cnt + <span class="number">1</span></span><br><span class="line">    edge[cnt].to = x  <span class="comment"># 反边</span></span><br><span class="line">    edge[cnt].next = head[y]</span><br><span class="line">    edge[cnt].v = <span class="number">0</span></span><br><span class="line">    head[y] = cnt</span><br><span class="line">    cnt = cnt + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(x, limit)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n, m, head, edge</span><br><span class="line">    <span class="keyword">if</span> x == n * m + <span class="number">1</span> <span class="keyword">or</span> limit == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> limit</span><br><span class="line">    e = int(head[x])</span><br><span class="line">    flow = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> e != <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">if</span> d[edge[e].to] == d[x] + <span class="number">1</span>:</span><br><span class="line">            f = DFS(edge[e].to, min(edge[e].v, limit))</span><br><span class="line">            <span class="keyword">if</span> f &gt; <span class="number">0</span>:</span><br><span class="line">                edge[e].v -= f</span><br><span class="line">                edge[e ^ <span class="number">1</span>].v += f</span><br><span class="line">                flow += f</span><br><span class="line">                limit -= f</span><br><span class="line">                <span class="keyword">if</span> limit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        e = edge[e].next</span><br><span class="line">    <span class="keyword">return</span> int(flow)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n, m, inf, head, edge</span><br><span class="line">    que = Queue(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">0</span>, n * m + <span class="number">2</span>):</span><br><span class="line">        d[it] = inf</span><br><span class="line">    d[n * m] = <span class="number">0</span></span><br><span class="line">    que.put(n * m)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> que.empty():</span><br><span class="line">        f = que.get()</span><br><span class="line">        e = head[f]</span><br><span class="line">        <span class="keyword">if</span> f == n * m + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> e != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> edge[e].v &gt; <span class="number">0</span> <span class="keyword">and</span> d[edge[e].to] == inf:</span><br><span class="line">                d[edge[e].to] = d[f] + <span class="number">1</span></span><br><span class="line">                que.put(edge[e].to)</span><br><span class="line">            e = edge[e].next</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lss = input().split()</span><br><span class="line">n = int(lss[<span class="number">0</span>])</span><br><span class="line">m = int(lss[<span class="number">1</span>])</span><br><span class="line">d = []</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">head = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">inf = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">edge = []</span><br><span class="line">op = []</span><br><span class="line">X = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">Y = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">    lss = input().split()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m):</span><br><span class="line">        op.append(int(lss[j]))</span><br><span class="line">        sum += int(lss[j])</span><br><span class="line">        head.append(<span class="number">-1</span>)</span><br><span class="line">        d.append(<span class="number">0</span>)</span><br><span class="line">head.append(<span class="number">-1</span>)</span><br><span class="line">d.append(<span class="number">0</span>)  <span class="comment"># 源点：nm</span></span><br><span class="line">head.append(<span class="number">-1</span>)</span><br><span class="line">d.append(<span class="number">0</span>)  <span class="comment"># 汇点：nm+1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m):</span><br><span class="line">        <span class="keyword">if</span> (i + j) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            addEdge(n * m, ID(i, j), op[ID(i, j)])</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):  <span class="comment"># 四个方向</span></span><br><span class="line">                xx = i + X[z]</span><br><span class="line">                yy = j + Y[z]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= xx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= yy &lt; m:</span><br><span class="line">                    addEdge(ID(i, j), ID(xx, yy), inf)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            addEdge(ID(i, j), n * m + <span class="number">1</span>, op[ID(i, j)])</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> BFS():</span><br><span class="line">    ans += DFS(n * m, inf)</span><br><span class="line">print(sum - ans)</span><br></pre></td></tr></table></figure></p>
<h3 id="最长不下降子序列问题"><a href="#最长不下降子序列问题" class="headerlink" title="最长不下降子序列问题"></a><a href="https://www.luogu.org/problemnew/show/P2766" target="_blank" rel="noopener">最长不下降子序列问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看着像一个智障的问题，其实它需要网络流解决。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问用dp搞出来，这里定义$dp[i]$为以i结尾的最长序列长度。对于第二问，可以这样建图：将所有点拆成两个部分$x$和$y$，并建边$(x_i,y_i)$，对于$dp[i]=1$的点，从源点开始向$x_i$引一条边，容量为1，对于$dp[a]+1=dp[b]$且满足不下降条件的$a$和$b(a &lt; b)$，引边$(y_a,x_b)$，容量为1，对于$dp[i]=s$（s为第一问答案）的点i，从$y_i$开始建边指向汇点，容量为1。容量为1保证了每一个点只能选一次，该图的最大流就是第二问答案。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三问对于$dp[a]+1=dp[b]$且满足不下降条件的$a$和$b(a &lt; b)$之间的边$(y_a,x_b)$，容量仍然为1，其余均置为无穷大。这些边没有容量限制意味着起点和终点可以有多个去向（来源），从而达到复用起点终点的目的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意这种方法需要特判第一问答案为1的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;30)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">505</span>], op[<span class="number">505</span>], n, s = <span class="number">1</span>, s2, s3;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v;</span><br><span class="line">&#125; edge[<span class="number">60000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1005</span>], cnt, d[<span class="number">1005</span>], cur[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) || limit == <span class="number">0</span>)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[i].to] == d[x] + <span class="number">1</span> &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123;</span><br><span class="line">            edge[i].v -= f, edge[i ^ <span class="number">1</span>].v += f, limit -= f, flow += f;</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); i++)d[i] = inf, cur[i] = head[i];</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>, que.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (f == (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; d[edge[i].to] == inf)d[edge[i].to] = d[f] + <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">cin</span> &gt;&gt; op[i];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)<span class="keyword">if</span> (op[i] &gt;= op[j])dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        s = max(s, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        add(i, i + n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == <span class="number">1</span>)add(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == s)add(i + n, n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)<span class="keyword">if</span> (op[j] &gt;= op[i] &amp;&amp; dp[j] == dp[i] + <span class="number">1</span>)add(i + n, j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (BFS())s2 += DFS(<span class="number">0</span>, inf);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    cnt = <span class="number">0</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        add(i, i + n, <span class="number">100000</span>);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == <span class="number">1</span>)add(<span class="number">0</span>, i, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == s)add(i + n, n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)<span class="keyword">if</span> (op[j] &gt;= op[i] &amp;&amp; dp[j] == dp[i] + <span class="number">1</span>)add(i + n, j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (BFS())s3 += DFS(<span class="number">0</span>, inf);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="NOI2009-植物大战僵尸（模板）"><a href="#NOI2009-植物大战僵尸（模板）" class="headerlink" title="[NOI2009]植物大战僵尸（模板）"></a><a href="https://www.luogu.org/problemnew/show/P2805" target="_blank" rel="noopener">[NOI2009]植物大战僵尸（模板）</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以作为最大权闭合子图的模板题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将每一个格子抽象为点，它们的顺序抽象为边可以建出一个图，具体做法：从某一个植物开始，向它保护的格子连有向边，同时对于每一行，右边的格子向左边相邻的格子连有向边。容易发现，有向边规定了攻击的顺序，只有将某一个格子的前驱结点全部攻击之后，才可以攻击这个格子。这里可以按照拓扑排序的方法来理解。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这个有向图，如果其中存在环，那么这个环一定是不可破的，它之后的所有点都同时不可破。因此在建完图之后需要来一次tarjan算法进行缩点，对于那些成环的点，将其缩成一点并打上标记，同时进行DFS对其之后的所有点也打上标记。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽离所有被打上标记的点，可以得到一个新图，现在问题转化为：在这个图上选取一些点，满足拓扑排序规则，使其权值之和最大。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样其实不好处理，可以将图反建，此时注意到要选取一个点，必须将其之后的点（就是原图中的前驱点）全部选上，本质上选了一个闭合子图，那么问题转化成求一个有向图的最大权闭合子图，可以用最小割来解决。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来建网络流图。对于求最大权闭合子图的网络流建模，可采用这样的方法：对于点权非负的点，从源点开始向其引一条边，容量限制为点权；对于权值为负的点，从其开始向汇点引一条边，容量限制为点权的相反数；对于原图中的边，将其直接搬到网络流图中，容量限制为无穷大。在这个图上求最小割，答案就是点权非负的权值之和与最小割的差。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) (x)*m+(y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S (n*m+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T (n*m+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF (1&lt;&lt;28)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, from;</span><br><span class="line">&#125; edge[<span class="number">3</span>][N * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">3</span>][N], cnt[<span class="number">3</span>], n, m, op[N], num[N], DFN[N], LOW[N], vis[N], DFNCNT, op2[N];</span><br><span class="line"><span class="keyword">int</span> cor[N], corID = <span class="number">1</span>, d[N], ans;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    edge[p][cnt[p]].to = y, edge[p][cnt[p]].v = z, edge[p][cnt[p]].next = head[p][x], edge[p][cnt[p]].from = x;</span><br><span class="line">    head[p][x] = cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//tarjan缩点染色</span></span><br><span class="line">    <span class="keyword">if</span> (DFN[x])<span class="keyword">return</span>;</span><br><span class="line">    DFN[x] = LOW[x] = ++DFNCNT, sta.push(x), vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">0</span>][x]; ~i; i = edge[<span class="number">0</span>][i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DFN[edge[<span class="number">0</span>][i].to] == <span class="number">0</span>)tarjan(edge[<span class="number">0</span>][i].to), LOW[x] = min(LOW[edge[<span class="number">0</span>][i].to], LOW[x]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[edge[<span class="number">0</span>][i].to])LOW[x] = min(DFN[edge[<span class="number">0</span>][i].to], LOW[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LOW[x] == DFN[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">do</span> vis[p = sta.top()] = <span class="number">0</span>, cor[p] = corID, sta.pop(), ++num[cor[p]];</span><br><span class="line">        <span class="keyword">while</span> (p != x);</span><br><span class="line">        <span class="keyword">if</span> (num[cor[p]] == <span class="number">1</span>)num[cor[p]] = <span class="number">0</span>, op2[cor[p]] = op[x];<span class="comment">//表示这个点可破</span></span><br><span class="line">        ++corID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>][x]; ~i; i = edge[<span class="number">1</span>][i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[edge[<span class="number">1</span>][i].to])vis[edge[<span class="number">1</span>][i].to] = <span class="number">1</span>, DFS(edge[<span class="number">1</span>][i].to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T || limit == <span class="number">0</span>)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">2</span>][x]; ~i; i = edge[<span class="number">2</span>][i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[edge[<span class="number">2</span>][i].to] == d[x] + <span class="number">1</span> &amp;&amp; (f = DFS(edge[<span class="number">2</span>][i].to, min(edge[<span class="number">2</span>][i].v, limit)))) &#123;</span><br><span class="line">            edge[<span class="number">2</span>][i].v -= f, edge[<span class="number">2</span>][i ^ <span class="number">1</span>].v += f, flow += f, limit -= f;</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; corID; i++)d[i] = INF;</span><br><span class="line">    d[S] = <span class="number">0</span>, d[T] = INF, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (f == T)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">2</span>][f]; ~i; i = edge[<span class="number">2</span>][i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">2</span>][i].v &gt; <span class="number">0</span> &amp;&amp; d[edge[<span class="number">2</span>][i].to] == INF)d[edge[<span class="number">2</span>][i].to] = d[f] + <span class="number">1</span>, que.push(edge[<span class="number">2</span>][i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j)add(<span class="number">0</span>, ID(i, j), ID(i, j - <span class="number">1</span>));<span class="comment">//攻击顺序自右向左</span></span><br><span class="line">            <span class="keyword">int</span> x, y, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; op[ID(i, j)] &gt;&gt; w;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; w; z++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">                add(<span class="number">0</span>, ID(i, j), ID(x, y));<span class="comment">//保护顺序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)tarjan(ID(i, j));<span class="comment">//缩点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cor[edge[<span class="number">0</span>][i].from] != cor[edge[<span class="number">0</span>][i].to])add(<span class="number">1</span>, cor[edge[<span class="number">0</span>][i].from], cor[edge[<span class="number">0</span>][i].to]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; corID; i++)<span class="keyword">if</span> (num[i] &amp;&amp; !vis[i])vis[i] = <span class="number">1</span>, DFS(i);<span class="comment">//vis=1表示不可破</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; corID; i++) &#123;<span class="comment">//建网络流图,S源点,T汇点</span></span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op2[i] &gt;= <span class="number">0</span>)ans += op2[i], add(<span class="number">2</span>, S, i, op2[i]), add(<span class="number">2</span>, i, S, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> add(<span class="number">2</span>, i, T, -op2[i]), add(<span class="number">2</span>, T, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[edge[<span class="number">1</span>][i].from] &amp;&amp; !vis[edge[<span class="number">1</span>][i].to]) &#123;</span><br><span class="line">            add(<span class="number">2</span>, edge[<span class="number">1</span>][i].to, edge[<span class="number">1</span>][i].from, INF), add(<span class="number">2</span>, edge[<span class="number">1</span>][i].from, edge[<span class="number">1</span>][i].to, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (BFS())ans -= DFS(S, INF &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(ans, <span class="number">0</span>);<span class="comment">//注意和0取最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SDOI2009-晨跑"><a href="#SDOI2009-晨跑" class="headerlink" title="[SDOI2009]晨跑"></a><a href="https://www.luogu.org/problemnew/show/P2153" target="_blank" rel="noopener">[SDOI2009]晨跑</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该是比较裸的费用流。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于每条边只能走一次，故将容量限制设为1，又由于每一点只能走一次，可以将一个点一分为二，中间加一条容量限制为1的有向边。对于所有的原边，其费用就是距离，而对于我们加入的新边，其费用都为0。注意源点与汇点拆点时容量限制应为无穷大。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终答案就是最大流和最小费用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;29)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, p;</span><br><span class="line">&#125; edge[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, head[<span class="number">1000</span>], n, m, S, T, dict[<span class="number">8000</span>], pre[<span class="number">8000</span>], flow[<span class="number">8000</span>], vis[<span class="number">8000</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> e = getchar();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; <span class="string">'-'</span>)e = getchar();</span><br><span class="line">    <span class="keyword">while</span> (e &gt; <span class="string">'-'</span>)s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (e &amp; <span class="number">15</span>), e = getchar();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &lt;= T; i++)vis[i] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>, flow[i] = dict[i] = inf;</span><br><span class="line">    vis[S] = <span class="number">1</span>, dict[S] = <span class="number">0</span>, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].p) &#123;</span><br><span class="line">                dict[edge[i].to] = dict[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] == <span class="number">-1</span> ? <span class="number">-1</span> : flow[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(), m = read(), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)add(i, i + n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span> + n, inf, <span class="number">0</span>), add(n, n &lt;&lt; <span class="number">1</span>, inf, <span class="number">0</span>), S = <span class="number">1</span>, T = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y, z; i &lt; m; i++)x = read(), y = read(), z = read(), add(x + n, y, <span class="number">1</span>, z);</span><br><span class="line">    <span class="keyword">int</span> increase, ans = <span class="number">0</span>, minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((increase = SPFA()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = T;</span><br><span class="line">        <span class="keyword">while</span> (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ <span class="number">1</span>].v += increase, now = edge[pre[now] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += increase, minCost += dict[T] * increase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; minCost;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SCOI2007-修车"><a href="#SCOI2007-修车" class="headerlink" title="[SCOI2007]修车"></a><a href="https://www.luogu.org/problemnew/show/P2053" target="_blank" rel="noopener">[SCOI2007]修车</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仍然是费用流，不过不是那么容易建图。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑一个师傅修若干辆车的总等待时间。如果修了$s$辆车，修车时间分别为$W_1,W_2,\cdots,W_s$，按照这个修车顺序，总时间为：</p>
<script type="math/tex; mode=display">T=sW_1+(s-1)W_2+\cdots+W_s</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，越先修车的对时间造成代价最大，并且可以发现，在修车的师傅固定时，每一个车对总代价的贡献只与它的顺序有关。如果这辆车是倒数第t个，那么它对总时间的贡献为$tW$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，可以建立车与修车师傅以及顺序之间的关系。将$M$个修车师傅看成$M$个点，再将它们分为$N$个点，表示N个顺序，其中第$i$个点表示倒数第$i$个修。这样可以建立车（$N$个点）到修车师傅以及顺序（$MN$个点）的完全二分图，权值为$iW$（与上文理解相同）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建完图之后，问题转化为求这个二分图上的最小权值完美匹配（只需要N个车完全匹配）。这样做的可行性在于，对于每一个师傅，他修车的顺序可以保证是连续的。证明：假设匹配时车$m$与第$i$位师傅的第$j$个点匹配（表示倒数第j个修），却没有车与第$j+1$个点匹配，又同时有车$n$与第$j+p(p&gt;1)$匹配。这时由于车$n$与第$j+1$个点匹配的权值更小，不满足最优性，故在保证最小权值的前提下这种不连续的情况不可能发生。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带权二分图匹配可以用网络流解决，这个方面的说明在网络流最后，文章链接见本文最开始部分。注意这里是求最小权值，故费用不用取相反数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;29)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, p;</span><br><span class="line">&#125; edge[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, head[<span class="number">1000</span>], n, m, S, T, dict[<span class="number">8000</span>], pre[<span class="number">8000</span>], flow[<span class="number">8000</span>], vis[<span class="number">8000</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> e = getchar();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; <span class="string">'-'</span>)e = getchar();</span><br><span class="line">    <span class="keyword">while</span> (e &gt; <span class="string">'-'</span>)s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (e &amp; <span class="number">15</span>), e = getchar();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + n * m + <span class="number">2</span>; i++)vis[i] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>, flow[i] = dict[i] = inf;</span><br><span class="line">    vis[S] = <span class="number">1</span>, dict[S] = <span class="number">0</span>, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].p) &#123;</span><br><span class="line">                dict[edge[i].to] = dict[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] == <span class="number">-1</span> ? <span class="number">-1</span> : flow[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = read(), n = read(), S = n + n * m + <span class="number">1</span>, T = n + n * m + <span class="number">2</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = read();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ss = <span class="number">1</span>; ss &lt;= n; ss++)add(i, n + (j - <span class="number">1</span>) * n + ss, <span class="number">1</span>, z * ss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)add(S, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)add(n + (i - <span class="number">1</span>) * n + j, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> increase, ans = <span class="number">0</span>, minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((increase = SPFA()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = T;</span><br><span class="line">        <span class="keyword">while</span> (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ <span class="number">1</span>].v += increase, now = edge[pre[now] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += increase, minCost += dict[T] * increase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f"</span>, minCost / (<span class="keyword">double</span>) n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZJOI2010-网络扩容"><a href="#ZJOI2010-网络扩容" class="headerlink" title="[ZJOI2010]网络扩容"></a><a href="https://www.luogu.org/problemnew/show/P2604" target="_blank" rel="noopener">[ZJOI2010]网络扩容</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的费用流。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问就是一个纯裸的网络最大流，直接求即可。再来看第二问，我们直接在图上的原边位置都分别加上一条与之相同的边，只不过将费用设置成相应的值，并将容量限制设置为无穷大，这样就可以使网络沿我们新加的边流，达到扩容的目的。根据最小费用的最优性，只有原边在满流时才可能沿费用不为0的新边，这个条件保证了答案正确性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这样加边无法限制最终流量，因此需要再引入一个新点，将原有汇点引一条边指向该点，并使容量限制为对应值，费用为0，这样就可以限制整体的流量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后在这个网络流图上跑一遍费用流即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;29)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) ((x-1)*m+y)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, p;</span><br><span class="line">&#125; edge[<span class="number">80000</span>], edge2[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, head[<span class="number">8000</span>], head2[<span class="number">8000</span>], n, m, S, T, dict[<span class="number">8000</span>], pre[<span class="number">8000</span>], flow[<span class="number">8000</span>], vis[<span class="number">8000</span>], k, cnt2;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> e = getchar();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; <span class="string">'-'</span>)e = getchar();</span><br><span class="line">    <span class="keyword">while</span> (e &gt; <span class="string">'-'</span>)s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (e &amp; <span class="number">15</span>), e = getchar();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    edge2[cnt2].to = y, edge2[cnt2].next = head2[x], edge2[cnt2].v = v, edge2[cnt2].p = p, head2[x] = cnt2++;</span><br><span class="line">    edge2[cnt2].to = x, edge2[cnt2].next = head2[y], edge2[cnt2].v = <span class="number">0</span>, edge2[cnt2].p = -p, head2[y] = cnt2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)vis[i] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>, flow[i] = dict[i] = inf;</span><br><span class="line">    vis[S] = <span class="number">1</span>, dict[S] = <span class="number">0</span>, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].p) &#123;</span><br><span class="line">                dict[edge[i].to] = dict[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] == <span class="number">-1</span> ? <span class="number">-1</span> : flow[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)vis[i] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>, flow[i] = dict[i] = inf;</span><br><span class="line">    vis[S] = <span class="number">1</span>, dict[S] = <span class="number">0</span>, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head2[f]; ~i; i = edge2[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge2[i].v &gt; <span class="number">0</span> &amp;&amp; dict[edge2[i].to] &gt; dict[f] + edge2[i].p) &#123;</span><br><span class="line">                dict[edge2[i].to] = dict[f] + edge2[i].p, pre[edge2[i].to] = i;</span><br><span class="line">                flow[edge2[i].to] = min(flow[f], edge2[i].v);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge2[i].to])que.push(edge2[i].to), vis[edge2[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] == <span class="number">-1</span> ? <span class="number">-1</span> : flow[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read(), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)), S = <span class="number">1</span>, <span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head2)), T = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y, z, p; i &lt; m; i++)</span><br><span class="line">        x = read(), y = read(), z = read(), p = read(), add(x, y, z, <span class="number">0</span>), add2(x, y, z, <span class="number">0</span>), add2(x, y, inf, p);</span><br><span class="line">    <span class="keyword">int</span> increase, ans = <span class="number">0</span>, minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((increase = SPFA()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = T;</span><br><span class="line">        <span class="keyword">while</span> (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ <span class="number">1</span>].v += increase, now = edge[pre[now] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += increase, minCost += dict[T] * increase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span>, k += ans, T = n + <span class="number">1</span>, add2(n, T, k, <span class="number">0</span>), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((increase = SPFA2()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = T;</span><br><span class="line">        <span class="keyword">while</span> (now != S)edge2[pre[now]].v -= increase, edge2[pre[now] ^ <span class="number">1</span>].v += increase, now = edge2[pre[now] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += increase, minCost += dict[T] * increase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minCost;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="NOI2012-美食节"><a href="#NOI2012-美食节" class="headerlink" title="[NOI2012]美食节"></a><a href="https://www.luogu.org/problemnew/show/P2050" target="_blank" rel="noopener">[NOI2012]美食节</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个题与上面“修车”这道题很像，推荐先做上面那一道再做本题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本思路与修车相同。将厨师按照时间戳拆点，然后连边形成完全二分图，再跑网络流即可。但是本题数据量比较大，直接就会导致TLE，因此需要加一些优化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到每一次增广必定先连接某个厨师的倒数第一个时间戳位置，因此一开始我们先只连接所有厨师的倒数第一个时间戳位置，当一次增广完成后，再动态加边，这样可以有效地降低时间复杂度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;29)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) (x-1)*p+y+n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 80100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, p;</span><br><span class="line">&#125; edge[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, head[<span class="number">80100</span>], n, m, S, T, p, dict[<span class="number">80100</span>], pre[<span class="number">80100</span>], flow[<span class="number">80100</span>], vis[<span class="number">80100</span>], op[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> sp[<span class="number">45</span>][<span class="number">101</span>], que[N], f, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> e = getchar();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; <span class="string">'-'</span>)e = getchar();</span><br><span class="line">    <span class="keyword">while</span> (e &gt; <span class="string">'-'</span>)s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (e &amp; <span class="number">15</span>), e = getchar();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f = b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p * m + n + <span class="number">2</span>; i++)vis[i] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>, flow[i] = dict[i] = inf;</span><br><span class="line">    vis[S] = <span class="number">1</span>, dict[S] = <span class="number">0</span>, que[b] = S, b = (b + <span class="number">1</span>) % N;</span><br><span class="line">    <span class="keyword">while</span> (f != b) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> fbd = que[f];</span><br><span class="line">        f = (f + <span class="number">1</span>) % N, vis[fbd] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[fbd]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dict[edge[i].to] &gt; dict[fbd] + edge[i].p) &#123;</span><br><span class="line">                dict[edge[i].to] = dict[fbd] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[fbd],</span><br><span class="line">                                                                                                      edge[i].v);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que[b] = edge[i].to, b = (b + <span class="number">1</span>) % N, vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] == <span class="number">-1</span> ? <span class="number">-1</span> : flow[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(), m = read(), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)op[i] = read(), p += op[i];</span><br><span class="line">    S = m * p + n + <span class="number">1</span>, T = m * p + n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)add(S, i, op[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)sp[i][j] = read(), add(i, ID(j, <span class="number">1</span>), <span class="number">1</span>, sp[i][j]);<span class="comment">//只连接一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> ps = <span class="number">1</span>; ps &lt;= p; ps++)add(ID(i, ps), T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> increase, ans = <span class="number">0</span>, minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((increase = SPFA()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> now = T, to = edge[pre[T] ^ <span class="number">1</span>].to - n - <span class="number">1</span>, x = to / p + <span class="number">1</span>, y = to % p + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; p)<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)add(i, ID(x, y + <span class="number">1</span>), <span class="number">1</span>, (y + <span class="number">1</span>) * sp[i][x]);<span class="comment">//加边</span></span><br><span class="line">        <span class="keyword">while</span> (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ <span class="number">1</span>].v += increase, now = edge[pre[now] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += increase, minCost += dict[T] * increase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, minCost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="餐巾计划问题"><a href="#餐巾计划问题" class="headerlink" title="餐巾计划问题"></a><a href="https://www.luogu.org/problemnew/show/P1251" target="_blank" rel="noopener">餐巾计划问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别好的一道网络流，建图方式不那么容易想到。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认清一个事实：每天早上都会通过一些方式（新购买或者经过清洗）得到该天需要的餐巾，晚上会得到同等数量的脏餐巾，根据这个事实就可以完成建图。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将每一天对应的点拆为早上（设为$D(x)$）和晚上（设为$D’(x)$）两个，早上表示新餐巾的流入，晚上表示脏餐巾的流出。建图方式如下：</p>
<ul>
<li>每天都可以购入新餐巾，加边$S-&gt;D(x)$，流量无穷大，费用为$p$。</li>
<li>每天都需要一定数量的餐巾（设为$c_i$），加边$D(x)-&gt;T$，流量$c_i$，费用0。</li>
<li>每天产生$c_i$数量的脏餐巾，加边$S-&gt;D’(x)$，流量$c_i$，费用0。</li>
<li>脏餐巾可以经过清洗，加边$D’(x)-&gt;D(x+m)$，流量无穷大，费用$f$，当然还要连接$D’(x)-&gt;D(x+n)$，费用就是$s$。</li>
<li>脏餐巾可以延期清洗，加边$D’(x)-&gt;D’(x+1)$，表示当天的脏餐巾可以流入下一天晚上，流量无穷大，费用0。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跑费用流即可。这里需要注意的一点是，在建图时可能会想到直接将早上对应的点连向当天晚上，来达到将早上餐巾用脏后流入晚上处理的效果，这样做并不正确，因为这些经过清洗的餐巾它们经过了多次利用，却用了同一个流，会导致总体流量减小，跑最小费用最大流时就不会再考虑这些重复利用的流，答案自然就不正确。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们这里的做法是给这些脏餐巾分配新的流，就可以保证正确性了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S ((N&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T ((N&lt;&lt;1)+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) ((x-1)*2+y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;29)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, p;</span><br><span class="line">&#125; edge[<span class="number">8000000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">4500</span>], N, p, m, f, n, s, vis[<span class="number">4500</span>], flow[<span class="number">4500</span>], pre[<span class="number">4500</span>], dis[<span class="number">4500</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ff, minCost;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> e = getchar();</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; <span class="string">'-'</span>)e = getchar();</span><br><span class="line">    <span class="keyword">while</span> (e &gt; <span class="string">'-'</span>)s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (e &amp; <span class="number">15</span>), e = getchar();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)vis[i] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>, dis[i] = inf;</span><br><span class="line">    dis[S] = <span class="number">0</span>, que.push(S), vis[S] = <span class="number">1</span>, flow[S] = inf;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123;</span><br><span class="line">                dis[edge[i].to] = dis[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(edge[i].v, flow[f]);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = read(), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= N; i++)add(ID(i, <span class="number">2</span>), T, x = read(), <span class="number">0</span>), add(S, ID(i, <span class="number">1</span>), x, <span class="number">0</span>);</span><br><span class="line">    p = read(), m = read(), f = read(), n = read(), s = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)add(S, ID(i, <span class="number">2</span>), inf, p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)add(ID(i, <span class="number">1</span>), ID(i + <span class="number">1</span>, <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + m &lt;= N)add(ID(i, <span class="number">1</span>), ID(i + m, <span class="number">2</span>), inf, f);</span><br><span class="line">        <span class="keyword">if</span> (i + n &lt;= N)add(ID(i, <span class="number">1</span>), ID(i + n, <span class="number">2</span>), inf, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (SPFA()) &#123;</span><br><span class="line">        <span class="keyword">int</span> ss = T;</span><br><span class="line">        <span class="keyword">while</span> (ss != S)edge[pre[ss]].v -= flow[T], edge[pre[ss] ^ <span class="number">1</span>].v += flow[T], ss = edge[pre[ss] ^ <span class="number">1</span>].to;</span><br><span class="line">        ff += flow[T], minCost += flow[T] * dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minCost;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CTSC1999-家园"><a href="#CTSC1999-家园" class="headerlink" title="[CTSC1999]家园"></a><a href="https://www.luogu.org/problemnew/show/P2754" target="_blank" rel="noopener">[CTSC1999]家园</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要技巧的网络流，还需要并查集以及枚举相关的知识。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到结点的转移与时间有关，那么按时间拆点是必要的：规定$D(x,t)$为$x$在时间$t$时的对应点（$x$为0或-1时为地球和月球）。建图方式如下：</p>
<ul>
<li>当某一时间$t$有太空船到达地球时，连接$S-&gt;D(0,t)$，容量为太空船的容量。</li>
<li>对于一个时刻$t$的太空站$x$，连接$D(x,t)-&gt;D(x’,t+1)$，这里$x’$根据太空船航线确定，容量为太空船容量。</li>
<li>对于所有时刻$t$，连接$D(-1,t)-&gt;T$，容量限制为无穷大。</li>
<li>对于所有太空站$x$，由于其中的人可以停留一站，故连接$D(x,t)-&gt;D(x,t+1)$，容量无穷大。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举时间$t$，动态加边，当最大流达到$k$时，此时的$t$就是答案。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于可能有无解的情况，需要先进行一步有解性判断。考虑到所有太空船的航线都相当于一个强连通分量，可以直接用并查集将它们合并起来，如果最后月球与地球是连通的，则有解，否则没有。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> merge_ID(x) (x==0?n+1:(x==-1?n+2:x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, t) ((t)*(n+2)+merge_ID(x)+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;28)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">50</span>], h[<span class="number">50</span>], n, m, k, head[<span class="number">500000</span>], ans, deep[<span class="number">500000</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v;</span><br><span class="line">&#125; edge[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findF</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = findF(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = findF(x), f2 = findF(y);</span><br><span class="line">    <span class="keyword">if</span> (f1 != f2)fa[f1] = f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (limit == <span class="number">0</span> || x == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[edge[i].to] == deep[x] + <span class="number">1</span> &amp;&amp;</span><br><span class="line">            (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123;</span><br><span class="line">            edge[i].v -= f, edge[i ^ <span class="number">1</span>].v += f, flow += f, limit -= f;</span><br><span class="line">            <span class="keyword">if</span> (!limit)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="built_in">memset</span>(deep, <span class="number">127</span>, <span class="keyword">sizeof</span>(deep)), deep[S] = <span class="number">0</span>, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; deep[edge[i].to] &gt; inf) &#123;</span><br><span class="line">                deep[edge[i].to] = deep[f] + <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">2</span>; i++)fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; h[i] &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, y; j &lt;= x; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">            vec[i].push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[i].size() - <span class="number">1</span>; j++) merge(merge_ID(vec[i][j]), merge_ID(vec[i][j + <span class="number">1</span>]));</span><br><span class="line">        merge(merge_ID(vec[i][vec[i].size() - <span class="number">1</span>]), merge_ID(vec[i][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (findF(merge_ID(<span class="number">0</span>)) != findF(merge_ID(<span class="number">-1</span>))) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="keyword">if</span> (vec[i][<span class="number">0</span>] == <span class="number">0</span>)add(S, ID(<span class="number">0</span>, <span class="number">0</span>), h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>;; t++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i][t % vec[i].size()] != <span class="number">0</span> &amp;&amp; vec[i][(t - <span class="number">1</span>) % vec[i].size()] != <span class="number">-1</span>)</span><br><span class="line">                add(ID(vec[i][(t - <span class="number">1</span>) % vec[i].size()], t - <span class="number">1</span>), ID(vec[i][t % vec[i].size()], t), h[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vec[i][t % vec[i].size()] == <span class="number">0</span>)add(S, ID(<span class="number">0</span>, t), h[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)add(ID(i, t - <span class="number">1</span>), ID(i, t), inf);</span><br><span class="line">        add(ID(<span class="number">-1</span>, t), T, inf);</span><br><span class="line">        <span class="keyword">while</span> (BFS())ans += DFS(S, inf);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= k) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="太空飞行计划问题"><a href="#太空飞行计划问题" class="headerlink" title="太空飞行计划问题"></a>太空飞行计划问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大权闭合子图问题，可参考上面的植物大战僵尸一题。本题更常规。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先建一个二分图，将实验连向对应的仪器。实验点权值就是其对应的赞助费用，仪器权值就是它们的价格。在这个图上跑一遍最大权闭合子图的网络流即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的问题就是如何求一种方案。如果实验对应的边被割，说明这个实验不再选用，如果仪器被割，说明购买这个仪器。是否被割可以通过权值是否为0来判断，这样就可以找出一种方案。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, t) ((1-(t))*m+x+2) <span class="comment">//t:是不是实验</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;28)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pay[<span class="number">50</span>], n, m, head[<span class="number">500000</span>], ans, deep[<span class="number">500000</span>], vis[<span class="number">500</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[<span class="number">50</span>], vvp;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v;</span><br><span class="line">&#125; edge[<span class="number">800000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (limit == <span class="number">0</span> || x == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[edge[i].to] == deep[x] + <span class="number">1</span> &amp;&amp;</span><br><span class="line">            (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123;</span><br><span class="line">            edge[i].v -= f, edge[i ^ <span class="number">1</span>].v += f, flow += f, limit -= f;</span><br><span class="line">            <span class="keyword">if</span> (!limit)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">2</span>; i++)deep[i] = inf;</span><br><span class="line">    deep[S] = <span class="number">0</span>, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; deep[edge[i].to] == inf) &#123;</span><br><span class="line">                deep[edge[i].to] = deep[f] + <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[T] != inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; !vis[edge[i].to])vis[edge[i].to] = <span class="number">1</span>, vvp.push_back(edge[i].to), DFS(edge[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)), getchar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ss[<span class="number">10000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(ss, <span class="number">0</span>, <span class="keyword">sizeof</span>(ss)), <span class="built_in">cin</span>.getline(ss, <span class="number">1000</span>), <span class="built_in">sscanf</span>(ss, <span class="string">"%d"</span>, pay + i);</span><br><span class="line">        <span class="keyword">int</span> ulen = <span class="number">0</span>, tool;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">sscanf</span>(ss + ulen, <span class="string">"%d"</span>, &amp;tool) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ulen == <span class="number">0</span>)pay[i] = tool, add(S, ID(i, <span class="number">1</span>), pay[i]), ans += pay[i];</span><br><span class="line">            <span class="keyword">else</span> add(ID(i, <span class="number">1</span>), ID(tool, <span class="number">0</span>), inf);</span><br><span class="line">            <span class="keyword">if</span> (tool == <span class="number">0</span>)ulen++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span> (tool)tool /= <span class="number">10</span>, ulen++;</span><br><span class="line">            ulen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), add(ID(i, <span class="number">0</span>), T, x);</span><br><span class="line">    <span class="keyword">while</span> (BFS())ans -= DFS(S, inf);</span><br><span class="line">    vis[S] = <span class="number">1</span>, DFS(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vvp.size(); i++)<span class="keyword">if</span> (vvp[i] - <span class="number">2</span> &lt;= m)<span class="built_in">cout</span> &lt;&lt; vvp[i] - <span class="number">2</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vvp.size(); i++)<span class="keyword">if</span> (vvp[i] - <span class="number">2</span> &gt; m)<span class="built_in">cout</span> &lt;&lt; vvp[i] - <span class="number">2</span> - m &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="航空路线问题"><a href="#航空路线问题" class="headerlink" title="航空路线问题"></a><a href="https://www.luogu.org/problemnew/show/P2770" target="_blank" rel="noopener">航空路线问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的费用流。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然每一个地点只能走一次，那么就拆点，并在两个点之间连一条容量为1的边。从终点到起点的路可以看成从起点到终点的反向路，这样问题等价于找从起点到终点的两条路，使途经点数最多。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以认为起点就是源点，终点为汇点。将汇点的入边边权设置为2，可以保证两条路径。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给边加上费用的限制（设置为-1），跑一遍费用流就可以了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意本题需要特判起点终点直接相连的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;28)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) ((x-1)*2+y)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v, p;</span><br><span class="line">&#125; edge[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">150</span>], n, v, dis[<span class="number">150</span>], flow[<span class="number">150</span>], pre[<span class="number">150</span>], vis[<span class="number">150</span>], ans, minCost;</span><br><span class="line"><span class="built_in">string</span> name[<span class="number">150</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mmp;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vvp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)dis[i] = inf, pre[i] = <span class="number">-1</span>, vis[i] = <span class="number">0</span>;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>, que.push(<span class="number">1</span>), vis[<span class="number">1</span>] = <span class="number">1</span>, flow[<span class="number">1</span>] = inf;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123;</span><br><span class="line">                dis[edge[i].to] = dis[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v);</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[<span class="number">2</span> * n] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span>)vvp.push_back(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].v == <span class="number">0</span> &amp;&amp; !vis[edge[i].to] &amp;&amp; edge[i].to &gt; x) &#123;</span><br><span class="line">            vis[edge[i].to] = <span class="number">1</span>, DFS(edge[i].to);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; v, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name[i];</span><br><span class="line">        mmp[name[i]] = i, add(ID(i, <span class="number">1</span>), ID(i, <span class="number">2</span>), i == <span class="number">1</span> ? inf : (i == n ? <span class="number">2</span> : <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1, s2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="keyword">if</span> (mmp[s1] &gt; mmp[s2])swap(s1, s2);</span><br><span class="line">        add(ID(mmp[s1], <span class="number">2</span>), ID(mmp[s2], <span class="number">1</span>), <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (SPFA()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">2</span> * n;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="number">1</span>)edge[pre[t]].v -= flow[<span class="number">2</span> * n], edge[pre[t] ^ <span class="number">1</span>].v += flow[<span class="number">2</span> * n], t = edge[pre[t] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += flow[<span class="number">2</span> * n], minCost += flow[<span class="number">2</span> * n] * dis[<span class="number">2</span> * n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">2</span>]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].to == <span class="number">2</span> * n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; name[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span> &lt;&lt; name[n] &lt;&lt; <span class="built_in">endl</span> &lt;&lt; name[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution!"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; -minCost &lt;&lt; <span class="built_in">endl</span>, <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)), DFS(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vvp.size(); i++)<span class="built_in">cout</span> &lt;&lt; name[vvp[i] / <span class="number">2</span> + <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        vvp.clear(), DFS(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = vvp.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="built_in">cout</span> &lt;&lt; name[vvp[i] / <span class="number">2</span> + <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="圆桌问题"><a href="#圆桌问题" class="headerlink" title="圆桌问题"></a><a href="https://www.luogu.org/problemnew/show/P3254" target="_blank" rel="noopener">圆桌问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以说是很简单的最大流了。将每一个单位和圆桌看成点，从源点开始向所有单位连边，容量限制为每个单位的人数；从圆桌开始向汇点连边，容量限制为圆桌上最大的人数。然后每一个单位向所有圆桌分别连边，容量限制为1，表示最多只能去一人。建好图之后跑一遍最大流，如果最大流不足总人数则无解。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于方案的输出根据原边的流量来判别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) ((y)*m+x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S (m+n+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T (m+n+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;28)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, v;</span><br><span class="line">&#125; edge[<span class="number">150</span> * <span class="number">270</span> * <span class="number">2</span> + <span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">150</span> + <span class="number">270</span> + <span class="number">10000</span>], deep[<span class="number">150</span> + <span class="number">270</span> + <span class="number">10000</span>], ans, sum, cur[<span class="number">150</span> + <span class="number">270</span> + <span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T || limit == <span class="number">0</span>)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> p, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">if</span> (deep[edge[i].to] == deep[x] + <span class="number">1</span> &amp;&amp; (p = DFS(edge[i].to, min(limit, edge[i].v)))) &#123;</span><br><span class="line">            edge[i].v -= p, edge[i ^ <span class="number">1</span>].v += p, limit -= p, flow += p;</span><br><span class="line">            <span class="keyword">if</span> (!limit)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)deep[i] = inf, cur[i] = head[i];</span><br><span class="line">    deep[S] = <span class="number">0</span>, que.push(S);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (f == T)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; deep[edge[i].to] == inf)deep[edge[i].to] = deep[f] + <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)add(ID(i, <span class="number">0</span>), ID(j, <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        add(S, ID(i, <span class="number">0</span>), x), sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        add(ID(i, <span class="number">1</span>), T, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (BFS())ans += DFS(S, inf);</span><br><span class="line">    <span class="keyword">if</span> (ans == sum)<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[ID(i, <span class="number">0</span>)]; ~j; j = edge[j].next)</span><br><span class="line">            <span class="keyword">if</span> (edge[j].v == <span class="number">0</span> &amp;&amp; edge[j].to &lt; S)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; edge[j].to - m &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="骑士共存问题"><a href="#骑士共存问题" class="headerlink" title="骑士共存问题"></a><a href="https://www.luogu.org/problemnew/show/P3355" target="_blank" rel="noopener">骑士共存问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将格子看成点，骑士可以跳跃的两个点之间关系看成边，可以得到一个二分图，问题即为求这个二分图上的最大独立集。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案就是点数与最大匹配的差，拿匈牙利算法就可以解决（<del>诶，好像与网络流没多大关系</del>）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) ((x-1)*n+y)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; edge[<span class="number">40000</span> * <span class="number">16</span> + <span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, head[<span class="number">40005</span>], vis2[<span class="number">40005</span>], be[<span class="number">40005</span>], vis[<span class="number">40005</span>], tim = <span class="number">1</span>, ans;</span><br><span class="line"><span class="keyword">bool</span> ss[<span class="number">40005</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Y[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ss[x] || ss[y])<span class="keyword">return</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[ID(x, y)]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis2[edge[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">            vis2[edge[i].to] = vis2[ID(x, y)] ^ <span class="number">1</span>;</span><br><span class="line">            DFS((edge[i].to - <span class="number">1</span>) / n + <span class="number">1</span>, (edge[i].to - <span class="number">1</span>) % n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[edge[i].to] != tim) &#123;</span><br><span class="line">            vis[edge[i].to] = tim;</span><br><span class="line">            <span class="keyword">if</span> (be[edge[i].to] == <span class="number">0</span> || f(be[edge[i].to])) &#123;</span><br><span class="line">                be[edge[i].to] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m, <span class="built_in">memset</span>(vis2, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis2)), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ss[ID(x, y)] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>, xx, yy; z &lt; <span class="number">4</span>; z++) &#123;</span><br><span class="line">                xx = i + X[z], yy = j + Y[z];</span><br><span class="line">                <span class="keyword">if</span> (xx &gt;= <span class="number">1</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= <span class="number">1</span> &amp;&amp; yy &lt;= n)add(ID(i, j), ID(xx, yy)), add(ID(xx, yy), ID(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="keyword">if</span> (!ss[ID(i, j)] &amp;&amp; vis2[ID(i, j)] == <span class="number">-1</span>)vis2[ID(i, j)] = <span class="number">0</span>, DFS(i, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++)<span class="keyword">if</span> (vis2[i] == <span class="number">1</span>)ans += f(i), ++tim;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n * n - m - ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="火星探险问题"><a href="#火星探险问题" class="headerlink" title="火星探险问题"></a><a href="https://www.luogu.org/problemnew/show/P3356" target="_blank" rel="noopener">火星探险问题</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很有意思的一题，比较肝的费用流。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑将所有点拆成三个。对于标记为1的点，这三个点都不使用；对于标记为0的点，只使用第一个分点；对于标记为2的点，这三个分点的用途如下：</p>
<ul>
<li>第一个分点：用于接受流。</li>
<li>第二个分点：表明这个点已经过采集</li>
<li>第三个分点：表明这个点不再采集</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从第一个分点向第二个分点连边，容量为1，费用为-1，同时向第三个分点连边，容量为无穷大，费用为0。对于地图上可以走的一条路径（向南或者向北）从出点出发（对于标记为2的点，其出点就是第2、3个分点，其余都是第1个分点）向入点连接（都是第1个分点），容量限制为无穷大，费用为0。设置一个源点，连接源点与坐标(1,1)的入点，容量限制为探测车数量，再连接右下角坐标点的出点与汇点，容量限制无穷大。建好图之后在上面跑最小费用最大流即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于方案的输出，在跑完费用流后来一遍DFS即可。这里一个错误是根据每一次增广的路径来得到方案，这样做并不对，是因为反边的存在导致增广可能经过反边。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y, z) ((x-1)*3*m+3*(y-1)+z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S 3*m*n+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T (S+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;28)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(x)  ((x - 1) / 3 / m + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y(y) ((y - 1) / 3 % m + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v, p;</span><br><span class="line">&#125; edge[<span class="number">5000000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">50000</span>], n, m, p, op[<span class="number">50</span>][<span class="number">50</span>], pre[<span class="number">50000</span>], flow[<span class="number">50000</span>], vis[<span class="number">50000</span>], dist[<span class="number">50000</span>], t;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vvp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)pre[i] = <span class="number">-1</span>, dist[i] = inf, vis[i] = <span class="number">0</span>;</span><br><span class="line">    dist[S] = <span class="number">0</span>, que.push(S), vis[S] = <span class="number">1</span>, flow[S] = inf;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dist[edge[i].to] &gt; dist[f] + edge[i].p) &#123;</span><br><span class="line">                dist[edge[i].to] = dist[f] + edge[i].p, flow[edge[i].to] = min(flow[f], edge[i].v), pre[edge[i].to] = i;</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X(x) == n &amp;&amp; Y(x) == m)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (op[X(x)][Y(x)] == <span class="number">0</span> || x % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &lt; inf &amp;&amp; (X(edge[i].to) - X(x) == <span class="number">1</span> || Y(edge[i].to) - Y(x) == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (X(edge[i].to) - X(x) == <span class="number">1</span>)<span class="built_in">cout</span> &lt;&lt; rk &lt;&lt; <span class="string">" 0"</span> &lt;&lt; <span class="built_in">endl</span>, DFS(edge[i].to, rk);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; rk &lt;&lt; <span class="string">" 1"</span> &lt;&lt; <span class="built_in">endl</span>, DFS(edge[i].to, rk);</span><br><span class="line">                ++edge[i].v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].to == ID(X(x), Y(x), <span class="number">2</span>) &amp;&amp; edge[i].v == <span class="number">0</span>) &#123;</span><br><span class="line">                DFS(edge[i].to, rk), ++edge[i].v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge[i].to == ID(X(x), Y(x), <span class="number">3</span>) &amp;&amp; edge[i].v &lt; inf) &#123;</span><br><span class="line">                DFS(edge[i].to, rk), ++edge[i].v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; m &gt;&gt; n, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)<span class="built_in">cin</span> &gt;&gt; op[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op[i][j] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (op[i][j] == <span class="number">2</span>)add(ID(i, j, <span class="number">1</span>), ID(i, j, <span class="number">2</span>), <span class="number">1</span>, <span class="number">-1</span>), add(ID(i, j, <span class="number">1</span>), ID(i, j, <span class="number">3</span>), inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op[i - <span class="number">1</span>][j] == <span class="number">0</span>)add(ID(i - <span class="number">1</span>, j, <span class="number">1</span>), ID(i, j, <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op[i - <span class="number">1</span>][j] == <span class="number">2</span>)</span><br><span class="line">                    add(ID(i - <span class="number">1</span>, j, <span class="number">2</span>), ID(i, j, <span class="number">1</span>), inf, <span class="number">0</span>), add(ID(i - <span class="number">1</span>, j, <span class="number">3</span>), ID(i, j, <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op[i][j - <span class="number">1</span>] == <span class="number">0</span>)add(ID(i, j - <span class="number">1</span>, <span class="number">1</span>), ID(i, j, <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op[i][j - <span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">                    add(ID(i, j - <span class="number">1</span>, <span class="number">2</span>), ID(i, j, <span class="number">1</span>), inf, <span class="number">0</span>), add(ID(i, j - <span class="number">1</span>, <span class="number">3</span>), ID(i, j, <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op[n][m] == <span class="number">2</span>)add(ID(n, m, <span class="number">2</span>), T, inf, <span class="number">0</span>), add(ID(n, m, <span class="number">3</span>), T, inf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> add(ID(n, m, <span class="number">1</span>), T, inf, <span class="number">0</span>);</span><br><span class="line">    add(S, ID(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        t = T;</span><br><span class="line">        <span class="keyword">while</span> (t != S)</span><br><span class="line">            vvp.push_back(t), edge[pre[t]].v -= flow[T], edge[pre[t] ^ <span class="number">1</span>].v += flow[T], t = edge[pre[t] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)DFS(ID(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长k可重区间集问题（模板）"><a href="#最长k可重区间集问题（模板）" class="headerlink" title="最长k可重区间集问题（模板）"></a><a href="https://www.luogu.org/problemnew/show/P3358" target="_blank" rel="noopener">最长k可重区间集问题（模板）</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个重要的模板。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对坐标点进行离散化。具体方法是将所有点排序，然后重新标号，容易知道离散化后的区间序列与原先等价，但坐标可以压缩至$[1,2n]$这个区间内。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建图方式如下：</p>
<ul>
<li>$S-&gt;1$，源点连接一号点（将2n个坐标看成点），容量限制为$k$，费用为0。</li>
<li>对于每一个点，向后继点连接一条边，容量限制无穷大，费用0。</li>
<li>对于每一个区间，连接$l-&gt;r$，容量为1，费用为其长度的相反数。</li>
<li>$2n-&gt;T$，表示接受流，容量限制无穷大，费用0。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对图的理解：区间加边可以支走一部分流量，由于一开始流量为$k$的限制，一旦某一部分已经将流量全部支配走，就不能再支配新的流量。这个条件便可以满足k重的约束。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个图上跑一遍最小费用最大流即可，答案就是最小费用的相反数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：当某一个区间左右端点相同时，由于这是开区间，忽略掉这个区间即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T (n&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;28)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">&#125; node[<span class="number">505</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v, p;</span><br><span class="line">&#125; edge[<span class="number">15000</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ssp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mmp;</span><br><span class="line"><span class="keyword">int</span> ID = <span class="number">1</span>, n, k, head[<span class="number">1500</span>], flow[<span class="number">1500</span>], pre[<span class="number">1500</span>], dis[<span class="number">1500</span>], vis[<span class="number">1500</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &lt;= T; i++)pre[i] = <span class="number">-1</span>, dis[i] = inf, vis[i] = <span class="number">0</span>;</span><br><span class="line">    dis[S] = <span class="number">0</span>, que.push(S), vis[S] = <span class="number">1</span>, flow[S] = inf;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123;</span><br><span class="line">                dis[edge[i].to] = dis[f] + edge[i].p, flow[edge[i].to] = min(flow[f], edge[i].v), pre[edge[i].to] = i;</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])vis[edge[i].to] = <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y)swap(x, y);</span><br><span class="line">        node[i].l = x, node[i].r = y, ssp.insert(x), ssp.insert(y), node[i].k = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:ssp)mmp[x] = ID++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)node[i].l = mmp[node[i].l], node[i].r = mmp[node[i].r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); i++)add(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    add(S, <span class="number">1</span>, k, <span class="number">0</span>), add(n &lt;&lt; <span class="number">1</span>, T, inf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)add(node[i].l, node[i].r, <span class="number">1</span>, -node[i].k);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = T;</span><br><span class="line">        <span class="keyword">while</span> (to != S)edge[pre[to]].v -= flow[T], edge[pre[to] ^ <span class="number">1</span>].v += flow[T], to = edge[pre[to] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += flow[T], minCost += flow[T] * dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -minCost;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长k可重线段集问题（模板）"><a href="#最长k可重线段集问题（模板）" class="headerlink" title="最长k可重线段集问题（模板）"></a><a href="https://www.luogu.org/problemnew/show/P3357" target="_blank" rel="noopener">最长k可重线段集问题（模板）</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和上一题类似，思路大致相同，这里只不过将费用换为长度的相反数来求，求长度要用到勾股定理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一个区别是，在本题中，如果两个端点的横坐标相同，这个坐标点仍然是被覆盖的，不能忽略。但是如果将它加入到图中，会出现负环，导致SPFA过程不断进行，然后死循环卡T。这里的解决方法是将点拆分为2，分为入点和出点，对于这种端点横坐标相同的线段，直接从该点对应入点出发向出点连边即可，这样可以有效避免上面的问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;28)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(x, y) ((((x)-1)&lt;&lt;1)+y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T (ID(n&lt;&lt;1,2)+1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">&#125; node[<span class="number">505</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v, p;</span><br><span class="line">&#125; edge[<span class="number">15000</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ssp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mmp;</span><br><span class="line"><span class="keyword">int</span> ID = <span class="number">1</span>, n, k, head[<span class="number">3000</span>], flow[<span class="number">3000</span>], pre[<span class="number">3000</span>], dis[<span class="number">3000</span>], vis[<span class="number">3000</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &lt;= T; i++)pre[i] = <span class="number">-1</span>, dis[i] = inf, vis[i] = <span class="number">0</span>;</span><br><span class="line">    dis[S] = <span class="number">0</span>, que.push(S), vis[S] = <span class="number">1</span>, flow[S] = inf;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = que.front();</span><br><span class="line">        que.pop(), vis[f] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[f]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].v &gt; <span class="number">0</span> &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123;</span><br><span class="line">                dis[edge[i].to] = dis[f] + edge[i].p, flow[edge[i].to] = min(flow[f], edge[i].v), pre[edge[i].to] = i;</span><br><span class="line">                <span class="keyword">if</span> (!vis[edge[i].to])vis[edge[i].to] = <span class="number">1</span>, que.push(edge[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++;</span><br><span class="line">    edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = <span class="number">0</span>, edge[cnt].p = -p, head[y] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c, d; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        node[i].k = (<span class="keyword">int</span>) (<span class="built_in">sqrt</span>((<span class="number">1l</span>l * c - a) * (<span class="number">1l</span>l * c - a) + (<span class="number">1l</span>l * d - b) * (<span class="number">1l</span>l * d - b)));</span><br><span class="line">        <span class="keyword">if</span> (a &gt; c)swap(a, c);</span><br><span class="line">        node[i].l = a, node[i].r = c, ssp.insert(a), ssp.insert(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:ssp)mmp[x] = ID++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)node[i].l = mmp[node[i].l], node[i].r = mmp[node[i].r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); i++)add(ID(i, <span class="number">2</span>), ID(i + <span class="number">1</span>, <span class="number">1</span>), inf, <span class="number">0</span>), add(ID(i, <span class="number">1</span>), ID(i, <span class="number">2</span>), inf, <span class="number">0</span>);</span><br><span class="line">    add(S, ID(<span class="number">1</span>, <span class="number">1</span>), k, <span class="number">0</span>), add(ID(n &lt;&lt; <span class="number">1</span>, <span class="number">2</span>), T, inf, <span class="number">0</span>), add(ID(n &lt;&lt; <span class="number">1</span>, <span class="number">1</span>), ID(n &lt;&lt; <span class="number">1</span>, <span class="number">2</span>), inf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[i].l != node[i].r)add(ID(node[i].l, <span class="number">2</span>), ID(node[i].r, <span class="number">1</span>), <span class="number">1</span>, -node[i].k);</span><br><span class="line">        <span class="keyword">else</span> add(ID(node[i].l, <span class="number">1</span>), ID(node[i].r, <span class="number">2</span>), <span class="number">1</span>, -node[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = T;</span><br><span class="line">        <span class="keyword">while</span> (to != S)edge[pre[to]].v -= flow[T], edge[pre[to] ^ <span class="number">1</span>].v += flow[T], to = edge[pre[to] ^ <span class="number">1</span>].to;</span><br><span class="line">        ans += flow[T], minCost += flow[T] * dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -minCost;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/提高算法/" rel="tag"><i class="fa fa-tag"></i>提高算法</a>
          
            <a href="/tags/图论/" rel="tag"><i class="fa fa-tag"></i>图论</a>
          
            <a href="/tags/网络流/" rel="tag"><i class="fa fa-tag"></i>网络流</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/21/虚树/" rel="next" title="虚树">
                <i class="fa fa-chevron-left"></i> 虚树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/14/再谈FFT：wav音频解析/" rel="prev" title="再谈FFT：wav音频解析">
                再谈FFT：wav音频解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Twifor">
            
              <p class="site-author-name" itemprop="name">Twifor</p>
              <p class="site-description motion-element" itemprop="description">一个打OI的弱鸡</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">134</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">64</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#负载平衡问题"><span class="nav-number">1.</span> <span class="nav-text">负载平衡问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小路径覆盖问题（模板）"><span class="nav-number">2.</span> <span class="nav-text">最小路径覆盖问题（模板）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#魔术球问题"><span class="nav-number">3.</span> <span class="nav-text">魔术球问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#试题库问题"><span class="nav-number">4.</span> <span class="nav-text">试题库问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方格取数问题"><span class="nav-number">5.</span> <span class="nav-text">方格取数问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长不下降子序列问题"><span class="nav-number">6.</span> <span class="nav-text">最长不下降子序列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NOI2009-植物大战僵尸（模板）"><span class="nav-number">7.</span> <span class="nav-text">[NOI2009]植物大战僵尸（模板）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDOI2009-晨跑"><span class="nav-number">8.</span> <span class="nav-text">[SDOI2009]晨跑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCOI2007-修车"><span class="nav-number">9.</span> <span class="nav-text">[SCOI2007]修车</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZJOI2010-网络扩容"><span class="nav-number">10.</span> <span class="nav-text">[ZJOI2010]网络扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NOI2012-美食节"><span class="nav-number">11.</span> <span class="nav-text">[NOI2012]美食节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#餐巾计划问题"><span class="nav-number">12.</span> <span class="nav-text">餐巾计划问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CTSC1999-家园"><span class="nav-number">13.</span> <span class="nav-text">[CTSC1999]家园</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#太空飞行计划问题"><span class="nav-number">14.</span> <span class="nav-text">太空飞行计划问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#航空路线问题"><span class="nav-number">15.</span> <span class="nav-text">航空路线问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#圆桌问题"><span class="nav-number">16.</span> <span class="nav-text">圆桌问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#骑士共存问题"><span class="nav-number">17.</span> <span class="nav-text">骑士共存问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#火星探险问题"><span class="nav-number">18.</span> <span class="nav-text">火星探险问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长k可重区间集问题（模板）"><span class="nav-number">19.</span> <span class="nav-text">最长k可重区间集问题（模板）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长k可重线段集问题（模板）"><span class="nav-number">20.</span> <span class="nav-text">最长k可重线段集问题（模板）</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Twifor</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="255,255,255" '="" opacity="0.85" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  




  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function (item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '2aSxA7Naxmi6lgfgVU1ulgcS-gzGzoHsz',
    appKey: '6G9RDaS7lVtgyGKw8AxxkLyi',
    placeholder: '写下评论吧~qwq',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>



  





  

  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
	  preview: 'none'
    },
	messageStyle: 'none',
	"HTML-CSS": {
      showMathMenu: false //关闭右击菜单显示
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow: auto hidden;
}
</style>

    
  


  

  

  

  

  

  

  

  

<script src="/js/src/snow.js"></script>
<script src="/live2d-widget/autoload.js"></script>
<style type="text/css">
.snow-container{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:100001;}</style>
<div class="snow-container"></div>
</body>
</html>

<script type="text/javascript" src="/js/src/clicklove.js"></script>
