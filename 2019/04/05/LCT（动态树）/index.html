
<!DOCTYPE html>
<html lang="en">


  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#202020" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

    
      <meta name="keywords" content="提高算法,数据结构,树,LCT," />
      

          
              <meta name="description"
                content="LCT（动态树）" />
              

                <link rel="icon" type="image/x-icon" href="/logo.ico">
                <title>
                  LCT（动态树）lyh&#39;s blog
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/xoxo.css">
                    
                      
  <meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <span class="title">
      lyh&#39;s blog
    </span>
  </a>

  <ul class="pure-menu-list clearfix">
    
      
          <li class="pure-menu-item"><a href="/" class="pure-menu-link">
              Home
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">
              Archives
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">
              Tags
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/search" class="pure-menu-link">
              Search
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/about" class="pure-menu-link">
              About
            </a></li>
          
            
  </ul>

</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        LCT（动态树）
      </h1>
      <span>
        
        <time class="time" datetime="2019-04-05T13:31:06.000Z">
        2019-04-05
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LCT/" rel="tag">LCT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8F%90%E9%AB%98%E7%AE%97%E6%B3%95/" rel="tag">提高算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 38 分钟</span>
    </header>

    <div class="post-content">
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍超强数据结构：LCT，这也是博客中目前为止最高级的数据结构。LCT需要前缀知识：<a href="https://twifor.github.io/2019/02/19/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/">树链剖分</a>、<a href="https://twifor.github.io/2019/03/02/Splay%EF%BC%88%E4%BC%B8%E5%B1%95%E6%A0%91%EF%BC%89/">Splay</a>。<br><span id="more"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树链剖分可以很好地维护树中两条链之间的路径信息，但是它的前提是树是静态的。如果树中有断边，连边和换根操作，那么树链剖分就不能再起它的作用。这时就需要动态树（Link-Cut-Tree，LCT）来解决这个问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCT的思想仍然是链的划分。在树链剖分中，曾经根据儿子的轻重关系来进行划分，LCT中也有类似的操作。在LCT中，边分为实边和虚边，其中实边所成的链称为实链。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实边中，父子都保留彼此的信息，但是虚边中仅有儿子保留父结点的信息，但父结点不保留儿子的信息，即认父不认子。实链和虚边满足以下性质：</p>
<ol>
<li>每一个结点存在且仅存在一个实链中。</li>
<li>不同的实链之间通过虚边相连，对于一棵splay，它的根结点会与另一棵splay树上的某个结点建立虚边关系。</li>
<li>实边和虚边是可以动态修改的。</li>
</ol>
<h3 id="LCT中的结点信息"><a href="#LCT中的结点信息" class="headerlink" title="LCT中的结点信息"></a>LCT中的结点信息</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与认识平衡树相同，这里当然也有LCT结点的结构定义。但是为了方便起见，不再使用结构体定义，直接应用数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>], fa[N];<span class="comment">//N是事先定义好的结点数目</span></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有两个信息：son表示结点的儿子，其中son[x][0]表示x的左儿子，son[x][1]为右儿子。fa[x]为结点x的父结点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时就有疑问：为什么这时一棵二叉树的结点定义？显然给定的树并不一定为二叉树。这里就是LCT的一个思想：将树中的所有实链变成一棵splay树，并让这些splay树通过虚边相连。splay树是二叉树，那么这里的结点定义就是二叉树的定义形式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到这里，需要引入LCT中splay的性质：LCT中，任何splay树中的结点相对根结点的深度必定互不相同，而且是连续的，并且splay树上左结点深度小于该结点深度，该结点深度小于右结点深度，即满足二叉查找树的性质。这样一来，splay的中序遍历序列就是按深度排列的树链结点序列。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是一些基本操作函数的定义，这些都是splay上面的操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">identify</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//判别儿子性质</span></span><br><span class="line">    <span class="keyword">return</span> son[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> s, <span class="type">int</span> w)</span> </span>&#123;<span class="comment">//建立父子关系，即连一条实边</span></span><br><span class="line">    fa[s] = f, son[f][w] = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里还需要一个特别的函数：isNotRoot()函数，它的作用是判断某一个结点是否为<strong>该结点所在的splay树</strong>的根结点。由前文可知，每一个结点都在唯一的实链中，并且这个实链用一棵splay树维护。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isNotRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[fa[x]][<span class="number">0</span>] == x || son[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判别方法比较简单，如果该结点的父结点不认这个儿子结点，就说明这是一条虚边，那么该结点就是splay上的根结点。在这个问题上，不推荐定义等价的isRoot()函数，这是因为LCT中判别非根的操作更多，而频繁逻辑取反相当费时。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解了上面的内容，可能一个很大的疑惑是：实边和虚边究竟是什么？它们对应原树上的什么？对于后者，前文已经提及，<strong>所有实边集和虚边集加起来就是树上的所有边的集合</strong>，即每一条边唯一地划分为虚边和实边中的一种。对于一棵splay树，有许多其它splay的根结点与该splay树上的某一结点建立虚边关系，该splay树的根结点也会与另一棵splay树上的结点建立虚边关系。如果结点x和结点y建立了虚边关系，并有fa[x]=y，那么在原树上y是x所在splay树上深度最小的结点的父结点。</p>
<h3 id="ratote和splay操作"><a href="#ratote和splay操作" class="headerlink" title="ratote和splay操作"></a>ratote和splay操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splay树上的旋转和伸展操作与普通splay类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//旋转</span></span><br><span class="line">    <span class="type">int</span> f = fa[x], g = fa[f], i = <span class="built_in">identify</span>(x), j = <span class="built_in">identify</span>(f);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNotRoot</span>(f))fa[x] = g;<span class="comment">//注意这里！！f为根时不能直接建立父子关系，因为这是虚边</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(g, x, j);<span class="comment">//否则建立实边关系</span></span><br><span class="line">    <span class="built_in">change</span>(f, son[x][i ^ <span class="number">1</span>], i), <span class="built_in">change</span>(x, f, i ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//伸展，这不是LCT的最终版splay操作，需要修改，下面会继续介绍。默认旋转到根，因此仅有一个参数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isNotRoot</span>(x)) &#123;</span><br><span class="line">        <span class="type">int</span> f = fa[x];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNotRoot</span>(f)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">identify</span>(x) == <span class="built_in">identify</span>(f))<span class="built_in">rotate</span>(f);<span class="comment">//双旋</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="access操作"><a href="#access操作" class="headerlink" title="access操作"></a>access操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access操作是LCT的核心操作，它的作用是<strong>将整棵树的根结点到某个结点之间的路径转变为实边，其余边断为虚边</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在原树中对于任意一个结点，它到根结点的路径必然是唯一的。access操作就是将这个唯一路径上的结点单独剥离出来形成一条实链，原先与该链上结点连接的实边断为虚边。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们要access(x)。首先将x结点splay到其所在splay树的根结点位置，这时结点x的右子树上的结点深度大于x，必然不在路径中，直接将边断为虚边；而对于左子树上的结点，其深度都小于结点x，必然都在结点x到根结点的路径上。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是找到结点x的父结点（虚边连接），继续递归操作。这样就可以得到下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; x; x = fa[i = x])<span class="built_in">splay</span>(x), son[x][<span class="number">1</span>] = i;<span class="comment">//换儿子，即不认子，断实边为虚边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="makeRoot操作"><a href="#makeRoot操作" class="headerlink" title="makeRoot操作"></a>makeRoot操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换根操作。它的作用是更换原树的树根，并保持LCT的性质不变。换根也是重要操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想让x变成树根，那么需要先access(x)打通根结点到x的路径，然后splay(x)，将x伸展到根，这时x必定没有右儿子。如果需要将变为根，那么只需要将这棵splay左右翻转过来即可。这里就需要用到文艺平衡树中的翻转标记，它的作用是标记以某一个结点为根的splay树需要翻转，注意打标记时这个结点的左右子树已经交换了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushr</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//翻转函数</span></span><br><span class="line">    <span class="built_in">swap</span>(son[x][<span class="number">0</span>], son[x][<span class="number">1</span>]), lazy[x] ^= <span class="number">1</span>;<span class="comment">//交换左右儿子，并且更新标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lazy就是翻转标记，是一种懒操作。那么makeRoot函数就可以写出了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makeRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x), <span class="built_in">splay</span>(x), <span class="built_in">pushr</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何下压标记？注意到在splay时，如果我们想要将x伸展到根位置，但是其到根的路径上有一些翻转标记，那么此时直接splay一定会出问题。于是在splay之前，我们需要把从splay的根结点到该结点之间路径上的所有结点从上到下依次下压标记，之后再进行伸展操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要一个下压标记的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[x])<span class="built_in">pushr</span>(son[x][<span class="number">0</span>]), <span class="built_in">pushr</span>(son[x][<span class="number">1</span>]), lazy[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后splay函数需要修改成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, y = x;</span><br><span class="line">    sta[++i] = y;<span class="comment">//手写一个栈</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isNotRoot</span>(y))sta[++i] = y = fa[y];<span class="comment">//将路径结点记录下来</span></span><br><span class="line">    <span class="keyword">while</span> (i)<span class="built_in">pushdown</span>(sta[i--]);<span class="comment">//利用栈的性质，从上而下依次放标记</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isNotRoot</span>(x)) &#123;</span><br><span class="line">        <span class="type">int</span> f = fa[x];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNotRoot</span>(f)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">identify</span>(x) == <span class="built_in">identify</span>(f))<span class="built_in">rotate</span>(f);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了：换根后能不能保证所有splay仍然满足对于新的树根，其深度互不相同？答案是可以保证，请读者自行思考。</p>
<h3 id="findRoot操作"><a href="#findRoot操作" class="headerlink" title="findRoot操作"></a>findRoot操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：通过某一个结点x找到整棵树的根。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做法比较简单。首先access(x)，然后在这一棵splay上不断找左儿子即可，最左侧的结点深度最小，就是整棵树的根结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x), <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (son[x][<span class="number">0</span>])<span class="built_in">pushdown</span>(x), x = son[x][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(x);<span class="comment">//保证复杂度</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到这里有下压标记操作，这是使用LCT中需要特别注意的一个地方：<strong>任何情况下，只要在splay树上通过左右儿子结点来找某一个结点，都不能保证标记成功下放。</strong>于是需要不断下压标记。</p>
<h3 id="link操作"><a href="#link操作" class="headerlink" title="link操作"></a>link操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link作用：当两个结点不在同一棵树上时连接两个结点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设要连接x和y。首先将x变成其所在树的根，然后从x向y连一条虚边。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="built_in">findRoot</span>(y))fa[x] = y;<span class="comment">//之前要判别是否在一棵树中，根据相同的根结点判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果保证连边合法，则可以简化为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x);</span><br><span class="line">    fa[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="cut操作"><a href="#cut操作" class="headerlink" title="cut操作"></a>cut操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cut作用：当两个结点相连时，断开两点之间的边。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设要断开x和y。首先将x变成根，然后access(y)，并且将x伸展到根，断开实边即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findRoot</span>(y) == x &amp;&amp; fa[y] == x &amp;&amp; !son[y][<span class="number">0</span>])fa[y] = <span class="number">0</span>, son[x][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//断实边</span></span><br><span class="line">	<span class="comment">//判定合法三要素：在同一棵树中，父结点是x并且y没有左儿子（没有中间的结点）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里findRoot操作内含了splay和access，不用再重复写出来。如果保证合法，则代码简化为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x), <span class="built_in">access</span>(y), <span class="built_in">splay</span>(x);</span><br><span class="line">    fa[y] = <span class="number">0</span>, son[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="split操作"><a href="#split操作" class="headerlink" title="split操作"></a>split操作</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split作用：将x到y的路径剥离出来，形成一棵splay树。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法比较容易，先换根，再access，最后splay。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x), <span class="built_in">access</span>(y), <span class="built_in">splay</span>(y);<span class="comment">//最后splay(x)也是可以的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="关于LCT的构造"><a href="#关于LCT的构造" class="headerlink" title="关于LCT的构造"></a>关于LCT的构造</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上面的讨论，可能还会有一个疑惑：给定一棵树，按照link进行操作，此时没有指定哪一个结点是根，怎么理解？这里需要注意到一个问题，起初未连任何边时，可以认为每一个结点都是一个独立的splay树，它们自己就是自己所在树的根。不断link后，整棵树的根结点就会隐式确定，也就是说，虽然我们没有指定谁是根结点，但是根结点已经在link中确定了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果确定根结点，并且可以按照点的深度排布给出点的连接次序，那么我们可以采用另一种不换根的方式来进行link。比如说指定1为根结点，与结点2相连，那么直接fa[2]=1就可以完成link操作。同样地，此时如果2与3相连，可以直接fa[3]=2。这样的link操作没有出现任何换根和access操作，但同样可以构造出合法的LCT。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，LCT的构造相当灵活。只要满足上面所说的LCT性质，构造出的LCT就是合法的。通常情况下，可以通过朴素的link操作来构造LCT，某些特殊情况下可以通过直接连虚边的方式进行构造。</p>
<h3 id="用LCT维护路径信息"><a href="#用LCT维护路径信息" class="headerlink" title="用LCT维护路径信息"></a>用LCT维护路径信息</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文这么多东西，还没有具体描述LCT维护路径信息的方法！这里其实就有各种搞法了，需要根据待维护的信息来进行变换。这里先以<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3690">模板题</a>为例，它需要维护路径上点权的异或值，并且需要单点修改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义v[x]为结点x的点权，val[x]表示以x为根的<strong>splay树</strong>上所有结点的异或值，然后可以得到更新函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//在其它地方也称为pushup函数</span></span><br><span class="line">    val[x] = v[x] ^ val[son[x][<span class="number">0</span>]] ^ val[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步update需要在rotate函数中体现出来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = fa[x], g = fa[f], i = <span class="built_in">identify</span>(x), j = <span class="built_in">identify</span>(f);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNotRoot</span>(f))fa[x] = g;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(g, x, j);</span><br><span class="line">    <span class="built_in">change</span>(f, son[x][i ^ <span class="number">1</span>], i), <span class="built_in">change</span>(x, f, i ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(f), <span class="built_in">update</span>(x);<span class="comment">//由于修改了结点连接，需要进行更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有哪些函数需要修改呢？注意到access函数重新划分了实边，需要进行update：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; x; x = fa[i = x])<span class="built_in">splay</span>(x), son[x][<span class="number">1</span>] = i, <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然还有cut函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findRoot</span>(y) == x &amp;&amp; fa[y] == x &amp;&amp; !son[y][<span class="number">0</span>])fa[y] = <span class="number">0</span>, son[x][<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link函数是不需要的。这是因为link函数连的是虚边，不影响splay树上的结果。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样似乎就比较完美了，那如何查询结果？如果需要查询x到y的异或结果，需要先split(x,y)，然后val[y]就是答案。（如果split最后一步是splay(x)，那么答案是val[x]）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要单点修改时，需要先splay(x)，然后直接修改v[x]的值，然后update(x)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出模板题全部代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> e = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; <span class="string">&#x27;-&#x27;</span>)e = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (e &gt; <span class="string">&#x27;-&#x27;</span>)s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (e &amp; <span class="number">15</span>), e = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, v[N], son[N][<span class="number">2</span>], fa[N], lazy[N], sta[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    val[x] = v[x] ^ val[son[x][<span class="number">0</span>]] ^ val[son[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isNotRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[fa[x]][<span class="number">0</span>] == x || son[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">identify</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> s, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    fa[s] = f, son[f][w] = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = fa[x], g = fa[f], i = <span class="built_in">identify</span>(x), j = <span class="built_in">identify</span>(f);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNotRoot</span>(f))fa[x] = g;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(g, x, j);</span><br><span class="line">    <span class="built_in">change</span>(f, son[x][i ^ <span class="number">1</span>], i), <span class="built_in">change</span>(x, f, i ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(f), <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushr</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(son[x][<span class="number">0</span>], son[x][<span class="number">1</span>]), lazy[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[x])<span class="built_in">pushr</span>(son[x][<span class="number">0</span>]), <span class="built_in">pushr</span>(son[x][<span class="number">1</span>]), lazy[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, y = x;</span><br><span class="line">    sta[++i] = y;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isNotRoot</span>(y))sta[++i] = y = fa[y];</span><br><span class="line">    <span class="keyword">while</span> (i)<span class="built_in">pushdown</span>(sta[i--]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isNotRoot</span>(x)) &#123;</span><br><span class="line">        <span class="type">int</span> f = fa[x];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNotRoot</span>(f)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">identify</span>(x) == <span class="built_in">identify</span>(f))<span class="built_in">rotate</span>(f);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; x; x = fa[i = x])<span class="built_in">splay</span>(x), son[x][<span class="number">1</span>] = i, <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makeRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x), <span class="built_in">splay</span>(x), <span class="built_in">pushr</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x), <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (son[x][<span class="number">0</span>])<span class="built_in">pushdown</span>(x), x = son[x][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="built_in">findRoot</span>(y))fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findRoot</span>(y) == x &amp;&amp; fa[y] == x &amp;&amp; !son[y][<span class="number">0</span>])fa[y] = <span class="number">0</span>, son[x][<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x), <span class="built_in">access</span>(y), <span class="built_in">splay</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)v[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>)<span class="built_in">split</span>(x, y), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">1</span>)<span class="built_in">link</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">2</span>)<span class="built_in">cut</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">splay</span>(x), v[x] = y, <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其它重要的事"><a href="#其它重要的事" class="headerlink" title="其它重要的事"></a>其它重要的事</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCT中如果需要修改区间怎么办？仍然先split，然后利用懒标记思想打上标记即可。下压操作可以合并到pushdown中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCT中各种修改，换根，下压标记，怎样才能知道通过访问val[x]得到的结果是已经得到更新的？这是一个很实用而且重要的问题。为了简化这个问题，我们记住并遵循下面的一些规则即可：</p>
<ul>
<li><strong>对点彻底更新。</strong>当我们修改信息（pushr函数）或者直接更新（update函数）时，做到彻底更新。对于单点修改，要将所有需要修改的地方都修改过来，对于链上修改，需要彻底修改点，然后打上标记。对于所在splay只有本身一个点的结点，可以只指明点权而不更新其额外信息，这是因为在这棵splay上的旋转操作可以自然更新信息。</li>
<li><strong>经过split得到的splay树的根结点信息是最新的。</strong></li>
<li><strong>不要轻易修改0号结点的点权。</strong>0号结点表示没有结点，在更新时常常用到，如果盲目修改，很可能会出问题。</li>
<li><strong>经过split得到的splay树除了根结点外的结点不一定是最新的（即可能有标记未下压）。</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反观上面单点修改的过程，这里就做到了对点彻底更新：将x的val值同样进行更新，不更新就会出错。另外必须先经过splay，才能修改，这是因为splay后只需要修改那一个点即可，否则不能做到完全修改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面看一道<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P2486">洛谷P2486 染色</a>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题涉及链上信息查询和链信息修改两个操作，定义val[x]表示该splay树上颜色段的数目，并定义修改颜色懒标记cl。用c[x]表示结点x的颜色，l[x]表示该splay树上深度最小点的颜色，r[x]为深度最大点的颜色。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更换颜色操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">color_pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x)c[x] = l[x] = r[x] = y, val[x] = <span class="number">1</span>, cl[x] = y;<span class="comment">//注意彻底更新：l和r、val也同时得到了更新，并且不要修改0结点，事实证明这是全部WA和AC的区别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外翻转操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(l[x], r[x]), <span class="built_in">swap</span>(son[x][<span class="number">0</span>], son[x][<span class="number">1</span>]), lazy[x] ^= <span class="number">1</span>;<span class="comment">//注意第一个swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下压操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[x])<span class="built_in">pushdown</span>(son[x][<span class="number">0</span>]), <span class="built_in">pushdown</span>(son[x][<span class="number">1</span>]), lazy[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cl[x])<span class="built_in">color_pushdown</span>(son[x][<span class="number">0</span>], cl[x]), <span class="built_in">color_pushdown</span>(son[x][<span class="number">1</span>], cl[x]), cl[x] = <span class="number">0</span>;<span class="comment">//多一个颜色下压</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面三步可以看出，所有点信息的更新都是彻底更新。然后实际操作中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e == <span class="string">&#x27;Q&#x27;</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">split</span>(x, y), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val[y]);<span class="comment">//split得到的splay树根结点信息是得到更新的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z), <span class="built_in">split</span>(x, y), <span class="built_in">color_pushdown</span>(y, z);<span class="comment">//对点进行彻底修改并打上标记</span></span><br></pre></td></tr></table></figure></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为LCT的问题通常比较难，这里并不会列很多题，可能会有单独的文章介绍。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不涉及题面，点击标题可跳转。</p>
<h4 id="NOI2014-魔法森林"><a href="#NOI2014-魔法森林" class="headerlink" title="[NOI2014]魔法森林"></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P2387">[NOI2014]魔法森林</a></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;涉及两种值，不容易处理。本题可以这样思考：将边按照a排序，然后将这些边依次加入，维护b的最小生成树，每次更新答案，这样一定可以取到最优解。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而维护b的最小生成树显然是一个动态的问题，用LCT再合适不过了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便提一下，这里维护的是边权，边权的处理可以直接在两个点之间插入一个点，使这个点的点权等于边权，从而化边权为点权。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> e = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &lt; <span class="string">&#x27;-&#x27;</span>)e = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (e &gt; <span class="string">&#x27;-&#x27;</span>)s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (e &amp; <span class="number">15</span>), e = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, a, b;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Edge e) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; e.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; vvp;</span><br><span class="line"><span class="type">int</span> n, m, v[N], son[N][<span class="number">2</span>], fa[N], lazy[N], sta[N], val[N], val2[N];</span><br><span class="line"><span class="type">int</span> l[N], r[N], cnt, ans = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val[son[x][<span class="number">0</span>]] &gt; val[son[x][<span class="number">1</span>]])val[x] = val[son[x][<span class="number">0</span>]], val2[x] = val2[son[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">else</span> val[x] = val[son[x][<span class="number">1</span>]], val2[x] = val2[son[x][<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">if</span> (v[x] &gt; val[x])val[x] = v[x], val2[x] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isNotRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[fa[x]][<span class="number">0</span>] == x || son[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">identify</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> son[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> s, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    fa[s] = f, son[f][w] = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = fa[x], g = fa[f], i = <span class="built_in">identify</span>(x), j = <span class="built_in">identify</span>(f);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNotRoot</span>(f))fa[x] = g;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(g, x, j);</span><br><span class="line">    <span class="built_in">change</span>(f, son[x][i ^ <span class="number">1</span>], i), <span class="built_in">change</span>(x, f, i ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(f), <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushr</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(son[x][<span class="number">0</span>], son[x][<span class="number">1</span>]), lazy[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[x])<span class="built_in">pushr</span>(son[x][<span class="number">0</span>]), <span class="built_in">pushr</span>(son[x][<span class="number">1</span>]), lazy[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, y = x;</span><br><span class="line">    sta[++i] = y;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isNotRoot</span>(y))sta[++i] = y = fa[y];</span><br><span class="line">    <span class="keyword">while</span> (i)<span class="built_in">pushdown</span>(sta[i--]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isNotRoot</span>(x)) &#123;</span><br><span class="line">        <span class="type">int</span> f = fa[x];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNotRoot</span>(f)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">identify</span>(x) == <span class="built_in">identify</span>(f))<span class="built_in">rotate</span>(f);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; x; x = fa[i = x])<span class="built_in">splay</span>(x), son[x][<span class="number">1</span>] = i, <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makeRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x), <span class="built_in">splay</span>(x), <span class="built_in">pushr</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x), <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (son[x][<span class="number">0</span>])<span class="built_in">pushdown</span>(x), x = son[x][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x), fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x), <span class="built_in">access</span>(y), <span class="built_in">splay</span>(x), fa[y] = <span class="number">0</span>, son[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeRoot</span>(x), <span class="built_in">access</span>(y), <span class="built_in">splay</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = ++cnt;</span><br><span class="line">    l[s] = vvp[i].x, r[s] = vvp[i].y;</span><br><span class="line">    val2[vvp[i].x] = vvp[i].x, val2[vvp[i].y] = vvp[i].y;</span><br><span class="line">    val[s] = v[s] = vvp[i].b, val2[s] = s;</span><br><span class="line">    <span class="built_in">link</span>(vvp[i].x, s), <span class="built_in">link</span>(s, vvp[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y, a, b; i &lt;= m; i++) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">        Edge e;</span><br><span class="line">        e.x = x, e.y = y, e.a = a, e.b = b;</span><br><span class="line">        vvp.<span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vvp.<span class="built_in">begin</span>(), vvp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">findRoot</span>(vvp[i].x) == <span class="built_in">findRoot</span>(vvp[i].y)) &#123;</span><br><span class="line">            <span class="built_in">split</span>(vvp[i].x, vvp[i].y);</span><br><span class="line">            <span class="keyword">if</span> (val[vvp[i].y] &gt; vvp[i].b) &#123;</span><br><span class="line">                <span class="type">int</span> now = val2[vvp[i].y];</span><br><span class="line">                <span class="built_in">cut</span>(now, l[now]), <span class="built_in">cut</span>(now, r[now]), <span class="built_in">solve</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">solve</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">findRoot</span>(<span class="number">1</span>) == <span class="built_in">findRoot</span>(n))<span class="built_in">split</span>(<span class="number">1</span>, n), ans = <span class="built_in">min</span>(ans, val[n] + vvp[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans == <span class="number">0x7fffffff</span> ? <span class="number">-1</span> : ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#LCT%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9%E4%BF%A1%E6%81%AF"><span class="toc-text">LCT中的结点信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ratote%E5%92%8Csplay%E6%93%8D%E4%BD%9C"><span class="toc-text">ratote和splay操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#access%E6%93%8D%E4%BD%9C"><span class="toc-text">access操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#makeRoot%E6%93%8D%E4%BD%9C"><span class="toc-text">makeRoot操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findRoot%E6%93%8D%E4%BD%9C"><span class="toc-text">findRoot操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#link%E6%93%8D%E4%BD%9C"><span class="toc-text">link操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cut%E6%93%8D%E4%BD%9C"><span class="toc-text">cut操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#split%E6%93%8D%E4%BD%9C"><span class="toc-text">split操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ELCT%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-text">关于LCT的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8LCT%E7%BB%B4%E6%8A%A4%E8%B7%AF%E5%BE%84%E4%BF%A1%E6%81%AF"><span class="toc-text">用LCT维护路径信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B"><span class="toc-text">其它重要的事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NOI2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97"><span class="toc-text">[NOI2014]魔法森林</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/04/03/%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/" rel="next" title="矩阵求逆">
          矩阵求逆
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/04/07/%E6%B4%9B%E8%B0%B7P4332-%E4%B8%89%E5%8F%89%E7%A5%9E%E7%BB%8F%E6%A0%91/" rel="prev" title="[洛谷P4332]三叉神经树">
            [洛谷P4332]三叉神经树
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://twifor.github.io">首页</a> |
        <a class="bottom-item" href="https://twifor.github.io/index_original.html" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/Twifor" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        },
        showMathMenu: false,
        "HTML-CSS": {
            preferredFont: "TeX", 
            availableFonts: ["STIX","TeX"],
            showMathMenuMSIE: false
        },
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
