
<!DOCTYPE html>
<html lang="en">


  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#202020" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

    
      <meta name="keywords" content="数学,贪心," />
      

          
              <meta name="description"
                content="浅谈贪心算法的拟阵理论" />
              

                <link rel="icon" type="image/x-icon" href="/logo.ico">
                <title>
                  浅谈贪心算法的拟阵理论lyh&#39;s blog
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/xoxo.css">
                    
                      
  <meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <span class="title">
      lyh&#39;s blog
    </span>
  </a>

  <ul class="pure-menu-list clearfix">
    
      
          <li class="pure-menu-item"><a href="/" class="pure-menu-link">
              Home
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">
              Archives
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">
              Tags
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/search" class="pure-menu-link">
              Search
            </a></li>
          
            
      
          <li class="pure-menu-item"><a href="/about" class="pure-menu-link">
              About
            </a></li>
          
            
  </ul>

</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        浅谈贪心算法的拟阵理论
      </h1>
      <span>
        
          <time class="time" datetime="2020-01-17T02:41:33.000Z">
            2020-01-17
          </time>
          
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
        <span class="post-tags">
          <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>
        </span>
      </span>
      <!-- <span class="slash">/</span> -->
      <!-- <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span> -->
      <span class="slash">/</span>
      <span class="read">阅读耗时 12 分钟</span>
    </header>

    <div class="post-content">
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拟阵，在贪心问题中得以应用的数学工具。本文需要线性代数基础的前置知识。<br><span id="more"></span></p>
<h3 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有限拟阵是一个序偶$(S,I)$，其中$S$为一个有限集合，而$I$为$S$中某些子集组成的有限非空集合。即有$x\in I$，则$x\subseteq S$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于拟阵的组成，遵循下面的<strong>三个公理</strong>：</p>
<ul>
<li>$\varnothing \in I$</li>
<li><strong>【遗传性】</strong>若$A\in I$且$B\subseteq A$，则有$B\in I$。</li>
<li><strong>【增广性（交换性）】</strong>对于$A,B\in I$,若$|A|&lt;|B|$，则$\exists x\in B-A$，有$A\cup \{x\}\in I$。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;称$I$中的集合为<strong>独立集</strong>。</p>
<h3 id="基与环"><a href="#基与环" class="headerlink" title="基与环"></a>基与环</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于拟阵$(S,I)$，若$A\in I$，且$A\cup\{x\}\not \in I,\forall x\in S-A$，则称$A$为一个极大独立集，或称<strong>基</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$A\subseteq S$，若有$A\not \in I$且$A-\{x\}\in I,\forall x\in A$，则称$A$为极小非独立集，或称<strong>环</strong>，也叫<strong>回路</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易得到下面这一个性质：</p>
<ul>
<li><strong>对于一个拟阵，其基的大小都相同。</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明可以使用反证法。若两个基$A$与$B$大小不同并令$|A|&lt;|B|$，则根据增广性，$\exists x\in B-A$，有$A\cup\{x\}\in I$，这样$A$便得到了扩展，这与$A$为基矛盾。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，我们还可以得到一个重要的定理：</p>
<ul>
<li><strong>【基交换定理】</strong>对于拟阵$(S,I)$，若$A$与$B$是拟阵的基，且$A\not=B$，则$\forall x\in A-B$，$\exists y\in B-A$，使得$(A-\{x\})\cup \{y\}\in I$。</li>
</ul>
<p>证明：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据遗传性，$A-\{x\}\in I$。然后由增广性，$\exists y\in B-(A\cup \{x\})$即$\exists y\in B-A$，使得$(A-\{x\})\cup \{y\}\in I$。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于拟阵$(S,I)$ ，则$\forall A\subseteq S$  ，定义其<strong>秩函数</strong>为， $A$的子集中极大独立集的大小，记作$r(A)$。</p>
<h3 id="常见拟阵"><a href="#常见拟阵" class="headerlink" title="常见拟阵"></a>常见拟阵</h3><h4 id="组合拟阵"><a href="#组合拟阵" class="headerlink" title="组合拟阵"></a>组合拟阵</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个有限集合$S$，令$I=\{A||A|\leq k\}$，则$(S,I)$组成一个拟阵。记为$U_n^k$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易证明该拟阵遵循三条公理。</p>
<h4 id="向量拟阵"><a href="#向量拟阵" class="headerlink" title="向量拟阵"></a>向量拟阵</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一组$n$维向量集合$S$，令$I=\{A\subseteq S|A$线性无关$\}$，则$(S,I)$是拟阵。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现线性无关的向量集合子集仍是线性无关的，重点在于证明其满足增广性质，使用反证法。对于两个向量集合$A,B\in I$，假定$|A|&lt;|B|$，若$\forall x\in B-A$都有$A\cup \{x\}\not \in I$，这说明$A$能够线性表示$B$。这样$B$的秩应该为$|A|$，但是由于$B\in I$，$B$的秩又应该为$|B|$，矛盾。由此可知增广性质成立。</p>
<h4 id="匹配拟阵"><a href="#匹配拟阵" class="headerlink" title="匹配拟阵"></a>匹配拟阵</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于二分图$(U,V,E)$，令$I=\{A\subseteq U|A$可以与$V$完美匹配$\}$，则$(U,I)$为拟阵。证明略。</p>
<h4 id="环拟阵"><a href="#环拟阵" class="headerlink" title="环拟阵"></a>环拟阵</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于无向图$G(V,E)$，令$I=\{A\subseteq E|A$无环$\}$，则$(S,I)$为拟阵。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里只证明第三条公理成立。对于$A,B\in I$，且$|A|&lt;|B|$，由于两者都无环，可知$G(V,A)$以及$G(V,B)$都是森林，且$G(V,A)$中的连通块数量多于$G(V,B)$，那么必然可以从$B-A$中得到一条边$x$，使得$A\cup\{x\}$仍无环。</p>
<h3 id="带权拟阵"><a href="#带权拟阵" class="headerlink" title="带权拟阵"></a>带权拟阵</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于拟阵$(S,I)$，我们给$S$中每一个元素$x$赋予一个非负权值$w(x)$，则成为了带权拟阵。此时一个集合的权值定义为其中元素的权值之和。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知，权值最大的集合必然为基。寻找权值最大的基是一个重要的问题，该问题可以用贪心算法解决。伪代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set <span class="title">get</span><span class="params">(M,w)</span></span>&#123;</span><br><span class="line">	对M.S按权值<span class="built_in">w</span>(x)从大到小排序</span><br><span class="line">	A=∅</span><br><span class="line">	<span class="keyword">for</span> x in M.S:</span><br><span class="line">		若A∪&#123;x&#125;∈M.I，则A=A∪&#123;x&#125;</span><br><span class="line">	<span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里返回一个集合，$M=(S,I)$是拟阵。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个算法是正确的，考虑利用拟阵的性质来简单地证明。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先假定$A=\{x_1,x_2,\cdots,x_n\}$是权值最大的集合（$x$按权值降序排列），则根据遗传性，$\{x_1\},\{x_1,x_2\},\cdots,\{x_1,x_2,\cdots,x_n\}$必然都在$I$中，也就是说，利用这个算法是可以取到的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一方面，若$x$是权值最大的元素，且$\{x\}\in I$，则我们将会把它加入$A$，这样的正确性在于：我们确定<strong>x必然是某一个权值最大集合的元素</strong>，证明如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若权值最大的集合为$B$，包含$x$的权值最大集合为$A$，假设$w(A)&lt;w(B)$。令$C=A\cap B$，则$w(A-C)&lt;w(B-C)$，将$A-C,B-C$表示为$A-C=\{x\}\cup A’,B-C=\{y\}\cup B’$，这里$y$是$B-C$中某一元素，那么根据基交换定理，可知$D=C\cup B’\cup\{x\}\in I$。显然有$w(D)=w(C)+w(B’)+w(x)\geq w(C)+w(B’)+w(y)=w(B)$，其中有$x\in D$，这样就得到了一个包含$x$但是权值不小于$B$的集合，矛盾。因此可知$x$必然在某一个权值最大的集合中，由此归纳下去，可知贪心算法正确。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法的时间复杂度为$O(nlogn+nf(n))$，其中$f(x)$是判断元素是否在$I$中的代价。</p>
<h3 id="拟阵与最小生成树"><a href="#拟阵与最小生成树" class="headerlink" title="拟阵与最小生成树"></a>拟阵与最小生成树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们尝试用拟阵来解决最小生成树问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造无向图$G(V,E)$的环拟阵$M=(S,I)$，容易发现，求最小生成树就是求拟阵的最小权值集合。上文中探讨的是最大权值，我们可以将边权取反，再加常数使得转化为等价的最大权值问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据最大权值集合的贪心算法，我们可以将权值从大到小排序（就是原边权最小到大排序），然后依次放入，判断能否出现在$I$中，即判断是否有环出现。环可以用并查集维护，这就得到了kruskal算法。这就是kruskal算法正确性的数学解释。</p>
<h3 id="拟阵交"><a href="#拟阵交" class="headerlink" title="拟阵交"></a>拟阵交</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于同一个集合$S$，构造两个拟阵$M_1=(S,I_1),M_2=(S,I_2)$，定义$M_1\cap M_2=(S,I_1\cap I_2)$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在很多情况下，我们希望得到拟阵交的最大的集合元素数目。然而，两个以上的拟阵交是NP问题，不过对于两个拟阵的交，有着一个优美的多项式算法。由于这个算法证明及相关理论复杂，这里暂不展开证明，直接给出算法步骤：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化答案集合$A=\varnothing$。然后构造图$G(V,E)$，这里$V=S$，$E$的定义如下：</p>
<ul>
<li>对于$x\in A,y\in S-A$，若$(A-\{x\})\cup\{y\}\in I_1$，则$&lt; x, y &gt;\in E$。</li>
<li>对于$x\in A,y\in S-A$，若$(A-\{x\})\cup\{y\}\in I_2$，则$&lt; y, x &gt;\in E$。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个图叫做<strong>交换图</strong>，记为$D_M(A)$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造$X_1=\{x\not \in A|A\cup\{x\}\in I_1\}$，$X_2=\{x\not \in A|A\cup\{x\}\in I_2\}$，然后在交换图上求$X_1$到$X_2$的最短路径$P$，更新$A$为$(A\cup P)-(A\cap P)$。重复上面的步骤，直到$P=\varnothing$。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法的时间复杂度为$O(r^2n)$，其中$r$是两个拟阵秩的较大者，$n$为$|S|$。在某种程度上可以认为是$O(n^3)$。</p>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9F%E9%98%B5"><span class="toc-text">拟阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%B8%8E%E7%8E%AF"><span class="toc-text">基与环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8B%9F%E9%98%B5"><span class="toc-text">常见拟阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%8B%9F%E9%98%B5"><span class="toc-text">组合拟阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%8B%9F%E9%98%B5"><span class="toc-text">向量拟阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%8B%9F%E9%98%B5"><span class="toc-text">匹配拟阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E6%8B%9F%E9%98%B5"><span class="toc-text">环拟阵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E6%8B%9F%E9%98%B5"><span class="toc-text">带权拟阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9F%E9%98%B5%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">拟阵与最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9F%E9%98%B5%E4%BA%A4"><span class="toc-text">拟阵交</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
  
      
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/01/15/Codeforces-Round-612-Div-2/" rel="next" title="Codeforces Round #612 (Div. 2)">
          Codeforces Round #612 (Div. 2)
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/01/17/Codeforces-Hello-2020/" rel="prev" title="Codeforces Hello 2020">
            Codeforces Hello 2020
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
      
    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://twifor.github.io">首页</a> |
        <a class="bottom-item" href="https://twifor.github.io/index_original.html" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/Twifor" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        },
        showMathMenu: false,
        "HTML-CSS": {
            preferredFont: "TeX", 
            availableFonts: ["STIX","TeX"],
            showMathMenuMSIE: false
        },
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
