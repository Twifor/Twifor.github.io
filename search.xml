<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[洛谷P3676]小清新数据结构题]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%B4%9B%E8%B0%B7P3676-%E5%B0%8F%E6%B8%85%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度：NOI/NOI+/CTSC 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在很久很久以前，有一棵n个点的树，每个点有一个点权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在有q次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个整数n、q。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n-1行每行两个整数a和b，表示树中a与b之间有一条边，保证给出的边不会重复。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来一行n个整数，第i个整数表示第i个点的点权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来q行每行两或三个数，如果第一个数为1，那么接下来有两个数x和y，表示将第x个点的点权修改为y，如果第一个数为2，那么接下来有一个数x，表示询问以x为根时每棵子树点权和的平方和。 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每个询问输出答案。 输入输出样例Sample input 4 51 22 32 44 3 2 12 21 1 32 31 2 42 4 Sample output 121140194 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，$1 \leq n,q \leq 200000$, $−10≤$输入的每个点权$\leq 10$。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接求不好求，考虑以1为根时，给某个结点点权加上$a$对答案的贡献。假设一开始子树$i$的点权和为$s_i$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然给修改一个结点的点权，只会影响其到根这一段路径$P$上的子树点权和，其贡献为： \sum_{i\in P}((s_i+a)^2-s_i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化简这个式子，得到： \sum_{i\in P}(2as_i+a^2)=2a\sum_{i\in P}s_i+|P|a^2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护一下每一个点对应的子树点权和，求这条路径上的子树点权和之和以及结点数量就可以求出贡献。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑换根。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当换$x$为根时，容易发现只有从1号结点到$x$这一段路径上的结点的子树点权和发生了变化，设这一段路径为$P$，结点$i$在以1为根时的子树点权和为$a_i$，以$x$为根时的点权和为$b_i$。设路径$P$上从1开始到$x$这一段连续的路径结点为$k_1,k_2,\cdots,k_p$那么有： a_{k_{i+1}}+b_{k_i}=a_1=b_{k_p}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么答案设为$Ans_x$，原有（以1为根）答案为$Ans_1$，则： Ans_x=Ans_1-\sum_{i\in P}a_i^2+\sum_{i\in P}b_i^2\\ =Ans_1-a_1+b_{k_p}+\sum_{i=k_1}^{k_{p-1}}(b_i^2-a_{i+1}^2)\\ =Ans_1-a_1+b_{k_p}+\sum_{i=k_1}^{k_{p-1}}a_1(b_i-a_{i+1})\\ =Ans_1+\sum_{i=k_1}^{k_{p-1}}a_1(a_1-2a_{i+1})\\ =Ans_1+(p-1)a_1^2-2a_1\sum_{i=k_2}^{k_p}a_i\\ =Ans_1+(p+1)a_1^2-2a_1\sum_{i\in P}a_i\\ =Ans_1+(p+1)a_1^2-2a_1\sum_{i\in P}s_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后拿数据结构维护上面的信息，这里用的LCT。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define N 200005using namespace std;struct Node &#123; int ch[2], fa, num, la1; long long sum, v, la2;&#125; nd[N];int sta[N];inline void update(int x) &#123; nd[x].num = nd[nd[x].ch[0]].num + nd[nd[x].ch[1]].num + 1; nd[x].sum = nd[nd[x].ch[0]].sum + nd[nd[x].ch[1]].sum + nd[x].v;&#125;inline void change(int f, int s, int w) &#123; nd[f].ch[w] = s, nd[s].fa = f;&#125;inline bool isNotRoot(int x) &#123; return nd[nd[x].fa].ch[0] == x || nd[nd[x].fa].ch[1] == x;&#125;inline int identify(int x) &#123; return nd[nd[x].fa].ch[1] == x;&#125;inline void pushr(int x) &#123; swap(nd[x].ch[0], nd[x].ch[1]), nd[x].la1 ^= 1;&#125;inline void pushd(int x) &#123; if (nd[x].la1)pushr(nd[x].ch[0]), pushr(nd[x].ch[1]), nd[x].la1 = 0; if (nd[x].la2) &#123; if (nd[x].ch[0]) &#123; nd[nd[x].ch[0]].v += nd[x].la2, nd[nd[x].ch[0]].sum += nd[nd[x].ch[0]].num * nd[x].la2; nd[nd[x].ch[0]].la2 += nd[x].la2; &#125; if (nd[x].ch[1]) &#123; nd[nd[x].ch[1]].v += nd[x].la2, nd[nd[x].ch[1]].sum += nd[nd[x].ch[1]].num * nd[x].la2; nd[nd[x].ch[1]].la2 += nd[x].la2; &#125; nd[x].la2 = 0; &#125;&#125;inline void rotate(int x) &#123; int f = nd[x].fa, g = nd[f].fa, i = identify(x), j = identify(f); if (isNotRoot(f))change(g, x, j); else nd[x].fa = g; change(f, nd[x].ch[i ^ 1], i), change(x, f, i ^ 1), update(f), update(x);&#125;inline void splay(int x) &#123; int i = 0, y = x; sta[++i] = y; while (isNotRoot(y))sta[++i] = y = nd[y].fa; while (i)pushd(sta[i--]); while (isNotRoot(x)) &#123; int f = nd[x].fa; if (isNotRoot(f)) &#123; if (identify(x) == identify(f))rotate(f); else rotate(x); &#125; rotate(x); &#125;&#125;inline void access(int x) &#123; for (int i = 0; x; x = nd[i = x].fa)splay(x), nd[x].ch[1] = i, update(x);&#125;inline void makeRoot(int x) &#123; access(x), splay(x), pushr(x);&#125;inline void link(int x, int y) &#123; makeRoot(x), nd[x].fa = y;&#125;int n, q;long long v[N], ans;inline void split(int x) &#123;//切出1~x树链 makeRoot(1), access(x), splay(x);&#125;inline void add(int x, long long k) &#123;//结点x点权加k split(x), ans += k * k * nd[x].num + 2 * k * nd[x].sum; nd[x].v += k, nd[x].sum += nd[x].num * k, nd[x].la2 += k;&#125;inline int read() &#123; char e = getchar(); int s = 0, g = 0; while (e &lt; '-')e = getchar(); if (e == '-')g = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return g ? -s : s;&#125;int main() &#123; n = read(), q = read(); for (int i = 1; i &lt; n; i++)link(read(), read()); for (int i = 1; i &lt;= n; i++)add(i, v[i] = read()); while (q--) &#123; int opt = read(), x; long long y; if (opt == 1) x = read(), y = read(), add(x, y - v[x]), v[x] = y; else &#123; split(x = read()), splay(1), y = nd[1].v, splay(x); printf("%lld\n", ans + y * ((nd[x].num + 1) * y - 2 * nd[x].sum)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3285]方伯伯的OJ]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%B4%9B%E8%B0%B7P3285-%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84OJ%2F</url>
    <content type="text"><![CDATA[难度：NOI/NOI+/CTSC 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方伯伯正在做他的Oj。现在他在处理Oj上的用户排名问题。Oj上注册了n个用户，编号为1～n“，一开始他们按照编号排名。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号： 操作格式为1 x y，意味着将编号为x的用户编号改为y，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证x必然出现在队列中，同时，1是一个当前不在排名中的编号。 操作格式为2 x，意味着将编号为x的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为x用户的排名。 操作格式为3 x，意味着将编号为x的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为x用户的排名。 操作格式为4 k，意味着查询当前排名为k的用户编号，执行完该操作后需要输出当前操作用户的编号。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了： x+a y+a x+a x+a k+a &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中a为上一次操作得到的输出，一开始a=0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：上一次操作得到的输出是5这一次操作的输入为：1 13 15因为这个输入是经过加密后的，所以你应该处理的操作是1 8 10现在你截获了方伯伯的所有操作，希望你能给出结果。 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第1行包含2个用空格分隔的整数n和m，表示初始用户数和操作数。此后有m行，每行是一个询问，询问格式如上所示。对于 100% 的数据，$1\leq n\leq 10^8，1\leq m\leq 10^5$ 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出包含m行。每行包含一个整数，其中第i行的整数表示第i个操作的输出。 输入输出样例Sample input 10 101 2 113 132 53 72 82 102 113 142 184 9 Sample ouput 22243557811 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较狠的数据结构题。首先拿平衡树维护这应该都能看出来，但是发现n的范围是那样大，不可能为每一个都开一个新结点，于是这里的思路就是缩点：将一段区间内的所有点看成一个点，等到需要时再将点分拆，这是本题基本的思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用缩点后的平衡数可以解决一部分操作，但是本题中很坑的一点是它还需要编号修改。我们建立的平衡树是按照排名进行组织的，已经失去了维护编号的能力，没法再索引编号。这里当然可以再建一棵平衡树，不过两棵平衡树都需要缩点再分拆，还需要交互，需要很好的码力。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里一个简便的操作是用动态开点的线段树维护用户编号对应的结点编号（其实本质上还是平衡树），容易和平衡树交互来完成这四种操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct Node &#123; int l, r, num, k, fa; int L, R;&#125; nd[N &lt;&lt; 7];struct STNode &#123; int l, r, v;&#125; stnd[N &lt;&lt; 7];int n, m, last, root, stroot;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline int newNode(int l, int r) &#123; static int cnt = 1; nd[cnt].L = l, nd[cnt].R = r, nd[cnt].num = r - l + 1, nd[cnt].k = rand(); return cnt++;&#125;inline void update(int x) &#123; nd[x].num = nd[nd[x].l].num + nd[nd[x].r].num + nd[x].R - nd[x].L + 1; nd[nd[x].l].fa = nd[nd[x].r].fa = x;&#125;inline int getNode(int s) &#123; static int ct = 1; stnd[ct].v = stnd[s].v; return ct++;&#125;void ins(int rt, int l, int r, int k, int L = 1, int R = static_cast&lt;int&gt;(2e8)) &#123;//线段树修改 if (L &gt;= l &amp;&amp; R &lt;= r) &#123; stnd[rt].v = k; return; &#125; int mid = (L + R) &gt;&gt; 1; if (l &gt; mid) &#123; if (stnd[rt].r == 0)stnd[rt].r = getNode(rt); ins(stnd[rt].r, l, r, k, mid + 1, R); &#125; else if (r &lt;= mid) &#123; if (stnd[rt].l == 0)stnd[rt].l = getNode(rt); ins(stnd[rt].l, l, r, k, L, mid); &#125; else &#123; if (stnd[rt].r == 0)stnd[rt].r = getNode(rt); if (stnd[rt].l == 0)stnd[rt].l = getNode(rt); ins(stnd[rt].l, l, mid, k, L, mid), ins(stnd[rt].r, mid + 1, r, k, mid + 1, R); &#125;&#125;int get(int rt, int k, int L = 1, int R = static_cast&lt;int&gt;(2e8)) &#123;//线段树查询 int mid = (L + R) &gt;&gt; 1; if (k &lt;= mid) &#123; if (stnd[rt].l == 0)return stnd[rt].v; return get(stnd[rt].l, k, L, mid); &#125; else &#123; if (stnd[rt].r == 0)return stnd[rt].v; return get(stnd[rt].r, k, mid + 1, R); &#125;&#125;inline int getRK(int x, int obj) &#123;//获取排名 int to = x, ans = 0, i = 0; while (to) &#123; if (i == 0)ans += nd[nd[to].l].num + (nd[to].R &gt;= obj &amp;&amp; nd[to].L &lt;= obj ? obj : nd[to].R) - nd[to].L + 1; i = nd[nd[to].fa].l == to, to = nd[to].fa; &#125; return ans;&#125;int fd(int rt, int s) &#123;//查找结点 if (nd[nd[rt].l].num + nd[rt].R - nd[rt].L + 1 &lt; s) return fd(nd[rt].r, s - nd[nd[rt].l].num - nd[rt].R + nd[rt].L - 1); else if (s &lt;= nd[nd[rt].l].num)return fd(nd[rt].l, s); return nd[rt].L + s - nd[nd[rt].l].num - 1;&#125;void split(int rt, int &amp;a, int &amp;b, int s) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; if (nd[nd[rt].l].num + nd[rt].R - nd[rt].L + 1 &lt;= s) a = rt, split(nd[rt].r, nd[a].r, b, s - nd[nd[rt].l].num - nd[rt].R + nd[rt].L - 1); else b = rt, split(nd[rt].l, a, nd[b].l, s); update(rt);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (nd[a].k &lt; nd[b].k)rt = b, merge(nd[rt].l, a, nd[b].l); else rt = a, merge(nd[rt].r, nd[a].r, b); update(rt);&#125;inline int change(int s, int x) &#123;//结点分拆 if (nd[s].L == x &amp;&amp; nd[s].R == x)return s; int pk = getRK(s, nd[s].R), a, b, c, r, p, ans; split(root, a, c, pk), split(a, a, b, pk - (nd[s].R - nd[s].L + 1)), r = nd[b].R; if (nd[b].L == x) &#123; p = newNode(x, x), ins(stroot, x, x, p), nd[b].num--, nd[b].L = x + 1, merge(b, p, b); merge(a, a, b), merge(root, a, c); return p; &#125; else nd[b].R = x - 1, nd[b].num -= r - x + 1; ans = p = newNode(x, x), ins(stroot, x, x, p), merge(b, b, p); if (x &lt; r)p = newNode(x + 1, r), ins(stroot, x + 1, r, p), merge(b, b, p); merge(a, a, b), merge(root, a, c); return ans;&#125;int main() &#123; srand(time(0)); n = read(), m = read(), merge(root, root, newNode(1, n)), stroot = getNode(0), ins(stroot, 1, n, root); while (m--) &#123; int opt = read(), x, y, p, a, b, c, d; if (opt == 1) &#123; x = read(), y = read(), x -= last, y -= last, p = get(stroot, x), printf("%d\n", last = getRK(p, x)); p = change(p, x), nd[p].L = nd[p].R = y, ins(stroot, y, y, p); &#125; else if (opt == 2 || opt == 3) &#123; x = read(), x -= last, p = get(stroot, x); p = change(p, x), printf("%d\n", last = d = getRK(p, nd[p].R)); split(root, a, c, d), split(a, a, b, d - (nd[p].R - nd[p].L + 1)); if (opt == 2)merge(b, b, a), merge(root, b, c); else merge(a, a, c), merge(root, a, b); &#125; else x = read() - last, printf("%d\n", last = fd(root, x)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6606]Distribution of books]]></title>
    <url>%2F2019%2F07%2F29%2Fbooks%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记这个题主要是弥补一下数据结构优化DP的相关知识。题目来源：2019多校赛第三场D题。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zz6d likes reading very much, so he bought a lot of books. One day, zz6d brought n books to a classroom in school. The books of zz6d is so popular that K students in the classroom want to borrow his books to read. Every book of zz6d has a number i (1&lt;=i&lt;=n). Every student in the classroom wants to get a continuous number books. Every book has a pleasure value, which can be 0 or even negative (causing discomfort). Now zz6d needs to distribute these books to K students. The pleasure value of each student is defined as the sum of the pleasure values of all the books he obtains.Zz6d didn’t want his classmates to be too happy, so he wanted to minimize the maximum pleasure of the K classmates. zz6d can hide some last numbered books and not distribute them,which means he can just split the first x books into k parts and ignore the rest books, every part is consecutive and no two parts intersect with each other.However,every classmate must get at least one book.Now he wonders how small can the maximum pleasure of the K classmates be. 1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6604]Blow up the city]]></title>
    <url>%2F2019%2F07%2F29%2Fcity%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;超好的一道支配树题目。来源：2019多校赛第三场B题。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Country A and B are at war. Country A needs to organize transport teams to deliver supplies toward some command center cities.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In order to ensure the delivery works efficiently, all the roads in country A work only one direction. Therefore, map of country A can be regarded as DAG( Directed Acyclic Graph ). Command center cities only received supplies and not send out supplies.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intelligence agency of country B is credibly informed that there will be two cities carrying out a critical transporting task in country A.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As long as any one of the two cities can not reach a command center city, the mission fails and country B will hold an enormous advantage. Therefore, country B plans to destroy one of the n cities in country A and all the roads directly connected. (If a city carrying out the task is also a command center city, it is possible to destroy the city to make the mission fail)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now country B has made q hypotheses about the two cities carrying out the critical task.Calculate the number of plan that makes the mission of country A fail. 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first line contains a integer T (1≤T≤10), denoting the number of test cases.In each test case, the first line are two integers n,m, denoting the number of cities and roads(1≤n≤100,000,1≤m≤200,000).Then m lines follow, each with two integers u and v, which means there is a directed road from city u to v (1≤u,v≤n,u≠v).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The next line is a integer q, denoting the number of queries (1≤q≤100,000)And then q lines follow, each with two integers a and b, which means the two cities carrying out the critical task are a and b (1≤a,b≤n,a≠b).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A city is a command center if and only if there is no road from it (its out degree is zero). 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For each query output a line with one integer, means the number of plan that makes the mission of country A fail. 输入输出样例Sample input 28 81 23 43 54 64 75 76 87 821 36 73 23 13 221 23 1 Sample output 4322 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目就是给一张DAG，其中没有出边的点称为指挥站，每一个点都可以通过沿图中的边走向指挥站。现在选定两个点，并删除图中任意一个点（可以是选定的点），使这两个点不都能通向任意一个指挥站，求删点的方案数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然只能删去一个点就能让这个点不能达到令一些点，那么这个被删去的点必然是必经点，看到必经点立即想到支配树，于是这题就可以拿支配树解决了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先从所有的指挥站出发，向一个新结点（不妨称为超级指挥站）连边，然后将图反建。现在要删去一个点，使得某个点与任何一个指挥站都不联通，如何解决？答案显然就是超级指挥站到该点的必经点，方案数自然就是这些必经点的数量再减去一（不能删超级指挥站，那是我们自己加的）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在反建的图上建支配树，DAG上的支配树比较容易建出，于是我们得到一棵树，它以超级指挥站为根。建立支配树的复杂度为$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在求两个点不都能走向超级指挥站的必经点数量，答案显然就是支配树上两个点到根的路径上的点的数量，不要忘了减去根。由于有多次询问，可以先一遍DFS预处理所有结点到根的结点数，然后用lca（倍增法）求点的数量，这一步复杂度为$O(qlogn)$，然后本题就切掉了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge &#123; int next, to;&#125; edge[200005], edge_opp[200005], edge_tree[200005];int head[100005], head_opp[100005], cnt1, cnt2, cnt3, n, m, in[100005], head_tree[100005], dep[100005];int gd[100005][25], ss[100005];vector&lt;int&gt; vvp;queue&lt;int&gt; que;inline void add(int x, int y) &#123; edge[cnt1].to = y, edge[cnt1].next = head[x], head[x] = cnt1++;&#125;inline void add_opp(int x, int y) &#123; edge_opp[cnt2].to = y, edge_opp[cnt2].next = head_opp[x], head_opp[x] = cnt2++;&#125;inline void add_tree(int x, int y) &#123; edge_tree[cnt3].to = y, edge_tree[cnt3].next = head_tree[x], head_tree[x] = cnt3++;&#125;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void topSort() &#123; que.push(0), vvp.clear(); while (!que.empty()) &#123; int f = que.front(); que.pop(), vvp.push_back(f); for (int i = head[f]; i; i = edge[i].next) &#123; --in[edge[i].to]; if (in[edge[i].to] == 0)que.push(edge[i].to); &#125; &#125;&#125;inline int LCA(int x, int y) &#123; if (dep[x] &gt; dep[y])swap(x, y); for (int i = 24; i &gt;= 0; i--)if (dep[gd[y][i]] &gt;= dep[x])y = gd[y][i]; if (x == y)return x; for (int i = 24; i &gt;= 0; i--)if (gd[x][i] != gd[y][i])x = gd[x][i], y = gd[y][i]; return gd[x][0];&#125;void DFS(int x, int s) &#123; ss[x] = s; for (int i = head_tree[x]; i; i = edge_tree[i].next)DFS(edge_tree[i].to, s + 1);&#125;int main() &#123; int t = read(); while (t--) &#123; n = read(), m = read(), memset(head, 0, sizeof(head)), memset(head_opp, 0, sizeof(head_opp)); cnt3 = cnt1 = cnt2 = 1, memset(in, 0, sizeof(in)), memset(head_tree, 0, sizeof(head_tree)); for (int i = 1, x, y; i &lt;= m; i++) &#123; x = read(), y = read(); add(y, x), add_opp(x, y), ++in[x]; &#125; for (int i = 1; i &lt;= n; i++)if (in[i] == 0)add(0, i), add_opp(i, 0), ++in[i]; dep[0] = 1, topSort(); for (int i = 1; i &lt;= n; i++) &#123; int s = edge_opp[head_opp[vvp[i]]].to, lca = s;//第一个前驱 for (int j = edge_opp[head_opp[vvp[i]]].next; j; j = edge_opp[j].next)lca = LCA(lca, edge_opp[j].to); add_tree(lca, vvp[i]), dep[vvp[i]] = dep[lca] + 1, gd[vvp[i]][0] = lca; for (int j = 1; j &lt; 25; j++)gd[vvp[i]][j] = gd[gd[vvp[i]][j - 1]][j - 1]; &#125; DFS(0, 0); int q = read(); while (q--) &#123; int a = read(), b = read(); int lca = LCA(a, b); printf("%d\n", ss[a] + ss[b] - ss[lca]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3313]旅行]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%B4%9B%E8%B0%B7P3313-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S国有N个城市，编号从1到N。城市间用N-1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了方便，我们用不同的正整数代表各种宗教， S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在S国的历史上常会发生以下几种事件： “CC x c“：城市x的居民全体改信了c教； “CW x w“：城市x的评级调整为w; “QS x y“：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级总和； “QM x y“：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级最大值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行包含整数N，Q依次表示城市数和事件数，N、Q≤100000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来N行，第i+l行两个整数Wi，Ci依次表示记录开始之前，城市i的评级和信仰。 接下来N-1行每行两个整数x，y表示一条双向道路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来Q行，每行一个操作，格式如上所述。 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个QS和QM事件，输出一行，表示旅行者记下的数字。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先肯定需要树链剖分，但答案的统计是按照种类来的，只开一棵线段树没法处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是考虑给每一个信仰开一棵线段树，但是这样直接爆内存。于是考虑动态加点，舍弃线段树的堆式储存，这样就可以开得动线段树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是树链剖分+动态加点线段树就能切掉本题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct Edge &#123; int to, next;&#125; edge[N &lt;&lt; 1];struct Node &#123; int l, r, max, sum;&#125; nd[N &lt;&lt; 7];int head[N], n, q, pj[N], xy[N], dep[N], sz[N], fa[N], son[N], top[N], ct = 1;int id[N], idhs[N], ID = 1, root[N];char opt[50];inline void add(int x, int y) &#123; static int cnt = 1; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;inline void ms(Node &amp;a, Node x, Node y) &#123; a.max = max(x.max, y.max), a.sum = x.sum + y.sum;&#125;void DFS(int x) &#123; sz[x] = 1; int ff = 0; for (int i = head[x]; i; i = edge[i].next) &#123; if (sz[edge[i].to] == 0) &#123; fa[edge[i].to] = x, dep[edge[i].to] = dep[x] + 1, DFS(edge[i].to), sz[x] += sz[edge[i].to]; if (ff &lt; sz[edge[i].to])ff = sz[edge[i].to], son[x] = edge[i].to; &#125; &#125;&#125;void DFS(int x, int tp) &#123; top[x] = tp, id[x] = ID, idhs[ID] = x, ++ID; if (son[x])DFS(son[x], tp); else return; for (int i = head[x]; i; i = edge[i].next)if (!id[edge[i].to])DFS(edge[i].to, edge[i].to);&#125;void del(int rt, int v, int L = 1, int R = n) &#123;//删除某一个点 if (L == R) &#123; nd[rt].sum = nd[rt].max = 0; return; &#125; int mid = (L + R) &gt;&gt; 1; if (v &gt; mid)del(nd[rt].r, v, mid + 1, R); else del(nd[rt].l, v, L, mid); ms(nd[rt], nd[nd[rt].l], nd[nd[rt].r]);&#125;void ins(int &amp;rt, int v, int L = 1, int R = n) &#123;//插入某一个点 if (rt == 0)rt = ct++; if (L == R) &#123; nd[rt].sum = nd[rt].max = pj[idhs[v]]; return; &#125; int mid = (L + R) &gt;&gt; 1; if (v &lt;= mid)ins(nd[rt].l, v, L, mid); else ins(nd[rt].r, v, mid + 1, R); ms(nd[rt], nd[nd[rt].l], nd[nd[rt].r]);&#125;Node qu(int rt, int l, int r, int L = 1, int R = n) &#123;//查询 if (rt == 0)return nd[0]; if (L &gt;= l &amp;&amp; R &lt;= r)return nd[rt]; int mid = (L + R) &gt;&gt; 1; if (l &gt; mid)return qu(nd[rt].r, l, r, mid + 1, R); else if (r &lt;= mid)return qu(nd[rt].l, l, r, L, mid); Node ss; ms(ss, qu(nd[rt].l, l, mid, L, mid), qu(nd[rt].r, mid + 1, r, mid + 1, R)); return ss;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++)scanf("%d%d", &amp;pj[i], &amp;xy[i]); for (int i = 1, x, y; i &lt; n; i++)scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x); dep[1] = 1, DFS(1), DFS(1, 1);//树剖过程 for (int i = 1; i &lt;= n; i++)ins(root[xy[i]], id[i]); while (q--) &#123; int x, y, s; scanf("%s%d%d", opt, &amp;x, &amp;y); if (opt[0] == 'C' &amp;&amp; opt[1] == 'C')del(root[xy[x]], id[x]), ins(root[xy[x] = y], id[x]); else if (opt[0] == 'C' &amp;&amp; opt[1] == 'W')pj[x] = y, ins(root[xy[x]], id[x]); else &#123; Node ans; ans.sum = ans.max = 0, s = xy[x]; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]])swap(x, y); ms(ans, ans, qu(root[s], id[top[y]], id[y])), y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y])swap(x, y); ms(ans, ans, qu(root[s], id[x], id[y])); if (opt[1] == 'S')printf("%d\n", ans.sum); else printf("%d\n", ans.max); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3302]森林]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%B4%9B%E8%B0%B7P3302-%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小Z有一片森林，含有N个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有M条边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小Z希望执行T个操作，操作有两类： Q x y k查询点x到点y路径上所有的权值中，第k小的权值是多少。此操作保证点x和点y连通，同时这两个节点的路径上至少有k个点。 L x y在点x和点y之间连接一条边。保证完成此操作后，仍然是一片森林。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了体现程序的在线性，我们把输入数据进行了加密。设lastans为程序上一次输出的结果，初始的时候lastans为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个输入的操作Q x y k,其真实操作为Q x^lastans y^lastans k^lastans。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个输入的操作L x y，其真实操作为L x^lastans y^lastans。其中^运算符表示异或，等价于pascal中的xor运算符。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请写一个程序來帮助小Z完成这些操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于所有的数据，$n,m,T&lt;=8*10^4$ 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数testcase，表示当前测试数据的测试点编号。保证1&lt;=testcase&lt;=20。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含三个整数N，M，T，分别表示节点数、初始边数、操作数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行包含N个非负整数表示 N个节点上的权值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 M行，每行包含两个整数x和 y，表示初始的时候，点x和点y 之间有一条无向边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 T行，每行描述一个操作，格式为”Q x y k“或者”L x y “，其含义见题目描述部分。 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一个第一类操作，输出一个非负整数表示答案。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看见第k小，立即想到主席树。但是本题和朴素的树上路径第k小不同的是，本题需要动态连边，问题的关键就是如何实现连边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在连边时，我们要考虑这两棵树连接的顺序，这里需要启发式合并：每一次都将较小的一棵树连向较大的一棵，然后在这棵小树上暴力重构主席树。可以证明，启发式合并时，每一个结点被重构的次数不会多于$logn$次，那么合并的复杂度仅为$O(logn)$，而主席树重构的复杂度为$O(nlogn)$，总复杂度$O(nlog^2n)$，对于这个数据范围来说还是可以接受的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在暴力重构主席树时，还需要维护lca的数组，总复杂度也是$O(nlog^2n)$。至于如何维护每一棵树的连接关系和总点数，这个可以用并查集实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct Node &#123; int l, r, v;&#125; nd[N &lt;&lt; 8];struct Edge &#123; int to, next;&#125; edge[N &lt;&lt; 2];int gd[N][28], fa[N], sz[N], head[N], root[N], ts, n, m, t, v[N], tmp[N], sv, ct = 1, dep[N], last;inline void add(int x, int y) &#123; static int cnt = 1; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;int build(int l = 1, int r = sv) &#123; int p = ct++, mid = (l + r) &gt;&gt; 1; if (l == r)return p; nd[p].l = build(l, mid), nd[p].r = build(mid + 1, r); return p;&#125;int ff(int x) &#123; return fa[x] == x ? x : fa[x] = ff(fa[x]);&#125;int newTree(int pre, int v, int l = 1, int r = sv) &#123; int p = ct++, mid = (l + r) &gt;&gt; 1; nd[p] = nd[pre], ++nd[p].v; if (l == r)return p; if (v &gt; mid)nd[p].r = newTree(nd[pre].r, v, mid + 1, r); else nd[p].l = newTree(nd[pre].l, v, l, mid); return p;&#125;void DFS(int x, int pre) &#123; root[x] = newTree(root[pre], lower_bound(tmp + 1, tmp + sv + 1, v[x]) - tmp); for (int i = head[x]; i; i = edge[i].next) &#123; if (edge[i].to == pre)continue; dep[edge[i].to] = dep[x] + 1, gd[edge[i].to][0] = x; for (int p = 1; p &lt; 25; p++)gd[edge[i].to][p] = gd[gd[edge[i].to][p - 1]][p - 1]; DFS(edge[i].to, x); &#125;&#125;inline int LCA(int x, int y) &#123; if (dep[x] &gt; dep[y])swap(x, y); for (int i = 24; i &gt;= 0; i--)if (dep[gd[y][i]] &gt;= dep[x])y = gd[y][i]; if (x == y)return x; for (int i = 24; i &gt;= 0; i--)if (gd[x][i] != gd[y][i])x = gd[x][i], y = gd[y][i]; return gd[x][0];&#125;void merge(int x, int y, bool g) &#123;//并查集合并操作 int f1 = ff(x), f2 = ff(y); if (f1 == f2)return; else if (sz[f1] &gt; sz[f2]) &#123;//较小的连接较大的 fa[f2] = f1, sz[f1] += sz[f2]; if (g) &#123; gd[y][0] = x, dep[y] = dep[x] + 1, add(x, y), add(y, x); for (int i = 1; i &lt; 25; i++)gd[y][i] = gd[gd[y][i - 1]][i - 1]; DFS(y, x);//暴力重构 &#125; &#125; else &#123; fa[f1] = f2, sz[f2] += sz[f1]; if (g) &#123; gd[x][0] = y, dep[x] = dep[y] + 1, add(x, y), add(y, x); for (int i = 1; i &lt; 25; i++)gd[x][i] = gd[gd[x][i - 1]][i - 1]; DFS(x, y); &#125; &#125;&#125;int qu(int lca, int a, int b, int k, int obj, int l = 1, int r = sv) &#123; if (l == r)return tmp[l]; int mid = (l + r) &gt;&gt; 1; int p = nd[nd[b].l].v + nd[nd[a].l].v - 2 * nd[nd[lca].l].v + (obj &gt;= l &amp;&amp; obj &lt;= mid ? 1 : 0); if (k &lt;= p)return qu(nd[lca].l, nd[a].l, nd[b].l, k, obj, l, mid); return qu(nd[lca].r, nd[a].r, nd[b].r, k - p, obj, mid + 1, r);&#125;int main() &#123; scanf("%d%d%d%d", &amp;ts, &amp;n, &amp;m, &amp;t); for (int i = 1; i &lt;= n; i++)fa[i] = i, scanf("%d", v + i), tmp[i] = v[i], sz[i] = 1; for (int i = 1, x, y; i &lt;= m; i++)scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x), merge(x, y, false); sort(tmp + 1, tmp + n + 1), sv = unique(tmp + 1, tmp + n + 1) - tmp - 1, root[0] = build(); for (int i = 1; i &lt;= n; i++)if (root[i] == 0)dep[ff(i)] = 1, DFS(ff(i), 0); while (t--) &#123; char opt; int x, y, k, lca; scanf(" %c", &amp;opt); if (opt == 'Q') &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;k), x ^= last, y ^= last, k ^= last, lca = LCA(x, y); printf("%d\n", last = qu(root[lca], root[x], root[y], k, lower_bound(tmp + 1, tmp + sv + 1, v[lca]) - tmp)); &#125; else if (opt == 'L')scanf("%d%d", &amp;x, &amp;y), x ^= last, y ^= last, merge(x, y, true); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P4699]Teams]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%B4%9B%E8%B0%B7P4699-Teams%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有n个小朋友要进行比赛，他们要被分为若干队伍。每一个小朋友都有一个要求，其中第i个小朋友要求他所在的队伍最少要有$a_i$个人（包括自己）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在请你求出一种划分方案，在满足所有小朋友的要求的情况下，最大化队伍的数量。同时在此基础上，请你最小化人数最多的队伍的人数。 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个数n表示小朋友的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n行，每行一个数，其中第i行的数字为$a_i$​。 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个数t，表示在你的方案中的队伍数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来t行，每行若干个空格隔开的数字，表示一只队伍。每一行首先输出一个数$k_i$ 表示第i只队伍的人数，接下来$k_i$个数依次描述该队伍内的小朋友的编号（从1开始）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若有多解（在满足题目要求的情况下），输出任意一个即可。 输入输出样例Sample input 521223 Sample output 22 4 23 5 1 3 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1\leq N\leq 1000000$，保证有解。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始以为是个傻X贪心，结果WA了后发现并不是这样。hack：8 1 2 4 5 5 5 5 5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将这些要求升序排序，可以发现最终的分组一定是一块一块的。那么考虑$DP(i)$为前$i$组成的最多组数，那么有状态转移方程： DP(i)=\max\{DP(j)\}+1,0\leq j\leq i-a_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$a_i$是升序后第$i$个的要求，和题目中的有所区别。这个方程是很好理解的。当不能组成组时，$DP$值设置成负无穷大即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法是$O(n^2)$的，但是发现最值可以拿前缀最大值优化，这样就是$O(n)$复杂度了。求最大组数不是问题，但是怎么保证最大值最小？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看见最大值最小考虑二分，这里的二分比较有意思，是对$DP$过程做一些修改。假设现在要判定答案$x$的正确性，那么每一个组的人数都不能多于$x$个，在DP转移时把方程改一下就好了： DP(i)=\max\{DP(j)\},i-x\leq j\leq i-a_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后看看最后的$DP(n)$是不是之前求出的最大组数，如果是，答案可行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理一下边界，这个方程是很好推的，但是复杂度没法降维了。由于我们是从DP值最大的那一个转移，不妨开一个数组g保存到当前位置，出现过的最大的DP值对应下标的最大值。考虑到全局最优必然需要子结构最优（这是DP的原理），因此如果想要最后的$DP(n)$达到最大，这些$DP(i)$都应该达到最大，于是只考虑最大的转移，这也是算法正确性的保证。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找到这个最大值出现的下标，如果它在范围里，则转移，否则$DP(i)$为无穷大，即无法转移（没法取到最大值，最终结果肯定不是最优的）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案也容易得，在转移时记录一下转移的下标即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是复杂度降为$O(n)$，再加上二分的复杂度，总复杂度$O(nlogn)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define N 1000005#define inf 0x3f3f3f3fusing namespace std;int dp[N], a[N], rk[N], n, b[N], g[N], e[N];bool cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;int check(int x) &#123; for (int i = 1; i &lt;= n; i++) &#123; int j = i - b[i]; if (j &lt; 0)dp[i] = -inf, e[i] = -1; else if (j == 0)dp[i] = 1, e[i] = 0; else if (i - g[j] &lt;= x)dp[i] = dp[g[j]] + 1, e[i] = g[j]; else dp[i] = -inf, e[i] = -1; g[i] = dp[i] &gt;= dp[g[i - 1]] ? i : g[i - 1]; &#125; return dp[n];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)scanf("%d", a + i), rk[i] = i; sort(rk + 1, rk + n + 1, cmp); for (int i = 1; i &lt;= n; i++)b[i] = a[rk[i]]; int l = 0, r = n, mid, ans = check(n); while (l &lt; r) &#123;//(,] if (r == l + 1) &#123; check(r), printf("%d\n", ans); for (int i = n; i &gt;= 1;) &#123; printf("%d ", i - e[i]); for (int j = i; j &gt; e[i]; j--)printf("%d ", rk[j]); i = e[i], printf("\n"); &#125; return 0; &#125; mid = (l + r) &gt;&gt; 1; if (check(mid) == ans)r = mid; else l = mid; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3644]巴邻旁之桥]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%B4%9B%E8%B0%B7P3644-%E5%B7%B4%E9%82%BB%E6%97%81%E4%B9%8B%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 A 和区域 B。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一块区域沿着河岸都建了恰好 1000000001 栋的建筑，每条岸边的建筑都从 0 编号到 1000000000。相邻的每对建筑相隔1个单位距离，河的宽度也是 1个单位长度。区域 A 中的i 号建筑物恰好与区域 B中的 i号建筑物隔河相对。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;城市中有N个居民。第 i 个居民的房子在区域 $P_i$的$S_i$号建筑上，同时他的办公室坐落在$Q_i$区域的$T_i$号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 K 座横跨河流的大桥。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当政府建造最多 K 座桥之后，设 $D_i$表示第i个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \cdots + D_N$最小。 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行包含两个正整数K和 N，分别表示桥的上限数量和居民的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 N行，每一行包含四个参数：$P_i, S_i, Q_i$和 $T_i$，表示第 i 个居民的房子在区域 $P_i$的 $S_i$号建筑上，且他的办公室位于 $Q_i$区域的 $T_i$号建筑上。 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出仅为一行，包含一个整数，表示 $D_1 + D_2 + \cdots + D_N$的最小值。 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1≤N≤100000, 1\leq K\leq 2$ 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题教育我们要根据数据范围想思路。一开始毫无思路，结果发现这个K才1~2。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于那些不用过河的人，直接预处理掉。对于那些需要过河的人，它们如果需要走位于$a$位置的桥，则需要走的距离是两点（起点、终点）到$a$的距离和再加一，问题转化为在数轴上选一点，使得所有点到该点的距离和最小。这个点显然是中点（中位数）。对于K=1的情况，sort一遍就完了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K=2的情况就麻烦得多（K若更大，则更麻烦）。首先每一个人肯定走离自己最近的桥，现在有两个桥，如何确定那些人该走哪一个？可以确定的一点是，如果将所有人按照自己的起点和终点坐标之和做一次排序，那么这两类人（走两个不同的桥）肯定是左边一片，右边一片。这样我们可以枚举这个分割线，然后两侧就转化为K=1的情况。现在问题就转化为如何动态地求一些数的中位数以及这些数到它的距离之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这显然可以用平衡树搞。开两棵平衡树，按坐标点权值排序。$O(logn)$二分出中位数，然后$O(logn)$求距离和。总体时间复杂度$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里为了省空间，可以在右移分割线时将右侧平衡树上的结点“割”下相应的一块给左平衡树，但是我这样做疯狂TLE。后来发现这样做使得左平衡树的平衡性被打破，使得其树高很快达到1000+，原因我也不清楚。解决方法是在移动结点时重新对需要移动的结点进行重随机化处理，以保证树的随机平衡性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;#define inf (1ll&lt;&lt;50)using namespace std;typedef long long ll;struct Q &#123; int l, r; bool operator&lt;(Q q) &#123; return l + r &lt; q.l + q.r; &#125;&#125;;struct Node &#123; int l, r, num, k; ll sum, v;&#125; nd[100100 &lt;&lt; 1];vector&lt;Q&gt; vvp;vector&lt;int&gt; vvp2;int k, n, root1, root2;ll ans;inline int newNode(ll x) &#123; static int p = 1; nd[p].v = x, nd[p].num = 1, nd[p].sum = x, nd[p].k = rand(); return p++;&#125;inline void update(int x) &#123; nd[x].num = nd[nd[x].l].num + nd[nd[x].r].num + 1; nd[x].sum = nd[nd[x].l].sum + nd[nd[x].r].sum + nd[x].v;&#125;void split(int rt, int &amp;a, int &amp;b, int s) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; if (nd[nd[rt].l].num + 1 &lt;= s)a = rt, split(nd[rt].r, nd[a].r, b, s - nd[nd[rt].l].num - 1); else b = rt, split(nd[rt].l, a, nd[b].l, s); update(rt);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (nd[a].k &lt; nd[b].k)rt = b, merge(nd[rt].l, a, nd[b].l); else rt = a, merge(nd[rt].r, nd[a].r, b); update(rt);&#125;int fd(int rt, int s) &#123; if (rt == 0)return 0; else if (nd[rt].v == s)return nd[nd[rt].l].num + 1; else if (nd[rt].v &lt; s)return nd[nd[rt].l].num + 1 + fd(nd[rt].r, s); return fd(nd[rt].l, s);&#125;int fdRk(int rt, int s) &#123; if (rt == 0)return 0; else if (nd[nd[rt].l].num + 1 == s)return rt; else if (nd[nd[rt].l].num + 1 &lt; s)return fdRk(nd[rt].r, s - nd[nd[rt].l].num - 1); return fdRk(nd[rt].l, s);&#125;void trans(int x) &#123;//两棵树交换结点：将右树权值为x的结点转移到左树上 register int s = fd(root2, x), a, b, c; split(root2, a, c, s), split(a, a, b, s - 1), merge(root2, a, c), nd[b].k = rand();//注意这里的重随机化 s = fd(root1, x), split(root1, a, c, s), merge(a, a, b), merge(root1, a, c);&#125;ll getAbs(int rt, ll x) &#123; if (rt == 0)return 0; if (nd[rt].v &lt; x)return 1ll * (nd[nd[rt].l].num + 1) * x - (nd[nd[rt].l].sum + nd[rt].v) + getAbs(nd[rt].r, x); return (nd[nd[rt].r].sum + nd[rt].v) - 1ll * (nd[nd[rt].r].num + 1) * x + getAbs(nd[rt].l, x);&#125;inline ll getMid(int rt) &#123; if (rt == 0)return 0; return nd[fdRk(rt, nd[rt].num &gt;&gt; 1)].v;&#125;int main() &#123; srand(time(0)), scanf("%d%d", &amp;k, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; char a, b; Q q; scanf(" %c", &amp;a), scanf("%d", &amp;q.l), scanf(" %c", &amp;b), scanf("%d", &amp;q.r); if (q.l &gt; q.r)swap(q.l, q.r); if (a == b)ans += q.r - q.l; else vvp.push_back(q); &#125; if (k == 1) &#123; if (vvp.empty()) &#123;//注意判空，否则RE cout &lt;&lt; ans; return 0; &#125; for (Q q:vvp)vvp2.push_back(q.l), vvp2.push_back(q.r), ++ans; sort(vvp2.begin(), vvp2.end()); register int mid = vvp2[vvp2.size() &gt;&gt; 1]; for (int s:vvp2)ans += abs(s - mid); printf("%lld", ans); &#125; else &#123; if (vvp.empty()) &#123; cout &lt;&lt; ans; return 0; &#125; ans += vvp.size(); ll tmp = inf; for (auto &amp;i : vvp) vvp2.push_back(i.l), vvp2.push_back(i.r); sort(vvp2.begin(), vvp2.end()), sort(vvp.begin(), vvp.end()); for (auto &amp;i:vvp2)merge(root2, root2, newNode(i)); tmp = min(tmp, getAbs(root2, getMid(root2))); for (register int i = 0; i &lt; vvp.size() - 1; i++) &#123; trans(vvp[i].l), trans(vvp[i].r); tmp = min(tmp, getAbs(root1, getMid(root1)) + getAbs(root2, getMid(root2))); &#125; cout &lt;&lt; ans + tmp; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2045]维护数列]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%B4%9B%E8%B0%B7P2045-%E7%BB%B4%E6%8A%A4%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格） 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M 表示要进行的操作数目。 第 2 行包含 N 个数字，描述初始时的数列。 以下 M 行，每行一条命令，格式参见问题描述中的表格。 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结 果，每个答案（数字）占一行。 输入输出样例Sample input 9 82 -6 3 5 1 -5 -3 6 3GET-SUM 5 4MAX-SUMINSERT 8 3 -5 7 2DELETE 12 1MAKE-SAME 3 3 2REVERSE 3 6GET-SUM 5 4MAX-SUM Sample output -110110 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以认为在任何时刻，数列中至少有 1 个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据一定是正确的，即指定位置的数在数列中一定存在。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50%的数据中，任何时刻数列中最多含有 30000 个数；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据中，任何时刻数列中最多含有 500000 个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据中，任何时刻数列中任何一个数字均在[-1000, 1000]内。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据中，M ≤20000，插入的数字总数不超过 4000000 。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很让人自闭的平衡树题，做这个题你需要知道平衡树相关的知识以及良好的心态。强烈推荐将本题代码多打几遍，能很好地提高码力。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用平衡树维护数列的相对位置信息。对于插入和删除操作，直接在平衡树上进行就可以了。对于第三个操作，需要用一个懒标记，表明这棵子树上的结点点权需要统一修改。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结点太多会炸空间，但注意到任意时刻最多有500000个数，故那些被删除的结点我们用一个队列回收，在需要开新结点时再拿出来复用。这样可以牺牲一些时间来换空间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于翻转操作，只需要打上一个翻转懒标记就可以了（还记得文艺平衡树吗？）。求和自然也很简单，直接像线段树那样维护即可。比较麻烦的是最后一个，需要维护额外的两个信息，关于这部分见线段树一文的后半部分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题有很多细节需要注意，一不留神就会疯狂WA，这里提一个比较隐晦的错误（我找了N个小时的bug）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里面有两个懒标记，一个是区间整体修改标记，另一个是翻转标记。这两个标记的含义是不同的，第一个与线段树相同，表示它的子树需要修改，而这个结点本身已经经过更新，后者表示这棵树需要翻转（即尚未翻转），这一点点区别会带来很大的麻烦。事实证明，对于前者，如果在split和merge过程中不断下放标记，结点是可以得到更新的，但是后者不可以！！即使下压了标记，也会出现某些结点未得到更新而出现惨案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免这种情况的发生，最好采用统一的标记下放方式，对于文艺平衡树也是如此。即标记代表其子树需要更新，而该结点本身已更新。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面代码（需要卡常）给出一些注释，标明一些可能出现细节问题的BUG。这里平衡树用的非旋Treap。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;#define N 510000using namespace std;struct Node &#123; int l, r, k, v, sum, num, la1, la2; int max, lmax, rmax;&#125; nd[N];queue&lt;int&gt; que;//回收队列int root, n, m;char opt[50];inline void down(int x) &#123;//下压标记 if (nd[x].la1 != 1000000000) &#123;//标记表示已被处理，1000000000就是没有标记，不要用0、1、-1这样的数做无标记的指标 nd[nd[x].l].v = nd[nd[x].r].v = nd[x].la1; nd[nd[x].l].la1 = nd[nd[x].r].la1 = nd[x].la1; nd[nd[x].l].lmax = nd[nd[x].l].rmax = nd[nd[x].l].max = nd[x].la1 &gt;= 0 ? nd[x].la1 * nd[nd[x].l].num : nd[x].la1; nd[nd[x].r].lmax = nd[nd[x].r].rmax = nd[nd[x].r].max = nd[x].la1 &gt;= 0 ? nd[x].la1 * nd[nd[x].r].num : nd[x].la1; nd[nd[x].l].sum = nd[nd[x].l].num * nd[x].la1, nd[nd[x].r].sum = nd[nd[x].r].num * nd[x].la1; nd[x].la1 = 1000000000; &#125; if (nd[x].la2) &#123;//第二个懒标记下压 swap(nd[nd[x].l].l, nd[nd[x].l].r), swap(nd[nd[x].l].lmax, nd[nd[x].l].rmax);//别忘了交换lmax和rmax swap(nd[nd[x].r].l, nd[nd[x].r].r), swap(nd[nd[x].r].lmax, nd[nd[x].r].rmax); nd[nd[x].l].la2 ^= 1, nd[nd[x].r].la2 ^= 1, nd[x].la2 = 0; &#125;&#125;inline void update(int x) &#123;//更新结点信息 nd[0].v = 0; nd[x].num = nd[nd[x].l].num + nd[nd[x].r].num + 1; nd[x].sum = nd[nd[x].l].sum + nd[nd[x].r].sum + nd[x].v; down(nd[x].l), down(nd[x].r); if (nd[x].l == 0 &amp;&amp; nd[x].r == 0)nd[x].max = nd[x].lmax = nd[x].rmax = nd[x].v;//这一步和线段树有区别，最好分类讨论 else if (nd[x].l == 0) &#123; nd[x].lmax = max(nd[x].v, nd[x].v + nd[nd[x].r].lmax); nd[x].rmax = max(nd[nd[x].r].rmax, nd[nd[x].r].sum + nd[x].v); nd[x].max = max(nd[nd[x].r].max, nd[x].v + nd[nd[x].r].lmax), nd[x].max = max(nd[x].max, nd[x].v); return; &#125; else if (nd[x].r == 0) &#123; nd[x].rmax = max(nd[x].v, nd[x].v + nd[nd[x].l].rmax); nd[x].lmax = max(nd[nd[x].l].lmax, nd[nd[x].l].sum + nd[x].v); nd[x].max = max(nd[nd[x].l].max, nd[x].v + nd[nd[x].l].rmax), nd[x].max = max(nd[x].max, nd[x].v); &#125; else &#123; nd[x].max = max(nd[nd[x].l].rmax + nd[nd[x].r].lmax + nd[x].v, max(nd[nd[x].l].max, nd[nd[x].r].max)); nd[x].max = max(nd[x].max, max(nd[nd[x].l].rmax, nd[nd[x].r].lmax) + nd[x].v); nd[x].max = max(nd[x].max, nd[x].v); nd[x].lmax = max(nd[nd[x].l].lmax, max(nd[nd[x].l].sum + nd[nd[x].r].lmax + nd[x].v, nd[nd[x].l].sum + nd[x].v)); nd[x].rmax = max(nd[nd[x].r].rmax, max(nd[nd[x].r].sum + nd[nd[x].l].rmax + nd[x].v, nd[nd[x].r].sum + nd[x].v)); &#125;&#125;inline int newNode(int v) &#123;//分配新结点 static int cnt = 1; int sv; if (!que.empty())sv = que.front(), que.pop();//优先从回收队列中取 else sv = cnt++; nd[sv].k = rand(), nd[sv].v = v, nd[sv].num = 1, nd[sv].max = nd[sv].rmax = nd[sv].lmax = v; nd[sv].r = nd[sv].l = 0, nd[sv].sum = v, nd[sv].la1 = 1000000000, nd[sv].la2 = 0; return sv;&#125;void split(int rt, int &amp;a, int &amp;b, int s) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; down(rt);//下压标记 if (nd[nd[rt].l].num + 1 &lt;= s)a = rt, split(nd[rt].r, nd[a].r, b, s - nd[nd[rt].l].num - 1); else b = rt, split(nd[rt].l, a, nd[b].l, s); update(rt);&#125;void merge(int &amp;rt, int a, int b) &#123; down(a), down(b); if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (nd[a].k &lt; nd[b].k)rt = b, merge(nd[rt].l, a, nd[b].l); else rt = a, merge(nd[rt].r, nd[a].r, b); update(rt);&#125;inline void insert() &#123;//插入 int pos, tot, pr = 0, a, b; scanf("%d%d", &amp;pos, &amp;tot); for (int i = 0, x; i &lt; tot; i++)scanf("%d", &amp;x), merge(pr, pr, newNode(x)); split(root, a, b, pos), merge(a, a, pr), merge(root, a, b);&#125;void trans(int x) &#123;//回收结点 if (x == 0)return; que.push(x), trans(nd[x].l), trans(nd[x].r);&#125;inline void del() &#123;//删除 int pos, a, b, c, tot; scanf("%d%d", &amp;pos, &amp;tot); split(root, a, c, pos - 1), split(c, b, c, tot), merge(root, a, c), trans(b);//回收b树的空间&#125;inline void ms() &#123;//区间整体修改 int pos, tot, C, a, b, c; scanf("%d%d%d", &amp;pos, &amp;tot, &amp;C); split(root, a, c, pos - 1), split(c, b, c, tot); nd[b].v = C, nd[b].sum = nd[b].num * C, nd[b].max = nd[b].lmax = nd[b].rmax = C &gt;= 0 ? C * nd[b].num : C; nd[b].la1 = C, merge(a, a, b), merge(root, a, c);&#125;inline void rs() &#123;//翻转 int pos, tot, a, b, c; scanf("%d%d", &amp;pos, &amp;tot); split(root, a, c, pos - 1), split(c, b, c, tot); swap(nd[b].l, nd[b].r), swap(nd[b].lmax, nd[b].rmax); nd[b].la2 ^= 1, merge(a, a, b), merge(root, a, c); //打完标记再合并&#125;inline void gs() &#123;//获得区间和 int pos, tot, a, b, c; scanf("%d%d", &amp;pos, &amp;tot); split(root, a, c, pos - 1), split(c, b, c, tot), printf("%d\n", nd[b].sum); merge(a, a, b), merge(root, a, c);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, x; i &lt;= n; i++)scanf("%d", &amp;x), merge(root, root, newNode(x)); while (m--) &#123; scanf("%s", opt); if (opt[0] == 'I')insert(); else if (opt[0] == 'D')del(); else if (opt[0] == 'M' &amp;&amp; opt[2] == 'K')ms(); else if (opt[0] == 'R')rs(); else if (opt[0] == 'G')gs(); else printf("%d\n", nd[root].max); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2602]数字计数]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%B4%9B%E8%B0%B7P2602-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。 输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件中仅包含一行两个整数a、b，含义如上所述。 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件中包含一行10个整数，分别表示0-9在[a,b]中出现了多少次。 输入输出样例Sample input 1 99 Sample output 9 20 20 20 20 20 20 20 20 20 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30%的数据中，$a\leq b\leq 10^6$；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据中，$a\leq b\leq 10^{12}$。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一篇关于数位DP的文章。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数位DP，顾名思义是在数位上进行的DP，这类题目通常方程不好列，但时间和空间复杂度比较低。可以说是人类智慧题。其实数位DP也是普通的DP，并不是什么高大上的东西。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们能够求出1~x的所有数码出现的次数，那么这个问题就解决了。因此下面考虑如何求1~x所有数，0~9的数码出现的次数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将这个x固定住，让它不参与状态的定义。然后对于这个x，令dp[x][s][y][z]表示x~0的数位，能不能超过原数（用y控制，y取0/1），能不能有前导0（用z控制，z取0/1），数码s的总出现次数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面转移就行了，这里预处理了10的幂，存入bin数组。看下面代码：1234567891011121314151617181920long long DP(int x, int y, bool isOK, bool isQ, long long p) &#123;//x~0位,y这个数码出现几次,isOK控制是否可以超过，isQ能否有前导0。这里的p是操作数（就是上面的s） if (dp[x][y][isOK][isQ] != -1)return dp[x][y][isOK][isQ];//记忆化 if (x == 0)return !isQ &amp;&amp; y == 0 ? 0 : (isOK ? 1 : y &lt;= p % 10);//递推边界 if (isOK) &#123;//能超过 if (!isQ &amp;&amp; y == 0)//不能有前导0 return dp[x][y][isOK][isQ] = DP(x - 1, y, true, false, p) + 9ll * DP(x - 1, y, true, true, p);//对这一位取0特判 return dp[x][y][isOK][isQ] = bin[x] + 10ll * DP(x - 1, y, true, true, p);//否则这一位随便取 &#125; dp[x][y][isOK][isQ] = 0; for (int i = 0; i &lt;= p / bin[x] % 10; i++) &#123;//取最高的数位 if (i &lt; p / bin[x] % 10) &#123;//对于小于最高位的情况 if (!isQ &amp;&amp; y == 0)dp[x][y][isOK][isQ] += DP(x - 1, y, true, i != 0, p);//对首位0特判 else dp[x][y][isOK][isQ] += (i == y) * bin[x] + DP(x - 1, y, true, true, p); &#125; else &#123;//最高位的情况 if (!isQ &amp;&amp; y == 0 &amp;&amp; i == 0)dp[x][y][isOK][isQ] += DP(x - 1, y, false, false, p); else dp[x][y][isOK][isQ] += (i == y) * (p % bin[x] + 1) + DP(x - 1, y, false, true, p); &#125; &#125; return dp[x][y][isOK][isQ];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读懂这个转移函数就可以了。12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;long long n, m, dp[15][15][2][2], bin[15];long long ans[10];long long DP(int x, int y, bool isOK, bool isQ, long long p) &#123;//x~0位,y出现几次,isOK控制是否可以超过，isQ能否有前导0 if (dp[x][y][isOK][isQ] != -1)return dp[x][y][isOK][isQ]; if (x == 0)return !isQ &amp;&amp; y == 0 ? 0 : (isOK ? 1 : y &lt;= p % 10); if (isOK) &#123; if (!isQ &amp;&amp; y == 0) return dp[x][y][isOK][isQ] = DP(x - 1, y, true, false, p) + 9ll * DP(x - 1, y, true, true, p); return dp[x][y][isOK][isQ] = bin[x] + 10ll * DP(x - 1, y, true, true, p); &#125; dp[x][y][isOK][isQ] = 0; for (int i = 0; i &lt;= p / bin[x] % 10; i++) &#123;/ if (i &lt; p / bin[x] % 10) &#123; if (!isQ &amp;&amp; y == 0)dp[x][y][isOK][isQ] += DP(x - 1, y, true, i != 0, p); else dp[x][y][isOK][isQ] += (i == y) * bin[x] + DP(x - 1, y, true, true, p); &#125; else &#123; if (!isQ &amp;&amp; y == 0 &amp;&amp; i == 0)dp[x][y][isOK][isQ] += DP(x - 1, y, false, false, p); else dp[x][y][isOK][isQ] += (i == y) * (p % bin[x] + 1) + DP(x - 1, y, false, true, p); &#125; &#125; return dp[x][y][isOK][isQ];&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(dp, -1, sizeof(dp)), bin[0] = 1; for (int i = 1; i &lt;= 15; i++)bin[i] = bin[i - 1] * 10ll; for (int i = 0; i &lt; 10; i++)ans[i] += DP(14, i, false, false, m); memset(dp, -1, sizeof(dp)); for (int i = 0; i &lt; 10; i++)ans[i] -= DP(14, i, false, false, n - 1); for (int i = 0; i &lt; 10; i++)cout &lt;&lt; ans[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2664]树上游戏]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%B4%9B%E8%B0%B7P2664-%E6%A0%91%E4%B8%8A%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：NOI/NOI+/CTSC 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lrb有一棵树，树的每个节点有个颜色。给一个长度为n的颜色序列，定义$s(i,j)$ 为i 到j 的颜色数量。以及 sum_i=\sum_{j=1}^is(i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在他想让你求出所有的sum[i]。 输入输出格式输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为一个整数n，表示树节点的数量，$n,c[i]\leq 10^5$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行为n个整数，分别表示n个节点的颜色$c[1],c[2]……c[n]$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n-1行，每行为两个整数x,y，表示$x$和$y$之间有一条边 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出n行，第i行为sum[i] 输入输出样例Sample input 51 2 3 2 31 22 32 41 5 Sample output 10911912 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有难度的点分治，强烈推荐一做。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先保证复杂度。对于每一次分治，我们必须在$O(n)$复杂度下完成处理。假设现在分治到以rt为根的子树，下面需要在$O(n)$复杂度下求所有经过rt点的路径对答案的贡献。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点分治的实质是将所有路径划分为两类：一类经过根结点，一类不经过，然后用分治的方法统计两类路径对答案的贡献（还记得吗？）。那么如何统计答案？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识一个事实：如果某一个点是其到根结点（不含根结点）的路径上第一次出现某种点权值的点，那么这个点将对其它点贡献答案size，这里的size是其子树上的点的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用一遍DFS统计每一种权值的对应贡献，这个贡献用一个数组存起来（设为color，color[x]表示权值x对应的答案贡献）。然后求它们的和，记为sum。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面遍历每一个子树。对于某一棵子树，对其进行DFS，删掉这个树上所有点对上面求出的数组以及sum的贡献。经过这一步操作得到的贡献数组以及sum就不再包含这个子树了。做这一步的目的是，使两个点对不出现在同一棵子树（同一棵子树上的点对路径不经过根，不需要统计）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这一棵子树，再进行一步遍历，记录所经过点到根（不含根）的所有点权种类，然后我们可以这样统计答案： ans_x+=sum-\sum_icolor[i]+p(n-size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里求和所用的$i$是出现在路径上的权值，$p$代表出现在路径上的权值种类数，$n$是整棵树（正在处理的树）的总点数，$size$是当前子树的点数。这个公式是易于理解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要注意的是，为了方便起见，在整个过程中，我们都不统计根结点权值对答案的贡献，因此当遍历到某一个权值与根相同的点时，认为它无点权，不计入贡献，也不统计种类数量。对于所有经过根的路径，根结点点权必然会计入答案，这样的话，我们只需要在答案贡献时统一加上一就好了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后需要单独统计根结点的答案。这个实现起来很简单，其贡献的答案就是$sum+size$。理解：其它权值的贡献加上自己本身权值种类的贡献。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分治过程中需要不断清数组，为了保证复杂度，不要用memset清空，这是40分与100分AC的差别。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct Edge &#123; int next, to;&#125; edge[N &lt;&lt; 1];int head[N], n, c[N], cnt = 1, vis[N], rt, minn, root_size[N], np, hs[N], numOfColor, objColor, size[N];int tempRoot;typedef long long ll;ll ans[N], color[N], sum, now;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS_root(int x, int fa) &#123; root_size[x] = 1; int ff = 0; for (int i = head[x]; i; i = edge[i].next) &#123; if (!vis[edge[i].to] &amp;&amp; edge[i].to != fa) &#123; DFS_root(edge[i].to, x), root_size[x] += root_size[edge[i].to]; ff = max(ff, root_size[edge[i].to]); &#125; &#125; ff = max(ff, np - root_size[x]); if (ff &lt; minn)minn = ff, rt = x;&#125;inline void findRoot(int x, int num) &#123; np = num, minn = 0x7fffffff, DFS_root(x, 0);&#125;void DFS(int x, int fa, int type) &#123; size[x] = 1; if (c[x] != objColor)++hs[c[x]]; for (int i = head[x]; i; i = edge[i].next) &#123; if (!vis[edge[i].to] &amp;&amp; edge[i].to != fa)DFS(edge[i].to, x, type), size[x] += size[edge[i].to]; &#125; if (c[x] != objColor &amp;&amp; hs[c[x]] == 1)color[c[x]] += type * size[x], sum += type * size[x]; if (c[x] != objColor)--hs[c[x]];&#125;void DFS_findAns(int x, int fa) &#123; if (c[x] != objColor)++hs[c[x]]; if (c[x] != objColor &amp;&amp; hs[c[x]] == 1)++numOfColor, now += color[c[x]]; ans[x] += sum - now + (numOfColor + 1) * (size[rt] - size[tempRoot]);//手动加一，计入根结点贡献 for (int i = head[x]; i; i = edge[i].next)if (!vis[edge[i].to] &amp;&amp; edge[i].to != fa)DFS_findAns(edge[i].to, x); if (c[x] != objColor &amp;&amp; hs[c[x]] == 1)--numOfColor, now -= color[c[x]]; if (c[x] != objColor)--hs[c[x]];&#125;void DFS_clear(int x, int fa) &#123; if (c[x] != objColor)color[c[x]] = 0; for (int i = head[x]; i; i = edge[i].next) &#123; if (edge[i].to != fa &amp;&amp; !vis[edge[i].to])DFS_clear(edge[i].to, x); &#125;&#125;void divide(int x) &#123;//点分治主函数 objColor = c[x], vis[x] = 1, sum = 0, DFS(x, 0, 1);//objColor是根的权值，不计入答案。第一遍DFS求sum和color数组 for (int i = head[x]; i; i = edge[i].next) &#123; if (!vis[edge[i].to]) &#123;//记录临时根（就是子树的根），一遍DFS清除子树贡献 tempRoot = edge[i].to, DFS(edge[i].to, x, -1), numOfColor = 0, now = 0; DFS_findAns(edge[i].to, x), DFS(edge[i].to, x, 1);//另一遍DFS找答案，最后一遍DFS恢复数据（再加回来） &#125; &#125; ans[x] += sum + size[x], DFS_clear(x, 0);//统计根结点答案，用DFS清空数组 for (int i = head[x]; i; i = edge[i].next)if (!vis[edge[i].to])findRoot(edge[i].to, size[edge[i].to]), divide(rt);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)scanf("%d", c + i); for (int i = 1, x, y; i &lt; n; i++) scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x); findRoot(1, n), divide(rt); for (int i = 1; i &lt;= n; i++)printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6602]Longest Subarray]]></title>
    <url>%2F2019%2F07%2F24%2FSubarray%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线段树神题。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You are given two integers $C,K$ and an array of $N$ integers $a_1,a_2,…,a_N$. It is guaranteed that the value of $a_i$ is between 1 to $C$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We define that a continuous subsequence $a_l,a_{l+1},…,a_r(l≤r)$ of array a is a good subarray if and only if the following condition is met: ∀x\in [1,C],\sum_{i=l}^r[a_i=x]=0or\sum_{i=l}^r[a_i=x]≥K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It implies that if a number appears in the subarray, it will appear no less than $K$ times.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You should find the longest good subarray and output its length. Or you should print 0 if you cannot find any. 输入输出格式输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There are multiple test cases.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each case starts with a line containing three positive integers $N,C,K(N,C,K≤10^5)$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second line contains $N$ integer $a_1,a_2,…,a_N(1≤a_i≤C)$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We guarantee that the sum of $N$s, the sum of $C$s and the sum of $K$s in all test cases are all no larger than $5×10^5$. 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For each test case, output one line containing an integer denoting the length of the longest good subarray. 输入输出样例Sample input 7 4 22 1 4 1 4 3 2 Sample output 4 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很巧妙的线段树题目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定右端点，考虑每一种数能够确定的左端点范围。很明显，每一种数的左端点都有两个连续的区间（不选的情况以及选了k个或更多的情况），我们给这些区间加上1。这样只需要找到第一个值为$C$（表示所有种类的数均满足）的下标就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找第一个值为$C$的数显然不能暴力，这样复杂度还是$O(n^2)$。这里注意到$C$一定是其中的最大值，于是用线段树维护区间最值，根据区间最值二分出第一个为$C$（就是最大值）的点。这里利用$C$是最大值的性质将找点操作优化到$O(logn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于其它右端点，将右端点顺次右移，途中维护线段树即可。总时间复杂度$O(nlogn)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;int n, c, k, tree[100005 &lt;&lt; 2], la[100005 &lt;&lt; 2];void build(int l = 1, int r = n, int k = 1) &#123; la[k] = tree[k] = 0; if (l == r)la[k] = tree[k] = 0; else build(l, (l + r) &gt;&gt; 1, k &lt;&lt; 1), build(((l + r) &gt;&gt; 1) + 1, r, k &lt;&lt; 1 | 1);&#125;inline void down(int x) &#123; tree[x &lt;&lt; 1] += la[x], tree[x &lt;&lt; 1 | 1] += la[x]; la[x &lt;&lt; 1] += la[x], la[x &lt;&lt; 1 | 1] += la[x], la[x] = 0;&#125;void update(int l, int r, int ss, int L = 1, int R = n, int k = 1) &#123; if (L &gt;= l &amp;&amp; R &lt;= r) &#123; la[k] += ss, tree[k] += ss; return; &#125; if (la[k])down(k); int mid = (L + R) &gt;&gt; 1; if (l &gt; mid)update(l, r, ss, mid + 1, R, k &lt;&lt; 1 | 1); else if (r &lt;= mid)update(l, r, ss, L, mid, k &lt;&lt; 1); else update(l, mid, ss, L, mid, k &lt;&lt; 1), update(mid + 1, r, ss, mid + 1, R, k &lt;&lt; 1 | 1); tree[k] = max(tree[k &lt;&lt; 1], tree[k &lt;&lt; 1 | 1]);&#125;int qu(int l, int r, int L = 1, int R = n, int k = 1) &#123; if (tree[k] != c)return -1; if (L == R)return L; if (la[k])down(k); int mid = (L + R) &gt;&gt; 1, ss; if (l &gt; mid)return qu(l, r, mid + 1, R, k &lt;&lt; 1 | 1); else if (r &lt;= mid)return qu(l, r, L, mid, k &lt;&lt; 1); return ((ss = qu(l, mid, L, mid, k &lt;&lt; 1)) == -1) ? qu(mid + 1, r, mid + 1, R, k &lt;&lt; 1 | 1) : ss;&#125;vector&lt;int&gt; vvp[100005];int l[100005];int main() &#123; while (scanf("%d%d%d", &amp;n, &amp;c, &amp;k) == 3) &#123; build(); int ans = 0, tmp, x; for (int i = 1; i &lt;= c; i++)vvp[i].clear(); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x), vvp[x].push_back(i); update(i, i, c);//这一格都可以不选 update(vvp[x].size() &gt; 1 ? vvp[x][vvp[x].size() - 2] + 1 : 1, i, -1); //但是，它自己必须得选上 if (vvp[x].size() == k)l[x] = 0, update(1, vvp[x][0], 1);//已经到k个，更新区间 else if (vvp[x].size() &gt; k)++l[x], update(vvp[x][l[x] - 1] + 1, vvp[x][l[x]], 1);//多于k个，右移区间 tmp = qu(1, i); if (tmp != -1)ans = max(ans, i - tmp + 1); &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应辛普森法]]></title>
    <url>%2F2019%2F07%2F23%2F%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个数学算法，用于求积分。 积分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然都学过高数，就不多说了这里需要先了解定积分，形如下面的形式： \int_a^b f(x)dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求解积分是一个十分具有实际意义的操作，辛普森积分法就是一种重要的求解方法。 辛普森法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辛普森法的思想是用二次函数来拟合原函数。现在我们用这样一个函数来拟合： g(x)=Ax^2+Bx+C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么就是求： \int_a^bAx^2+Bx+Cdx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面求这个积分就好了： \frac {Ab^3} {3} +\frac {Bb^2} {2} +Cb-\frac {Aa^3} {3} -\frac {Ba^2} {2} -Ca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就化这个式子，并注意到$f(x)$近似就是$g(x)$，最后可以化成这个样： \frac {b-a} {6} (f(a)+f(b)+4f(\frac {a+b} {2}))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子称为辛普森积分公式，它给出了求一个函数积分的估计值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区间很大时，这种计算的误差相当大，当区间不断细分时它的准确率就会不断上升。现在需要将区间细分，以达到提高精度的效果。但是区间不宜过多，这样时间消耗太大，又不宜过少，这样就不能满足精度。对于一个给定的精度，如果程序能够动态调整其划分区间的策略，那么就可以同时满足效率和精度的要求了，这就是自适应辛普森法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应辛普森法的代码十分短小精悍：1234567891011inline double simpson(double l, double r) &#123;//辛普森公式，f就是积分函数，需要自己定义 double mid = (l + r) / 2; return (f(l) + f(r) + 4.0 * f(mid)) * (r - l) / 6.0;&#125;double asr(double l, double r, double ans, double eps) &#123;//eps是精度，可取1e-6，ans是估计答案 double mid = (l + r) / 2; double ll = simpson(l, mid), rr = simpson(mid, r);//左右半区间分治 if (fabs(ll + rr - ans) &lt;= 15 * eps)return ll + rr + (ll + rr - ans) / 15.0;//满足精度需求，直接返回 return asr(l, mid, ll, eps / 2.0) + asr(mid, r, rr, eps / 2.0);//不满足继续分治&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的写法是一种通用写法，其中为什么需要乘上15，我也不知道（逃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应辛普森法其实是一个很板子的代码，基本也不需要多少复杂的变化，当成一个知识点了解一下吧。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6333]Harvest of Apples]]></title>
    <url>%2F2019%2F07%2F21%2FApples%2F</url>
    <content type="text"><![CDATA[题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There are $n$ apples on a tree, numbered from $1$ to $n$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Count the number of ways to pick at most $m$ apples. 输入输出格式输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first line of the input contains an integer $T (1≤T≤10^5)$ denoting the number of test cases.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each test case consists of one line with two integers $n,m (1≤m≤n≤10^5)$. 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For each test case, print an integer representing the number of ways modulo $10^9+7$. 输入输出样例Sample input 25 21000 500 Sample ouput 16924129523 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫队算法神题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是求： \sum_{i=0}^mC_n^i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂度$O(Tn)$，会T，考虑将要求的数写成$S(n,m)$的形式： S(n,m)=\sum_{i=0}^mC_n^i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立即可以推知： S(n,m)=S(n,m-1)+C_n^m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外注意到： C_n^m=C_{n-1}^{m-1}+C_{n-1}^m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可得： S(n,m)=2S(n-1,m)-C_{n-1}^m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将区间$[0,10^5]$分块处理，$n$看成区间左端点，$m$看成区间右端点，根据上面的递推式进行更新，跑一遍莫队算法即可，复杂度在$O(T\sqrt n)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意移动指针时可能出现$m&gt;n$的情况，这样的时候组合数直接就是0。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int fac[100005], inv[100005], t, l, r, now, belong[100005];const int MOD = static_cast&lt;const int&gt;(1e9 + 7);struct Node &#123; int n, m; int ans, rk; bool operator&lt;(Node s) &#123; if (belong[n] == belong[s.n])return belong[m] &lt; belong[s.m]; return belong[n] &lt; belong[s.n]; &#125;&#125; node[100005];inline int C(int n, int m) &#123; if (n &lt; 0 || m &lt; 0)return 0;//注意这里的判断 if (m &gt; n)return 0; return 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD;&#125;int qPow(int x, int y) &#123; int ans = 1, sta = x; while (y) &#123; if (y &amp; 1)ans = 1ll * ans * sta % MOD; sta = 1ll * sta * sta % MOD, y &gt;&gt;= 1; &#125; return ans;&#125;bool cmp(Node a, Node b) &#123; return a.rk &lt; b.rk;&#125;int main() &#123; ios::sync_with_stdio(false); fac[0] = 1, inv[0] = 1; for (int i = 1; i &lt;= 100000; i++)fac[i] = 1ll * fac[i - 1] * i % MOD;//预处理阶乘以及逆元 for (int i = 1; i &lt;= 100000; i++)inv[i] = qPow(fac[i], MOD - 2); cin &gt;&gt; t; for (int i = 1; i &lt;= t; i++)cin &gt;&gt; node[i].n &gt;&gt; node[i].m, node[i].rk = i; int base = static_cast&lt;int&gt;(sqrt(100000)); for (int i = 0; i &lt;= 100000; i++)belong[i] = i / base + 1;//分块 sort(node + 1, node + t + 1); l = 1, r = 0, now = 1;//C(1,0)=1 for (int i = 1; i &lt;= t; i++) &#123; while (l &gt; node[i].n)now = 1ll * (1ll * now + C(l - 1, r)) % MOD * inv[2] % MOD, --l;//移动指针的过程 while (l &lt; node[i].n)now = 1ll * (2ll * now - C(l, r)) % MOD, ++l; while (r &gt; node[i].m)now = (now - C(l, r)) % MOD, --r; while (r &lt; node[i].m)now = (now + C(l, r + 1)) % MOD, ++r; node[i].ans = now; &#125; sort(node + 1, node + t + 1, cmp); for (int i = 1; i &lt;= t; i++)cout &lt;&lt; (node[i].ans + MOD) % MOD &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1096G]Lucky Tickets]]></title>
    <url>%2F2019%2F07%2F20%2FTickets%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个比赛原题？ 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All bus tickets in Berland have their numbers. A number consists of $n$ digits ($n$ is even). Only k decimal digits $d_1,d_2,…,d_k$ can be used to form ticket numbers. If 0 is among these digits, then numbers may have leading zeroes. For example, if $n=4$ and only digits 0 and 4 can be used, then 0000, 4004, 4440 are valid ticket numbers, and 0002, 00, 44443 are not.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A ticket is lucky if the sum of first $\frac {n} {2}$ digits is equal to the sum of remaining $\frac {n} {2}$ digits.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate the number of different lucky tickets in Berland. Since the answer may be big, print it modulo 998244353. 输入输出格式输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first line contains two integers $n$ and$k$ $(2≤n≤2⋅10^5,1≤k≤10)$ — the number of digits in each ticket number, and the number of different decimal digits that may be used. $n$ is even.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second line contains a sequence of pairwise distinct integers $d_1,d_2,…,d_k (0≤d_i≤9)$ — the digits that may be used in ticket numbers. The digits are given in arbitrary order. 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print the number of lucky ticket numbers, taken modulo 998244353. 输入输出样例Sample input1 4 21 8 Sample output1 6 Sample input2 20 16 Sample output2 1 Sample input3 10 56 1 4 0 3 Sample output3 569725 Sample input4 1000 75 4 0 1 8 3 2 Sample output4 460571165 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成函数。构造一个多项式如下： A(x)=\sum_{i=0}^9a_ix^i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$a_i$在$i$被选入时为1，否则为0。对这个多项式求$\frac {n} {2}$次幂，每一项的系数就是它的方案数，答案就是这些系数的平方和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常数可能过大，导致$exp$与$ln$的快速幂T了，换倍增快速幂就能AC。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)#define MOD 998244353#define G 3#define N 1000005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol, tmp, ans;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;void NTT(int l, int *c, int type) &#123; for (register int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (register int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; register int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (register int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; register int w = 1; for (register int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; register int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (register int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); if (i &gt; a-&gt;l)a-&gt;op[i] = 0; if (i &gt; b-&gt;l)b-&gt;op[i] = 0; &#125; NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (register int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (register int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;vector&lt;int&gt; vvp;int main() &#123; int n = read() &gt;&gt; 1, k = read(); pol.l = 9, ans.op[0] = 1, ans.l = 0; for (register int i = 1; i &lt;= k; i++)vvp.push_back(read()); for (register int i = 0; i &lt; vvp.size(); i++)pol.op[vvp[i]] = 1; while (n) &#123;//倍增快速幂 if (n &amp; 1) &#123; tmp.l = pol.l; for (int i = 0; i &lt;= pol.l; i++)tmp.op[i] = pol.op[i]; multiple(&amp;ans, &amp;tmp, &amp;ans); &#125; for (int i = 0; i &lt;= pol.l; i++)tmp.op[i] = pol.op[i]; tmp.l = pol.l, multiple(&amp;pol, &amp;tmp, &amp;pol); n &gt;&gt;= 1; &#125; long long sans = 0; for (register int i = 0; i &lt;= ans.l; i++)sans = (sans + 1ll * ans.op[i] * ans.op[i] % MOD) % MOD; cout &lt;&lt; sans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式专题]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文整理OI相关的多项式有关算法，长期更新。注意，这里的模块顺序虽然保证了前置知识在前的原则，但是它们不一定有必然的逻辑关系。 多项式乘法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多项式乘法运算可以说是多项式中的基本功。朴素的多项式乘法时间复杂度$O(n^2)$，通常可以使用FFT以及NTT来将时间复杂度降至$O(nlogn)$，关于这两个算法前面的文章有所介绍，见FFT以及NTT。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使问题更简便，这里封装一下NTT的代码。首先定义多项式类：123struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l为最高项指数，N是最高项次数，通常取一个更大一点的值&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;封装NTT以及多项式乘法：12345678910111213141516171819202122232425262728293031323334353637#define MOD 998244353//NTT模数#define G 3 //原根int tr[N &lt;&lt; 2];int qPow(int a, int b) &#123;//快速幂 int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;void NTT(int l, int *c, int type) &#123;//NTT模板 for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD; c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++)tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更安全地进行乘法，最好使用下面的形式：12345678910111213inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); if (i &gt; a-&gt;l)a-&gt;op[i] = 0;//高次项系数清零 if (i &gt; b-&gt;l)b-&gt;op[i] = 0; &#125; NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的板子直接拿来用就可以了。这里需要注意一个问题：multiple函数会修改a与b的值，如果不希望修改需要事先备份。其次，这里的多项式乘数a与b不能相同。此处的板子可以直接切掉多项式乘法模板题（见FFT）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以从更高的层次去理解多项式乘法。注意到对于两个多项式$A(x)$，$B(x)$，它们的乘积$C(x)=A(x)B(x)$的系数满足： C[x]=\sum_{i=0}^xA[i]B[x-i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是卷积，也写成如下形式： C[x]=\sum_{a+b=x}A[a]B[b]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡是形如这样的求和式都可以用FFT/NTT优化。 多项式求逆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多项式求逆是多项式专题中的重要问题，多项式的逆定义如下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于最高次项次数为n-1的多项式$A(x)$，若存在$B(x)$使得： A(x)B(x)\equiv 1\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则称$B(x)$为$A(x)$在模$x^n$下的逆多项式。比如$A(x)=1+x$与$B(x)=1-x$就在模$x^2$下互为逆多项式，这是因为： A(x)B(x)=(1+x)(1-x)=1-x^2\equiv 1 \pmod {x^2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若$B(x)$为$A(x)$的逆多项式，也记$A^{-1}(x)=B(x)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知如果$A(x)$与$B(x)$在模$x^n$下互逆，则$A(x)B(x)$的所有次数为$1$到$n-1$的项系数都为0而常数项为1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨逆多项式的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在要求$A(x)$在模$x^n$下的逆多项式。如果$A(x)$最高次项次数为0，那么其逆多项式就是常数项的逆元。假设在$x^{\lceil \frac {n} {2}\rceil}$下的逆多项式已经求出，为$B’(x)$，即有： A(x)B'(x)\equiv 1\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设需要求的逆多项式为$B(x)$，那么有： A(x)B(x)\equiv 1\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也满足： A(x)B(x)\equiv 1\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是有： A(x)(B(x)-B'(x))\equiv 0\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两边同时去乘$B’(x)$，得到： B(x)-B'(x)\equiv 0\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两边平方： (B(x)-B'(x))^2\equiv B^2(x)+{B'}^2(x)-2B(x)B'(x)\equiv 0\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时乘上$A(x)$，得到： B(x)+A(x){B'}^2(x)-2B'(x)\equiv 0\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立即得到： B(x)\equiv 2B'(x)-A(x){B'}^2(x)\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面公式给出了$B(x)$与$B’(x)$的递推关系，这使得我们可以在$O(lognM)$复杂度下递推出逆多项式，$M$是多项式乘法的复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要求系数在模空间下给出，并且模数恰好是NTT模数，那么我们可以用NTT来使乘法复杂度达到$O(nlogn)$，总复杂度大约就是$O(nlog^2n)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到在相乘时，$A(x)$中次数不小于n的项是无用的，它们不会影响答案，因此可以在相乘时滤掉这些项，达到每一次相乘时最高次项次数不断下降的效果，最终复杂度就是$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;核心代码如下：12345678910111213141516171819void inv(Pol *ans, const Pol *x, int rk) &#123;//求x的逆，在x^rk意义下，存入ans，x不会被修改 if (rk == 1) &#123;//递推边界 ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;附模板题代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol1, pol2, tmp;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;void inv(Pol *ans, const Pol *x, int rk) &#123; if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; pol1.l = n - 1; for (int i = 0; i &lt;= pol1.l; i++)cin &gt;&gt; pol1.op[i]; inv(&amp;pol2, &amp;pol1, n); for (int i = 0; i &lt;= pol2.l; i++)cout &lt;&lt; (pol2.op[i] + MOD) % MOD &lt;&lt; " "; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和乘法逆元类似，多项式逆元有着它的应用，其中一个重要应用就是求$\displaystyle\frac {B(x)} {A(x)}$在$x^n$模意义下的多项式，答案就是$B(x)A^{-1}(x)$。 多项式对数函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个n-1次多项式$A(x)$，求在模$x^n$意义下的$B(x)$满足： B(x)\equiv ln(A(x))\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种问题可以用求导的方式解决，首先求个导： B'(x)\equiv \frac {A'(x)} {A(x)} \pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是： B'(x)\equiv A'(x)A^{-1}(x)\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后对$B’(x)$积分就可以了。这里定义一下求导和积分函数：123456789inline void diff(Pol *s) &#123; for (int i = 0; i &lt; s-&gt;l; i++)s-&gt;op[i] = 1ll * s-&gt;op[i + 1] * (i + 1) % MOD; s-&gt;op[s-&gt;l] = 0, --s-&gt;l;&#125;inline void integral(Pol *s) &#123; for (int i = s-&gt;l + 1; i &gt;= 1; i--)s-&gt;op[i] = 1ll * s-&gt;op[i - 1] * qPow(i, MOD - 2) % MOD; ++s-&gt;l, s-&gt;op[0] = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后用上面的模板代码去求逆以及乘积即可，复杂度$O(nlogn)$，模板题全代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol1, pol2, tmp;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;inline void diff(Pol *s) &#123;//求导 for (int i = 0; i &lt; s-&gt;l; i++)s-&gt;op[i] = 1ll * s-&gt;op[i + 1] * (i + 1) % MOD; s-&gt;op[s-&gt;l] = 0, --s-&gt;l;&#125;inline void integral(Pol *s) &#123;//积分 for (int i = s-&gt;l + 1; i &gt;= 1; i--)s-&gt;op[i] = 1ll * s-&gt;op[i - 1] * qPow(i, MOD - 2) % MOD; ++s-&gt;l, s-&gt;op[0] = 0;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;void inv(Pol *ans, const Pol *x, int rk) &#123;//求逆 if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); if (i &gt; a-&gt;l)a-&gt;op[i] = 0; if (i &gt; b-&gt;l)b-&gt;op[i] = 0; &#125; NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; pol1.l = n - 1; for (int i = 0; i &lt;= pol1.l; i++)cin &gt;&gt; pol1.op[i]; inv(&amp;pol2, &amp;pol1, n), diff(&amp;pol1), multiple(&amp;pol1, &amp;pol1, &amp;pol2), integral(&amp;pol1); for (int i = 0; i &lt;= n - 1; i++)cout &lt;&lt; pol1.op[i] &lt;&lt; " "; return 0;&#125; 多项式指数函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以认为是对数函数的逆运算。为了让问题更简便，封装一下求ln的函数：12345inline void getLn(Pol *ans, const Pol *x, int rk) &#123;//求x的ln，在x^rk意义下，存入ans，x不会被改变 inv(ans, x, rk); for (int i = 0; i &lt; rk; i++)tmp.op[i] = i &lt;= x-&gt;l ? x-&gt;op[i] : 0, tmp.l = rk - 1; diff(&amp;tmp), multiple(ans, &amp;tmp, ans), integral(ans), ans-&gt;l = rk - 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定n-1次多项式$A(x)$，求模$x^n$意义下的$B(x)$满足： B(x)\equiv e^{A(x)}\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先两边取个$ln$，然后移项： ln(B(x))-A(x)\equiv 0\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左侧式中，$A(x)$是给定的，可以认为是常量，而$B(x)$是变量，那么可以将左侧看成关于$B(x)$的函数$G(B(x))$，令其对$B(x)$求导可得： G'(B(x))=B^{-1}(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑其它问题。既然将$B(x)$看成是$G$的自变量，那么现在要做的实质上就是求$G$的零点，但这个函数的零点显然不是那么容易求： G(B(x))\equiv 0\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑迭代。假设现在已经求出$F(x)$满足： G(F(x))\equiv 0\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将$G(X)$在这一点做幂级数展开： G(X)=\sum_{i=0}^\infty \frac {G^{(i)}(F(x))} {i!}(X-F(x))^i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$X$表示一个多项式。现在要求满足$G(X)\equiv 0\pmod {x^n}$的$X$，$X$当然也满足$G(X)\equiv 0\pmod {x^{\lceil \frac {n} {2}\rceil}}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据$G(X)$的形式，当然可以推出： X-F(x)\equiv 0 \pmod{x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是： (X-F(x))^2\equiv 0\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样只需要拿出幂级数展开的前两项就可以了，因为后面的全是0： G(X)\equiv G(F(x))+G'(F(x))(X-F(x))\equiv 0\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样$X$就求出来了，这里的$X$就是$B(x)$： X\equiv F(x)-\frac {G(F(x))} {G'(F(x))}\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是牛顿迭代公式，代入上面求出的导数： X\equiv F(x)-F(x)(ln(F(x))-A(x))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终： B(x)=x\equiv F(x)(1-ln(F(x))+A(x))\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;边界条件为$n=1$时，$B(x)=1$。这样就可以写出核心迭代函数，和inv很像：12345678910111213141516171819void getExp(Pol *ans, const Pol *x, int rk) &#123; if (rk == 1) &#123;//迭代边界 ans-&gt;l = 0, ans-&gt;op[0] = 1; return; &#125; getExp(ans, x, (rk + 1) &gt;&gt; 1), getLn(&amp;tmp2, ans, rk);//用一个临时变量存ln int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt; rk ? x-&gt;op[i] : 0; ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; tmp2.op[i] = i &lt;= tmp2.l ? tmp2.op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1), NTT(l, tmp2.op, 1); for (int i = 0; i &lt; l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * (1ll - tmp2.op[i] + tmp.op[i]) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂度$O(nlogn)$(?)，附模板题全代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol1, pol2, tmp, tmp2;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;inline void diff(Pol *s) &#123; for (int i = 0; i &lt; s-&gt;l; i++)s-&gt;op[i] = 1ll * s-&gt;op[i + 1] * (i + 1) % MOD; s-&gt;op[s-&gt;l] = 0, --s-&gt;l;&#125;inline void integral(Pol *s) &#123; for (int i = s-&gt;l + 1; i &gt;= 1; i--)s-&gt;op[i] = 1ll * s-&gt;op[i - 1] * qPow(i, MOD - 2) % MOD; ++s-&gt;l, s-&gt;op[0] = 0;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;void inv(Pol *ans, const Pol *x, int rk) &#123;//求逆 if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); if (i &gt; a-&gt;l)a-&gt;op[i] = 0; if (i &gt; b-&gt;l)b-&gt;op[i] = 0; &#125; NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125;inline void getLn(Pol *ans, const Pol *x, int rk) &#123;//求x的ln inv(ans, x, rk); for (int i = 0; i &lt; rk; i++)tmp.op[i] = i &lt;= x-&gt;l ? x-&gt;op[i] : 0, tmp.l = rk - 1; diff(&amp;tmp), multiple(ans, &amp;tmp, ans), integral(ans), ans-&gt;l = rk - 1;&#125;void getExp(Pol *ans, const Pol *x, int rk) &#123; if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = 1; return; &#125; getExp(ans, x, (rk + 1) &gt;&gt; 1), getLn(&amp;tmp2, ans, rk); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt; rk ? x-&gt;op[i] : 0; ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; tmp2.op[i] = i &lt;= tmp2.l ? tmp2.op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1), NTT(l, tmp2.op, 1); for (int i = 0; i &lt; l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * (1ll - tmp2.op[i] + tmp.op[i]) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; pol1.l = n - 1; for (int i = 0; i &lt;= pol1.l; i++)cin &gt;&gt; pol1.op[i]; getExp(&amp;pol2, &amp;pol1, n); for (int i = 0; i &lt;= pol2.l; i++)cout &lt;&lt; pol2.op[i] &lt;&lt; " "; return 0;&#125; 多项式快速幂&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面求对数以及求指数的基础上我们可以很方便地求多项式快速幂。它适用于$A(x)$常数项为1的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在要求一个$B(x)$满足： B(x)\equiv A^k(x)\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两边取对数： ln(B(x))\equiv kln(A(x))\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再取指数： B(x)\equiv e^{kln(A(x))}\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就转化为求指数和求对数的问题了，复杂度$O(nlogn)$。这个算法支持k非常大的情况，因为k无论多大最终都会取模。模板题全代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol1, pol2, tmp, tmp2;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;inline void diff(Pol *s) &#123; for (int i = 0; i &lt; s-&gt;l; i++)s-&gt;op[i] = 1ll * s-&gt;op[i + 1] * (i + 1) % MOD; s-&gt;op[s-&gt;l] = 0, --s-&gt;l;&#125;inline void integral(Pol *s) &#123; for (int i = s-&gt;l + 1; i &gt;= 1; i--)s-&gt;op[i] = 1ll * s-&gt;op[i - 1] * qPow(i, MOD - 2) % MOD; ++s-&gt;l, s-&gt;op[0] = 0;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;void inv(Pol *ans, const Pol *x, int rk) &#123;//求逆 if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); if (i &gt; a-&gt;l)a-&gt;op[i] = 0; if (i &gt; b-&gt;l)b-&gt;op[i] = 0; &#125; NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125;inline void getLn(Pol *ans, const Pol *x, int rk) &#123;//求x的ln inv(ans, x, rk); for (int i = 0; i &lt; rk; i++)tmp.op[i] = i &lt;= x-&gt;l ? x-&gt;op[i] : 0, tmp.l = rk - 1; diff(&amp;tmp), multiple(ans, &amp;tmp, ans), integral(ans), ans-&gt;l = rk - 1;&#125;void getExp(Pol *ans, const Pol *x, int rk) &#123; if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = 1; return; &#125; getExp(ans, x, (rk + 1) &gt;&gt; 1), getLn(&amp;tmp2, ans, rk); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt; rk ? x-&gt;op[i] : 0; ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; tmp2.op[i] = i &lt;= tmp2.l ? tmp2.op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1), NTT(l, tmp2.op, 1); for (int i = 0; i &lt; l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * (1ll - tmp2.op[i] + tmp.op[i]) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;inline int read() &#123; char e = getchar(); long long s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(), s %= MOD; return s;&#125;int main() &#123; int n = read(), k = read(); pol1.l = n - 1; for (int i = 0; i &lt;= pol1.l; i++)pol1.op[i] = read(); getLn(&amp;pol2, &amp;pol1, n); for (int i = 0; i &lt;= pol2.l; i++)pol2.op[i] = 1ll * pol2.op[i] * k % MOD; getExp(&amp;pol1, &amp;pol2, n); for (int i = 0; i &lt;= pol1.l; i++)cout &lt;&lt; pol1.op[i] &lt;&lt; " "; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面基于$ln$和$exp$的快速幂常数很大，在某些情况下会T，所以这里也补充一下倍增快速幂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路很简单，就是按照普通快速幂的思路，只不过将数乘改成多项式乘法。复杂度$O(nlog^2n)$。我们可以用下面的样式去写倍增多项式快速幂。12345678910while (n) &#123; if (n &amp; 1) &#123; tmp.l = pol.l;//复制一份 for (int i = 0; i &lt;= pol.l; i++)tmp.op[i] = pol.op[i]; multiple(&amp;ans, &amp;tmp, &amp;ans); &#125; for (int i = 0; i &lt;= pol.l; i++)tmp.op[i] = pol.op[i];//继续复制 tmp.l = pol.l, multiple(&amp;pol, &amp;tmp, &amp;pol); n &gt;&gt;= 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里主要注意一下复制的问题，其余就没有什么了。这种方法在某些情况下比上面的快速幂更优。 多项式开根&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多项式开根其实就是平方的逆运算（废话），是要求一个多项式$B(x)$满足： B^2(x)\equiv A(x)\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这里两边取个$ln$就能转化为$ln$和$exp$问题了，但是这样做常数巨大，不是很好的做法。这里的解法是迭代+求逆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据之前迭代的思路，我们先假定求出了一个$F(x)$满足： F^2(x)\equiv A(x)\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$B(x)$当然也满足： B^2(x)\equiv A(x)\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么： B^2(x)-F^2(x)\equiv 0\pmod {x^{\lceil \frac {n} {2}\rceil}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两边平方并拆项： B^4(x)+2B^2(x)F^2(x)+F^4(x)\equiv 4B^2(x)F^2(x)\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两边开根： B^2(x)+F^2(x)\equiv A(x)+F^2(x)\equiv 2B(x)F(x)\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以： B(x)\equiv \frac {F^2(x)+A(x)} {2F(x)}\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迭代进行这个过程就可以完成开根运算。边界条件为$n=1$时，$B(x)=1$（因为题目保证$A(x)$常数项为1）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol1, pol2, tmp, tmp2;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;void inv(Pol *ans, const Pol *x, int rk) &#123;//求逆 if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;void polSqrt(Pol *ans, const Pol *x, int rk) &#123;//开根函数 if (rk == 1) &#123;//边界条件 ans-&gt;l = 0, ans-&gt;op[0] = 1; return; &#125; polSqrt(ans, x, (rk + 1) &gt;&gt; 1), inv(&amp;tmp2, ans, rk); int l = 1, le = 0, inv2 = qPow(2, MOD - 2); while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0; ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; tmp2.op[i] = i &lt;= tmp2.l ? tmp2.op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1), NTT(l, tmp2.op, 1); for (int i = 0; i &lt; l; i++) &#123; ans-&gt;op[i] = 1ll * (tmp.op[i] + 1ll * ans-&gt;op[i] * ans-&gt;op[i]) % MOD * inv2 % MOD * tmp2.op[i] % MOD; &#125; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; pol1.l = n - 1; for (int i = 0; i &lt;= pol1.l; i++)cin &gt;&gt; pol1.op[i]; polSqrt(&amp;pol2, &amp;pol1, n); for (int i = 0; i &lt;= pol2.l; i++)cout &lt;&lt; pol2.op[i] &lt;&lt; " "; return 0;&#125; 拉格朗日插值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个部分和上面没有多大关系，但是这是一个重要方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知$n+1$个点可以确定一个最高$n$次多项式，求这个多项式的一个方法是列方程然后高斯消元，时间复杂度$O(n^3)$，拉格朗日插值法可以很好地解决这个问题，将时间复杂度降至$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉格朗日插值法构造多项式其实就像一个结论，根据这$n$个点构造多项式如下： F(x)=\sum_{i=1}^ny_i\frac {\prod_{j\not =i}(x-x_j)} {\prod_{j\not =i}(x_i-x_j)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将这$n$个点代入上面的多项式，都可以得到相应的值，可知这个多项式是正确的，而构造这个多项式的时间复杂度显然是$O(n^2)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题示例代码：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define MOD 998244353using namespace std;int qPow(int x, int y) &#123; int ans = 1, sta = x; while (y) &#123; if (y &amp; 1)ans = 1ll * ans * sta % MOD; sta = 1ll * sta * sta % MOD, y &gt;&gt;= 1; &#125; return ans;&#125;int n, k, x[2500], y[2500], ans;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; x[i] &gt;&gt; y[i]; for (int i = 1; i &lt;= n; i++) &#123; int tmp = y[i]; for (int j = 1; j &lt;= n; j++) &#123; if (i != j)tmp = 1ll * tmp * (k - x[j]) % MOD * qPow(x[i] - x[j], MOD - 2) % MOD; &#125; ans = (ans + tmp) % MOD; &#125; cout &lt;&lt; (ans + MOD) % MOD; return 0;&#125; 多项式除法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个$n$次多项式$A(x)$和一个$m$次多项式$G(x)$，求$n-m$次多项式$Q(x)$以及次数小于$m$的多项式$R(x)$满足： A(x)=B(x)G(x)+R(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里可以把$Q(x)$看成商，$R(x)$看成余数（模）。下面考虑如何求$Q(x)$以及$R(x)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提出$A(x)$中的$x^n$，并定义这种操作为$R$。那么有： A_R(x)=x^nA(\frac {1} {n})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知$A_R(x)$与$A(x)$的系数满足如下关系： A_R(x)[i]=A(x)[n-i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实就是将系数反置，这个操作可以$O(n)$完成。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一开始的式子： A(x)=B(x)Q(x)+R(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可得： A(\frac {1} {n})=B(\frac {1} {n})Q(\frac {1} {n})+R(\frac {1} {n})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一步步往下推： x^nA(\frac {1} {n})=x^{n-m}B(\frac {1} {n})x^mQ(\frac {1} {n})+x^{n-m+1}x^{m-1}R(\frac {1} {n})\\ A_R(x)=B_R(x)Q_R(x)+x^{n-m+1}R_R(x)\\ A_R(x)\equiv B_R(x)Q_R(x)\pmod {x^{n-m+1}}\\ Q_R(x)\equiv A_R(x)B_R^{-1}(x)\pmod{x^{n-m+1}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后求个逆求个乘法就求出了$Q_R(x)$，经系数反置后得到$Q(x)$。之后： R(x)=A(x)-B(x)Q(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求出$R(x)$即可。复杂度$O(nlogn)$。模板题代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G0 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; F, G, pol3, tmp, tmp2;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G0, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;void inv(Pol *ans, const Pol *x, int rk) &#123; if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;inline void toR(Pol *a, const Pol *b) &#123;//R操作 for (int i = 0; i &lt;= b-&gt;l; i++)a-&gt;op[i] = b-&gt;op[b-&gt;l - i]; a-&gt;l = b-&gt;l;&#125;inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); if (i &gt; a-&gt;l)a-&gt;op[i] = 0;//高次项系数清零 if (i &gt; b-&gt;l)b-&gt;op[i] = 0; &#125; NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; F.l &gt;&gt; G.l; for (int i = 0; i &lt;= F.l; i++)cin &gt;&gt; F.op[i]; for (int i = 0; i &lt;= G.l; i++)cin &gt;&gt; G.op[i]; toR(&amp;pol3, &amp;G), inv(&amp;tmp2, &amp;pol3, F.l - G.l + 1), toR(&amp;tmp, &amp;F); multiple(&amp;tmp2, &amp;tmp, &amp;tmp2), tmp2.l = F.l - G.l, toR(&amp;tmp, &amp;tmp2); for (int i = 0; i &lt;= tmp.l; i++)cout &lt;&lt; tmp.op[i] &lt;&lt; " "; cout &lt;&lt; endl; multiple(&amp;tmp, &amp;tmp, &amp;G); for (int i = 0; i &lt; G.l; i++)cout &lt;&lt; (F.op[i] - tmp.op[i] + MOD) % MOD &lt;&lt; " "; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了方便后面的操作，封装一步求模的过程：123456789inline void mod(Pol *ans, const Pol *a, const Pol *b) &#123;//a除以b得到余数ans toR(&amp;tmp3, b), inv(&amp;tmp2, &amp;tmp3, a-&gt;l - b-&gt;l + 1), toR(ans, a); multiple(&amp;tmp2, ans, &amp;tmp2), tmp2.l = a-&gt;l - b-&gt;l, toR(ans, &amp;tmp2); //到这一步ans就是商 for (int i = 0; i &lt;= b-&gt;l; i++)tmp.op[i] = b-&gt;op[i];//复制一份b tmp.l = b-&gt;l, multiple(ans, ans, &amp;tmp); for (int i = 0; i &lt; b-&gt;l; i++)ans-&gt;op[i] = (a-&gt;op[i] - ans-&gt;op[i] + MOD) % MOD; ans-&gt;l = b-&gt;l - 1;&#125; 分治 FFT/NTT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于大多数卷积问题，我们卷一下就好了。但对于某些问题，计算后半段需要前半段的结果，这样似乎只能递推去求，导致复杂度退化。其实，对于这样的问题有一种很好的方法去解决，这就是分治思想。分治FFT/NTT就是这样一种思想的体现，它在很多地方都有应用，其中也蕴含了CDQ分治（以后文章探讨）的理念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来看这样一个问题：分治FFT模板。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，后面的$f_i$需要前面的$f_i$，这样就不能直接卷积，考虑分治。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分治FFT/NTT的思想是将问题规模一分为二，考虑前半个问题对后半个问题的影响，然后再解决后半个问题。这里的重点在于分治时两个子问题会有单方面的影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将区间$[0,n-1]$一分为二，分别求解其中的$f_i$。显然，后半区间的值对前半区间没有任何影响，但是没有前半区间的值，无法求后半区间。于是我们先递归地求前半区间的$f_i$值。当区间左右端点相同时直接结束递归，注意当$l=r=0$时赋值$f_0=1$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里提一下为什么$l=r$时直接结束递归。当我们在一个区间$[l,r]$上计算时，只考虑当前这个区间对答案的影响，这是一个重要思想。当$l=r$相同时，$f_i$对自己的贡献是多少？根据题目中的式子可知它没有任何贡献，于是直接结束递归。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在递归求右半边区间之前，先考虑左半区间对右半区间的影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，对于右半区间的某一个点$x,x\in [mid+1,r]$，左半区间对其系数的贡献为： \sum_{i=l}^{mid}f_ig_{x-i}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个卷积，拿NTT去求，可将时间复杂度降到$O(nlogn)$，求完后将答案加到数组中就好了，之后再递归地求右半区间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分治的时间复杂度为$O(logn)$，每一次还需要$O(nlogn)$的NTT，总时间复杂度为$O(nlog^2n)$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol1, tmp1, tmp2, ans;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;inline void multiple(Pol *ans, Pol *a, Pol *b) &#123;//将a与b相乘并计入ans int l = 1, le = 0; while (l &lt;= a-&gt;l + b-&gt;l)l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); if (i &gt; a-&gt;l)a-&gt;op[i] = 0;//高次项系数清零 if (i &gt; b-&gt;l)b-&gt;op[i] = 0; &#125; NTT(l, a-&gt;op, 1), NTT(l, b-&gt;op, 1); for (int i = 0; i &lt; l; i++)a-&gt;op[i] = 1ll * a-&gt;op[i] * b-&gt;op[i] % MOD; NTT(l, a-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = a-&gt;l + b-&gt;l; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * a-&gt;op[i] * l % MOD;&#125;void merge_NTT(int l, int r) &#123;//分治NTT if (l == r) &#123; if (l == 0)ans.op[0] = 1;//递归结束边界条件 return; &#125; int mid = (l + r) &gt;&gt; 1; merge_NTT(l, mid);//递归左半区间 for (int i = l, j = 0; i &lt;= mid; i++, j++)tmp1.op[j] = ans.op[i];//复制一遍数组 for (int i = 0; i &lt;= r - l; i++)tmp2.op[i] = pol1.op[i]; tmp1.l = mid - l, tmp2.l = r - l, multiple(&amp;tmp1, &amp;tmp1, &amp;tmp2);//求卷积 for (int i = mid + 1, j = mid - l + 1; i &lt;= r; i++, j++)ans.op[i] = (ans.op[i] + tmp1.op[j]) % MOD;//答案加上去 merge_NTT(mid + 1, r);//递归求右半区间&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; pol1.l = n - 1; for (int i = 1; i &lt;= n - 1; i++)cin &gt;&gt; pol1.op[i]; merge_NTT(0, n - 1); for (int i = 0; i &lt;= n - 1; i++)cout &lt;&lt; ans.op[i] &lt;&lt; " "; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个题比较有趣的地方是它可以用多项式求逆直接切掉，复杂度更低（$O(nlogn)$）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了方便，不妨令$g_0=0$，这样就有： f_x=\sum_{i=0}^xf_ig_{x-i}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上式适用于$x&gt;0$的情况，对于$x=0$时，$f_0=1$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后构造$n-1$次多项式$F(x)$以及$G(x)$： F(x)=\sum_{i=0}^{n-1}f_ix^i\\ G(x)=\sum_{i=0}^{n-1}g_ix^i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么： F(x)G(x)=\sum_{i=0}^{2n-2}\sum_{j=0}^if_jg_{i-j}x^i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实就是： F(x)G(x)=\sum_{i=0}^{2n-2}f_ix^i=F(x)-f_0x^0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很快就能得到： F(x)\equiv(1-G(x))^{-1}\pmod {x^n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求个逆就可以了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define G 3#define N 100005using namespace std;int tr[N &lt;&lt; 2];struct Pol &#123;//多项式类 int l, op[N &lt;&lt; 2] = &#123;0&#125;;//l最高项指数&#125; pol1, pol2, tmp;int n;int qPow(int a, int b) &#123; int ans = 1, x = a; while (b) &#123; if (b &amp; 1)ans = 1ll * ans * x % MOD; x = 1ll * x * x % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;void NTT(int l, int *c, int type) &#123; for (int i = 0; i &lt; l; i++)if (i &lt; tr[i])swap(c[i], c[tr[i]]); for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1) &#123; int wn = qPow(G, (MOD - 1) / (mid &lt;&lt; 1)); if (type == -1)wn = qPow(wn, MOD - 2); for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len) &#123; int w = 1; for (int k = 0; k &lt; mid; k++, w = 1ll * w * wn % MOD) &#123; int x = c[j + k], y = 1ll * w * c[j + mid + k] % MOD; c[j + k] = ((x + y) % MOD + MOD) % MOD, c[j + mid + k] = ((x - y) % MOD + MOD) % MOD; &#125; &#125; &#125;&#125;void inv(Pol *ans, const Pol *x, int rk) &#123; if (rk == 1) &#123; ans-&gt;l = 0, ans-&gt;op[0] = qPow(x-&gt;op[0], MOD - 2); return; &#125; inv(ans, x, (rk + 1) &gt;&gt; 1); int l = 1, le = 0; while (l &lt;= (rk &lt;&lt; 1))l &lt;&lt;= 1, ++le; for (int i = 0; i &lt; l; i++) &#123; tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); tmp.op[i] = i &lt;= min(x-&gt;l, rk - 1) ? x-&gt;op[i] : 0;//高次项滤掉，零项补零 ans-&gt;op[i] = i &lt;= ans-&gt;l ? ans-&gt;op[i] : 0; &#125; NTT(l, tmp.op, 1), NTT(l, ans-&gt;op, 1); for (int i = 0; i &lt; l; i++) ans-&gt;op[i] = (2ll * ans-&gt;op[i] % MOD - (1ll * tmp.op[i] * ans-&gt;op[i] % MOD) * 1ll * ans-&gt;op[i] % MOD) % MOD; NTT(l, ans-&gt;op, -1), l = qPow(l, MOD - 2), ans-&gt;l = rk - 1; for (int i = 0; i &lt;= ans-&gt;l; i++)ans-&gt;op[i] = 1ll * ans-&gt;op[i] * l % MOD;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; pol1.l = n - 1, pol1.op[0] = 1; for (int i = 1; i &lt;= pol1.l; i++)cin &gt;&gt; pol1.op[i]; for (int i = 1; i &lt;= pol1.l; i++)pol1.op[i] = -pol1.op[i]; inv(&amp;pol2, &amp;pol1, n); for (int i = 0; i &lt;= pol2.l; i++)cout &lt;&lt; (pol2.op[i] + MOD) % MOD &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF498C]Array and Operations]]></title>
    <url>%2F2019%2F07%2F18%2FOperations%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比赛原题第二弹，网络流+数论。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You have written on a piece of paper an array of n positive integers $a[1], a[2], …, a[n]$ and $m$ good pairs of integers $(i_1, j_1), (i_2, j_2), …, (i_m, j_m)$. Each good pair $(i_k, j_k)$ meets the following conditions: $i_k + j_k$ is an odd number and $1 ≤ i_k &lt; j_k ≤ n$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In one operation you can perform a sequence of actions: take one of the good pairs $(i_k, j_k)$ and some integer $v (v &gt; 1)$, which divides both numbers $a[i_k]$ and $a[j_k]$; divide both numbers by $v$, i. e. perform the assignments: $\frac {a_{ik}} {v}$ and$\frac {a_{jk}} {v}$ .Determine the maximum number of operations you can sequentially perform on the given array. Note that one pair may be used several times in the described operations. 输入输出格式输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first line contains two space-separated integers $n, m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100)$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second line contains n space-separated integers $a[1], a[2], …, a[n] (1 ≤ a[i] ≤ 10^9)$ — the description of the array.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The following $m$ lines contain the description of good pairs. The k-th line contains two space-separated integers $i_k, j_k$ ($1 ≤ i_k &lt; j_k ≤ n$, $i_k + j_k$ is an odd number).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It is guaranteed that all the good pairs are distinct. 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output the answer for the problem. 输入输出样例Sample intput1 3 28 3 81 22 3 Sample output2 0 Sample input2 3 28 12 81 22 3 Sample output2 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$i_k+j_k$为奇数，这说明每一对数只能一个来自奇数位，一个来自偶数位，这样将奇偶数位分开，在上面连线，可以得到一个二分图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每一个数作质因数分解，最多可以拆出10个互异的质因子。于是将每一个数都拆成10个点，每一个点代表这个数的某一个质因子。之后就可以用网络流解决了。建图如下： $S-&gt;V(x,y)$，$x$为奇数。这里$V(x,y)$是第$x$个数的第$y$个质因子对应的点编号，其容量限制设置为第$x$个数含有这个质因子的数目。 $V(x,y)-&gt;T$，$x$为偶数，理解同上。 对于一对数$(i_k,j_k)$，我们从奇数位出发向偶数位连边。如果两个数$a_{ik}$与$a_{jk}$存在相同的质因子，那么连接这两个点，容量限制为无穷大。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这个图的理解：源点与汇点限制质因子数目，中间的边代表转移，每有一个流流过便代表一次合法的操作。最后在这个图上跑一遍最大流即可，答案就是最大流量。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define JS(x) ((x)%2?(x)/2+1:(x)/2)#define ID(x, y) ((x)%2==0?(JS(n)*10+((x)/2-1)*10+y):(((x)/2)*10+y))#define inf (1&lt;&lt;28)#define S 0#define T (n%2?ID(n-1,10)+1:ID(n,10)+1)using namespace std;struct Edge &#123; int next, to, v;&#125; edge[500000];int head[1500], n, m, op[150], dep[1500];vector&lt;int&gt; vvp[150], num[150];queue&lt;int&gt; que;inline void add(int x, int y, int v) &#123;// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; v &lt;&lt; endl; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;inline int BFS() &#123; for (int i = S; i &lt;= T; i++)dep[i] = inf; while (!que.empty())que.pop(); dep[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(); if (f == T)return 1; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dep[edge[i].to] == inf)dep[edge[i].to] = dep[f] + 1, que.push(edge[i].to); &#125; &#125; return 0;&#125;int DFS(int x, int limit) &#123; if (x == T || limit == 0)return limit; int p, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (dep[edge[i].to] == dep[x] + 1 &amp;&amp; (p = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= p, edge[i ^ 1].v += p, limit -= p, flow += p; if (limit == 0)break; &#125; &#125; return flow;&#125;int main() &#123; memset(head, -1, sizeof(head)), cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 2; j * j &lt;= op[i]; j++) &#123; if (op[i] % j == 0) &#123; vvp[i].push_back(j), num[i].push_back(0); while (op[i] % j == 0)num[i][num[i].size() - 1]++, op[i] /= j; &#125; &#125; if (op[i] != 1) vvp[i].push_back(op[i]), num[i].push_back(1); for (int j = 0; j &lt; vvp[i].size(); j++) &#123; if (i % 2)add(S, ID(i, j + 1), num[i][j]); else add(ID(i, j + 1), T, num[i][j]); &#125; &#125; for (int i = 1, x, y; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; y; if (x % 2 == 0)swap(x, y); for (int j = 0; j &lt; vvp[x].size(); j++) &#123; for (int z = 0; z &lt; vvp[y].size(); z++)if (vvp[x][j] == vvp[y][z])add(ID(x, j + 1), ID(y, z + 1), inf); &#125; &#125; int ans = 0; while (BFS())ans += DFS(S, inf); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hihocoder1063]Travel on a Tree]]></title>
    <url>%2F2019%2F07%2F17%2FTree%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两天打比赛打的贼烂，我还是菜啊。这里记一个比赛原题，一个树型DP。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You have been given a weighted tree which has n nodes. Each node has a value vi and each edge has a length wi. You start at node 1, and can move a distance of d at most. How many values you can gather at most? For each node you can pick the value once no matter how many times you pass it. 输入输出格式输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first line of the input contains one integer $n (1 ≤ n ≤ 100)$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second line contains n numbers, each of them denotes the value of one node: $v_i (0 ≤ v_i ≤ 2）$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For the next n-1 lines, each line contains 3 numbers $(ai, bi, wi)$, representing an edge between ai and bi of length $w_i (1 ≤ a_i, b_i ≤ n, 1 ≤ w_i ≤ 10^4)$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The next line has a number q, representing the total number of queries$ (0 ≤ q ≤ 100000)$. The next $q$ lines, each line contains a number $d$ representing the distance you can move at most. 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For each query output the maximum values you can gather in one line. 输入输出样例Sample input 30 1 11 2 51 3 3331011 Sample output 112 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到点权是0~2，并且没有给$d$的范围，那么我们可以从点权上入手，考虑树型DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令$DP(x,y,z)$表示在以$x$为根的树上，获得至少$y$的点权，并且在$z$状态下（$z$只能取0或1，$z=0$时表示不用返回根，否则需要返回根）时至少要移动的距离。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使问题更简便，我仍然使用那个粗鄙的方法：多叉树转二叉树。引入一些新的点，使原树转化为二叉树，新加入的边边权为0，新加入的点点权也为0，容易知道两棵树是等价的。转化为二叉树可以使状态转移方程更容易列出，时间复杂度没变（只是常数大了），这就是我们转换的目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何时候如果根结点的点权$v_x \geq y$，则$DP(x,y,0/1)=0$，这是很好理解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若根结点只有一个儿子，则有： DP(x,y,0)=DP(ch[0],y-v_x,0)+w_0\\ DP(x,y,1)=DP(ch[0],y-v_x,1)+2w_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里$ch[0]$是$x$的儿子，$w_0$则是边权。这个方程也是很好理解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个儿子的时候就不是那么容易转移，考虑对两个儿子结点进行点权分配。首先全部分配给左儿子，在$z$取值的两种情况下有以下的转移： z=0:DP(ch[0],y-v_x,0)+w_0\\ z=1:DP(ch[1],y-v_x,1)+2w_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只给另一个儿子分配类比即可。如果两个儿子都分配，且给第一个儿子$i$的权值，那么在$z=0$时转移为： \min\{DP(ch[0],i,0)+DP(ch[1],y-v_x-i,1)+w_1,DP(ch[0],i,1)+DP(ch[1],y-v_x-i,0)+w_0\}+w_1+w_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$z=1$时就是： DP(ch[0],i,1)+DP(ch[1],y-v_x-i,1)+2(w_0+w_1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取上面的最小值转移到相应的$DP$值，不成立时取无穷大。对于询问直接二分找答案就可以了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;27)using namespace std;struct Edge &#123; int next, to, v;&#125; edge[500], edge2[50000];int head[500], cnt = 1, n, q, op[50000], dp[50000][250][2], now, head2[50000], cnt2 = 1, ss;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;inline void add2(int x, int y, int z) &#123; edge2[cnt2].to = y, edge2[cnt2].next = head2[x], edge2[cnt2].v = z, head2[x] = cnt2++;&#125;int DP(int rt, int dd, int isOK) &#123; if (dp[rt][dd][isOK] != -1)return dp[rt][dd][isOK]; int ch[2], now = 0, v[2]; for (int i = head2[rt]; i; i = edge2[i].next)ch[now] = edge2[i].to, v[now++] = edge2[i].v; if (now == 0)return dp[rt][dd][isOK] = (dd &lt;= op[rt] ? 0 : inf); if (now == 1)return dp[rt][dd][isOK] = (dd &lt;= op[rt] ? 0 : DP(ch[0], dd - op[rt], isOK) + v[0] * (isOK + 1)); dp[rt][dd][isOK] = inf; if (op[rt] &gt;= dd)return dp[rt][dd][isOK] = 0; for (int i = 0; i &lt;= dd - op[rt]; i++) &#123; if (i == 0)dp[rt][dd][isOK] = min(dp[rt][dd][isOK], DP(ch[1], dd - op[rt], isOK) + v[1] * (isOK + 1)); else if (i == dd - op[rt]) dp[rt][dd][isOK] = min(dp[rt][dd][isOK], DP(ch[0], dd - op[rt], isOK) + v[0] * (isOK + 1)); else if (!isOK) dp[rt][dd][isOK] = min(min(DP(ch[0], i, true) + DP(ch[1], dd - op[rt] - i, false) + 2 * v[0] + v[1], DP(ch[0], i, false) + DP(ch[1], dd - op[rt] - i, true) + v[0] + 2 * v[1]), dp[rt][dd][isOK]); else dp[rt][dd][isOK] = min(DP(ch[0], i, true) + DP(ch[1], dd - op[rt] - i, true) + 2 * v[0] + 2 * v[1], dp[rt][dd][isOK]); &#125; return dp[rt][dd][isOK];&#125;void DFS(int x, int pre) &#123; int pp = 0, ss = x; for (int i = head[x]; i; i = edge[i].next) &#123; if (edge[i].to == pre)continue; if (pp == 0)add2(ss, edge[i].to, edge[i].v), ++pp; else if (edge[i].next == 0)add2(ss, edge[i].to, edge[i].v); else add2(ss, now, 0), add2(now, edge[i].to, edge[i].v), ss = now++; &#125; for (int i = head[x]; i; i = edge[i].next)if (edge[i].to != pre)DFS(edge[i].to, x);&#125;int main() &#123; cin &gt;&gt; n, memset(dp, -1, sizeof(dp)); now = n + 1; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; ss += op[i]; &#125; for (int i = 1, x, y, z; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z), add(y, x, z); &#125; DFS(1, 0), cin &gt;&gt; q; while (q--) &#123; int x; cin &gt;&gt; x; int l = 0, r = ss + 1;//[,) while (l &lt; r) &#123; if (r == l + 1) &#123; cout &lt;&lt; l &lt;&lt; endl; break; &#125; int mid = (l + r) &gt;&gt; 1; if (DP(1, mid, 0) &lt;= x)l = mid; else r = mid; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3953]逛公园]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%B4%9B%E8%B0%B7P3953-%E9%80%9B%E5%85%AC%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策策同学特别喜欢逛公园。公园可以看成一张$N$个点$M$条边构成的有向图，且没有自环和重边。其中1号点是公园的入口，$N$号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策策每天都会去逛公园，他总是从1号点进去，从$N$号点出来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果1号点到$N$号点的最短路长为$d$，那么策策只会喜欢长度不超过$d + K$的路线。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为避免输出过大，答案对$P$取模。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有无穷多条合法的路线，请输出-1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$100\%$的数据, $1 \le P \le 10^9,1 \le a_i,b_i \le N ,0 \le c_i \le 1000,k\leq 50$。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数$T$, 代表数据组数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来$T$组数据，对于每组数据：第一行包含四个整数$N,M,K,P$每两个整数之间用一个空格隔开。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来MM行，每行三个整数$a_i,b_i,c_i$，代表编号为$a_i,b_i$的点之间有一条权值为$c_i$的有向边，每两个整数之间用一个空格隔开。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件包含$T$行，每行一个整数代表答案。 输入输出样例Sample input 25 7 2 101 2 12 4 04 5 22 3 23 4 13 5 21 5 32 2 0 101 2 02 1 0 Sample output 3-1 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最短路计数类题目，还算比较常规。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先一遍Dijkstra算法求最短路。这里如果要求最短路的走法个数可以规定$dp(i)$为从$i$开始的最短路数目，然后向出点转移即可。但是由于$k$的存在，需要给$dp$加一维成为$dp(i,j)$，表示从$i$开始走，并且最大允许多走$j$个单位的路径可以得到的方案数，这个方法可行主要是利用了$k$较小的特点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这可以认为是DP类的题目，但是与DP问题稍有不同，严格来说应该叫记忆化搜索。当求$dp(i,j)$时，会递归地去求很多相关的$dp$数据，如果此时又回到$dp(i,j)$，说明存在0环，方案数就是无穷大。在这个问题的处理中，我们需要用搜索式的方法来确定$dp(i,j)$的最终值，因此与常规的DP不同，称为记忆化搜索更为贴切。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;30)using namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;struct Edge &#123; int next, v, to;&#125; edge[200005], edge2[200005];int n, m, k, p, cnt, head[100005], dis[100005], dp[100005][55], cnt2, head2[100005], na[100005];int heap[100005], ID[100005], size;bool vis[100005][55], lk;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++; edge2[cnt2].to = x, edge2[cnt2].next = head2[y], edge2[cnt2].v = z, head2[y] = cnt2++;&#125;int DP(int x, int y) &#123;//DP过程 if (lk)return 0; if (vis[x][y]) &#123; vis[x][y] = false, lk = true; return 0; &#125; if (dp[x][y] != -1)return dp[x][y]; vis[x][y] = true, dp[x][y] = x == n; for (int i = head[x]; i; i = edge[i].next) &#123; if (dis[x] + edge[i].v - dis[edge[i].to] &lt;= y &amp;&amp; na[edge[i].to]) &#123; dp[x][y] += DP(edge[i].to, y - (dis[x] + edge[i].v - dis[edge[i].to])), dp[x][y] %= p; &#125; &#125; vis[x][y] = false; return dp[x][y];&#125;void DFS(int x) &#123; na[x] = 1; for (int i = head2[x]; i; i = edge2[i].next)if (!na[edge2[i].to])DFS(edge2[i].to);&#125;inline void solve(int x) &#123; int x1 = x &lt;&lt; 1, x2 = x &lt;&lt; 1 | 1, minn = x; if (x1 &lt;= size &amp;&amp; dis[heap[x1]] &lt; dis[heap[minn]])minn = x1; if (x2 &lt;= size &amp;&amp; dis[heap[x2]] &lt; dis[heap[minn]])minn = x2; if (minn != x)swap(ID[heap[minn]], ID[heap[x]]), swap(heap[minn], heap[x]), solve(minn);&#125;inline int top() &#123; int r = heap[1]; heap[1] = heap[size--], ID[heap[1]] = 1, solve(1); return r;&#125;inline void up(int x) &#123; if (x == 1)return; if (dis[heap[x &gt;&gt; 1]] &gt; dis[heap[x]]) ID[heap[x &gt;&gt; 1]] = x, ID[heap[x]] = x &gt;&gt; 1, swap(heap[x &gt;&gt; 1], heap[x]), up(x &gt;&gt; 1);&#125;inline void add(int x) &#123; heap[++size] = x, ID[x] = size, up(size);&#125;int main() &#123;// freopen("text.in", "r", stdin); int t = read(), ans = 0; while (t--) &#123; n = read(), m = read(), k = read(), p = read(), lk = false, cnt = 1, cnt2 = 1; for (register int i = 1; i &lt;= n; i++) &#123; dis[i] = inf, head2[i] = head[i] = 0, na[i] = 0, ID[i] = 0; for (register int j = 0; j &lt;= k; j++)dp[i][j] = -1; &#125; for (int i = 1, x, y, z; i &lt;= m; i++)x = read(), y = read(), z = read(), add(x, y, z); dis[1] = 0, add(1); while (size &gt; 0) &#123; int i1 = top(); for (register int i = head[i1]; i; i = edge[i].next) &#123; if (dis[i1] + edge[i].v &lt; dis[edge[i].to]) &#123; dis[edge[i].to] = dis[i1] + edge[i].v; if (ID[edge[i].to] != 0)up(ID[edge[i].to]); else add(edge[i].to); &#125; &#125; &#125; DFS(n), ans = DP(1, k); if (lk)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>图的最短路</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2569]股票交易]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%B4%9B%E8%B0%B7P2569-%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近lxhgww 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一段时间的观察，lxhgww 预测到了未来$T$天内某只股票的走势，第$i$天的股票买入价为每股$AP_i$，第$i$天的股票卖出价为每股$BP_i$（数据保证对于每个$i$，都有 $AP_i \geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第$i$天的一次买入至多只能购买$AS_i$股，一次卖出至多只能卖出$BS_i$股。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔$W$天，也就是说如果在第$i$天发生了交易，那么从第$i+1$天到第$i+W$天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过$MaxP$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第1天之前，lxhgww 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然$T$天以后，lxhgww 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据第一行包括3个整数，分别是 $T$，$MaxP$，$W$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来$T$行，第$i$行代表第$i-1$天的股票走势，每行4个整数，分别表示 $AP_i,BP_i,AS_i,BS_i$。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出数据为一行，包括1个数字，表示lxhgww 能赚到的最多的钱数。 输入输出样例Sample input 5 2 02 1 1 12 1 1 13 2 1 14 3 1 15 4 1 1 Sample output 3 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$30\%$的数据，$0\leq W&lt;T\leq 50,1\leq MaxP≤50$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$50\%$的数据，$0\leq W&lt;T\leq 2000,1\leq MaxP≤50$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$100\%$的数据，$0\leq W&lt;T\leq 2000,1\leq MaxP≤2000$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于所有的数据，$1\leq BP_i\leq AP_i\leq 1000,1\leq AS_i,BS_i\leq MaxP$ 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常规的动态规划题。定义$dp(i,j)$为当前拥有j股，在i~T天能够得到的最大收益，那么有状态转移方程：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第i天交易时： dp(i,j)=\max\{dp(i+W+1,j+k_1)-k_1AP_i,dp(i+W+1,j-k_2)+k_2BP_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不交易时： dp(i,j)=dp(i+1,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实就是枚举第i天可以买入或卖出的股票数目然后转移。参数需要满足以下制约条件： 1\leq k_1\leq \min(MaxP-j,AS_i),\ \ 1\leq k_2\leq \min(BS_i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同一天不可能同时买入和卖出（由于$AP_i \geq BP_i$的存在，一定不最优），故分别考虑即可。先来看第i天买入的情况。 dp(i,j)=\max\{dp(i+W+1,j+k_1)-k_1AP_i\},\ 1\leq k_1\leq \min(MaxP-j,AS_i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DP本身的复杂度为$O(TMaxP)$，转移复杂度为$O(MaxP)$，总复杂度$O(TMaxp^2)$，显然不可取，需要优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将DP方程改成下面的形式： dp(i,j)=\max\{dp(i+W+1,x)-xAP_i\}+jAP_i,\ j+1\leq x\leq \min(MaxP,AS_i+j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到x的区间左右端点都是单调不减的，且max中的取值与j没有关系，那么就可以使用单调队列优化，将总复杂度降到$O(TMaxP)$。同理，卖出也可以写成： dp(i,j)=\max\{dp(i+W+1,x)-xBP_i\}+jBP_i,\ \max(j-BS_i,0)\leq x\leq j-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加单调队列后，复杂度降维，本题就被切掉了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;deque&lt;int&gt; dq1, dq2;int T, MaxP, W, AP[2005], BP[2005], AS[2005], BS[2005], dp[2005][2005], now1, now2;inline void add1(int i, int j) &#123; while (!dq1.empty() &amp;&amp; -AP[i] * j + dp[i + W + 1][j] &gt; -AP[i] * dq1.back() + dp[i + W + 1][dq1.back()]) dq1.pop_back(); dq1.push_back(j);&#125;inline int f1(int j) &#123; while (dq1.front() &lt; j)dq1.pop_front(); return dq1.front();&#125;inline void add2(int i, int j) &#123; while (!dq2.empty() &amp;&amp; -BP[i] * j + dp[i + W + 1][j] &gt; -BP[i] * dq2.back() + dp[i + W + 1][dq2.back()]) dq2.pop_back(); dq2.push_back(j);&#125;inline int f2(int j) &#123; while (dq2.front() &lt; j)dq2.pop_front(); return dq2.front();&#125;int main() &#123; T = read(), MaxP = read(), W = read(); for (int i = 1; i &lt;= T; i++)AP[i] = read(), BP[i] = read(), AS[i] = read(), BS[i] = read(); for (int i = 0; i &lt;= MaxP; i++)dp[T][i] = min(i, BS[T]) * BP[T]; for (int i = T - 1; i &gt;= 1; i--) &#123; dq1.clear(), dq2.clear(), now1 = 0, now2 = max(1 - BS[i], 0) - 1; for (int j = 0; j &lt;= MaxP; j++) &#123; if (i + W &gt;= T)dp[i][j] = max(dp[i + 1][j], min(j, BS[i]) * BP[i]); else &#123; if (j != MaxP) &#123; for (int ss = now1 + 1; ss &lt;= min(MaxP, AS[i] + j); ss++)add1(i, ss), now1 = ss; dp[i][j] = max(dp[i][j], j * AP[i] - AP[i] * f1(j + 1) + dp[i + W + 1][f1(j + 1)]); &#125; if (j != 0) &#123; for (int ss = now2 + 1; ss &lt;= j - 1; ss++)add2(i, ss), now2 = ss; dp[i][j] = max(dp[i][j], j * BP[i] - BP[i] * f2(max(j - BS[i], 0)) + dp[i + W + 1][f2(max(j - BS[i], 0))]); &#125; dp[i][j] = max(dp[i][j], dp[i + 1][j]); &#125; &#125; &#125; cout &lt;&lt; max(0, dp[1][0]); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3317]重建]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%B4%9B%E8%B0%B7P3317-%E9%87%8D%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T国有N个城市，用若干双向道路连接。一对城市之间至多存在一条道路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，此前T国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有N-1条，且能联通所有城市的概率。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行包含整数N。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来N行，每行N个实数，第i+l行，列的数G[i][j]表示城市i与j之间仍有道路联通的概率。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入保证G[i][j]=G[j][i]，且G[i][i]=0；G[i][j]至多包含两位小数。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出一个任意位数的实数表示答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的答案与标准答案相对误差不超过$10^{-4}$即视为正确。 输入输出样例Sample input 30 0.5 0.50.5 0 0.50.5 0.5 0 Sample ouput 0.375 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1 &lt; N ≤50$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据保证答案非零时，答案不小于$10^{-4}$ 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本质上是求按照给定每条边出现的概率，求得到生成树的概率。本题需要矩阵树前缀知识。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在构造基比霍夫矩阵时，需要用到邻接矩阵，这里的邻接矩阵在有边时为1，否则为0，同时度数矩阵的对角线数值为相邻边的数目。如果将有边时的值改成权值，同时将度数矩阵的对角线数值改成相邻边的权值之和，再求N-1阶主子式绝对值会得到什么？这里求出的就是： \sum_{tree}\prod_{in\ tree} e(i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$e(i,j)$是边权值，这个结论称为变元矩阵树定理。在有重边的情况下，我们还可以将权值定义为重边数目，即在有重边的情况下变元矩阵树定理同样可以应用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到原问题，现在需要求： \sum_{tree}\prod_{in\ tree} P(i,j)\prod_{not\ in\ tree}(1-P(i,j))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是： \sum_{tree}\prod_{in\ tree} P(i,j)\frac {\prod (1-P(i,j))} {\prod_{in\ tree}(1-P(i,j))}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即： \prod (1-P(i,j))\sum_{tree}\frac {\prod_{in\ tree} P(i,j)}{\prod_{in\ tree}(1-P(i,j))}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是有： \prod (1-P(i,j))\sum_{tree}\prod_{in\ tree}\frac {P(i,j)}{(1-P(i,j))}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令权值为： e(i,j)=\frac {P(i,j)} {1-P(i,j)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以用矩阵树求了，但还需要注意一个问题：$P(i,j)$为1时分母为0，这时可以将所有值为1的概率减去EPS（通常为$10^{-5}$）再计算。至于行列式的计算可以用高斯消元法化为上三角行列式再处理，时间复杂度$O(n^3)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const double EPS = 1e-5;double p[55][55], K[55][55], op[55][55];int n;inline double guess() &#123; double ss = 1.0; for (int i = 1; i &lt;= n; i++) &#123; int maxn = i; for (int j = i + 1; j &lt;= n; j++)if (fabs(K[j][i]) &gt; fabs(K[maxn][i]))maxn = j; if (i != maxn)swap(K[i], K[maxn]), ss *= -1; if (fabs(K[maxn][i]) &lt; EPS)return 0; double div = K[i][i]; for (int j = i; j &lt;= n; j++)K[i][j] /= div; ss *= div; for (int j = i + 1; j &lt;= n; j++) &#123; div = K[j][i]; for (int z = 1; z &lt;= n; z++)K[j][z] -= K[i][z] * div; &#125; &#125; for (int i = 1; i &lt;= n; i++)ss *= K[i][i]; return ss;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; p[i][j]; op[i][j] = p[i][j]; if (fabs(op[i][j] - 1.00) &lt; EPS)op[i][j] = 1.00 - EPS; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; if (fabs(p[i][j] - 1.00) &lt; EPS)p[i][j] = 1.00 - EPS; p[i][j] = p[i][j] / (1 - p[i][j]); K[i][i] += p[i][j]; if (i != j)K[i][j] = -p[i][j]; &#125; --n; double ans = fabs(guess()); ++n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++)ans *= 1 - op[i][j]; &#125; printf("%.6f", ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3231]消毒]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%B4%9B%E8%B0%B7P3231-%E6%B6%88%E6%AF%92%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在生物实验室工作的小T遇到了大麻烦。由于实验室最近升级的缘故，他的分格实验皿是一个长方体,其尺寸为$abc$，$a、b、c$均为正整数。为了实验的方便，它被划分为$abc$个单位立方体区域，每个单位立方体尺寸为$1$。用$(i,j,k)$标识一个单位立方体，$1&lt;=i&lt;=a，1&lt;=j&lt;=b，1&lt;=k&lt;=c$。这个实验皿已经很久没有人用了，现在，小T被导师要求将其中一些单位立方体区域进行消毒操作（每个区域可以被重复消毒）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而由于严格的实验要求，他被要求使用一种特定的F试剂来进行消毒。 这种F试剂特别奇怪，每次对尺寸为$xyz$的长方体区域（它由$xyz$个单位立方体组 成）进行消毒时，只需要使用$min\{x,y,z\}$单位的F试剂。F试剂的价格不菲，这可难倒了小T。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在请你告诉他，最少要用多少单位的F试剂。(注：$min\{x,y,z\}$表示x、y、z中的最小者。) 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行是一个正整数D，表示数据组数。接下来是D组数据，每组数据开头是三个数$a,b,c$表示实验皿的尺寸。接下来会出现$a$个$b$行$c$列的用空格隔开的01矩阵，0表示对应的单位立方体不要求消毒，1表示对应的单位立方体需要消毒；例如，如果第1个01矩阵的第2行第3列为1，则表示单位立方体$(1,2,3)$需要被消毒。输入保证满足$abc&lt;=5000,T&lt;=3$。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅包含D行，每行一个整数，表示对应实验皿最少要用多少单位的F试剂。 输入输出样例Sample input 14 4 41 0 1 10 0 1 10 0 0 00 0 0 00 0 1 11 0 1 10 0 0 00 0 0 00 0 0 00 0 0 01 0 0 00 0 0 00 0 0 00 0 0 00 0 0 01 0 0 0 Sample output 3 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还算比较简单的二分图问题。首先将问题简化，看二维平面上的结论。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于二维平面上的点，将每一个值为1的点的横坐标值向纵坐标连一条边，可以得到一个二分图。注意到每选取一条边（对应一个点）就相当于选取了其所在的一行或者一列（因为F试剂的量只看最小的坐标值，故直接选一行或一列能尽可能利用其带来的价值）。由于需要覆盖所有的点，在二分图上就是覆盖所有的边，问题便转化为求二分图的最小点覆盖，直接套板子即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三维的情景较二维更麻烦。对于一个平面，如果我们仍利用二维平面上的结论，就会选取这个平面上的几个横向区域和纵向区域，它们消耗的试剂都是1，这样即使将这些区域向第三维上无限扩展，试剂量也不会增加。于是就有了一个思路：将三维的所有点全部压至一个平面上处理，转化为二维平面上的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做显然是不对的，比如当某个平面上全是点而其它平面上没有点时，选用第三维坐标去覆盖就会更优。于是另一个思路产生：暴力枚举哪些平面需要一次性处理（覆盖其所在的整个平面，消耗试剂量1），然后剩下的压扁成一个二维平面，之后求和，取最小值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$abc≤5000$，可知至少有一个坐标不超过17，那么枚举需要$2^{17}$次循环，每一次再进行一遍二分图匹配，在时间复杂度上说得过去。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define N 5001using namespace std;struct node &#123; int i, j, k;&#125; ele[N];struct Edge &#123; int to, next;&#125; edge[N];bool isOK[18], lk;int head[N], D, a, b, c, type, cnt = 1, ans, now, be[N], vis[N], pp;inline int read() &#123; int s = 0; char e = getchar(); while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;int f(int x) &#123; for (int i = head[x]; i; i = edge[i].next) &#123; if (vis[edge[i].to] == 0) &#123; vis[edge[i].to] = 1; if (!be[edge[i].to] || f(be[edge[i].to])) &#123; be[edge[i].to] = x; return 1; &#125; &#125; &#125; return 0;&#125;void add(int x, int y) &#123; edge[pp].to = y, edge[pp].next = head[x], head[x] = pp++;&#125;int main() &#123; D = read(); while (D--) &#123; a = read(), b = read(), c = read(); if (a &lt;= b &amp;&amp; a &lt;= c) type = 1; else if (b &lt;= a &amp;&amp; b &lt;= c) type = 2; else type = 3; memset(isOK, false, sizeof(isOK)), cnt = 1; for (int i = 1; i &lt;= a; ++i) for (int j = 1; j &lt;= b; ++j) for (int k = 1; k &lt;= c; ++k) &#123; if (!read()) continue; if (type == 1) ele[cnt].i = i, ele[cnt].j = j, ele[cnt].k = k; if (type == 2) ele[cnt].i = j, ele[cnt].j = i, ele[cnt].k = k; if (type == 3) ele[cnt].i = k, ele[cnt].j = i, ele[cnt].k = j; isOK[ele[cnt].i] = true, ++cnt; &#125; if (type == 2) swap(a, b); else if (type == 3) swap(b, c), swap(a, b); ans = a; for (int s = 0; s &lt; (1 &lt;&lt; a); ++s) &#123; lk = true, now = 0; for (int i = 1; i &lt;= a &amp;&amp; lk; ++i) if (((1 &lt;&lt; (i - 1)) &amp; s) &amp;&amp; !isOK[i]) &#123; lk = false; break; &#125; if (!lk) continue; for (int p = 0; p &lt; a; p++)if ((1 &lt;&lt; p) &amp; s)++now; memset(head, 0, sizeof(head)), memset(be, 0, sizeof(be)), pp = 1; for (int i = 1; i &lt; cnt; i++) if (!((1 &lt;&lt; (ele[i].i - 1)) &amp; s)) add(ele[i].j, ele[i].k); for (int i = 1; i &lt;= b; i++) &#123; memset(vis, 0, sizeof(vis)), now += f(i); if (now &gt;= ans) break; &#125; ans = min(ans, now); &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈FFT：wav音频解析]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%86%8D%E8%B0%88FFT%EF%BC%9Awav%E9%9F%B3%E9%A2%91%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文是快速傅里叶变换（FFT）的后续。这一篇文章和OI确实没有什么关系，它是对FFT在工程领域应用的一个介绍。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上一篇文章中，我们认识了FFT在OI中的一个应用：求卷积。但事实上，FFT在信号处理领域有着重要的应用，它在一些信号处理领域（比如音频解析）方面如何应用？与OI中FFT有哪些区别与联系？这是本文讨论的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，本文并不是在一个专业的角度去阐述，而是在一个尽可能通俗易懂的角度来探讨FFT。下面我们用一个实例：解析一段wav中声音的频率信息。 从声音说起&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，声音是由振动产生的，振动会产生波，波在介质中传播引起人耳鼓膜振动，于是人就有了听觉。由此可见，声音实质上就是波。这种波在某种意义上可以看成是一个关于时间的连续函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（上图来源：百度百科-声波）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，这种波中蕴含着大量的信息，计算机是不能处理这种几乎无穷多的信息的。也就是说，计算机只能处理和存储离散的数据，于是在储存声波时，需要对其进行采样。采样的频率称为采样率，它在数值上等于1s内对声波进行采样的次数。常用的采样率比如44100Hz，是指1s内对声波进行44100次采样，这样我们如果想存一段1s的声音，只需存下这44100个数据即可，这样计算机就可以存储和处理这些声波了。 时域与频域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些声波数据，它们是以时间为参照的，这种分析的方法称之为时域分析。仅用时域分析有什么不好呢？设想将两个不同频率的声音波形合在一起得到一个新的波形，现要求从这个新的波形中滤掉其中一个频率（这种操作称之为滤波），可以发现在时域领域，这是极难做到的，而傅里叶的工作很好地解决了这个问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1822年，傅里叶证明了下面的定理，称之为傅里叶定理： 【傅里叶定理】任何连续测量的时序或信号，都可以表示为不同频率的正弦波信号的无限叠加。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个定理揭示了一个信号可以分解成若干正弦波之和，它在信号处理领域有着极为重要的意义。它告诉我们所谓复杂的信号也只是很多正弦波的叠加，相对于处理复杂的信号，当然是处理正弦波更为容易一些。既然一个波可以分解成若干正弦波，这些正弦波肯定是有固定的频率的（当然，它还有其它重要的性质比如周期性，相位，振幅等等），将这些正弦波的频率放到横坐标上，将它们的振幅放到纵坐标上，可以得到一个图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（图片来源于网络，侵删）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是频域，它显示了在一个频率范围内每个给定频带内的信号量。在频域中进行滤波是十分容易的，从图上来看，我们只需抽掉一根竖线就可以完成这个操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文的主角：傅里叶变换，就是时域与频域相互转换的桥梁。 傅里叶变换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机中数据是离散的，需要使用离散傅里叶变换（DFT）来将时域转化为频域。DFT的作用是：对一段有限长的离散信号，找出它所含有的各个频率正弦波分量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于给定的N组数据$x(n)$，DFT可以表示为： X_k=\sum_{n=0}^{N-1}x(n)e^{-2\pi i\frac {kn} {N}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公式不好理解，下面简单解释一下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了找到给定的离散信号中是否含有某一个频率的正弦波，可以先生成N个该正弦波的对应值，然后计算两个离散值的相关程度。代数中判断两个离散值相关程度的方法就是将对应值相乘再相加。 \sum_{n=0}^{N-1}x(n)y(n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个值的大小反映了两者的相关程度，下面用c++写一段代码来看这个操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定函数$f(x)=cos(\frac {2\pi} {10} x)+cos(\frac {2\pi} {15} x)$，取样30个点：123const double PI = 3.1415926535;double ss[50];for (int i = 0; i &lt; 30; i++)ss[i] = cos(2 * PI * i / 10) + cos(2 * PI * i / 15); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定30个基函数去与之计算相关程度，它们为： f_k(x)=cos(\frac {2\pi kx} {30}),k=0,1,\cdots,2912345for (int i = 0; i &lt; 30; i++) &#123; double ans = 0; for (int j = 0; j &lt; 30; j++)ans += cos(2 * PI * i * j / 30) * ss[j]; cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果：1234567891011121314151617181920212223242526272829300 -1.67396e-091 -1.6675e-092 153 154 -1.56941e-095 -1.50941e-096 -1.43485e-097 -1.34496e-098 -1.23867e-099 -1.11475e-0910 -9.71563e-1011 -8.07107e-1012 -6.18845e-1013 -4.03583e-1014 -1.57221e-1015 1.25701e-1016 4.52261e-1017 8.32149e-1018 1.27892e-0919 1.81208e-0920 2.46101e-0921 3.27228e-0922 4.32537e-0923 5.76929e-0924 7.92693e-0925 1.16812e-0826 2.09319e-0827 1528 1529 -1.36485e-08 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序认为2、3、27、28这四个函数与原有离散数据有较大的相关性，其余基本没有相关性。其实第2个函数$cos(\frac {2\pi 2x} {30})$与第28个函数$cos(\frac {2\pi 28x} {30})$本质上是一个函数，这是因为： cos(\frac {2\pi 28x} {30})=cos(\frac {2\pi 28x} {30}-2\pi x)=cos(-\frac {4\pi x} {30})=cos(\frac {2\pi 2x} {30})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后可以发现，只有两个函数与原离散数据相符，从而就得知原函数$f(x)$的组成，这就是DFT的思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这样再来看DFT的公式，发现与上面描述的仍有较大出入。这是因为三角函数具有相位，即可能有$cos(2\pi x+\frac {\pi} {4})$这样的存在，单纯的余弦函数是不能描述出相位的。考虑到一个含相位的余弦函数可以分解成一个余弦函数与正弦函数的和，因此可以考虑另取30个基函数去求相关性，为了区分两者，给正弦函数乘一个i变成虚数： f_k(x)=isin(\frac {2\pi kx} {30}),k=0,1,\cdots,29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是最终综合来看，我们得到了这30个基函数： f_k(x)=cos(\frac {2\pi kx} {30})+isin(\frac {2\pi kx} {30}),k=0,1,\cdots,29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据欧拉公式，它就是： f_k(x)=e^{i\frac {2\pi kx} {30}},k=0,1,\cdots,29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们最终得出的相位是相对于余弦函数的，对于一个函数： acosx+bsinx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样模就是$\sqrt{a^2+b^2}$，相位就是$arctan(-\frac {a} {b})$，有一个负号不方便，因此可以在取基函数时就加入负号，得到： f_k(x)=e^{-i\frac {2\pi kx} {30}},k=0,1,\cdots,29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在再看DFT的公式就容易理解了。 FFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的讨论中可以看出，如果我们需要进行DFT，需要对N个基函数分别求一次相关程度，求一次相关程度的复杂度是$O(n)$的，故总时间复杂度为$O(n^2)$，效率比较低，这时快速傅里叶变换（FFT）就发挥作用了，它可以将这个过程优化到$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那这里的FFT与OI中的FFT有什么区别？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取一个多项式如下： a(0)+a(1)x+a(2)x^2+\cdots+a(N-1)x^{N-1}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定N是2的方幂。这里的$a(n)$就是离散数值，x是多项式的自变量，现在代入基函数$cos(\frac {2\pi kx} {N})-isin(\frac {2\pi kx} {N})$，这个式子得到的其实就是相关程度。根据FFT的算法过程，多项式中分别代入了所有我们需要的基函数，因此OI中的FFT其实与这里的信号处理没有本质区别，可以说OI中的FFT是对原有FFT的花式应用。 FFT应用实例：分析wav&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在来试着应用FFT：给定一小段单音调音频，编程判断其声音频率。为了方便起见，我们选用wav格式的声音文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的例子都是在44100Hz采样率，16位的数据位数下进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据wav文件的格式，前44个字节是文件的信息，之后才是数据，它们每2个字节（16位）记录一个采样的数据，数据用小端的方式存储。这里用一个c++框架Qt的一些功能去实现解析的过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要有一个1000Hz的正弦波音频文件，在Qt中，调用QDataStream读取其二进制数据流：123456QCoreApplication a(argc, argv);QFile file("bgm.wav");//读文件file.open(QIODevice::ReadOnly);QDataStream stream(&amp;file);stream.setByteOrder(QDataStream::LittleEndian);//小端方式读二进制流stream.skipRawData(44);//跳过前44个字节 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我这里的音频文件是双声道的，它的数据中左右声道来回切换，我们需要将一半的数据滤掉，只处理其一个声道的信息。1234567891011121314151617struct Complex &#123;//定义复数 double a, b; Complex(double x = 0, double y = 0) : a(x), b(y)&#123; &#125; Complex operator+(Complex c) &#123; return &#123;a + c.a, b + c.b&#125;; &#125; Complex operator*(Complex c) &#123; return &#123;a * c.a - b * c.b, a * c.b + b * c.a&#125;; &#125; Complex operator-(Complex c) &#123; return &#123;a - c.a, b - c.b&#125;; &#125;&#125; op[33554435]; 1234567qint16 e;bool k = true;for (int i = 0; i &lt; (2097152 &lt;&lt; 1); i++)&#123;//2097152是2的21次方，FFT要求数据量是2的方幂 stream &gt;&gt; e; if (k) op[i &gt;&gt; 1].a = e, k = false;//只读取一半 else k = true;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后进行FFT，代码如下：123456789101112131415int tr[33554435];void FFT(int l, Complex *c, int type = -1) &#123;//快速傅里叶变换 for (int i = 0; i &lt; l; i++) if (i &lt; tr[i]) std::swap(c[i], c[tr[i]]); //交换 for (int mid = 1; mid &lt; l; mid &lt;&lt;= 1)&#123; //mid为区间一半的长度 Complex wn(cos(Pi / mid), type * sin(Pi / mid));//2pi/2mid就是pi/mid for (int len = mid &lt;&lt; 1, j = 0; j &lt; l; j += len)&#123; //len是区间长度，j为现在所对应的区间首标记 Complex w(1.0, 0); for (int k = 0; k &lt; mid; k++, w = w * wn)&#123; Complex x = c[j + k], y = w * c[j + mid + k];//蝴蝶效应 c[j + k] = x + y, c[j + mid + k] = x - y; &#125; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然还有预处理：1for (int i = 0; i &lt; l; i++) tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (le - 1)); //构造 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后就得到了所有的值，从中选取一个最大的值，并得到其编号：12345678FFT(l, op);//调用FFTdouble maxn = -10000;for (int i = 0; i &lt; 2097152; i++)&#123; if (op[i].a &gt; maxn)&#123;//找到权重最大的一个，并记录其频率 maxn = op[i].a; ans = i; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设实际上该信号为$cos(\omega x)$，而采样率为44100Hz，于是第x个测试数据值应为$cos(\omega \frac{x} {44100})$。FFT求出的形式应形如$cos(\frac {2\pi kx} {2097152})$，于是$\omega \frac{x} {44100}=\frac {2\pi kx} {2097152}$，得到$\omega=\frac {44100*2\pi k}{2097152}$，频率就是$\frac {44100k}{2097152}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行程序，得到ans为47554，当然还有另一个2049598，将它们分别代入到上面的式子中，计算得到999.990以及43100.009。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实前一个数据999.990已经十分接近正确答案1000Hz了，这是一个不错的检验结果，后一个频率是超声波舍掉即可。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流应用专题]]></title>
    <url>%2F2019%2F05%2F26%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有必要整理一下网络流模型了，本文长期更新。以下题目许多出自网络流24题专题，点击标题可跳转。前缀知识：网络流。 负载平衡问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络流只要建出图来就好说。本题中可以这样建图：设出源点和汇点，从源点开始向每一个点引一条边，容量限制为对应点的初始值，每一个再向汇点引一条边，容量限制为所有点权之和除以点数（就是最后平衡时的点权）。这些边的费用均为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后再考虑点之间的转化。对于相邻的点，向这两个点引两条边，容量限制无穷大，费用为1（就是流量代价）。在这个图上跑费用流即可，答案就是最小费用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个网络流模型可以这样理解：源点对点进行初始化，汇点限制末状态，中间边代表转移，费用代表代价。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//SPFA+EK算法费用流#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge &#123; int next, to, v, price;&#125; edge[20005];int head[205], cnt, op[105], n, sum, vis[105], ans, pre[105], flow[105], dict[105];inline void add(int x, int y, int v, int p) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].price = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].price = -p, head[y] = cnt++;&#125;queue&lt;int&gt; que;inline int SPFA() &#123; for (int i = 0; i &lt;= n + 1; i++)dict[i] = 0x7fffffff, vis[0] = 0, pre[i] = -1; while (!que.empty())que.pop(); que.push(0), vis[0] = 1, dict[0] = 0, flow[0] = 0x7fffffff; while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].price) &#123; dict[edge[i].to] = dict[f] + edge[i].price, pre[edge[i].to] = i; flow[edge[i].to] = min(flow[f], edge[i].v); if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[n + 1] == -1 ? -1 : flow[n + 1];&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i], head[i] = -1; sum += op[i]; &#125; head[0] = head[n + 1] = -1; for (int i = 1; i &lt;= n; i++)add(0, i, op[i], 0), add(i, n + 1, sum / n, 0); for (int i = 1; i &lt;= n; i++) &#123;//建图过程 if (i == 1)add(1, 2, 1 &lt;&lt; 30, 1), add(1, n, 1 &lt;&lt; 30, 1); else if (i == n)add(n, n - 1, 1 &lt;&lt; 30, 1), add(n, 1, 1 &lt;&lt; 30, 1); else add(i, i - 1, 1 &lt;&lt; 30, 1), add(i, i + 1, 1 &lt;&lt; 30, 1); &#125; int increase; while ((increase = SPFA()) != -1) &#123;//费用流算法 int p = n + 1; while (p != 0)edge[pre[p]].v -= increase, edge[pre[p] ^ 1].v += increase, p = edge[pre[p] ^ 1].to; ans += increase * dict[n + 1]; &#125; cout &lt;&lt; ans; return 0;&#125; 最小路径覆盖问题（模板）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个重要模型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于DAG上的最小路径覆盖，我们可以这样理解：起初，可以将所有的点视为一个个独立的集合，这样集合数量为n（n为点数），这个值很可能不是最小的；这时注意到两个路径之间可以合并，且对于每一个点只能合并一次，每合并一个就意味着答案减去1。这样建图方法就可以推知了。首先将每一个点分为$x$,$y$，从源点开始向每一个点的$x$点引一条边，容量为1，再从每一个点的$y$开始，向汇点引一条边，容量为1。对于原DAG上的每一条边$(a,b)$，在网络流上建立边$(x_a,y_b)$，容量为1。这样做可以使每一个点仅能使用一次，最后的流量就是合并的次数。在图上跑最大流算法，求出最大流$flow$，答案就是$n-flow$。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Dinic算法#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge &#123; int to, next, v;&#125; edge[20005];int head[500], cnt, n, m, d[500], cur[500], vis[500];inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;queue&lt;int&gt; que;int DFS(int x, int limit) &#123; if (x == (n &lt;&lt; 1 | 1) || limit == 0)return limit; int f, flow = 0; for (int i = cur[x]; ~i; i = edge[i].next) &#123; cur[x] = i;//当前弧优化 if (d[edge[i].to] == d[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(edge[i].v, limit)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, limit -= f, flow += f; if (limit == 0)break; &#125; &#125; return flow;&#125;inline int BFS() &#123; for (int i = 0; i &lt;= (n &lt;&lt; 1 | 1); i++)d[i] = 0x7fffffff, cur[i] = head[i]; while (!que.empty())que.pop(); d[0] = 0, que.push(0); while (!que.empty()) &#123; int f = que.front(); que.pop(); if (f == (n &lt;&lt; 1 | 1))return 1; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (d[edge[i].to] == 0x7fffffff &amp;&amp; edge[i].v &gt; 0)d[edge[i].to] = d[f] + 1, que.push(edge[i].to); &#125; &#125; return 0;&#125;void solve(int x) &#123;//递归找答案 vis[x] = 1; cout &lt;&lt; x &lt;&lt; " "; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i].to &gt; n &amp;&amp; edge[i].to &lt;= (n &lt;&lt; 1) &amp;&amp; edge[i].v == 0) &#123;//流出点为邻接点 solve(edge[i].to - n); return; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y + n, 1); &#125; for (int i = 1; i &lt;= n; i++)add(0, i, 1), add(i + n, n &lt;&lt; 1 | 1, 1); int ans = 0; while (BFS())ans += DFS(0, 0x7fffffff); ans = n - ans; for (int i = 1; i &lt;= ans; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (vis[j])continue; for (int e = head[j + n]; ~e; e = edge[e].next) &#123; if (edge[e].to == (n &lt;&lt; 1 | 1) &amp;&amp; edge[e].v == 1) &#123;//没有流，说明是起点 solve(j); cout &lt;&lt; endl; break; &#125; &#125; &#125; &#125; cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有环的有向图，可以先tarjan缩点，再跑网络流。 魔术球问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个在上面模板的基础上就很好理解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到每一个柱子上的数必然是递增的，并且每一个柱子都可以看成是一个路径（结合模板）。可以从小到大枚举答案，建图跑最大流，然后更新答案。这里根据答案单调性，可以用二分优化。下面代码是朴素的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define N 2000using namespace std;struct Edge &#123; int to, next, v;&#125; edge[200005];int head[5005], cnt, sp, d[5005], cur[5005], vis[5005], ans;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;queue&lt;int&gt; que;int DFS(int x, int limit) &#123; if (x == (N &lt;&lt; 1 | 1) || limit == 0)return limit; int f, flow = 0; for (int i = cur[x]; ~i; i = edge[i].next) &#123; cur[x] = i;//当前弧优化 if (d[edge[i].to] == d[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(edge[i].v, limit)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, limit -= f, flow += f; if (limit == 0)break; &#125; &#125; return flow;&#125;inline int BFS() &#123; for (int i = 0; i &lt;= (N &lt;&lt; 1 | 1); i++)d[i] = 0x7fffffff, cur[i] = head[i]; while (!que.empty())que.pop(); d[0] = 0, que.push(0); while (!que.empty()) &#123; int f = que.front(); que.pop(); if (f == (N &lt;&lt; 1 | 1))return 1; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (d[edge[i].to] == 0x7fffffff &amp;&amp; edge[i].v &gt; 0)d[edge[i].to] = d[f] + 1, que.push(edge[i].to); &#125; &#125; return 0;&#125;void solve(int x) &#123; vis[x] = 1; cout &lt;&lt; x &lt;&lt; " "; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i].to &gt; N &amp;&amp; edge[i].to &lt;= N + ans &amp;&amp; edge[i].v == 0) &#123; solve(edge[i].to - N); return; &#125; &#125;&#125;int main() &#123; int flow = 0; cin &gt;&gt; sp; memset(head, -1, sizeof(head)); add(0, 1, 1), add(1 + N, N &lt;&lt; 1 | 1, 1), add(0, 2, 1), add(2 + N, N &lt;&lt; 1 | 1, 1);//先加入1和2这两个数 for (int now = 3; now &lt;= N; now++) &#123; add(0, now, 1), add(now + N, N &lt;&lt; 1 | 1, 1);//加入新边 for (int i = 1; i &lt; now; i++) &#123; int sp = (int) sqrt(i + now); if (sp * sp == i + now)add(i, now + N, 1);//加入新边 &#125; while (BFS())flow += DFS(0, 0x7fffffff);//跑Dinic最大流，这里不用清图，在上一个的基础上跑算法即可 if (now - flow &lt;= sp)ans = now; if (now - flow &gt; sp)break;//提前结束，相当于剪枝 &#125; cout &lt;&lt; ans &lt;&lt; endl; for (int i = 1; i &lt;= sp; i++) &#123;//这里和模板的处理方式基本相同 for (int j = 1; j &lt;= ans; j++) &#123; if (vis[j])continue; for (int e = head[j + N]; ~e; e = edge[e].next) &#123; if (edge[e].to == (N &lt;&lt; 1 | 1) &amp;&amp; edge[e].v == 1) &#123; solve(j); cout &lt;&lt; endl; break; &#125; &#125; &#125; &#125; return 0;&#125; 试题库问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题比较简单。考虑到每一个题只能用一次，而且它只能对一个类型做出贡献。建立源点到每一个点的边，容量为1，然后对于一个题目的类型，从该点出发向类型建立边，容量为1，最后从每个类型开始，向汇点建立边，容量为规定的题目数量。在这个图上跑最大流即可。如果最大流不足m，则无解。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge &#123; int next, to, v;&#125; edge[50000];int head[5000], cnt, k, n, kp[25], d[5000], cur[5005], sum;inline void add(int x, int y, int v) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;queue&lt;int&gt; que;int DFS(int x, int limit) &#123; if (x == (n &lt;&lt; 1 | 1) || limit == 0)return limit; int f = 0, flow = 0; for (int i = cur[x]; ~i; i = edge[i].next) &#123; cur[x] = i; if (d[edge[i].to] == d[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(edge[i].v, limit)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, limit -= f, flow += f; if (limit == 0)break; &#125; &#125; return flow;&#125;inline int BFS() &#123; for (int i = 0; i &lt;= (n &lt;&lt; 1 | 1); i++)d[i] = 0x7fffffff, cur[i] = head[i]; while (!que.empty())que.pop(); d[0] = 0, que.push(0); while (!que.empty()) &#123; int f = que.front(); que.pop(); if (f == (n &lt;&lt; 1 | 1))return 1; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (d[edge[i].to] == 0x7fffffff &amp;&amp; edge[i].v &gt; 0)d[edge[i].to] = d[f] + 1, que.push(edge[i].to); &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; k &gt;&gt; n; memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; kp[i]; add(i + n, n &lt;&lt; 1 | 1, kp[i]), sum += kp[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; add(0, i, 1); int p; cin &gt;&gt; p; while (p--) &#123; int x; cin &gt;&gt; x; add(i, x + n, 1); &#125; &#125; int ans = 0; while (BFS())ans += DFS(0, 0x7fffffff); if (ans != sum)cout &lt;&lt; "No Solution!"; else &#123; for (int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; i &lt;&lt; ": "; for (int e = head[i + n]; ~e; e = edge[e].next) &#123; if (edge[e].to &gt;= 1 &amp;&amp; edge[e].to &lt;= n &amp;&amp; edge[e].v == 1)cout &lt;&lt; edge[e].to &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 方格取数问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对棋盘上的点进行黑白染色，可以得到一个二分图。现在需要在上面选几个点，使得它们两两不相邻，可以这样建图：从源点引边指向黑点，容量限制为黑点的值，从白点引边指向汇点，容量限制为白点的值；对于相邻的黑点和白点，从黑点开始引边指向相应的白点，容量限制为无穷大。建完图之后，在这个图上求最小割。可以这样理解：对网络流的割就是断开某些边使源点汇点不连通且边权最小，由于黑白点之间边权为无穷大，故它们必然不会被割，这样只能割与源点和汇点相连的边，一条边被割便意味着与之对应的点不选。对于一个合理的选点情况，将它们放到图中，源点和汇点应该是不连通的。我们在图上求最小割，本质上是删点的过程，它使得源点汇点不连通，这样剩下的点就是我们需要选的点，并保证了被删去的点点权尽可能小，从而得到最大的答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是答案就是所有数的和与最小割的差。由于某种原因，本题代码用python给出：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108from queue import Queuedef ID(x, y): global n, m return m * x + yclass Edge: next = 0 v = 0 to = 0def addEdge(x, y, zt): global cnt, edge, head edge.append(Edge()) edge.append(Edge()) edge[cnt].to = y edge[cnt].next = head[x] edge[cnt].v = zt head[x] = cnt cnt = cnt + 1 edge[cnt].to = x # 反边 edge[cnt].next = head[y] edge[cnt].v = 0 head[y] = cnt cnt = cnt + 1def DFS(x, limit): global n, m, head, edge if x == n * m + 1 or limit == 0: return limit e = int(head[x]) flow = 0 while e != -1: if d[edge[e].to] == d[x] + 1: f = DFS(edge[e].to, min(edge[e].v, limit)) if f &gt; 0: edge[e].v -= f edge[e ^ 1].v += f flow += f limit -= f if limit == 0: break e = edge[e].next return int(flow)def BFS(): global n, m, inf, head, edge que = Queue(0) for it in range(0, n * m + 2): d[it] = inf d[n * m] = 0 que.put(n * m) while not que.empty(): f = que.get() e = head[f] if f == n * m + 1: return True while e != -1: if edge[e].v &gt; 0 and d[edge[e].to] == inf: d[edge[e].to] = d[f] + 1 que.put(edge[e].to) e = edge[e].next return Falselss = input().split()n = int(lss[0])m = int(lss[1])d = []sum = 0head = []cnt = 0inf = 1 &lt;&lt; 30edge = []op = []X = [-1, 0, 1, 0]Y = [0, 1, 0, -1]for i in range(0, n): lss = input().split() for j in range(0, m): op.append(int(lss[j])) sum += int(lss[j]) head.append(-1) d.append(0)head.append(-1)d.append(0) # 源点：nmhead.append(-1)d.append(0) # 汇点：nm+1for i in range(0, n): for j in range(0, m): if (i + j) % 2 == 1: addEdge(n * m, ID(i, j), op[ID(i, j)]) for z in range(0, 4): # 四个方向 xx = i + X[z] yy = j + Y[z] if 0 &lt;= xx &lt; n and 0 &lt;= yy &lt; m: addEdge(ID(i, j), ID(xx, yy), inf) else: addEdge(ID(i, j), n * m + 1, op[ID(i, j)])ans = 0while BFS(): ans += DFS(n * m, inf)print(sum - ans) 最长不下降子序列问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看着像一个智障的问题，其实它需要网络流解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问用dp搞出来，这里定义$dp[i]$为以i结尾的最长序列长度。对于第二问，可以这样建图：将所有点拆成两个部分$x$和$y$，并建边$(x_i,y_i)$，对于$dp[i]=1$的点，从源点开始向$x_i$引一条边，容量为1，对于$dp[a]+1=dp[b]$且满足不下降条件的$a$和$b(a &lt; b)$，引边$(y_a,x_b)$，容量为1，对于$dp[i]=s$（s为第一问答案）的点i，从$y_i$开始建边指向汇点，容量为1。容量为1保证了每一个点只能选一次，该图的最大流就是第二问答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三问对于$dp[a]+1=dp[b]$且满足不下降条件的$a$和$b(a &lt; b)$之间的边$(y_a,x_b)$，容量仍然为1，其余均置为无穷大。这些边没有容量限制意味着起点和终点可以有多个去向（来源），从而达到复用起点终点的目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意这种方法需要特判第一问答案为1的情况。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;30)using namespace std;int dp[505], op[505], n, s = 1, s2, s3;struct Edge &#123; int to, next, v;&#125; edge[60000];int head[1005], cnt, d[1005], cur[1005];inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;queue&lt;int&gt; que;int DFS(int x, int limit) &#123; if (x == (n &lt;&lt; 1 | 1) || limit == 0)return limit; int f, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; cur[x] = i; if (d[edge[i].to] == d[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, limit -= f, flow += f; if (limit == 0)break; &#125; &#125; return flow;&#125;inline int BFS() &#123; for (int i = 0; i &lt;= (n &lt;&lt; 1 | 1); i++)d[i] = inf, cur[i] = head[i]; while (!que.empty())que.pop(); d[0] = 0, que.push(0); while (!que.empty()) &#123; int f = que.front(); que.pop(); if (f == (n &lt;&lt; 1 | 1))return 1; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; d[edge[i].to] == inf)d[edge[i].to] = d[f] + 1, que.push(edge[i].to); &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; n, memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = 1; for (int j = 1; j &lt; i; j++)if (op[i] &gt;= op[j])dp[i] = max(dp[i], dp[j] + 1); s = max(s, dp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; add(i, i + n, 1); if (dp[i] == 1)add(0, i, 1); else if (dp[i] == s)add(i + n, n &lt;&lt; 1 | 1, 1); for (int j = i + 1; j &lt;= n; j++)if (op[j] &gt;= op[i] &amp;&amp; dp[j] == dp[i] + 1)add(i + n, j, 1); &#125; cout &lt;&lt; s &lt;&lt; endl; if (s == 1) &#123; cout &lt;&lt; n &lt;&lt; endl &lt;&lt; n; return 0; &#125; while (BFS())s2 += DFS(0, inf); cout &lt;&lt; s2 &lt;&lt; endl; cnt = 0, memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= n; i++) &#123; add(i, i + n, 100000); if (dp[i] == 1)add(0, i, 10000); else if (dp[i] == s)add(i + n, n &lt;&lt; 1 | 1, 100000); for (int j = i + 1; j &lt;= n; j++)if (op[j] &gt;= op[i] &amp;&amp; dp[j] == dp[i] + 1)add(i + n, j, 1); &#125; while (BFS())s3 += DFS(0, inf); cout &lt;&lt; s3 &lt;&lt; endl; return 0;&#125; [NOI2009]植物大战僵尸（模板）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以作为最大权闭合子图的模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将每一个格子抽象为点，它们的顺序抽象为边可以建出一个图，具体做法：从某一个植物开始，向它保护的格子连有向边，同时对于每一行，右边的格子向左边相邻的格子连有向边。容易发现，有向边规定了攻击的顺序，只有将某一个格子的前驱结点全部攻击之后，才可以攻击这个格子。这里可以按照拓扑排序的方法来理解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这个有向图，如果其中存在环，那么这个环一定是不可破的，它之后的所有点都同时不可破。因此在建完图之后需要来一次tarjan算法进行缩点，对于那些成环的点，将其缩成一点并打上标记，同时进行DFS对其之后的所有点也打上标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽离所有被打上标记的点，可以得到一个新图，现在问题转化为：在这个图上选取一些点，满足拓扑排序规则，使其权值之和最大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样其实不好处理，可以将图反建，此时注意到要选取一个点，必须将其之后的点（就是原图中的前驱点）全部选上，本质上选了一个闭合子图，那么问题转化成求一个有向图的最大权闭合子图，可以用最小割来解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来建网络流图。对于求最大权闭合子图的网络流建模，可采用这样的方法：对于点权非负的点，从源点开始向其引一条边，容量限制为点权；对于权值为负的点，从其开始向汇点引一条边，容量限制为点权的相反数；对于原图中的边，将其直接搬到网络流图中，容量限制为无穷大。在这个图上求最小割，答案就是点权非负的权值之和与最小割的差。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;#define ID(x, y) (x)*m+(y)#define N 100000#define S (n*m+1)#define T (n*m+2)#define INF (1&lt;&lt;28)using namespace std;struct Edge &#123; int next, to, v, from;&#125; edge[3][N * 10];int head[3][N], cnt[3], n, m, op[N], num[N], DFN[N], LOW[N], vis[N], DFNCNT, op2[N];int cor[N], corID = 1, d[N], ans;stack&lt;int&gt; sta;queue&lt;int&gt; que;inline void add(int p, int x, int y, int z = 0) &#123; edge[p][cnt[p]].to = y, edge[p][cnt[p]].v = z, edge[p][cnt[p]].next = head[p][x], edge[p][cnt[p]].from = x; head[p][x] = cnt[p]++;&#125;void tarjan(int x) &#123;//tarjan缩点染色 if (DFN[x])return; DFN[x] = LOW[x] = ++DFNCNT, sta.push(x), vis[x] = 1; for (int i = head[0][x]; ~i; i = edge[0][i].next) &#123; if (DFN[edge[0][i].to] == 0)tarjan(edge[0][i].to), LOW[x] = min(LOW[edge[0][i].to], LOW[x]); else if (vis[edge[0][i].to])LOW[x] = min(DFN[edge[0][i].to], LOW[x]); &#125; if (LOW[x] == DFN[x]) &#123; int p; do vis[p = sta.top()] = 0, cor[p] = corID, sta.pop(), ++num[cor[p]]; while (p != x); if (num[cor[p]] == 1)num[cor[p]] = 0, op2[cor[p]] = op[x];//表示这个点可破 ++corID; &#125;&#125;void DFS(int x) &#123; for (int i = head[1][x]; ~i; i = edge[1][i].next) &#123; if (!vis[edge[1][i].to])vis[edge[1][i].to] = 1, DFS(edge[1][i].to); &#125;&#125;int DFS(int x, int limit) &#123; if (x == T || limit == 0)return limit; int f, flow = 0; for (int i = head[2][x]; ~i; i = edge[2][i].next) &#123; if (d[edge[2][i].to] == d[x] + 1 &amp;&amp; (f = DFS(edge[2][i].to, min(edge[2][i].v, limit)))) &#123; edge[2][i].v -= f, edge[2][i ^ 1].v += f, flow += f, limit -= f; if (limit == 0)break; &#125; &#125; return flow;&#125;int BFS() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt; corID; i++)d[i] = INF; d[S] = 0, d[T] = INF, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(); if (f == T)return 1; for (int i = head[2][f]; ~i; i = edge[2][i].next) &#123; if (edge[2][i].v &gt; 0 &amp;&amp; d[edge[2][i].to] == INF)d[edge[2][i].to] = d[f] + 1, que.push(edge[2][i].to); &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(head, -1, sizeof(head)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (j)add(0, ID(i, j), ID(i, j - 1));//攻击顺序自右向左 int x, y, w; cin &gt;&gt; op[ID(i, j)] &gt;&gt; w; for (int z = 0; z &lt; w; z++) &#123; cin &gt;&gt; x &gt;&gt; y; add(0, ID(i, j), ID(x, y));//保护顺序 &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++)tarjan(ID(i, j));//缩点 for (int i = 0; i &lt; cnt[0]; i++) &#123; if (cor[edge[0][i].from] != cor[edge[0][i].to])add(1, cor[edge[0][i].from], cor[edge[0][i].to]); &#125; for (int i = 1; i &lt; corID; i++)if (num[i] &amp;&amp; !vis[i])vis[i] = 1, DFS(i);//vis=1表示不可破 for (int i = 1; i &lt; corID; i++) &#123;//建网络流图,S源点,T汇点 if (!vis[i]) &#123; if (op2[i] &gt;= 0)ans += op2[i], add(2, S, i, op2[i]), add(2, i, S, 0); else add(2, i, T, -op2[i]), add(2, T, i, 0); &#125; &#125; for (int i = 0; i &lt; cnt[1]; i++) &#123; if (!vis[edge[1][i].from] &amp;&amp; !vis[edge[1][i].to]) &#123; add(2, edge[1][i].to, edge[1][i].from, INF), add(2, edge[1][i].from, edge[1][i].to, 0); &#125; &#125; while (BFS())ans -= DFS(S, INF &lt;&lt; 2); cout &lt;&lt; max(ans, 0);//注意和0取最大值 return 0;&#125; [SDOI2009]晨跑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该是比较裸的费用流。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于每条边只能走一次，故将容量限制设为1，又由于每一点只能走一次，可以将一个点一分为二，中间加一条容量限制为1的有向边。对于所有的原边，其费用就是距离，而对于我们加入的新边，其费用都为0。注意源点与汇点拆点时容量限制应为无穷大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终答案就是最大流和最小费用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;29)using namespace std;struct Edge &#123; int next, to, v, p;&#125; edge[80000];int cnt, head[1000], n, m, S, T, dict[8000], pre[8000], flow[8000], vis[8000];queue&lt;int&gt; que;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void add(int x, int y, int v, int p) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;inline int SPFA() &#123; while (!que.empty())que.pop(); for (int i = S; i &lt;= T; i++)vis[i] = 0, pre[i] = -1, flow[i] = dict[i] = inf; vis[S] = 1, dict[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].p) &#123; dict[edge[i].to] = dict[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v); if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[T] == -1 ? -1 : flow[T];&#125;int main() &#123; n = read(), m = read(), memset(head, -1, sizeof(head)); for (int i = 2; i &lt; n; i++)add(i, i + n, 1, 0); add(1, 1 + n, inf, 0), add(n, n &lt;&lt; 1, inf, 0), S = 1, T = n &lt;&lt; 1; for (int i = 0, x, y, z; i &lt; m; i++)x = read(), y = read(), z = read(), add(x + n, y, 1, z); int increase, ans = 0, minCost = 0; while ((increase = SPFA()) != -1) &#123; int now = T; while (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ 1].v += increase, now = edge[pre[now] ^ 1].to; ans += increase, minCost += dict[T] * increase; &#125; cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; minCost; return 0;&#125; [SCOI2007]修车&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仍然是费用流，不过不是那么容易建图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑一个师傅修若干辆车的总等待时间。如果修了$s$辆车，修车时间分别为$W_1,W_2,\cdots,W_s$，按照这个修车顺序，总时间为： T=sW_1+(s-1)W_2+\cdots+W_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，越先修车的对时间造成代价最大，并且可以发现，在修车的师傅固定时，每一个车对总代价的贡献只与它的顺序有关。如果这辆车是倒数第t个，那么它对总时间的贡献为$tW$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，可以建立车与修车师傅以及顺序之间的关系。将$M$个修车师傅看成$M$个点，再将它们分为$N$个点，表示N个顺序，其中第$i$个点表示倒数第$i$个修。这样可以建立车（$N$个点）到修车师傅以及顺序（$MN$个点）的完全二分图，权值为$iW$（与上文理解相同）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建完图之后，问题转化为求这个二分图上的最小权值完美匹配（只需要N个车完全匹配）。这样做的可行性在于，对于每一个师傅，他修车的顺序可以保证是连续的。证明：假设匹配时车$m$与第$i$位师傅的第$j$个点匹配（表示倒数第j个修），却没有车与第$j+1$个点匹配，又同时有车$n$与第$j+p(p&gt;1)$匹配。这时由于车$n$与第$j+1$个点匹配的权值更小，不满足最优性，故在保证最小权值的前提下这种不连续的情况不可能发生。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带权二分图匹配可以用网络流解决，这个方面的说明在网络流最后，文章链接见本文最开始部分。注意这里是求最小权值，故费用不用取相反数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;29)using namespace std;struct Edge &#123; int next, to, v, p;&#125; edge[80000];int cnt, head[1000], n, m, S, T, dict[8000], pre[8000], flow[8000], vis[8000];queue&lt;int&gt; que;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void add(int x, int y, int v, int p) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;inline int SPFA() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n + n * m + 2; i++)vis[i] = 0, pre[i] = -1, flow[i] = dict[i] = inf; vis[S] = 1, dict[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].p) &#123; dict[edge[i].to] = dict[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v); if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[T] == -1 ? -1 : flow[T];&#125;int main() &#123; m = read(), n = read(), S = n + n * m + 1, T = n + n * m + 2, memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int z = read(); for (int ss = 1; ss &lt;= n; ss++)add(i, n + (j - 1) * n + ss, 1, z * ss); &#125; &#125; for (int i = 1; i &lt;= n; i++)add(S, i, 1, 0); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++)add(n + (i - 1) * n + j, T, 1, 0); &#125; int increase, ans = 0, minCost = 0; while ((increase = SPFA()) != -1) &#123; int now = T; while (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ 1].v += increase, now = edge[pre[now] ^ 1].to; ans += increase, minCost += dict[T] * increase; &#125; printf("%.2f", minCost / (double) n); return 0;&#125; [ZJOI2010]网络扩容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的费用流。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问就是一个纯裸的网络最大流，直接求即可。再来看第二问，我们直接在图上的原边位置都分别加上一条与之相同的边，只不过将费用设置成相应的值，并将容量限制设置为无穷大，这样就可以使网络沿我们新加的边流，达到扩容的目的。根据最小费用的最优性，只有原边在满流时才可能沿费用不为0的新边，这个条件保证了答案正确性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这样加边无法限制最终流量，因此需要再引入一个新点，将原有汇点引一条边指向该点，并使容量限制为对应值，费用为0，这样就可以限制整体的流量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后在这个网络流图上跑一遍费用流即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;29)#define ID(x, y) ((x-1)*m+y)using namespace std;struct Edge &#123; int next, to, v, p;&#125; edge[80000], edge2[80000];int cnt, head[8000], head2[8000], n, m, S, T, dict[8000], pre[8000], flow[8000], vis[8000], k, cnt2;queue&lt;int&gt; que;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void add(int x, int y, int v, int p) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;inline void add2(int x, int y, int v, int p) &#123; edge2[cnt2].to = y, edge2[cnt2].next = head2[x], edge2[cnt2].v = v, edge2[cnt2].p = p, head2[x] = cnt2++; edge2[cnt2].to = x, edge2[cnt2].next = head2[y], edge2[cnt2].v = 0, edge2[cnt2].p = -p, head2[y] = cnt2++;&#125;inline int SPFA() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)vis[i] = 0, pre[i] = -1, flow[i] = dict[i] = inf; vis[S] = 1, dict[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].p) &#123; dict[edge[i].to] = dict[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v); if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[T] == -1 ? -1 : flow[T];&#125;inline int SPFA2() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n + 1; i++)vis[i] = 0, pre[i] = -1, flow[i] = dict[i] = inf; vis[S] = 1, dict[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head2[f]; ~i; i = edge2[i].next) &#123; if (edge2[i].v &gt; 0 &amp;&amp; dict[edge2[i].to] &gt; dict[f] + edge2[i].p) &#123; dict[edge2[i].to] = dict[f] + edge2[i].p, pre[edge2[i].to] = i; flow[edge2[i].to] = min(flow[f], edge2[i].v); if (!vis[edge2[i].to])que.push(edge2[i].to), vis[edge2[i].to] = 1; &#125; &#125; &#125; return pre[T] == -1 ? -1 : flow[T];&#125;int main() &#123; n = read(), m = read(), k = read(), memset(head, -1, sizeof(head)), S = 1, memset(head2, -1, sizeof(head2)), T = n; for (int i = 0, x, y, z, p; i &lt; m; i++) x = read(), y = read(), z = read(), p = read(), add(x, y, z, 0), add2(x, y, z, 0), add2(x, y, inf, p); int increase, ans = 0, minCost = 0; while ((increase = SPFA()) != -1) &#123; int now = T; while (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ 1].v += increase, now = edge[pre[now] ^ 1].to; ans += increase, minCost += dict[T] * increase; &#125; cout &lt;&lt; ans &lt;&lt; " ", k += ans, T = n + 1, add2(n, T, k, 0), ans = 0; while ((increase = SPFA2()) != -1) &#123; int now = T; while (now != S)edge2[pre[now]].v -= increase, edge2[pre[now] ^ 1].v += increase, now = edge2[pre[now] ^ 1].to; ans += increase, minCost += dict[T] * increase; &#125; cout &lt;&lt; minCost; return 0;&#125; [NOI2012]美食节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个题与上面“修车”这道题很像，推荐先做上面那一道再做本题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本思路与修车相同。将厨师按照时间戳拆点，然后连边形成完全二分图，再跑网络流即可。但是本题数据量比较大，直接就会导致TLE，因此需要加一些优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到每一次增广必定先连接某个厨师的倒数第一个时间戳位置，因此一开始我们先只连接所有厨师的倒数第一个时间戳位置，当一次增广完成后，再动态加边，这样可以有效地降低时间复杂度。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;29)#define ID(x, y) (x-1)*p+y+n#define N 80100using namespace std;struct Edge &#123; int next, to, v, p;&#125; edge[2000000];int cnt, head[80100], n, m, S, T, p, dict[80100], pre[80100], flow[80100], vis[80100], op[50];int sp[45][101], que[N], f, b;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void add(int x, int y, int v, int p) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;inline int SPFA() &#123; f = b = 0; for (register int i = 1; i &lt;= p * m + n + 2; i++)vis[i] = 0, pre[i] = -1, flow[i] = dict[i] = inf; vis[S] = 1, dict[S] = 0, que[b] = S, b = (b + 1) % N; while (f != b) &#123; register int fbd = que[f]; f = (f + 1) % N, vis[fbd] = 0; for (register int i = head[fbd]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[fbd] + edge[i].p) &#123; dict[edge[i].to] = dict[fbd] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[fbd], edge[i].v); if (!vis[edge[i].to])que[b] = edge[i].to, b = (b + 1) % N, vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[T] == -1 ? -1 : flow[T];&#125;int main() &#123; n = read(), m = read(), memset(head, -1, sizeof(head)); for (register int i = 1; i &lt;= n; i++)op[i] = read(), p += op[i]; S = m * p + n + 1, T = m * p + n + 2; for (register int i = 1; i &lt;= n; i++)add(S, i, op[i], 0); for (register int i = 1; i &lt;= n; i++) &#123; for (register int j = 1; j &lt;= m; j++)sp[i][j] = read(), add(i, ID(j, 1), 1, sp[i][j]);//只连接一个 &#125; for (register int i = 1; i &lt;= m; i++) &#123; for (register int ps = 1; ps &lt;= p; ps++)add(ID(i, ps), T, 1, 0); &#125; register int increase, ans = 0, minCost = 0; while ((increase = SPFA()) != -1) &#123; register int now = T, to = edge[pre[T] ^ 1].to - n - 1, x = to / p + 1, y = to % p + 1; if (y &lt; p)for (register int i = 1; i &lt;= n; i++)add(i, ID(x, y + 1), 1, (y + 1) * sp[i][x]);//加边 while (now != S)edge[pre[now]].v -= increase, edge[pre[now] ^ 1].v += increase, now = edge[pre[now] ^ 1].to; ans += increase, minCost += dict[T] * increase; &#125; printf("%d", minCost); return 0;&#125; 餐巾计划问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别好的一道网络流，建图方式不那么容易想到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认清一个事实：每天早上都会通过一些方式（新购买或者经过清洗）得到该天需要的餐巾，晚上会得到同等数量的脏餐巾，根据这个事实就可以完成建图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将每一天对应的点拆为早上（设为$D(x)$）和晚上（设为$D’(x)$）两个，早上表示新餐巾的流入，晚上表示脏餐巾的流出。建图方式如下： 每天都可以购入新餐巾，加边$S-&gt;D(x)$，流量无穷大，费用为$p$。 每天都需要一定数量的餐巾（设为$c_i$），加边$D(x)-&gt;T$，流量$c_i$，费用0。 每天产生$c_i$数量的脏餐巾，加边$S-&gt;D’(x)$，流量$c_i$，费用0。 脏餐巾可以经过清洗，加边$D’(x)-&gt;D(x+m)$，流量无穷大，费用$f$，当然还要连接$D’(x)-&gt;D(x+n)$，费用就是$s$。 脏餐巾可以延期清洗，加边$D’(x)-&gt;D’(x+1)$，表示当天的脏餐巾可以流入下一天晚上，流量无穷大，费用0。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跑费用流即可。这里需要注意的一点是，在建图时可能会想到直接将早上对应的点连向当天晚上，来达到将早上餐巾用脏后流入晚上处理的效果，这样做并不正确，因为这些经过清洗的餐巾它们经过了多次利用，却用了同一个流，会导致总体流量减小，跑最小费用最大流时就不会再考虑这些重复利用的流，答案自然就不正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们这里的做法是给这些脏餐巾分配新的流，就可以保证正确性了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define S ((N&lt;&lt;1)+1)#define T ((N&lt;&lt;1)+2)#define ID(x, y) ((x-1)*2+y)#define inf (1&lt;&lt;29)struct Edge &#123; int next, to, v, p;&#125; edge[8000000];int head[4500], N, p, m, f, n, s, vis[4500], flow[4500], pre[4500], dis[4500];long long ff, minCost;queue&lt;int&gt; que;inline void add(int x, int y, int v, int p) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;int SPFA() &#123; for (int i = 1; i &lt;= T; i++)vis[i] = 0, pre[i] = -1, dis[i] = inf; dis[S] = 0, que.push(S), vis[S] = 1, flow[S] = inf; while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123; dis[edge[i].to] = dis[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(edge[i].v, flow[f]); if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[T] != -1;&#125;int main() &#123; N = read(), memset(head, -1, sizeof(head)); for (int i = 1, x; i &lt;= N; i++)add(ID(i, 2), T, x = read(), 0), add(S, ID(i, 1), x, 0); p = read(), m = read(), f = read(), n = read(), s = read(); for (int i = 1; i &lt;= N; i++)add(S, ID(i, 2), inf, p); for (int i = 1; i &lt; N; i++)add(ID(i, 1), ID(i + 1, 1), inf, 0); for (int i = 1; i &lt;= N; i++) &#123; if (i + m &lt;= N)add(ID(i, 1), ID(i + m, 2), inf, f); if (i + n &lt;= N)add(ID(i, 1), ID(i + n, 2), inf, s); &#125; while (SPFA()) &#123; int ss = T; while (ss != S)edge[pre[ss]].v -= flow[T], edge[pre[ss] ^ 1].v += flow[T], ss = edge[pre[ss] ^ 1].to; ff += flow[T], minCost += flow[T] * dis[T]; &#125; cout &lt;&lt; minCost; return 0;&#125; [CTSC1999]家园&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要技巧的网络流，还需要并查集以及枚举相关的知识。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到结点的转移与时间有关，那么按时间拆点是必要的：规定$D(x,t)$为$x$在时间$t$时的对应点（$x$为0或-1时为地球和月球）。建图方式如下： 当某一时间$t$有太空船到达地球时，连接$S-&gt;D(0,t)$，容量为太空船的容量。 对于一个时刻$t$的太空站$x$，连接$D(x,t)-&gt;D(x’,t+1)$，这里$x’$根据太空船航线确定，容量为太空船容量。 对于所有时刻$t$，连接$D(-1,t)-&gt;T$，容量限制为无穷大。 对于所有太空站$x$，由于其中的人可以停留一站，故连接$D(x,t)-&gt;D(x,t+1)$，容量无穷大。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举时间$t$，动态加边，当最大流达到$k$时，此时的$t$就是答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于可能有无解的情况，需要先进行一步有解性判断。考虑到所有太空船的航线都相当于一个强连通分量，可以直接用并查集将它们合并起来，如果最后月球与地球是连通的，则有解，否则没有。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;#define merge_ID(x) (x==0?n+1:(x==-1?n+2:x))#define ID(x, t) ((t)*(n+2)+merge_ID(x)+2)#define S 1#define T 2#define inf (1&lt;&lt;28)using namespace std;int fa[50], h[50], n, m, k, head[500000], ans, deep[500000];vector&lt;int&gt; vec[50];queue&lt;int&gt; que;struct Edge &#123; int next, to, v;&#125; edge[500000];int findF(int x) &#123; return fa[x] == x ? x : fa[x] = findF(fa[x]);&#125;inline void merge(int x, int y) &#123; int f1 = findF(x), f2 = findF(y); if (f1 != f2)fa[f1] = f2;&#125;inline void add(int x, int y, int v) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;int DFS(int x, int limit) &#123; if (limit == 0 || x == T)return limit; int f, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (deep[edge[i].to] == deep[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, flow += f, limit -= f; if (!limit)break; &#125; &#125; return flow;&#125;inline bool BFS() &#123; while (!que.empty())que.pop(); memset(deep, 127, sizeof(deep)), deep[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; deep[edge[i].to] &gt; inf) &#123; deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); if (edge[i].to == T)return true; &#125; &#125; &#125; return false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k, memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= n + 2; i++)fa[i] = i; for (int i = 1, x; i &lt;= m; i++) &#123; cin &gt;&gt; h[i] &gt;&gt; x; for (int j = 1, y; j &lt;= x; j++) &#123; cin &gt;&gt; y; vec[i].push_back(y); &#125; for (int j = 0; j &lt; vec[i].size() - 1; j++) merge(merge_ID(vec[i][j]), merge_ID(vec[i][j + 1])); merge(merge_ID(vec[i][vec[i].size() - 1]), merge_ID(vec[i][0])); &#125; if (findF(merge_ID(0)) != findF(merge_ID(-1))) &#123; cout &lt;&lt; 0; return 0; &#125; for (int i = 1; i &lt;= m; i++)if (vec[i][0] == 0)add(S, ID(0, 0), h[i]); for (int t = 1;; t++) &#123; for (int i = 1; i &lt;= m; i++) &#123; if (vec[i][t % vec[i].size()] != 0 &amp;&amp; vec[i][(t - 1) % vec[i].size()] != -1) add(ID(vec[i][(t - 1) % vec[i].size()], t - 1), ID(vec[i][t % vec[i].size()], t), h[i]); else if (vec[i][t % vec[i].size()] == 0)add(S, ID(0, t), h[i]); &#125; for (int i = 1; i &lt;= n; i++)add(ID(i, t - 1), ID(i, t), inf); add(ID(-1, t), T, inf); while (BFS())ans += DFS(S, inf); if (ans &gt;= k) &#123; cout &lt;&lt; t; return 0; &#125; &#125;&#125; 太空飞行计划问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大权闭合子图问题，可参考上面的植物大战僵尸一题。本题更常规。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先建一个二分图，将实验连向对应的仪器。实验点权值就是其对应的赞助费用，仪器权值就是它们的价格。在这个图上跑一遍最大权闭合子图的网络流即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的问题就是如何求一种方案。如果实验对应的边被割，说明这个实验不再选用，如果仪器被割，说明购买这个仪器。是否被割可以通过权值是否为0来判断，这样就可以找出一种方案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define ID(x, t) ((1-(t))*m+x+2) //t:是不是实验#define S 1#define T 2#define inf (1&lt;&lt;28)using namespace std;int pay[50], n, m, head[500000], ans, deep[500000], vis[500];vector&lt;int&gt; vec[50], vvp;queue&lt;int&gt; que;struct Edge &#123; int next, to, v;&#125; edge[800000];inline void add(int x, int y, int v) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;int DFS(int x, int limit) &#123; if (limit == 0 || x == T)return limit; int f, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (deep[edge[i].to] == deep[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, flow += f, limit -= f; if (!limit)break; &#125; &#125; return flow;&#125;bool BFS() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n + m + 2; i++)deep[i] = inf; deep[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; deep[edge[i].to] == inf) &#123; deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); if (edge[i].to == T)return true; &#125; &#125; &#125; return deep[T] != inf;&#125;void DFS(int x) &#123; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; !vis[edge[i].to])vis[edge[i].to] = 1, vvp.push_back(edge[i].to), DFS(edge[i].to); &#125;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n, memset(head, -1, sizeof(head)), getchar(); for (int i = 1; i &lt;= m; i++) &#123; char ss[10000]; memset(ss, 0, sizeof(ss)), cin.getline(ss, 1000), sscanf(ss, "%d", pay + i); int ulen = 0, tool; while (sscanf(ss + ulen, "%d", &amp;tool) == 1) &#123; if (ulen == 0)pay[i] = tool, add(S, ID(i, 1), pay[i]), ans += pay[i]; else add(ID(i, 1), ID(tool, 0), inf); if (tool == 0)ulen++; else while (tool)tool /= 10, ulen++; ulen++; &#125; &#125; for (int i = 1, x; i &lt;= n; i++)scanf("%d", &amp;x), add(ID(i, 0), T, x); while (BFS())ans -= DFS(S, inf); vis[S] = 1, DFS(S); for (int i = 0; i &lt; vvp.size(); i++)if (vvp[i] - 2 &lt;= m)cout &lt;&lt; vvp[i] - 2 &lt;&lt; " "; cout &lt;&lt; endl; for (int i = 0; i &lt; vvp.size(); i++)if (vvp[i] - 2 &gt; m)cout &lt;&lt; vvp[i] - 2 - m &lt;&lt; " "; cout &lt;&lt; endl &lt;&lt; ans; return 0;&#125; 航空路线问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的费用流。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然每一个地点只能走一次，那么就拆点，并在两个点之间连一条容量为1的边。从终点到起点的路可以看成从起点到终点的反向路，这样问题等价于找从起点到终点的两条路，使途经点数最多。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以认为起点就是源点，终点为汇点。将汇点的入边边权设置为2，可以保证两条路径。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给边加上费用的限制（设置为-1），跑一遍费用流就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意本题需要特判起点终点直接相连的情况。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define inf (1&lt;&lt;28)#define ID(x, y) ((x-1)*2+y)using namespace std;struct Edge &#123; int next, to, v, p;&#125; edge[100000];int head[150], n, v, dis[150], flow[150], pre[150], vis[150], ans, minCost;string name[150];map&lt;string, int&gt; mmp;queue&lt;int&gt; que;vector&lt;int&gt; vvp;inline void add(int x, int y, int v, int p) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;int SPFA() &#123; for (int i = 1; i &lt;= 2 * n; i++)dis[i] = inf, pre[i] = -1, vis[i] = 0; dis[1] = 0, que.push(1), vis[1] = 1, flow[1] = inf; while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123; dis[edge[i].to] = dis[f] + edge[i].p, pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v); if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[2 * n] != -1;&#125;void DFS(int x) &#123; if (x % 2)vvp.push_back(x); for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i].v == 0 &amp;&amp; !vis[edge[i].to] &amp;&amp; edge[i].to &gt; x) &#123; vis[edge[i].to] = 1, DFS(edge[i].to); break; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; v, memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; name[i]; mmp[name[i]] = i, add(ID(i, 1), ID(i, 2), i == 1 ? inf : (i == n ? 2 : 1), 0); &#125; for (int i = 1; i &lt;= v; i++) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; if (mmp[s1] &gt; mmp[s2])swap(s1, s2); add(ID(mmp[s1], 2), ID(mmp[s2], 1), 1, -1); &#125; while (SPFA()) &#123; int t = 2 * n; while (t != 1)edge[pre[t]].v -= flow[2 * n], edge[pre[t] ^ 1].v += flow[2 * n], t = edge[pre[t] ^ 1].to; ans += flow[2 * n], minCost += flow[2 * n] * dis[2 * n]; &#125; if (ans &lt; 2) &#123; for (int i = head[2]; ~i; i = edge[i].next) &#123; if (edge[i].to == 2 * n - 1) &#123; cout &lt;&lt; 2 &lt;&lt; endl &lt;&lt; name[1] &lt;&lt; endl &lt;&lt; name[n] &lt;&lt; endl &lt;&lt; name[1]; return 0; &#125; &#125; cout &lt;&lt; "No Solution!"; return 0; &#125; else &#123; cout &lt;&lt; -minCost &lt;&lt; endl, memset(vis, 0, sizeof(vis)), DFS(2); cout &lt;&lt; name[1] &lt;&lt; endl; for (int i = 0; i &lt; vvp.size(); i++)cout &lt;&lt; name[vvp[i] / 2 + 1] &lt;&lt; endl; vvp.clear(), DFS(2); for (int i = vvp.size() - 1; i &gt;= 0; i--)cout &lt;&lt; name[vvp[i] / 2 + 1] &lt;&lt; endl; cout &lt;&lt; name[1] &lt;&lt; endl; &#125; return 0;&#125; 圆桌问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以说是很简单的最大流了。将每一个单位和圆桌看成点，从源点开始向所有单位连边，容量限制为每个单位的人数；从圆桌开始向汇点连边，容量限制为圆桌上最大的人数。然后每一个单位向所有圆桌分别连边，容量限制为1，表示最多只能去一人。建好图之后跑一遍最大流，如果最大流不足总人数则无解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于方案的输出根据原边的流量来判别。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define ID(x, y) ((y)*m+x)#define S (m+n+1)#define T (m+n+2)#define inf (1&lt;&lt;28)using namespace std;struct Edge &#123; int next, to, v;&#125; edge[150 * 270 * 2 + 10000];int head[150 + 270 + 10000], deep[150 + 270 + 10000], ans, sum, cur[150 + 270 + 10000];int n, m;queue&lt;int&gt; que;void add(int x, int y, int v) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, head[y] = cnt++;&#125;int DFS(int x, int limit) &#123; if (x == T || limit == 0)return limit; int p, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; cur[x] = i; if (deep[edge[i].to] == deep[x] + 1 &amp;&amp; (p = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= p, edge[i ^ 1].v += p, limit -= p, flow += p; if (!limit)break; &#125; &#125; return flow;&#125;int BFS() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= T; i++)deep[i] = inf, cur[i] = head[i]; deep[S] = 0, que.push(S); while (!que.empty()) &#123; int f = que.front(); que.pop(); if (f == T)return 1; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; deep[edge[i].to] == inf)deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n, memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++)add(ID(i, 0), ID(j, 1), 1); for (int i = 1, x; i &lt;= m; i++) &#123; cin &gt;&gt; x; add(S, ID(i, 0), x), sum += x; &#125; for (int i = 1, x; i &lt;= n; i++) &#123; cin &gt;&gt; x; add(ID(i, 1), T, x); &#125; while (BFS())ans += DFS(S, inf); if (ans == sum)cout &lt;&lt; 1 &lt;&lt; endl; else &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = head[ID(i, 0)]; ~j; j = edge[j].next) if (edge[j].v == 0 &amp;&amp; edge[j].to &lt; S) cout &lt;&lt; edge[j].to - m &lt;&lt; " "; cout &lt;&lt; endl; &#125; return 0;&#125; 骑士共存问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将格子看成点，骑士可以跳跃的两个点之间关系看成边，可以得到一个二分图，问题即为求这个二分图上的最大独立集。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案就是点数与最大匹配的差，拿匈牙利算法就可以解决（诶，好像与网络流没多大关系）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define ID(x, y) ((x-1)*n+y)using namespace std;struct Edge &#123; int to, next;&#125; edge[40000 * 16 + 100];int n, m, head[40005], vis2[40005], be[40005], vis[40005], tim = 1, ans;bool ss[40005];const int X[] = &#123;1, 2, 2, 1&#125;;const int Y[] = &#123;2, 1, -1, -2&#125;;inline void add(int x, int y) &#123; static int cnt = 0; if (ss[x] || ss[y])return; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS(int x, int y) &#123; for (int i = head[ID(x, y)]; ~i; i = edge[i].next) &#123; if (vis2[edge[i].to] == -1) &#123; vis2[edge[i].to] = vis2[ID(x, y)] ^ 1; DFS((edge[i].to - 1) / n + 1, (edge[i].to - 1) % n + 1); &#125; &#125;&#125;int f(int x) &#123; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (vis[edge[i].to] != tim) &#123; vis[edge[i].to] = tim; if (be[edge[i].to] == 0 || f(be[edge[i].to])) &#123; be[edge[i].to] = x; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m, memset(vis2, -1, sizeof(vis2)), memset(head, -1, sizeof(head)); for (int i = 1, x, y; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; y; ss[ID(x, y)] = true; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; for (int z = 0, xx, yy; z &lt; 4; z++) &#123; xx = i + X[z], yy = j + Y[z]; if (xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= n)add(ID(i, j), ID(xx, yy)), add(ID(xx, yy), ID(i, j)); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++)if (!ss[ID(i, j)] &amp;&amp; vis2[ID(i, j)] == -1)vis2[ID(i, j)] = 0, DFS(i, j); for (int i = 1; i &lt;= n * n; i++)if (vis2[i] == 1)ans += f(i), ++tim; cout &lt;&lt; n * n - m - ans; return 0;&#125; 火星探险问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很有意思的一题，比较肝的费用流。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑将所有点拆成三个。对于标记为1的点，这三个点都不使用；对于标记为0的点，只使用第一个分点；对于标记为2的点，这三个分点的用途如下： 第一个分点：用于接受流。 第二个分点：表明这个点已经过采集 第三个分点：表明这个点不再采集 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从第一个分点向第二个分点连边，容量为1，费用为-1，同时向第三个分点连边，容量为无穷大，费用为0。对于地图上可以走的一条路径（向南或者向北）从出点出发（对于标记为2的点，其出点就是第2、3个分点，其余都是第1个分点）向入点连接（都是第1个分点），容量限制为无穷大，费用为0。设置一个源点，连接源点与坐标(1,1)的入点，容量限制为探测车数量，再连接右下角坐标点的出点与汇点，容量限制无穷大。建好图之后在上面跑最小费用最大流即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于方案的输出，在跑完费用流后来一遍DFS即可。这里一个错误是根据每一次增广的路径来得到方案，这样做并不对，是因为反边的存在导致增广可能经过反边。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define ID(x, y, z) ((x-1)*3*m+3*(y-1)+z)#define S 3*m*n+1#define T (S+1)#define inf (1&lt;&lt;28)#define X(x) ((x - 1) / 3 / m + 1)#define Y(y) ((y - 1) / 3 % m + 1)using namespace std;struct Edge &#123; int to, next, v, p;&#125; edge[5000000];int head[50000], n, m, p, op[50][50], pre[50000], flow[50000], vis[50000], dist[50000], t;queue&lt;int&gt; que;vector&lt;int&gt; vvp;inline void add(int x, int y, int v, int p) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;inline int BFS() &#123; for (int i = 1; i &lt;= T; i++)pre[i] = -1, dist[i] = inf, vis[i] = 0; dist[S] = 0, que.push(S), vis[S] = 1, flow[S] = inf; while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dist[edge[i].to] &gt; dist[f] + edge[i].p) &#123; dist[edge[i].to] = dist[f] + edge[i].p, flow[edge[i].to] = min(flow[f], edge[i].v), pre[edge[i].to] = i; if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return pre[T] != -1;&#125;void DFS(int x, int rk) &#123; if (X(x) == n &amp;&amp; Y(x) == m)return; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (i % 2)continue; if (op[X(x)][Y(x)] == 0 || x % 3 != 1) &#123; if (edge[i].v &lt; inf &amp;&amp; (X(edge[i].to) - X(x) == 1 || Y(edge[i].to) - Y(x) == 1)) &#123; if (X(edge[i].to) - X(x) == 1)cout &lt;&lt; rk &lt;&lt; " 0" &lt;&lt; endl, DFS(edge[i].to, rk); else cout &lt;&lt; rk &lt;&lt; " 1" &lt;&lt; endl, DFS(edge[i].to, rk); ++edge[i].v; return; &#125; &#125; else &#123; if (edge[i].to == ID(X(x), Y(x), 2) &amp;&amp; edge[i].v == 0) &#123; DFS(edge[i].to, rk), ++edge[i].v; return; &#125; else if (edge[i].to == ID(X(x), Y(x), 3) &amp;&amp; edge[i].v &lt; inf) &#123; DFS(edge[i].to, rk), ++edge[i].v; return; &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; p &gt;&gt; m &gt;&gt; n, memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= n; i++)for (int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (op[i][j] == 1)continue; if (op[i][j] == 2)add(ID(i, j, 1), ID(i, j, 2), 1, -1), add(ID(i, j, 1), ID(i, j, 3), inf, 0); if (i - 1 &gt;= 1) &#123; if (op[i - 1][j] == 0)add(ID(i - 1, j, 1), ID(i, j, 1), inf, 0); else if (op[i - 1][j] == 2) add(ID(i - 1, j, 2), ID(i, j, 1), inf, 0), add(ID(i - 1, j, 3), ID(i, j, 1), inf, 0); &#125; if (j - 1 &gt;= 1) &#123; if (op[i][j - 1] == 0)add(ID(i, j - 1, 1), ID(i, j, 1), inf, 0); else if (op[i][j - 1] == 2) add(ID(i, j - 1, 2), ID(i, j, 1), inf, 0), add(ID(i, j - 1, 3), ID(i, j, 1), inf, 0); &#125; &#125; &#125; if (op[n][m] == 2)add(ID(n, m, 2), T, inf, 0), add(ID(n, m, 3), T, inf, 0); else add(ID(n, m, 1), T, inf, 0); add(S, ID(1, 1, 1), p, 0); while (BFS()) &#123; t = T; while (t != S) vvp.push_back(t), edge[pre[t]].v -= flow[T], edge[pre[t] ^ 1].v += flow[T], t = edge[pre[t] ^ 1].to; &#125; for (int i = 1; i &lt;= p; i++)DFS(ID(1, 1, 1), i); return 0;&#125; 最长k可重区间集问题（模板）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个重要的模板。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对坐标点进行离散化。具体方法是将所有点排序，然后重新标号，容易知道离散化后的区间序列与原先等价，但坐标可以压缩至$[1,2n]$这个区间内。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建图方式如下： $S-&gt;1$，源点连接一号点（将2n个坐标看成点），容量限制为$k$，费用为0。 对于每一个点，向后继点连接一条边，容量限制无穷大，费用0。 对于每一个区间，连接$l-&gt;r$，容量为1，费用为其长度的相反数。 $2n-&gt;T$，表示接受流，容量限制无穷大，费用0。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对图的理解：区间加边可以支走一部分流量，由于一开始流量为$k$的限制，一旦某一部分已经将流量全部支配走，就不能再支配新的流量。这个条件便可以满足k重的约束。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个图上跑一遍最小费用最大流即可，答案就是最小费用的相反数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：当某一个区间左右端点相同时，由于这是开区间，忽略掉这个区间即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define S 0#define T (n&lt;&lt;1|1)#define inf (1&lt;&lt;28)using namespace std;struct Node &#123; int l, r, k;&#125; node[505];struct Edge &#123; int to, next, v, p;&#125; edge[15000];set&lt;int&gt; ssp;map&lt;int, int&gt; mmp;int ID = 1, n, k, head[1500], flow[1500], pre[1500], dis[1500], vis[1500];queue&lt;int&gt; que;inline int BFS() &#123; for (int i = S; i &lt;= T; i++)pre[i] = -1, dis[i] = inf, vis[i] = 0; dis[S] = 0, que.push(S), vis[S] = 1, flow[S] = inf; while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123; dis[edge[i].to] = dis[f] + edge[i].p, flow[edge[i].to] = min(flow[f], edge[i].v), pre[edge[i].to] = i; if (!vis[edge[i].to])vis[edge[i].to] = 1, que.push(edge[i].to); &#125; &#125; &#125; return pre[T] != -1;&#125;inline void add(int x, int y, int v, int p) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k, memset(head, -1, sizeof(head)); for (int i = 1, x, y; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; if (x &gt; y)swap(x, y); node[i].l = x, node[i].r = y, ssp.insert(x), ssp.insert(y), node[i].k = y - x; &#125; for (int x:ssp)mmp[x] = ID++; for (int i = 1; i &lt;= n; i++)node[i].l = mmp[node[i].l], node[i].r = mmp[node[i].r]; for (int i = 1; i &lt; (n &lt;&lt; 1); i++)add(i, i + 1, inf, 0); add(S, 1, k, 0), add(n &lt;&lt; 1, T, inf, 0); for (int i = 1; i &lt;= n; i++)add(node[i].l, node[i].r, 1, -node[i].k); int ans = 0, minCost = 0; while (BFS()) &#123; int to = T; while (to != S)edge[pre[to]].v -= flow[T], edge[pre[to] ^ 1].v += flow[T], to = edge[pre[to] ^ 1].to; ans += flow[T], minCost += flow[T] * dis[T]; &#125; cout &lt;&lt; -minCost; return 0;&#125; 最长k可重线段集问题（模板）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和上一题类似，思路大致相同，这里只不过将费用换为长度的相反数来求，求长度要用到勾股定理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一个区别是，在本题中，如果两个端点的横坐标相同，这个坐标点仍然是被覆盖的，不能忽略。但是如果将它加入到图中，会出现负环，导致SPFA过程不断进行，然后死循环卡T。这里的解决方法是将点拆分为2，分为入点和出点，对于这种端点横坐标相同的线段，直接从该点对应入点出发向出点连边即可，这样可以有效避免上面的问题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define S 0#define inf (1&lt;&lt;28)#define ID(x, y) ((((x)-1)&lt;&lt;1)+y)#define T (ID(n&lt;&lt;1,2)+1)using namespace std;struct Node &#123; int l, r, k;&#125; node[505];struct Edge &#123; int to, next, v, p;&#125; edge[15000];set&lt;int&gt; ssp;map&lt;int, int&gt; mmp;int ID = 1, n, k, head[3000], flow[3000], pre[3000], dis[3000], vis[3000];queue&lt;int&gt; que;inline int BFS() &#123; for (int i = S; i &lt;= T; i++)pre[i] = -1, dis[i] = inf, vis[i] = 0; dis[S] = 0, que.push(S), vis[S] = 1, flow[S] = inf; while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dis[edge[i].to] &gt; dis[f] + edge[i].p) &#123; dis[edge[i].to] = dis[f] + edge[i].p, flow[edge[i].to] = min(flow[f], edge[i].v), pre[edge[i].to] = i; if (!vis[edge[i].to])vis[edge[i].to] = 1, que.push(edge[i].to); &#125; &#125; &#125; return pre[T] != -1;&#125;inline void add(int x, int y, int v, int p) &#123; static int cnt = 0; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, edge[cnt].p = p, head[x] = cnt++; edge[cnt].to = x, edge[cnt].next = head[y], edge[cnt].v = 0, edge[cnt].p = -p, head[y] = cnt++;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k, memset(head, -1, sizeof(head)); for (int i = 1, a, b, c, d; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; node[i].k = (int) (sqrt((1ll * c - a) * (1ll * c - a) + (1ll * d - b) * (1ll * d - b))); if (a &gt; c)swap(a, c); node[i].l = a, node[i].r = c, ssp.insert(a), ssp.insert(c); &#125; for (int x:ssp)mmp[x] = ID++; for (int i = 1; i &lt;= n; i++)node[i].l = mmp[node[i].l], node[i].r = mmp[node[i].r]; for (int i = 1; i &lt; (n &lt;&lt; 1); i++)add(ID(i, 2), ID(i + 1, 1), inf, 0), add(ID(i, 1), ID(i, 2), inf, 0); add(S, ID(1, 1), k, 0), add(ID(n &lt;&lt; 1, 2), T, inf, 0), add(ID(n &lt;&lt; 1, 1), ID(n &lt;&lt; 1, 2), inf, 0); for (int i = 1; i &lt;= n; i++) &#123; if (node[i].l != node[i].r)add(ID(node[i].l, 2), ID(node[i].r, 1), 1, -node[i].k); else add(ID(node[i].l, 1), ID(node[i].r, 2), 1, -node[i].k); &#125; long long ans = 0, minCost = 0; while (BFS()) &#123; int to = T; while (to != S)edge[pre[to]].v -= flow[T], edge[pre[to] ^ 1].v += flow[T], to = edge[pre[to] ^ 1].to; ans += flow[T], minCost += flow[T] * dis[T]; &#125; cout &lt;&lt; -minCost; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚树]]></title>
    <url>%2F2019%2F05%2F21%2F%E8%99%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍虚树，一个解决树上动态规划的利器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来一个经典例题：洛谷P2011消耗战。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显是树型DP，但是奈何n过大，时间复杂度达到$O(nm)$，必然TLE，但是我们又没有什么好的解决思路。这时看到了一个条件$\displaystyle\sum_{i=1}^mk_i&lt;=500000$，这说明无论m有多大，k的总和总是不大于500000，这个条件能不能用来优化算法？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是肯定的，这时就需要引入虚树这个黑科技。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓虚树是指将原树中与问题无关的点剔除，保留与问题有关的点及其lca，之后得到的树。经过这种处理后的树保留了点的相对关系，又去除了冗余的点，可以提高算法效率，这样得到的树就称为虚树。相对应地，原有的树称为原树。虚树能够有效利用与问题有关的点，这样k总和不大于500000的条件就很好地利用上了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图是例题样例图。假如现在需要处理10和6两个点，那么树可以简化成这样：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后复杂度就降下来了，这就是虚树。 虚树的构建&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定原树和我们需要处理的点，如何求虚树呢？这里需要前缀知识：求LCA。只要不是暴力，选哪一个求LCA的方法均可，包括但不仅限于倍增法、tarjan算法、树链剖分。这里选择倍增法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要对树上结点进行DFS排序，得到其编号DFN。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再次，对给定的点按照DFS序排序，用一个栈维护加入虚树的结点遍号，之后将点按照DFS序从小到大的顺序依次加入虚树，规则如下： 若栈中元素数目小于2个，则直接进栈。 若栈中元素数目不小于2个，则求待进栈结点与栈首结点的lca。如果lca就是栈首元素，说明待入栈结点是栈首元素的子结点，直接进栈。 如果lca不是栈首元素，说明栈首元素已经没有需要处理的子结点（毕竟是按照DFS序进栈的），这时构建虚树子树，构建方法是：取栈首元素和第二个元素，若两者都是lca的子结点（这个用DFS序判断），则两者连边作为虚树的树边，根据DFS序，可知第二个元素必定是栈首元素的父结点，加完边后栈首元素出栈，重复这个过程直到栈中元素少于2个或者栈首元素和第二元素不都是lca的子结点。这个过程完成后，判断lca是否是栈首元素，若否说明当前栈首元素是栈中唯一一个为lca子结点的结点，连接lca和这个结点，然后将栈首替换为lca。最后待进栈元素进栈。 最后，可能虚树仍然没有构建完成，最后还需要一次出栈处理。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步示例代码：123456789101112inline void insert(int x) &#123;//建立虚树 if (top &lt;= 1)sta[++top] = x;//数组模拟栈 else &#123; int lca = LCA(sta[top], x);//求lca if (lca == sta[top])sta[++top] = x; else &#123; while (top &gt; 1 &amp;&amp; DFN[lca] &lt;= DFN[sta[top - 1]])add(sta[top - 1], sta[top]), --top; if (lca != sta[top])add(lca, sta[top]), sta[top] = lca; sta[++top] = x; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一次出栈处理代码：1while (top &gt; 1)add(sta[top - 1], sta[top]), --top;//最后一次的出栈处理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里会有一个问题：虚树边权如何定义？这个需要具体分析，本题中将点和点之间的链化成了一条边，根据题目性质，这一条边权值应该是它所连接的两点在原树中链边权的最小值。这个可以用倍增法快速求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建完虚树之后，DP方程就很好列了（本来就好列）。规定$dp(i)$为以i点为根的子树中，去除所有目标点所需的最小代价，那么有转移方程： dp(i)=\begin{cases} \infty & vis[i]\\ \displaystyle\sum_{j=1}^k\min\{val(i,j),dp(j)\} & !vis[i] \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vis[x]$在i为目标结点时为1，否则为0。k为i结点的儿子数目，编号为1~k，$val(i,j)$是结点i到结点j在虚树上的连边权值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后本题就切掉了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define N 250005using namespace std;inline int read() &#123;//读入优化 char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;unordered_set&lt;int&gt; ssp;//用于预处理struct Edge &#123; int to, next, v;&#125; edge[N &lt;&lt; 1], vedge[N];int n, m, head[N], vhead[N], x, y, z, cnt = 1, vcnt = 1, grand[N][19], DFN[N], depth[N], DFNCNT = 1;int op[500002], sta[500002], top, grand_min[N][19];long long dp[N];bool vis[N];inline void add(int x, int y, int w) &#123;//原树 edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = w, head[x] = cnt++;&#125;inline void addv(int x, int y, int w) &#123;//虚树 vedge[vcnt].to = y, vedge[vcnt].next = vhead[x], vedge[vcnt].v = w, vhead[x] = vcnt++;&#125;inline int LCA(int x, int y) &#123;//倍增LCA if (depth[x] &gt; depth[y])swap(x, y); for (int i = 18; i &gt;= 0; i--)if (depth[grand[y][i]] &gt;= depth[x])y = grand[y][i]; if (x == y)return x; for (int i = 18; i &gt;= 0; i--)if (grand[x][i] != grand[y][i])x = grand[x][i], y = grand[y][i]; return grand[x][0];&#125;inline int minEdge(int x, int y) &#123;//求最小边权 int ans = 0x7fffffff; if (depth[x] &gt; depth[y])swap(x, y); for (int i = 18; i &gt;= 0; i--)if (depth[grand[y][i]] &gt;= depth[x])ans = min(ans, grand_min[y][i]), y = grand[y][i]; return ans;&#125;void DFS(int x) &#123; DFN[x] = DFNCNT++; for (int i = head[x]; i; i = edge[i].next) &#123; if (depth[edge[i].to] == 0) &#123; depth[edge[i].to] = depth[x] + 1, grand[edge[i].to][0] = x, grand_min[edge[i].to][0] = edge[i].v; for (int j = 1; j &lt;= 18; j++)grand[edge[i].to][j] = grand[grand[edge[i].to][j - 1]][j - 1]; for (int j = 1; j &lt;= 18; j++) grand_min[edge[i].to][j] = min(grand_min[edge[i].to][j - 1], grand_min[grand[edge[i].to][j - 1]][j - 1]); DFS(edge[i].to); &#125; &#125;&#125;bool cmp(int x, int y) &#123; return DFN[x] &lt; DFN[y];&#125;inline void insert(int x) &#123;//建立虚树 ssp.insert(x); if (top &lt;= 1)sta[++top] = x; else &#123; int lca = LCA(sta[top], x); if (lca == sta[top])sta[++top] = x; else &#123; while (top &gt; 1 &amp;&amp; DFN[lca] &lt;= DFN[sta[top - 1]]) addv(sta[top - 1], sta[top], minEdge(sta[top - 1], sta[top])), --top; if (lca != sta[top])addv(lca, sta[top], minEdge(lca, sta[top])), sta[top] = lca, ssp.insert(lca); sta[++top] = x; &#125; &#125;&#125;long long DP(int x) &#123;//DP过程 if (dp[x] != -1)return dp[x]; if (vis[x])return dp[x] = 1l &lt;&lt; 60; dp[x] = 0ll; for (int i = vhead[x]; i; i = vedge[i].next)dp[x] += min(1ll * vedge[i].v, DP(vedge[i].to)); return dp[x];&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; i++)x = read(), y = read(), z = read(), add(x, y, z), add(y, x, z); depth[1] = 1, DFS(1), m = read(); for (int i = 1; i &lt;= m; i++) &#123; int k = read(); sta[top = 1] = 1, vcnt = 1, ssp.insert(1); for (int j = 1; j &lt;= k; j++)op[j] = read(), vis[op[j]] = true; sort(op + 1, op + k + 1, cmp); for (int j = 1; j &lt;= k; j++)insert(op[j]);//构建虚树 while (top &gt; 1)addv(sta[top - 1], sta[top], minEdge(sta[top - 1], sta[top])), --top; for (int it : ssp)dp[it] = -1; printf("%lld\n", DP(1)); for (int it : ssp)vis[it] = false, vhead[it] = 0; ssp.clear(); &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要注意一个问题：不能在每一次查询中都清一遍数组，这样时间复杂度就退化了（又达到$O(nm)$）。正确解法是记录这一次查询用到了那些位置，然后再单独对这些位置做初始化。上面代码中用unordered_set实现。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2515]软件安装]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%B4%9B%E8%B0%B7P2515-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们的手头有$N$个软件，对于一个软件$i$，它要占用$W_i$的磁盘空间，它的价值为$V_i$。我们希望从中选择一些软件安装到一台磁盘容量为$M$计算机上，使得这些软件的价值尽可能大（即$V_i$的和最大）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是现在有个问题：软件之间存在依赖关系，即软件i只有在安装了软件$j$（包括软件$j$的直接或间接依赖）的情况下才能正确工作（软件$i$依赖软件$j$)。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在知道了软件之间的依赖关系：软件i依赖软件$D_i$。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则$D_i=0$，这时只要这个软件安装了，它就能正常工作。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行：$N,M(0\leq N\leq 100, 0\leq M\leq 500)$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行：$W_1,W_2, … W_i, …, W_n (0\leq W_i\leq M)$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第3行：$V_1, V_2, …, V_i, …, V_n (0\leq V_i\leq 1000)$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第4行：$D_1, D_2, …, D_i, …, D_n (0\leq D_i\leq N, D_i≠i)$ 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，代表最大价值 输入输出样例Sample input 3 105 5 62 3 40 1 1 Sample output 5 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有依赖问题，这就是一个简单的01背包。软件依赖问题使得本题具有一定难度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先根据依赖关系建图，若A依赖于B（B不是0时），那么连一条有向边从B指向A。注意本题中可能出现循环依赖的现象，显然，对于循环依赖的软件，它们要么全被安装，要么全不被安装，因此可以看成一个软件。由于循环依赖的存在，在建完图后，需要用tarjan算法缩点，这样可以得到一个森林。建一个超级源点指向所有树的根结点得到一棵树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是DP。本人方法比较奇葩：先多叉树转二叉树，然后再DP。规定$dp(i,j)$表示根结点编号为i的子树，空间限制为j时的最大价值，那么显然有： dp(i,j)=\begin{cases} 0 & j< W_i\\ V_i+\max\{dp(lc_i,k)+dp(rc_i,j-k)\},0\leq k\leq j & j\geq W_i \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移就是向两个子树进行空间分配，取其中的最大值。最终代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define N 105using namespace std;int n, m, w[N], v[N], id = 1, dp[N &lt;&lt; 2][505], cnt = 1, nw[N &lt;&lt; 2], nv[N &lt;&lt; 2], degree[N], ch[N &lt;&lt; 2][2];int head[N], color[N], DFN[N], LOW[N], DFNCNT = 1, ID = 1, vis[N], nhead[N], ncnt = 1, in[N &lt;&lt; 2];struct Edge &#123; int to, next, from;&#125; edge[N], nedge[N &lt;&lt; 1];inline void add(int x, int y) &#123; edge[cnt].from = x, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;inline void nadd(int x, int y) &#123; nedge[ncnt].to = y, nedge[ncnt].next = nhead[x], nhead[x] = ncnt++;&#125;stack&lt;int&gt; sta;void tarjan(int x) &#123;//缩点 if (DFN[x])return; LOW[x] = DFN[x] = DFNCNT++, sta.push(x), vis[x] = 1; for (int i = head[x]; i; i = edge[i].next) &#123; if (!DFN[edge[i].to])tarjan(edge[i].to), LOW[x] = min(LOW[x], LOW[edge[i].to]); else if (vis[edge[i].to])LOW[x] = min(LOW[x], DFN[edge[i].to]); &#125; if (DFN[x] == LOW[x]) &#123; int t; do color[t = sta.top()] = id, vis[t] = 0, sta.pop(); while (t != x); ++id; &#125;&#125;int DP(int x, int y) &#123;//递归进行DP if (dp[x][y] != -1)return dp[x][y]; if (y &lt; nw[x])return dp[x][y] = 0; if (ch[x][0] == 0)return dp[x][y] = nv[x]; if (ch[x][1] == 0)return dp[x][y] = nv[x] + DP(ch[x][0], y - nw[x]); dp[x][y] = 0; for (int i = 0; i &lt;= y - nw[x]; i++) dp[x][y] = max(dp[x][y], DP(ch[x][0], i) + DP(ch[x][1], y - nw[x] - i) + nv[x]); return dp[x][y];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; v[i]; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; if (x != 0)add(x, i); &#125; for (int i = 1; i &lt;= n; i++)tarjan(i); for (int i = 1; i &lt;= n; i++)nw[color[i]] += w[i], nv[color[i]] += v[i];//新建点 for (int i = 1; i &lt; cnt; i++) if (color[edge[i].from] != color[edge[i].to]) nadd(color[edge[i].from], color[edge[i].to]), ++degree[color[edge[i].from]], ++in[color[edge[i].to]];//重建图 color[0] = id; for (int i = 1; i &lt; id; i++)if (in[i] == 0)nadd(id, i), ++degree[color[0]];//连接超级源点0 ID = id + 1, memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= id; i++) &#123;//多叉树转二叉树 int pt = 0, last = i; for (int j = nhead[i]; j; j = nedge[j].next) &#123; if (degree[i] == 1)ch[i][0] = nedge[j].to; else if (degree[i] == 2)pt ? ch[i][1] = nedge[j].to : ch[i][0] = nedge[j].to, ++pt; else &#123; if (pt == degree[i] - 2)ch[last][0] = nedge[j].to, ++pt; else if (pt == degree[i] - 1)ch[last][1] = nedge[j].to; else ch[last][0] = nedge[j].to, last = ch[last][1] = ID++, ++pt; &#125; &#125; &#125; cout &lt;&lt; DP(color[0], m); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法不是正规的，但是是一个很好想的做法，正规解法是树上背包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样地，规定$dp(i,j)$为编号为i的子树，限制为j时的最大价值，转移时肯定不能像二叉树那样对子结点分配，只能通过不断更新的方式。12345678910void DP(int x) &#123; int v; for (int i = nw[x]; i &lt;= m; i++)dp[x][i] = nv[x];//预处理，其余为0 for (int i = nhead[x]; i; i = nedge[i].next) &#123;//遍历所有结点 DP(v = nedge[i].to);//DP子结点 for (int j = m - nw[x]; j &gt;= 0; j--) &#123;//枚举剩下的空间，倒序枚举 for (int z = 1; z &lt;= j; z++)dp[x][j + nw[x]] = max(dp[x][j + nw[x]], dp[x][j + nw[x] - z] + dp[v][z]);//枚举分配给这个子结点的空间 &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define N 105using namespace std;int n, m, w[N], v[N], id = 1, dp[N &lt;&lt; 2][505], cnt = 1, nw[N &lt;&lt; 2], nv[N &lt;&lt; 2];int head[N], color[N], DFN[N], LOW[N], DFNCNT = 1, vis[N], nhead[N], ncnt = 1, in[N &lt;&lt; 2];struct Edge &#123; int to, next, from;&#125; edge[N], nedge[N &lt;&lt; 1];inline void add(int x, int y) &#123; edge[cnt].from = x, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;inline void nadd(int x, int y) &#123; nedge[ncnt].to = y, nedge[ncnt].next = nhead[x], nhead[x] = ncnt++;&#125;stack&lt;int&gt; sta;void tarjan(int x) &#123;//缩点 if (DFN[x])return; LOW[x] = DFN[x] = DFNCNT++, sta.push(x), vis[x] = 1; for (int i = head[x]; i; i = edge[i].next) &#123; if (!DFN[edge[i].to])tarjan(edge[i].to), LOW[x] = min(LOW[x], LOW[edge[i].to]); else if (vis[edge[i].to])LOW[x] = min(LOW[x], DFN[edge[i].to]); &#125; if (DFN[x] == LOW[x]) &#123; int t; do color[t = sta.top()] = id, vis[t] = 0, sta.pop(); while (t != x); ++id; &#125;&#125;void DP(int x) &#123; int v; for (int i = nw[x]; i &lt;= m; i++)dp[x][i] = nv[x]; for (int i = nhead[x]; i; i = nedge[i].next) &#123; DP(v = nedge[i].to); for (int j = m - nw[x]; j &gt;= 0; j--) &#123; for (int z = 1; z &lt;= j; z++)dp[x][j + nw[x]] = max(dp[x][j + nw[x]], dp[x][j + nw[x] - z] + dp[v][z]); &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; v[i]; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; if (x != 0)add(x, i); &#125; for (int i = 1; i &lt;= n; i++)tarjan(i); for (int i = 1; i &lt;= n; i++)nw[color[i]] += w[i], nv[color[i]] += v[i];//新建点 for (int i = 1; i &lt; cnt; i++) if (color[edge[i].from] != color[edge[i].to]) nadd(color[edge[i].from], color[edge[i].to]), ++in[color[edge[i].to]];//重建图 color[0] = id; for (int i = 1; i &lt; id; i++)if (in[i] == 0)nadd(id, i); DP(color[0]); cout &lt;&lt; dp[color[0]][m]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>动态规划</tag>
        <tag>强连通分量</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斜率优化DP]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继四边形不等式和单调队列之后的另一个DP优化方法，这样常见的DP优化方法基本全了。 斜率优化DP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在DP状态转移方程中，常常可以看到这样的一种形式： dp[x]=\min\{dp[i]+f(i,x)\},i]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hihocoder1554]Shortest Nore0061]]></title>
    <url>%2F2019%2F05%2F12%2FNore0061%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个比较有意思的DP类字符串问题。涉及到子序列问题，故为了弥补漏洞，写这个题。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nore0061 is a weird Nore. Just like all Nores, Nore0061 is a string lover. Nore0061’s given name is string A and the family name is string B. One day Nore King sends Nore0061 a strange alphanumeric string S, and ask Nore0061 to find the shortest substring S’ of S such that S’ can partition into three nonintersecting subsequences {A’, B’, C’} so that A’ = A and B = B’. 输入输出格式输入格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first line contains one single alphanumeric string A(1 ≤ |A| ≤ 100). The second line contains one single alphanumeric string B(1 ≤ |B| ≤ 100). The third line contains one single alphanumeric string S(1 ≤ |S| ≤ 3000). 输出格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One single integer denoting the length of such shortest substring. If no such substring, just print -1 instead. 输入输出样例Sample input Twyj0mJXRiqNuRj4mRKyTcwFKj0KmCJAFpXRiHGNq Sample output 22 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑动态规划。规定$dp[x][y][z]$表示：若串A前x位，串B前y位是串S前z位的两个不相交子序列，则为首位匹配的最大位置，否则为0。这样可以比较容易地推出dp数组。时间复杂度$O(l_1l_2l_3)$，$l_1、l_2、l_3$是三个串的长度。12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;char a[102], b[102], str[3005];int dp[102][102][3005];int l1, l2, len;inline void getDP(int l = 1, int r = len) &#123; dp[1][0][l] = str[l] == a[1], dp[0][1][l] = str[l] == b[1]; for (int i = l + 1; i &lt;= r; i++) &#123; for (int j = 0; j &lt;= l1; j++) &#123; for (int z = 0; z &lt;= l2; z++) &#123; if (j) &#123; if (str[i] == a[j])dp[j][z][i] = max(dp[j][z][i - 1], j == 1 &amp;&amp; z == 0 ? i : dp[j - 1][z][i - 1]); else dp[j][z][i] = dp[j][z][i - 1]; &#125; if (z) &#123; int x = dp[j][z][i]; if (str[i] == b[z])dp[j][z][i] = max(dp[j][z][i - 1], j == 0 &amp;&amp; z == 1 ? i : dp[j][z - 1][i - 1]); else dp[j][z][i] = dp[j][z][i - 1]; dp[j][z][i] = max(dp[j][z][i], x); &#125; &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; (a + 1) &gt;&gt; (b + 1) &gt;&gt; (str + 1); l1 = strlen(a + 1), l2 = strlen(b + 1), len = strlen(str + 1); getDP(); int ans = 30000; for (int i = 1; i &lt;= len; i++) if (dp[l1][l2][i])ans = min(ans, i - dp[l1][l2][i] + 1); cout &lt;&lt; (ans == 30000 ? -1 : ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维凸包]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一篇关于计算几何的文章：二维凸包。 凸包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要知道什么是二维凸包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个不严谨的理解：在二维平面上，给定若干个点，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。如果视点为一个个钉子，则凸包可以理解成套在钉子外的橡皮筋，如下图：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凸包的长度是二维平面中可以将所有点围起来的闭合线长度中的最小值。 二维凸包的求法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用栈来实现，时间复杂度线性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对点进行排序，以横坐标为第一关键字，纵坐标为第二关键字升序排序。然后，将凸包分成上下两部分分别求解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于下半部分，正序遍历一遍点，将其依次加入栈。如果栈的大小不小于3，则比较栈顶元素与其前驱元素的斜率以及前驱元素与前驱的前驱元素的斜率，若前者小，则弹出前驱元素。这个过程需要循环进行。1234567for (int i = 1; i &lt;= n; i++) &#123; sta[++top] = point[i]; while (top &gt;= 3 &amp;&amp; get(sta[top], sta[top - 2]) &lt; get(sta[top - 2], sta[top - 1])) &#123;//get求斜率 sta[top - 1] = sta[top]; top--; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于上半部分，只需要将遍历顺序翻转即可：1234567for (int i = n; i &gt;= 1; i--) &#123; sta[++top] = point[i]; while (top &gt;= 3 &amp;&amp; get(sta[top], sta[top - 2]) &lt; get(sta[top - 2], sta[top - 1])) &#123; sta[top - 1] = sta[top]; top--; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两者合起来就是二维凸包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的算法其实保证了凸包斜率由小再大的性质，可以很方便地计算凸包。附模板题代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;double ans = 0;struct Point &#123; double x, y; bool operator&lt;(Point p) &#123;//排序方法 return x != p.x ? x &lt; p.x : y &lt; p.y; &#125;&#125; point[10005];Point sta[10005];int n, top;inline double get(Point a, Point b) &#123;//求斜率 if (a.x == b.x)return 1e10;//斜率无穷大 return (b.y - a.y) / (b.x - a.x);&#125;inline double getS(Point a, Point b) &#123;//求点对间距离 return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; point[i].x &gt;&gt; point[i].y; sort(point + 1, point + n + 1); for (int i = 1; i &lt;= n; i++) &#123;//下半部分 sta[++top] = point[i]; while (top &gt;= 3 &amp;&amp; get(sta[top], sta[top - 2]) &lt; get(sta[top - 2], sta[top - 1])) &#123; sta[top - 1] = sta[top]; top--; &#125; &#125; for (int i = 2; i &lt;= top; i++)ans += getS(sta[i], sta[i - 1]); top = 0; for (int i = n; i &gt;= 1; i--) &#123;//上半部分 sta[++top] = point[i]; while (top &gt;= 3 &amp;&amp; get(sta[top], sta[top - 2]) &lt; get(sta[top - 2], sta[top - 1])) &#123; sta[top - 1] = sta[top]; top--; &#125; &#125; for (int i = 2; i &lt;= top; i++)ans += getS(sta[i], sta[i - 1]); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杜教筛]]></title>
    <url>%2F2019%2F05%2F10%2F%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杜教筛可以在低于线性复杂度$(O(n^{\frac {2} {3}}))$下求积性函数前缀和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看一个简单的问题：如何求莫比乌斯函数或者欧拉函数前缀和？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接线性筛出两个函数，然后求前缀和即可，时间复杂度$O(n)$。这样做的效率确实很优秀，但是在OI中就是会有人去卡这个复杂度，所以需要低于线性复杂度的算法，这就是杜教筛。 积性函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个数论函数$f(x)$，如果满足以下性质： f(xy)=f(x)f(y),gcd(x,y)=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则称$f(x)$为积性函数。莫比乌斯函数和欧拉函数都是积性函数，另外约数个数$d(x)$以及约数和$\sigma(x)$也是积性函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;积性函数与积性函数的乘积仍然是积性函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于任意的整数$x$和$y$都有$f(xy)=f(x)f(y)$，则称$f(x)$为完全积性函数，它有以下几个： $\epsilon(x)$，元函数。在$x=1$是为1，否则为0，可以写成$\epsilon(x)=[x=1]$。 $I(x)$，恒等函数。恒为1，$I(x)=1$。 $id(x)$，单位函数。满足$id(x)=x$。 狄利克雷卷积&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的FFT/NTT以及FWT中介绍过很多卷积的快速求法，这里的狄利克雷卷积也是一种卷积，定义如下： (f*g)(x)=\sum_{d|x}f(d)g(\frac {x} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$*$运算定义为$f$卷积$g$，它满足以下运算律： 交换律。即有$f*g=g*f$ 结合律。即有$(f*g)*h=f*(g*h)$ 对加法的分配律。即有$(f+g)*h=f*h+g*h$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;狄利克雷卷积中存在幺元，即元函数$\epsilon$，满足$f*\epsilon=\epsilon*f=f$。 杜教筛&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杜教筛巧妙利用积性函数以及狄利克雷卷积的性质将复杂的前缀和求解问题转化为简单问题，进而降低时间复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如现在我们需要求积性函数$f(x)$的前缀和$\displaystyle\sum_{i=1}^nf(i)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造两个积性函数满足$h=f*g$，那么有： \sum_{i=1}^nh(i)=\sum_{i=1}^n\sum_{d|i}g(d)f(\frac {i} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举因子： \sum_{i=1}^nh(i)=\sum_{d=1}^ng(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记$S(x)=\displaystyle\sum_{i=1}^xf(i)$，那么有： \sum_{i=1}^nh(i)=\sum_{d=1}^ng(d)S(\lfloor\frac{n}{d}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提出第一项： \sum_{i=1}^nh(i)=g(1)S(n)+\sum_{d=2}^ng(d)S(\lfloor\frac{n}{d}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移项： g(1)S(n)=\sum_{i=1}^nh(i)-\sum_{d=2}^ng(d)S(\lfloor\frac{n}{d}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化到这一步，可知如果$h$和$g$的前缀和易求，那么$S(x)$就可以很快地求出来，这就是杜教筛的思想。 模板&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在来用杜教筛求莫比乌斯函数的前缀和。注意到莫比乌斯函数的性质$\displaystyle\sum_{d|n}\mu(d)=[n=1]$，可知有$\mu*I=\epsilon$，那么直接代入上文推出的式子： S(n)=1-\sum_{d=2}^nS(\lfloor\frac{n}{d}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后者整除分块处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑求欧拉函数前缀和，注意到欧拉函数的一个性质$\displaystyle\sum_{d|n}\phi(d)=n$，即有$\phi*I=id$，那么代入公式，得到： S(n)=\sum_{i=1}^ni-\sum_{d=2}^nS(\lfloor\frac{n}{d}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者可以$O(1)$去求，后者整除分块。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后来看如何求$x\phi(x)$的前缀和。可以将$g$设置成单位函数$id$，这样狄利克雷卷积就是： (x\phi*id)(n)=\sum_{d|n}d\phi(d)\frac {n} {d}=n\sum_{d|n}\phi(d)=n^2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以$h(x)=x^2$，代入公式得到： S(n)=\sum_{i=1}^ni^2-\sum_{d=2}^ndS(\lfloor\frac{n}{d}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者有公式： \sum_{i=1}^ni^2=\frac {n(n+1)(2n+1)} {6}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后后者整除分块即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何代码实现呢？首先我们需要预处理$\sqrt n$范围的前缀和，这一步线性筛出，然后利用上面的公式递推，期间需要用hash表保存前缀和结果，可以用map也可以用平衡树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;附模板题代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define N 5000000using namespace std;typedef unsigned long long ull;unordered_map&lt;int, int&gt; mmp1;unordered_map&lt;int, ull&gt; mmp2;int n, prim[N + 5], tot = 0;int ms[N + 5];ull ps[N + 5];bool vis[N + 5];void init() &#123;//预处理，线性筛 ms[1] = ps[1] = 1; for (register int i = 2; i &lt;= N; i++) &#123; if (!vis[i])ps[i] = i - 1, ms[i] = -1, prim[++tot] = i; for (register int j = 1; j &lt;= tot; j++) &#123; if (prim[j] * i &gt; N)break; vis[i * prim[j]] = true; if (i % prim[j])ms[i * prim[j]] = -ms[i], ps[i * prim[j]] = ps[i] * (prim[j] - 1); else &#123; ms[i * prim[j]] = 0, ps[i * prim[j]] = ps[i] * prim[j]; break; &#125; &#125; &#125; for (int i = 2; i &lt;= N; i++)ps[i] += ps[i - 1], ms[i] += ms[i - 1];//前缀和&#125;int getS1(int x) &#123;//莫比乌斯函数 if (x &lt;= N)return ms[x]; if (mmp1.count(x) != 0)return mmp1[x]; register int ans = 0, l = 2, r; while (l &lt;= x) &#123; r = x / (x / l), ans += (r - l + 1) * getS1(x / l), l = r + 1; if (l &lt; 0)break;//防止溢出出错 &#125; return mmp1[x] = 1 - ans;&#125;ull getS2(int x) &#123;//欧拉函数 if (x &lt;= N)return ps[x]; if (mmp2.count(x) != 0)return mmp2[x]; register ull ans = 0; register int l = 2, r; while (l &lt;= x) &#123; r = x / (x / l), ans += (r - l + 1) * getS2(x / l), l = r + 1; if (l &lt; 0)break; &#125; return mmp2[x] = x * (x + 1ll) / 2 - ans;&#125;int main() &#123; init(); register int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; cout &lt;&lt; getS2(n) &lt;&lt; " " &lt;&lt; getS1(n) &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS算法]]></title>
    <url>%2F2019%2F05%2F03%2FBSGS%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BSGS算法（Baby-Step-Giant-Step，大步小步法，简称BSGS），也简称北上广深算法。是一类用于求解高次同余方程的算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入：现在需要解这么一个同余方程： A^x\equiv B(mod\ C)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（这里C是质数）要求使得上式成立的最小x。一种方法是暴力测试，复杂度线性，但是当实际答案特别大时效率低下。BSGS算法可以将其压到根号级别。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要A与C互质。假设$m=\lceil \sqrt C\rceil$（注意这里是向上取整），然后以m为除数，根据带余除法原理可以将x写成$x=im+j$的形式，这样同余式就是： A^{im+j}\equiv B(mod\ C)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然A与C互质，故A的幂次与C也应该互质，那么A的幂次关于C的逆元存在，用它的i次方去乘同余式两侧，得到： A^j\equiv B(A^{-m})^i(mod\ C)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到j的范围是[0, m)中的整数，可以先枚举这个区间中的值，求得数对$(A^j\%C,j)$，把这些数对用hash表存起来。注意对于多个j满足$A^j\%C$为同一个值时，记录最小的j，这是为了保证最后求出的x最小。这一步为算法中的“小步”，时间复杂度$O(\sqrt C)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后枚举右边的i，对于每一个i，求出$B(A^{-m})^i$，然后到hash表中找对应的j，答案即为$x=im+j$，这一步为算法中的“大步”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i的范围如何确定？这里i的取值范围定为$[0,m)$中的整数。取这个范围的原因是如果i在这个范围内都无解，那么$i≥m$时必然也无解。根据j的范围和i的范围，可知x可能的区间是$[0,m(m-1)+m-1]$。这个区间的右端点$m^2-1$一定不比C-1小。根据欧拉定理有$A^{\phi(C)}\equiv 1(mod\ C)$，可知x不可能大于$\phi(C)$，而当C为质数时，$\phi(C)$不会超过C-1，因此所有可能的范围我们都考虑到了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伪模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是求： \frac {10^x-1} {9}\equiv k(mod\ m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m不是3的时候，这个式子等价于： 10^x-1\equiv 9k(mod\ m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么就是： 10^x\equiv 9k+1(mod\ m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当m不是2和5的时候（此时m与10不互质），用BSGS算法解决即可。对于m=2、3、5的情况特判。在乘过程中可能会爆long long，需要用快速乘。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cmath&gt;#include &lt;map&gt;using namespace std;typedef long long ll;ll k, m;map&lt;ll, ll&gt; hs;ll qMutiple(ll a, ll b) &#123;//快速乘 ll ans = 0, s = a; while (b) &#123; if (b &amp; 1)ans = (ans + s) % m; b &gt;&gt;= 1, s = (s &lt;&lt; 1) % m; &#125; return ans;&#125;ll qPow(ll a, ll b) &#123;//快速幂 ll ans = 1ll, s = a; while (b) &#123; if (b &amp; 1)ans = qMutiple(ans, s); b &gt;&gt;= 1, s = qMutiple(s, s); &#125; return ans;&#125;ll BSGS(ll x, ll p) &#123; ll s = static_cast&lt;ll&gt;(sqrt(m * 1.0) + 2), ps = 1ll, tp = 1ll; for (ll i = 0; i &lt; s; i++, ps = qMutiple(ps, x))if (!hs.count(ps))hs[ps] = i; ps = qPow(x, m - s - 1);//Fermat小定理:逆元 for (ll i = 0; i &lt; s; i++, tp = qMutiple(tp, ps)) &#123; if (hs.count(qMutiple(tp, p)))return i * s + hs[qMutiple(tp, p)]; &#125; return -1;//无解-1&#125;int main() &#123; cin &gt;&gt; k &gt;&gt; m; if (m == 2) &#123;//特判 k %= 2; if (k == 0)cout &lt;&lt; -1; else cout &lt;&lt; 1; return 0; &#125; else if (m == 3) &#123; k %= 3; if (k == 0)cout &lt;&lt; 3; else if (k == 1)cout &lt;&lt; 1; else cout &lt;&lt; 2; return 0; &#125; else if (m == 5) &#123; k %= 5; if (k != 1)cout &lt;&lt; -1; else cout &lt;&lt; 1; return 0; &#125; cout &lt;&lt; BSGS(10, (9 * k + 1) % m); return 0;&#125; exBSGS算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当A与C不互质（或者说C为非质数时）BSGS算法是不适用的，此时就需要使用exBSGS算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察下面的同余式： A^x\equiv B(mod\ C)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个结论：若$d=gcd(A,C)$，则当$d\not|C$且$B≠1$时，方程无自然数解，$B=1$时有解0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有解时，将同余式两侧同时去除d，得到： A^{x-1}\frac {A} {d}\equiv \frac {B} {d}(mod\ \frac {C} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就有： A^{x-1}\equiv \frac {B} {d} (\frac {A} {d})^{-1}(mod\ \frac {C} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反复使用这种变换手段，直到满足模数与$A$互质为止，此时用BSGS算法解决。模板题：戳这里，注意这题不要用快速乘（一点也不快）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll gcd(ll x, ll y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;ll exGcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123;//扩展欧几里得 if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll t = exGcd(b, a % b, y, x); y -= a / b * x; return t;&#125;unordered_map&lt;ll, ll&gt; hs;//比map快ll BSGS(ll x, ll p, ll m) &#123; hs.clear(); ll s = static_cast&lt;ll&gt;(sqrt(m * 1.0) + 2), ps = 1ll, tp = 1ll, a, b; for (ll i = 0; i &lt; s; i++, ps = ps * x % m)if (!hs.count(ps))hs[ps] = i; exGcd(ps, m, a, b), ps = (a % m + m) % m;//a为逆元，注意正数化 for (ll i = 0; i &lt; s; i++, tp = tp * ps % m) &#123; if (hs.count(tp * p % m))return i * s + hs[tp * p % m]; &#125; return -1;//无解-1&#125;ll exBSGS(ll a, ll b, ll p) &#123; ll d, k = 0, x, y, ans; while ((d = gcd(a, p)) != 1) &#123; if (b % d)return b == 1 ? 0 : -1; b /= d, p /= d, ++k, exGcd(a / d, p, x, y), x = (x % p + p) % p, b = b * x % p; &#125; return (ans = BSGS(a, b, p)) == -1 ? -1 : ans + k;&#125;int main() &#123; int a, p, b; while (cin &gt;&gt; a &gt;&gt; p &gt;&gt; b) &#123; if (a == 0 &amp;&amp; b == 0 &amp;&amp; p == 0)return 0; ll x = exBSGS(a, b, p); if (x == -1)cout &lt;&lt; "No Solution" &lt;&lt; endl; else cout &lt;&lt; x &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支配树]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点支配问题是图上的一类问题，可以用支配树这一利器解决。 支配点与支配树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个有向图中，如果从x到y的所有路径都会经过一个点r，则称r支配y。对于y的所有支配点，离y最近的一个称为（最近）支配点，记作idom[y]。所有的点引一条边连向idom，可以得到一棵树，称为支配树。支配树的根结点为x，并且从x到y路径上的所有点都支配y，这体现了支配的传递性。 DAG上的支配树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求支配树是一个具有实际意义的问题，下面先从简单情况谈起：对于DAG上的支配树求法。来看一道模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，一个生物的灾难值就是其支配的点的数目，体现在支配树上就是其子树上结点数目减去一。由于可能有多个生产者，我们需要引入一个超级源点作为根，再构造支配树。下面就考虑如何在DAG上构造支配树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，对给定的图进行拓扑排序，得到一个拓扑序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步，按照拓扑序从小到大开始，依次将每一个点放到支配树上。假定现在需要将x这个结点放入支配树中，并且其之前的所有点均已加入支配树。然后求出该结点所有前驱的支配点，该支配点就是x的支配点。这是因为必须经过该结点的某一个前驱才能到达该结点，否则不可达，因此所有前驱共同的支配点就是x的支配点。那如何求前驱的支配点？不要忘了前驱的拓扑序小于x，它们必然已经加入了支配树，因此它们的LCA就是共同的支配点。这里用一步在线求LCA的倍增算法即可完成。时间复杂度为线性对数阶。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define N (65534+50)using namespace std;vector&lt;int&gt; ch[N], ch_opp[N], tree[N];int n, st[N], depth[N], grand[N][20], ans[N], in[N];int t = 0;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void topSort() &#123;//拓扑排序 queue&lt;int&gt; que; for (int i = 1; i &lt;= n; i++) if (!in[i])ch[0].push_back(i), ch_opp[i].push_back(0), que.push(i);//0是超级源点 while (!que.empty()) &#123; int f = que.front(); que.pop(), st[++t] = f;//排序结果放到s中 for (int i = 0; i &lt; ch[f].size(); i++) &#123; --in[ch[f][i]]; if (!in[ch[f][i]]) que.push(ch[f][i]); &#125; &#125;&#125;inline int lca(int x, int y) &#123;//倍增法求LCA if (depth[x] &gt; depth[y])swap(x, y);//y的深度大 if (depth[x] != depth[y]) &#123; for (int i = 17; i &gt;= 0; i--)if (depth[grand[y][i]] &gt;= depth[x])y = grand[y][i]; &#125; if (x == y)return x; for (int i = 17; i &gt;= 0; i--) &#123; if (grand[x][i] != grand[y][i])x = grand[x][i], y = grand[y][i]; &#125; return grand[x][0];&#125;int DFS(int x) &#123; if (tree[x].empty())return ans[x] = 1; for (int i = 0; i &lt; tree[x].size(); i++)ans[x] += DFS(tree[x][i]); return ++ans[x];&#125;int main() &#123; n = read(), depth[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x = read(); while (x)ch[x].push_back(i), ch_opp[i].push_back(x), ++in[i], x = read();//建图 &#125; topSort(); for (int i = 1; i &lt;= n; i++) &#123; int f = ch_opp[st[i]][0];//第一个前驱 for (int j = 1; j &lt; ch_opp[st[i]].size(); j++)f = lca(f, ch_opp[st[i]][j]);//求共同的LCA tree[f].push_back(st[i]), grand[st[i]][0] = f, depth[st[i]] = depth[f] + 1;//更新 for (int j = 1; j &lt;= 17; j++)grand[st[i]][j] = grand[grand[st[i]][j - 1]][j - 1]; &#125; DFS(0);//一遍DFS求子树结点数目 for (int i = 1; i &lt;= n; i++)printf("%d\n", ans[i] - 1);//减去一就是答案 return 0;&#125; Lengauer−Tarjan算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DAG上的求支配树方法比较容易，但是对于可以有环的有向图，支配树便不是那么易求。这里介绍在线性对数时间复杂度下求解有向图支配树的Lengauer-Tarjan算法。 半必经点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要DFS树，对有向图中点进行DFN排序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于x到y，如果存在一条路径使得这条路径上的所有点（除了x和y本身）的DFN都大于DFN[x]，则称x为y的半必经点。这其中DFN值最小的一个称为最小半必经点（半支配点），即为sdom[y]=x。特别地，y的所有前驱结点都是y的半必经点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以证明，在DFS树上，添加sdom[x]到x的有向边后，得到的DAG的支配关系与原图一致，这样可以将有环的有向图转化为DAG，但是这不是很优秀的做法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照DFN从大到小枚举每一个点，对于一个点x，先枚举其前驱，如果其DFN小，则比较其与sdom[x]，取更小的一个。如果前驱DFN大于DFN[x]，则该前驱一定不会成为sdom[x]，这时取前驱在已经构造的树（是指目前已经经过遍历的点及其邻边在DFS树上的部分）上的满足DFN[z]&gt;DFN[x]的祖先z，对比sdom[x]和sdom[z]的DFN来更新x的sdom。这里的操作可以用加权并查集实现，权值定义为到根DFN[sdom[x]]最小的x。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步就是半必经点转支配点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找到sdom[x]到x路径上（不含sdom[x]）使得DFN[sdom[z]]最小的z点，此时如果sdom[z]=sdom[x]，则idom[x]=sdom[x]，否则idom[x]就是idom[z]。模板题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define N 200005#define M 300005using namespace std;struct Edge &#123; int to, next;&#125; edge[M * 5];int head[N], pre[N], cat[N], tree[N], n, m, father[N], DFN[N], DFNCNT, cnt = 1;int sdom[N], idom[N], val[N], fa[N], rk[N], ans[N];inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void add(int *p, int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = p[x], p[x] = cnt++;&#125;void DFS(int x) &#123; DFN[x] = ++DFNCNT, rk[DFNCNT] = x;//建立DFN到点的映射 for (int i = head[x]; i; i = edge[i].next) &#123; if (!DFN[edge[i].to])DFS(edge[i].to), fa[edge[i].to] = x;//记录fa &#125;&#125;int find(int x) &#123; if (father[x] == x)return x; int rt = find(father[x]); if (DFN[sdom[val[father[x]]]] &lt; DFN[sdom[val[x]]])val[x] = val[father[x]]; return father[x] = rt;&#125;inline void tarjan() &#123;//板子... for (int i = DFNCNT; i &gt;= 2; i--) &#123;//反向遍历 int now = rk[i], res = n; for (int j = pre[now]; j; j = edge[j].next) &#123;//处理前驱 if (!DFN[edge[j].to])continue; if (DFN[edge[j].to] &lt; DFN[now])res = min(res, DFN[edge[j].to]);//更新答案 else find(edge[j].to), res = min(res, DFN[sdom[val[edge[j].to]]]); &#125; sdom[now] = rk[res], father[now] = fa[now], add(cat, sdom[now], now), now = fa[now];//并查集合并，图的建立 for (int j = cat[now]; j; j = edge[j].next) &#123;//更新一波idom find(edge[j].to); if (sdom[val[edge[j].to]] == now)idom[edge[j].to] = now;//就是idom[edge[j].to] = sdom[val[edge[j].to]] else idom[edge[j].to] = val[edge[j].to]; &#125; &#125; for (int i = 2, now; i &lt;= DFNCNT; i++) &#123; now = rk[i]; if (idom[now] != sdom[now])idom[now] = idom[idom[now]]; &#125;&#125;int DFS_ans(int x) &#123; if (!tree[x])return ans[x] = 1; for (int i = tree[x]; i; i = edge[i].next)ans[x] += DFS_ans(edge[i].to); return ++ans[x];&#125;int main() &#123; n = read(), m = read(); for (int i = 0; i &lt; m; i++) &#123; int x = read(), y = read(); add(head, x, y), add(pre, y, x);//建立反图 &#125; for (int i = 1; i &lt;= n; i++)val[i] = sdom[i] = father[i] = i;//初始化 DFS(1), tarjan(), cnt = 1; for (int i = 2; i &lt;= n; i++)if (idom[i])add(tree, idom[i], i);//建立支配树 DFS_ans(1); for (int i = 1; i &lt;= n; i++)cout &lt;&lt; ans[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT问题]]></title>
    <url>%2F2019%2F04%2F30%2F2-SAT%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍2-SAT问题及其解决方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SAT问题即Satisfiability（可满足性问题），是指对一串布尔变量，对其进行赋值，使之满足布尔方程的问题。对于每一个约束条件，我们可以将它们写成布尔表达式的形式。比如对于布尔变量$a、b$，布尔表达式$¬a∨b$就是一个约束条件，它的意思是要求a为假或者b为真。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果每一个约束条件只有两个条件（如同上文举的例子），则称其为2-SAT问题，它可以抽象为图，用图论的方式去解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于约束条件$a∨b$，它的意思是a为真或者b为真，这个式子也可以理解成$\lnot a\rightarrow b ∧ \lnot b \rightarrow a$，显然两个式子是等价的。这时我们可以将变量抽象为点，$\rightarrow$引导的关系抽象为有向边，建立有向图。由于取非的存在，顶点数扩大一倍，我们通常用x+n来表示x的取反形式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建完图之后，容易发现同一个强连通分量中的点其真值必然是相同的。因此如果一个变量及其取反形式在同一个强连通分量中，该问题无解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那对于有解的情况，如何确定答案？对有向图tarjan强连通缩点后进行拓扑排序，对于每一个变量，我们认为拓扑序靠后的一个真值为真，靠前的一个为假。比如$\lnot x$拓扑序靠后，其真值为真，因此我们判定$x$为假。这样做的好处是不会出现自相矛盾的情况，重复这个步骤就可以得到一组特解。注意这种方法不能得到全部的解。算法时间复杂度为线性时间复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题：戳这里。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出示例代码，这里利用tarjan缩点本身可以得到反拓扑序相对顺序这一特点省略了拓扑排序过程。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define N 1000005using namespace std;struct Edge &#123; int next, to;&#125; edge[N &lt;&lt; 1];int head[N &lt;&lt; 1], cnt = 1, n, m, color[N &lt;&lt; 1], DFN[N &lt;&lt; 1], LOW[N &lt;&lt; 1], in = 1, ID = 1, vis[N &lt;&lt; 1];inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;stack&lt;int&gt; sta;void tarjan(int x) &#123;//tarjan算法过程 if (DFN[x])return; DFN[x] = LOW[x] = in++, vis[x] = 1, sta.push(x); for (int i = head[x]; i; i = edge[i].next) &#123; if (vis[edge[i].to])LOW[x] = min(DFN[edge[i].to], LOW[x]); else if (!DFN[edge[i].to])tarjan(edge[i].to), LOW[x] = min(LOW[x], LOW[edge[i].to]); &#125; if (DFN[x] == LOW[x]) &#123; int t; do color[t = sta.top()] = ID, vis[t] = 0, sta.pop(); while (t != x); ID++; &#125;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) &#123; int a = read(), b = read(), c = read(), d = read(); if (b &amp;&amp; d)add(a + n, c), add(c + n, a);//建图 else if ((!b) &amp;&amp; d)add(a, c), add(c + n, a + n); else if (b)add(a + n, c + n), add(c, a); else add(a, c + n), add(c, a + n); &#125; for (int i = 1; i &lt;= (n &lt;&lt; 1); i++)tarjan(i);//tarjan缩点 for (int i = 1; i &lt;= n; i++) &#123; if (color[i] == color[i + n]) &#123;//在同一个强连通分量中无解 cout &lt;&lt; "IMPOSSIBLE"; return 0; &#125; &#125; cout &lt;&lt; "POSSIBLE" &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; if (color[i] &lt; color[i + n])cout &lt;&lt; "1 ";//注意是反拓扑序 else cout &lt;&lt; "0 "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>图论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卢卡斯定理]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个模板。卢卡斯定理用于大组合数求模运算。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先引入卢卡斯定理。 【卢卡斯定理】对于整数$n，m（m&gt;0）和质数p，$若$n=sp+q , m=tp+r$，则有$C^{n}_m mod\ p=C^s_tC^q_r mod\ p$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明略。该定理可以用于快速求大组合数对某个质数的模。这里有模板题。123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;long long n, m, p, op[100005];long long qPow(long long a, long long p) &#123;//快速幂 long long b = p - 2ll, s = a, ans = 1ll; while (b &gt; 0) &#123; if (b &amp; 1)ans = ans * s % p; s = s * s % p, b &gt;&gt;= 1; &#125; return ans;&#125;long long C(long long a, long long b, long long p) &#123; if (b &lt; a)return 0ll;//仍然注意边界处理 long long s = op[a] * op[b - a] % p;//根据定义式，求分子 return op[b] * qPow(s, p) % p;//乘法逆元处理&#125;long long lucas(long long x, long long y, long long p) &#123; if (x == 0)return 1ll;//注意处理边界 return lucas(x / p, y / p, p) * C(x % p, y % p, p) % p;//后者直接求，前者递归求&#125;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; op[0] = op[1] = 1ll; for (int i = 2; i &lt;= p; i++)op[i] = op[i - 1] * i % p;//预处理阶乘 cout &lt;&lt; lucas(m, m + n, p) &lt;&lt; endl; &#125; return 0;&#125; 扩展卢卡斯&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果模数不是质数，卢卡斯定理便不再适用，这个时候如何求解组合数的模？需要用到扩展卢卡斯，只不过这一个算法与卢卡斯定理并没有什么关系，它需要前缀知识：扩展欧几里得算法和中国剩余定理（CRT）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于模数mod，根据整数分解唯一性定理，可以将其分解成下面的形式： mod=\prod p^s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果可以求出$C_n^m$对$p^s$的模，那么可以利用CRT合并答案，问题转化为如何求组合数对质数的幂次的模。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于分母不一定与质数幂次互质，其逆元不一定存在，无法用逆元来求模。这里可以根据组合数定义： C_n^m=\frac {n!} {m!(n-m)!}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将分子分母的所有因子p单独提出，这样就可以用逆元了，最后再乘上这些p因子乘积对$p^s$的模即可。下面考虑如何在剔除因子p的情况下快速求解阶乘。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在假设要求解$x!$，质数为$p$，模数为$p^s$。将x分成几块：$1$到$p^s$是第一块，$p^s+1$到$2p^s$是第二块，依次类推，最后剩余的数暂且不去管它。可以发现，每一块都含有相同数量的p的倍数，并且对于每一块，将这些p的倍数剔除，剩下的数乘起来模$p^s$的值都是相同的。对于x来说，这样的块有$\lfloor \frac {x} {p^s} \rfloor$块，这样只需求解第一块除去p的倍数的数的乘积，再用一个快速幂即可。对于剩下的数，将它们暴力乘起来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在已经处理了所有非p的倍数，对于p的倍数，将它们依次除去因子p（前文已经说明需要剔除因子p），可以得到一个阶乘，容易知道这个阶乘是$\lfloor \frac {x} {p}\rfloor !$，递归求解即可，递归终止条件是$0!=1$。12345678ll fac(ll a, ll p, ll pk) &#123;//求阶乘：a!，p是质数，pk是p的幂次，这里定义long long 为ll ll ans = 1ll; if (a == 0)return 1ll; for (ll i = 2; i &lt;= pk; i++)if (i % p)ans = ans * i % pk;//第一块 ans = qPow(ans, a / pk, pk);//qPow是快速幂 for (ll i = 2; i &lt;= a % pk; i++)if (i % p)ans = ans * i % pk;//暴力处理剩余的 return ans * fac(a / p, p, pk) % pk;//递归&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那现在如何知道$x!$中有多少p的因子呢？首先p的倍数有$\lfloor \frac {x} {p}\rfloor$个，将它们全部除以p，得到一个阶乘$\lfloor \frac {x} {p}\rfloor !$，再计入它的p因子数目即可。若令$f(x)$表示$x!$中因子p的数目，由此得到递推式： f(x)=f(\lfloor \frac {x} {p}\rfloor)+\lfloor \frac {x} {p} \rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样组合数求解函数就可以写出了：12345678ll C(ll a, ll b, ll p, ll pk) &#123; ll x = fac(a, p, pk), y = fac(b, p, pk), z = fac(a - b, p, pk);//先求阶乘 ll k = 0; for (ll i = a; i; i /= p)k += i / p;//递归求p因子数目 for (ll i = b; i; i /= p)k -= i / p; for (ll i = a - b; i; i /= p)k -= i / p;//这是k就是提出来的p因子数目 return x * inv(y, pk) % pk * inv(z, pk) % pk * qPow(p, k, pk) % pk;//inv是逆元&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来一步中国剩余定理即可：12345678910111213141516ll CRT(ll a, ll m, ll mod) &#123;//中国剩余定理 return a * inv(mod / m, m) % mod * (mod / m) % mod;&#125;ll exLucas(ll n, ll m, ll mod) &#123;//扩展卢卡斯主函数 ll ans = 0ll, tmp = mod, pk; for (ll i = 2; i * i &lt;= tmp; i++) &#123; if (tmp % i == 0) &#123; pk = 1ll; while (tmp % i == 0)pk = pk * i, tmp /= i; ans = (ans + CRT(C(n, m, i, pk), pk, mod)) % mod; &#125; &#125; if (tmp &gt; 1)ans = (ans + CRT(C(n, m, tmp, tmp), tmp, mod)) % mod; return ans;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于模数不一定是质数，故采用扩展欧几里得的方式来求逆元：123456789101112131415ll exGcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123;//扩展欧几里得 if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll r = exGcd(b, a % b, y, x); y -= a / b * x; return r;&#125;ll inv(ll a, ll b) &#123;//求逆元 ll x, y; exGcd(a, b, x, y); return (x % b + b) % b;//保证非负&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;附模板题全代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll exGcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll r = exGcd(b, a % b, y, x); y -= a / b * x; return r;&#125;ll qPow(ll a, ll b, ll mod) &#123; ll ans = 1ll, sta = a; while (b) &#123; if (b &amp; 1)ans = ans * sta % mod; sta = sta * sta % mod, b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll a, ll b) &#123; ll x, y; exGcd(a, b, x, y); return (x % b + b) % b;&#125;ll CRT(ll a, ll m, ll mod) &#123; return a * inv(mod / m, m) % mod * (mod / m) % mod;&#125;ll fac(ll a, ll p, ll pk) &#123; ll ans = 1ll; if (a == 0)return 1ll; for (ll i = 2; i &lt;= pk; i++)if (i % p)ans = ans * i % pk; ans = qPow(ans, a / pk, pk); for (ll i = 2; i &lt;= a % pk; i++)if (i % p)ans = ans * i % pk; return ans * fac(a / p, p, pk) % pk;&#125;ll C(ll a, ll b, ll p, ll pk) &#123; ll x = fac(a, p, pk), y = fac(b, p, pk), z = fac(a - b, p, pk); ll k = 0; for (ll i = a; i; i /= p)k += i / p; for (ll i = b; i; i /= p)k -= i / p; for (ll i = a - b; i; i /= p)k -= i / p; return x * inv(y, pk) % pk * inv(z, pk) % pk * qPow(p, k, pk) % pk;&#125;ll exLucas(ll n, ll m, ll mod) &#123; ll ans = 0ll, tmp = mod, pk; for (ll i = 2; i * i &lt;= tmp; i++) &#123; if (tmp % i == 0) &#123; pk = 1ll; while (tmp % i == 0)pk = pk * i, tmp /= i; ans = (ans + CRT(C(n, m, i, pk), pk, mod)) % mod; &#125; &#125; if (tmp &gt; 1)ans = (ans + CRT(C(n, m, tmp, tmp), tmp, mod)) % mod; return ans;&#125;int main() &#123; ll n, m, mod; cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod; cout &lt;&lt; exLucas(n, m, mod); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Polya定理]]></title>
    <url>%2F2019%2F04%2F29%2FPolya%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍Polya定理，在OI中常用于计数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍Polya定理前，需要有一些前缀知识。 群&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;群是一种代数系统。对于一个非空集合和定义在它上面的运算组成的系统称为代数系统。这里定义集合为$S$，运算为$*$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;群满足以下条件： 封闭性。对于任意$a\in S,b\in S$，有$a*b\in S$。 满足结合律。即有$a*(b*c)=(a*b)*c$。 存在幺元。即有$e\in S$，满足$a*e=e*a=a$。 存在逆元。即对于$a\in S$，存在$a^{-1}\in S$满足$a*a^{-1}=e$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意群不一定满足交换律。 置换与置换群&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于1~n这n个元素的一个排列，通过(1~n)-&gt;(1~n)元素的一一映射关系得到另一个排列，称为一个置换。下面就表示一个置换： \begin{pmatrix} 1&2&3&4\\ 4&3&1&2 \end{pmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于n个元素，其n!个不同的置换组成集合$S$。定义$\bigodot$表示置换的左复合运算，即对于$x,y\in S$，有$x\bigodot y$表示对这n个元素先应用x置换，再应用y置换。比如： \begin{pmatrix} 1&2&3&4\\ 4&3&1&2 \end{pmatrix} \bigodot \begin{pmatrix} 2&3&1&4\\ 3&1&2&4 \end{pmatrix}= \begin{pmatrix} 1&2&3&4\\ 4&1&2&3 \end{pmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以证明$S$与运算$\bigodot$形成一个群，这个群的任一子群称为置换群。 Burnside引理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于集合$S$和其置换群，由该置换群上的置换诱导形成的等价关系必然可以将$S$划分为若干个等价类。这里的直观理解是：当$S$上的一个元素可以通过置换群中的置换操作得到另一个元素，则它们在一个等价类中。计算等价类数量是一个具有实际意义的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个元素经过某一个置换$P$得到它本身，则称该元素为置换$P$下的不动点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【Burnside（伯恩赛德）引理】由S的置换群&lt;$G,\bigodot$&gt;诱导的等价关系将$S$划分所得的等价类数目等于： \frac {1} {|G|}\sum_{\pi \in G}\psi(\pi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\psi(\pi)$为置换$\pi$的不动点数目。 Ploya定理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Burnside定理确实可以计数，但是时间复杂度高，这里就引入了Polya定理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里用一个实际例子：给定一个含有n个珠子串起来的环，用m种不同的颜色给它们染色，有多少种本质不同的染色方案？这里的本质不同是指不能通过旋转得到另一个染色方案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个问题里，我们对n个珠子从上面开始，顺时针编号1~n，这就是一个排列。它可以通过旋转这一种置换得到另一个排列，比如对于n=4时，起初排列为：1、2、3、4，顺时针旋转一个单位得到排列4、1、2、3，这是一个置换。这同时说明1、2、3、4与4、1、2、3在一个等价类中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个置换中，如果将1~n看成点，映射关系看成有向边，则得到了一个有向图。我们定义有向图中强连通分量的数目为该置换的循环节数目，每一个强连通分量就称为循环节。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了应用Burnside引理，下面考虑如何求置换的不动点数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一种染色方案经置换$\pi$后不变，那么该置换每一个循环节内部点的颜色必然相同，不同循环节的颜色互不干扰。如果定义$c(\pi)$为置换$\pi$的循环节数目，显然不动点数目就是$m^{c(\pi)}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时应用Burnside引理可以得到等价类数目： \frac {1} {|G|}\sum_{\pi\in G}m^{c(\pi)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是总的方案数，同时我们也得到了Polya定理的表达形式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在旋转中，可以得到一个结论：旋转k步对应置换的循环节数目为$gcd(k,n)$。除了旋转还有翻转这一个置换类型，有结论：n为奇数时，循环节数目为$\frac {n} {2}+1$；n为偶数时，若翻转线穿过珠子，则为$\frac {n} {2}+1$，否则为$\frac {n} {2}$。 示例模板&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题：戳这里。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里只有旋转操作，应用Polya定理，答案即为： \frac {1} {n} \sum_{i=1}n^{gcd(i,n)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的置换定义为：不旋转、顺时针旋转1位、…、顺时针旋转n-1位，它们满足群的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是求解这个求和式的时间复杂度是$O(n)$的，容易TLE，考虑优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举$gcd(i,n)$，得到： \frac {1} {n}\sum_{d|n}\phi(\frac {n} {d})n^d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\phi(x)$是欧拉函数，这里用定义式去求解，总体时间复杂度为$O(\sqrt n)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define MOD (1000000000+7)using namespace std;typedef long long ll;ll euler(int x) &#123;//求欧拉函数 ll ans = 1; for (ll i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; ans *= (i - 1), x /= i; while (x % i == 0)ans *= i, x /= i; &#125; &#125; if (x &gt; 1)ans *= (x - 1); return ans;&#125;ll qPow(int a, int b) &#123;//快速幂 ll ans = 1, s = a; while (b &gt; 0) &#123; if (b &amp; 1)ans = (ans * s) % MOD; s = (s * s) % MOD, b &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); int t, x; ll inv, ans; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; x; inv = qPow(x, MOD - 2);//逆元 ans = 0ll; for (int i = 1; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; ans = (ans + euler(i) * qPow(x, x / i)) % MOD; if (i * i != x)ans = (ans + euler(x / i) * qPow(x, i)) % MOD; &#125; &#125; ans = ans * inv % MOD; cout &lt;&lt; ans &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫比乌斯反演及常见套路，不涉及证明。莫比乌斯反演难在公式推导和应用。 整除分块&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍莫比乌斯反演之前，先了解整除分块。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整除分块需要解决的问题是，如何求解下面的求和式： \sum_{i=1}^n \lfloor \frac {n} {i}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然可以$O(n)$解决，但那样在某些问题中不是正确复杂度。注意求和元素有许多重复的部分，它们呈块状分布，并且可以发现每一个块中，最右边的值为n/(n/l)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么就可以得到下面的快速计算算法：12345int solve(int x) &#123; int l = 1, r, ans = 0; while (l &lt;= x)r = x / (x / l), ans += (r - l + 1) * (x / l), l = r + 1; return ans;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是整除分块算法，可以在$O(\sqrt n)$下完成上面求和式的计算。有时候右边的求和元素可能乘一个函数，这时维护一下前缀和即可。 莫比乌斯函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫比乌斯函数$\mu(x)$是莫比乌斯反演中的重要函数，它是定义在正整数集下的函数，具体定义如下： $\mu(1)=1$ 当$x=\displaystyle\prod_{i=1}^s p_i^{\alpha_i}$时（这里p为质数），如果所有的质数指数$\alpha_i$均为1，则$\mu(x)=(-1)^s$，否则为0。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫比乌斯函数可以通过线性筛筛出来，类似筛欧拉函数的过程，只需将欧拉筛修改一下即可：123456789101112131415int mu[N+1] = &#123;0&#125;;//记录莫比乌斯函数值int mark[N+1] = &#123;0&#125;;//记录是不是素数int prim[N+1], tot = 0;//储存当前已知的素数,tot记录个数for (int i = 2; i &lt;= N; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; mu[i] = -1;//判断为素数,直接给莫比乌斯函数赋值 &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (i * prim[j] &gt; N)break; mark[i * prim[j]] = 1;//标记这个数一定不是素数 if (i % prim[j] == 0)break;//其实应该赋0，但是初始化即为0，省略这一步 else mu[i * prim[j]] = -mu[i]; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别忘了mu[1]=1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫比乌斯函数有以下性质： 对于任何正整数n，有$\displaystyle\sum_{d|n}\mu(d)=[n=1]$，这里[P]在P条件成立时为1，否则为0。这个性质很常用。 莫比乌斯函数与欧拉函数的关系：$\displaystyle\sum_{d|n}\frac {\mu(d)} {d}=\frac {\phi(n)} {n}$ 莫比乌斯函数是积性函数，即在$gcd(a,b)=1$时，有$\mu(ab)=\mu(a)\mu(b)$。 莫比乌斯反演定理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个定义在自然数集上的函数$F(x)$和$f(x)$，若有： F(x)=\sum_{d|x}f(d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么有： f(x)=\sum_{d|x}\mu(d)F(\frac {x} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个定理称为莫比乌斯反演定理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫比乌斯反演定理还有另一种形式，当$F(x)$和$G(x)$满足： F(x)=\sum_{x|d}f(d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么有： f(x)=\sum_{x|d}\mu(\frac {d} {x})F(d)关于公式推导&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫比乌斯反演的应用难在推导，这里介绍几个必要的公式。 \sum_{i=1}^n\sum_{j=1}^ma_ib_j=(\sum_{i=1}^na_i)(\sum_{j=1}^mb_j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个比较显然的结论。 \lfloor \frac {x} {ab} \rfloor=\lfloor \frac {\lfloor\frac {x} {a}\rfloor} {b}\rfloor=\lfloor \frac {\lfloor\frac {x} {b}\rfloor} {a}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子也有简化运算的功能，证明如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设$x=kab+p,0\leq p&lt;ab$，则$\lfloor \frac {x} {ab} \rfloor=k$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么可以推得$\lfloor \frac {x} {a}\rfloor=kb+\lfloor \frac {p} {a} \rfloor$。从而$\lfloor \frac {\frac {x} {a}} {b}\rfloor=k+\lfloor \frac {\lfloor \frac {p} {a} \rfloor} {b}\rfloor$。由于$p&lt;ab$，故后一项必然为0。得证。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子有一个推论：如果$\lfloor \frac {n} {a}\rfloor=\lfloor \frac {n} {b}\rfloor$，那么有$\lfloor \frac {n} {pa}\rfloor=\lfloor \frac {n} {pb}\rfloor$，这里p是正整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其余以后更新。 经典例题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍几个例题，不涉及题面，可点开标题链接自查。 ZAP-Queries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等价于求： \sum_{i=1}^a\sum_{j=1}^b[gcd(i,j)=d]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$[P]$在P条件成立时为1，否则为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于gcd的莫比乌斯反演题目，大多走两个套路，这里是第一种：设$\displaystyle f(x)=\sum_{i=1}^a\sum_{j=1}^b[gcd(i,j)=x]$，并设$\displaystyle g(x)=\sum_{i=1}^a\sum_{j=1}^b[gcd(i,j)=sx]$，s为正整数。容易发现，有下面的关系： g(x)=\sum_{x|y}f(y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫比乌斯反演一步得到： f(x)=\sum_{x|y}\mu(\frac {y} {x})g(y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到g(x)是可以直接求出来的： g(x)=\lfloor \frac {a} {x}\rfloor\lfloor\frac {b} {x}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么f(x)就是： f(x)=\sum_{x|y}\mu(\frac {y} {x})\lfloor \frac {a} {y}\rfloor\lfloor\frac {b} {y}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为： f(d)=\sum_{d|y}\mu(\frac {y} {d})\lfloor \frac {a} {y}\rfloor\lfloor\frac {b} {y}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举$\frac {y} {d}$，可以得到： f(d)=\sum_{i=1}^{\lfloor \frac {a} {d} \rfloor}\mu(i)\lfloor \frac {a} {id}\rfloor\lfloor\frac {b} {id}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要满足$a\leq b$。到这一步就可以计算了，后面的求和式用整除分块去计算。时间复杂度$O(\sqrt n)$，相当高效。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define N 50000using namespace std;typedef long long ll;int mu[N + 1], prim[N + 1], mark[N + 1], tot, n, m, k;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void getMu() &#123;//求莫比乌斯函数 for (int i = 2; i &lt;= N; i++) &#123; if (!mark[i])prim[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot; j++) &#123; if ((ll) i * prim[j] &gt; N)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0)break; else mu[i * prim[j]] = -mu[i]; &#125; &#125; mu[1] = 1;&#125;int main() &#123; int t = read(); getMu(); for (int i = 1; i &lt;= N; i++)mu[i] += mu[i - 1];//维护前缀和 while (t--) &#123; n = read(), m = read(), k = read(); if (n &gt; m)swap(n, m); int l = 1, r; ll ans = 0; while (l &lt;= n) &#123; r = min(n / (n / l), m / (m / l)); ans += (ll) (n / (l * k)) * (m / (l * k)) * (mu[r] - mu[l - 1]); l = r + 1; &#125; printf("%lld\n", ans); &#125; return 0;&#125; YY的GCD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实就是求： \sum_{i=1}^N\sum_{j=1}^M[gcd(i,j)=p],p\in prime,N\leq M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接用上一个问题的结论，得到： \sum_{p\in prime}\sum_{i=1}^{\lfloor \frac {N} {p} \rfloor}\mu(i)\lfloor \frac {N} {ip}\rfloor\lfloor\frac {M} {ip}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举ip，得到： \sum_{i=1}^N\sum_{t|i,t\in prime}\mu(\frac {i} {t})\lfloor \frac {N} {i}\rfloor\lfloor\frac {M} {i}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是： \sum_{i=1}^N\lfloor \frac {N} {i}\rfloor\lfloor\frac {M} {i}\rfloor\sum_{t|i,t\in prime}\mu(\frac {i} {t})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后一个求和式可以用埃氏筛法的形式筛出来，然后整除分块处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define N 10000000using namespace std;typedef long long ll;int mu[N + 1], prim[N + 1], mark[N + 1], tot, n, m;ll sum[N + 1];inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void getMu() &#123; for (int i = 2; i &lt;= N; i++) &#123; if (!mark[i])prim[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot; j++) &#123; if ((ll) i * prim[j] &gt; N)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0)break; else mu[i * prim[j]] = -mu[i]; &#125; &#125; mu[1] = 1;&#125;int main() &#123; int t = read(); getMu(); for (int i = 1; i &lt;= tot; i++) &#123; for (int j = 1; (ll) prim[i] * j &lt; N; j++)sum[prim[i] * j] += mu[j];//筛后一个求和式的过程 &#125; for (int i = 1; i &lt; N; i++)sum[i] += sum[i - 1]; while (t--) &#123; n = read(), m = read(); if (n &gt; m)swap(n, m); int l = 1, r; ll ans = 0; while (l &lt;= n) &#123; r = min(n / (n / l), m / (m / l)); ans += (ll) (n / l) * (m / l) * (sum[r] - sum[l - 1]); l = r + 1; &#125; printf("%lld\n", ans); &#125; return 0;&#125; 约数个数和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已经描述的很明确了，求： \sum_{i=1}^N\sum_{j=1}^Md(ij)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$d(x)$为x的约数个数，这里有一个公式： d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实我并不会证，然后原式即为： \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd问题第二个套路出现了：利用莫比乌斯函数性质得到： \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}\sum_{d|gcd(i,j)}\mu(d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举d： \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}\sum_{d=1}^N\mu(d)[d|gcd(x,y)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提出d所在的求和： \sum_{d=1}^N\mu(d)\sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[d|gcd(x,y)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举因子，这个操作很常用： \sum_{d=1}^N\mu(d)\sum_{i=1}^N\sum_{j=1}^M[d|gcd(i,j)]\lfloor \frac {N} {i}\rfloor\lfloor \frac {M} {j}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只枚举i、j关于d的倍数，得到： \sum_{d=1}^N\mu(d)\sum_{i=1}^{\lfloor \frac {N} {d}\rfloor}\sum_{j=1}^{\lfloor \frac {M} {d}\rfloor}\lfloor \frac {N} {id}\rfloor\lfloor \frac {M} {jd}\rfloor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是： \sum_{d=1}^N\mu(d)(\sum_{i=1}^{\lfloor \frac {N} {d}\rfloor}\lfloor \frac {N} {id}\rfloor)(\sum_{j=1}^{\lfloor \frac {M} {d}\rfloor}\lfloor \frac {M} {jd}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样仍然不容易看出算法来，再来一步： \sum_{d=1}^N\mu(d)(\sum_{i=1}^{\lfloor \frac {N} {d}\rfloor}\lfloor \frac {\lfloor\frac {N} {d}\rfloor} {i}\rfloor)(\sum_{j=1}^{\lfloor \frac {M} {d}\rfloor}\lfloor \frac {\lfloor\frac {M} {d}\rfloor} {j}\rfloor)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后面两个求和都是整除分块的前缀和，预处理一下，再用整除分块求和即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define N 50000using namespace std;typedef long long ll;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;ll s[N + 5];int mu[N + 5], prim[N + 5], tot, mark[N + 5];inline void init() &#123; for (int i = 2; i &lt;= N; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; mu[i] = -1; &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (prim[j] * (ll) i &gt; N)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0)break; mu[i * prim[j]] = -mu[i]; &#125; &#125; mu[1] = 1; for (int i = 2; i &lt;= N; i++)mu[i] += mu[i - 1];//前缀和 for (int i = 1; i &lt;= N; i++) &#123;//预处理 int l = 1, r; while (l &lt;= i)r = i / (i / l), s[i] += (ll) (r - l + 1) * (i / l), l = r + 1; &#125;&#125;int main() &#123; int t = read(), n, m; init(); while (t--) &#123; n = read(), m = read(); if (n &gt; m)swap(n, m); int l = 1, r; ll ans = 0; while (l &lt;= n)r = min(n / (n / l), m / (m / l)), ans += (mu[r] - mu[l - 1]) * s[n / l] * s[m / l], l = r + 1; printf("%lld\n", ans); &#125; return 0;&#125; Problem b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实就是第一个问题的修改版，它的下界不再为1。这里需要用到容斥原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义： S(i,j)=\{(x,y)|1\leq x\leq i,1\leq y\leq j,gcd(x,y)=k\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义我们需要求的集合为A，那么有关系： S(b,d)-A=S(a-1,d)\cup S(b,c-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以： |A|=|S(b,d)|-|S(a-1,d)\cup S(b,c-1)|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后者用一步容斥原理： |S(a-1,d)\cup S(b,c-1)|=|S(a-1,d)|+|S(b,c-1)|-|S(a-1,c-1)|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以答案即为： |S(b,d)|-|S(a-1,d)|-|S(b,c-1)|+|S(a-1,c-1)|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就转化为第一个问题了，直接求四遍即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define N 50000using namespace std;typedef long long ll;int mu[N + 1], prim[N + 1], mark[N + 1], tot, k, a, b, c, d;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;inline void getMu() &#123;//求莫比乌斯函数 for (int i = 2; i &lt;= N; i++) &#123; if (!mark[i])prim[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot; j++) &#123; if ((ll) i * prim[j] &gt; N)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0)break; else mu[i * prim[j]] = -mu[i]; &#125; &#125; mu[1] = 1;&#125;ll getAns(int n, int m) &#123; if (n &gt; m)swap(n, m); int l = 1, r; ll ans = 0; while (l &lt;= n) &#123; r = min(n / (n / l), m / (m / l)); ans += (ll) (n / (l * k)) * (m / (l * k)) * (mu[r] - mu[l - 1]); l = r + 1; &#125; return ans;&#125;int main() &#123; int t = read(); getMu(); for (int i = 1; i &lt;= N; i++)mu[i] += mu[i - 1]; while (t--) &#123; a = read(), b = read(), c = read(), d = read(), k = read(); printf("%lld\n", getAns(b, d) - getAns(b, c - 1) - getAns(a - 1, d) + getAns(a - 1, c - 1)); &#125; return 0;&#125; Crash的数字表格&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本质上是求： \sum_{i=1}^N\sum_{j=1}^Mlcm(i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是： \sum_{i=1}^N\sum_{j=1}^M\frac {ij} {gcd(i,j)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举最大公因数： \sum_{d=1}^N\sum_{i=1}^N\sum_{j=1}^M\frac {ij} {d} [gcd(i,j)=d]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只枚举d的倍数： \sum_{d=1}^Nd\sum_{i=1}^{\lfloor \frac {N}{d}\rfloor}\sum_{j=1}^{\lfloor \frac {M}{d}\rfloor}ij[gcd(i,j)=1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用gcd的第二个套路，得到： \sum_{d=1}^Nd\sum_{i=1}^{\lfloor \frac {N}{d}\rfloor}\sum_{j=1}^{\lfloor \frac {M}{d}\rfloor}ij\sum_{x|gcd(i,j)}\mu(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举x，这一步转化已经用了很多次了： \sum_{d=1}^Nd\sum_{x=1}^{\lfloor \frac {N}{d}\rfloor}\mu(x)\sum_{i=1}^{\lfloor \frac {N}{d}\rfloor}\sum_{j=1}^{\lfloor \frac {M}{d}\rfloor}ij[x|gcd(i,j)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只枚举x的倍数，这一步也很常用： \sum_{d=1}^Nd\sum_{x=1}^{\lfloor \frac {N}{d}\rfloor}x^2\mu(x)\sum_{i=1}^{\lfloor \frac {N}{dx}\rfloor}\sum_{j=1}^{\lfloor \frac {M}{dx}\rfloor}ij&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样不好看，来一步转化： \sum_{d=1}^Nd\sum_{x=1}^{\lfloor \frac {N}{d}\rfloor}x^2\mu(x)(\sum_{i=1}^{\lfloor \frac {\lfloor \frac {N}{d}\rfloor}{x}\rfloor}i)(\sum_{j=1}^{\lfloor \frac {\lfloor \frac {M}{d}\rfloor}{x}\rfloor}j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后面是一个等差数列求和，而$x^2\mu(x)$可以线性筛出，套一个整除分块即可。代码常数大一些，可以卡常过去。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define MOD 20101009#define N 10000000using namespace std;typedef long long ll;int mu[N + 1], prim[N + 1], mark[N + 1], tot, n, m;inline void getMu() &#123;//求莫比乌斯函数 for (int i = 2; i &lt;= N; i++) &#123; if (!mark[i])prim[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot; j++) &#123; if ((ll) i * prim[j] &gt; N)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0)break; else mu[i * prim[j]] = -mu[i]; &#125; &#125; mu[1] = 1; for (int i = 1; i &lt;= N; i++)mu[i] = 1ll * i * i % MOD * 1ll * mu[i] * 1ll % MOD; for (int i = 1; i &lt;= N; i++)mu[i] = (mu[i] + mu[i - 1]) % MOD;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; getMu(); if (n &gt; m)swap(n, m); long long ans = 0ll, inv = 10050505ll;//这是逆元 for (int i = 1; i &lt;= n; i++) &#123; int p = n / i, l = 1, r; long long sum = 0, tmp = 1l; while (l &lt;= p) &#123; tmp = 1l; r = min(p / (p / l), (m / i) / (m / i / l)); tmp = tmp * (1ll * mu[r] - 1ll * mu[l - 1]) % MOD; tmp = tmp * (1ll + p / l) % MOD * 1ll * (p / l) % MOD * 1ll * inv % MOD; tmp = tmp * (1ll + m / i / l) % MOD * 1ll * (m / i / l) % MOD * 1ll * inv % MOD; sum = (sum + tmp) % MOD; l = r + 1; &#125; ans = (ans + sum * 1ll * i) % MOD; &#125; cout &lt;&lt; (ans + MOD) % MOD; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速沃尔什变换（FWT）]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%EF%BC%88FWT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速沃尔什变换（FWT）是一类解决位运算卷积问题的算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看下面一个式子： c_k=\sum_{i+j=k}a_ib_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这明显是一个卷积，可以通过FFT或者NTT（MTT）解决，但是如果遇到了下面的情况： c_k=\sum_{i\bigoplus j=k}a_ib_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$\bigoplus$是位运算（or、ans、xor），如何求卷积？这就是快速沃尔什变换解决的问题，它可以在$O(nlogn)$复杂度下解决问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FWT的优化思想与FFT相同：构造映射tf，使得下面式子成立： tf(A*B)=tf(A)tf(B)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面的乘号$*$是卷积乘法。同样需要反向映射utf满足： utf(tf(A))=A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需要将tf和utf运算压至$O(nlogn)$即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FWT中有着分治思想：将长度为2的方幂的序列一分为2，即将序列$A$分为$A_0$和$A_1$，记为$A=(A_0,A_1)$。则三类位运算的tf与utf构造方法如下： or运算tf(A)=(tf(A_0),tf(A_0)+tf(A_1))\\ utf(A)=(utf(A_0),utf(A_1)-utf(A_0))and运算tf(A)=(tf(A_0)+tf(A_1),tf(A_1))\\ utf(A)=(utf(A_0)-utf(A_1),utf(A_1))xor运算tf(A)=(tf(A_0)+tf(A_1),tf(A_0)-tf(A_1))\\ utf(A)=(\frac {utf(A_0)+utf(A_1)} {2},\frac {utf(A_0)-utf(A_1)} {2})代码模板&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明略。模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将FFT的板子改一改就可以得到FWT的板子，注意取模。除以2时需要转化为乘2的逆元499122177。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define MOD 998244353using namespace std;typedef long long ll;ll f[1 &lt;&lt; 20], g[1 &lt;&lt; 20], a[1 &lt;&lt; 20], b[1 &lt;&lt; 20];int n;inline void FWT_or(ll *s, int type) &#123; for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) &#123; for (int len = mid &lt;&lt; 1, j = 0; j &lt; n; j += len) &#123; for (int k = 0; k &lt; len &gt;&gt; 1; k++) &#123; s[j + mid + k] = (s[j + mid + k] + type * s[j + k]) % MOD; &#125; &#125; &#125;&#125;inline void FWT_and(ll *s, int type) &#123; for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) &#123; for (int len = mid &lt;&lt; 1, j = 0; j &lt; n; j += len) &#123; for (int k = 0; k &lt; len &gt;&gt; 1; k++) &#123; s[j + k] = (s[j + k] + type * s[j + mid + k]) % MOD; &#125; &#125; &#125;&#125;inline void FWT_xor(ll *s, int type) &#123; for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) &#123; for (int len = mid &lt;&lt; 1, j = 0; j &lt; n; j += len) &#123; for (int k = 0; k &lt; len &gt;&gt; 1; k++) &#123; ll v = s[j + k]; s[j + k] = (s[j + k] + s[j + mid + k]) % MOD, s[j + k + mid] = (v - s[j + mid + k]) % MOD; if (type == -1)s[j + k] = s[j + k] * 499122177 % MOD, s[j + k + mid] = s[j + k + mid] * 499122177 % MOD; &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; n = 1 &lt;&lt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; f[i]; for (int i = 0; i &lt; n; i++)cin &gt;&gt; g[i]; for (int i = 0; i &lt; n; i++)a[i] = f[i], b[i] = g[i]; FWT_or(a, 1), FWT_or(b, 1); for (int i = 0; i &lt; n; i++)a[i] = a[i] * b[i] % MOD; FWT_or(a, -1); for (int i = 0; i &lt; n; i++)cout &lt;&lt; (a[i] + MOD) % MOD &lt;&lt; " "; cout &lt;&lt; endl; for (int i = 0; i &lt; n; i++)a[i] = f[i], b[i] = g[i]; FWT_and(a, 1), FWT_and(b, 1); for (int i = 0; i &lt; n; i++)a[i] = a[i] * b[i] % MOD; FWT_and(a, -1); for (int i = 0; i &lt; n; i++)cout &lt;&lt; (a[i] + MOD) % MOD &lt;&lt; " "; cout &lt;&lt; endl; for (int i = 0; i &lt; n; i++)a[i] = f[i], b[i] = g[i]; FWT_xor(a, 1), FWT_xor(b, 1); for (int i = 0; i &lt; n; i++)a[i] = a[i] * b[i] % MOD; FWT_xor(a, -1); for (int i = 0; i &lt; n; i++)cout &lt;&lt; (a[i] + MOD) % MOD &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线性基是处理异或问题的有力工具。 基&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个线性空间中，如果一组向量满足以下条件： 线性无关 空间中的任何向量都可以由这一组向量线性表示 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则称这一组向量为线性空间的一个基。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在异或运算中，可以这样定义一个只有异或运算的线性空间的基： 线性无关：即每一个向量不能由其它向量经异或运算得到 空间中的任何向量都可以由这一组向量异或得到 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则称它们为这个空间的基，或是线性基。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定n个向量，从中选取任意个数，使得它们异或和最大。这种求最大值的问题可以用线性基解决。可以发现，将这n个数化为二进制，可以得到n个向量，每一个向量的元素取值只能为0或1。如果能够求出这n个向量的极大无关组（或其等价的形式）就可以用这个向量组来表示空间中的所有向量，可以简化问题。 线性基的求法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定n个数，可以用下面算法来求： 遍历每一个数x，求出它们最高位1的位置i（从0开始），初始化线性基数组p每一位为0。 若p[i]为0，则p[i]=x，否则令x=x^p[i]，重新计算最高位1的位置，递归进行，直到x加入数组或x变为0。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到异或运算的逆运算就是其本身，这样的话可以看出上面的过程本质上是高斯消元的过程，将矩阵化为上三角矩阵，从而得到极大无关组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的算法有一个应用：判定给定的数能否异或得到某数，方法即为先将给定的数组加入，再加入待判定的数。若该数最终加入了线性基，则不可表示，否则可表示。 最值的求法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到了线性基，如何求最大或最小异或和？可以发现p数组每一位最高位1是递增的，对于满秩矩阵最小值自然就是最小的非0值，不满秩即为0；而最大值可以贪心去求，算法为： 从大到小遍历p数组，若异或上p[i]可以使答案更大，则异或，否则继续。 第k小的求法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要求第k小，可以考虑先将求出来的线性基进一步转化，把每一位p[i]变成唯一的第i位为1的数。这一步可以从高位到低位遍历线性基，并向后扫，若后面的数第i位为1，则异或p[i]，这样可以将线性基化为上面的形式。之后求第k小有如下的算法：将k二进制拆分，若第i位为1，则答案异或上线性基中第i+1个不为0的数。这里需要注意0的处理。 例题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[HDU6579]Operation，2019第一次多校赛B题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题需要动态向后面加数并且求$[l,r]$中某些数的最大值，后者是线性基能够解决的经典问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这样的问题，我们可以考虑贪心地求前缀线性基。对于每一个前缀，维护一个线性基数组，这在$O(nlogn)$时空复杂度下可以完成。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在加入一个数后，我们希望靠后的数能够出现在更高位的位置（贪心思想）。于是当某一位与要加入的数冲突时，如果原有的数在待加入的数左侧，那么我们不移动待加入的数，而是移动原有的数，将其挪动到更低位的位置。由于需要考虑位置关系，我们需要维护一个数组记录每一个数的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询的时候使用线性基。从高位开始遍历，如果对应的数在区间范围内，并且异或上值更大，那么我们异或上这个值，最终得到的就是答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于新加入的数，相当于一个新的前缀，维护一下线性基就好了。总体时间复杂度$O(nlogn+mlogn)$。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;typedef int i;using namespace std;int op[1000005][31], num[1000005][31], n, m;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;int query(int x) &#123; for (int i = 30; i &gt;= 0; i--)if ((1 &lt;&lt; i) &amp; x)return i; return -1;&#125;void add(int rk, int w, int pp) &#123; int p = query(w); if (p == -1)return; if (op[rk][p] == 0)op[rk][p] = w, num[rk][p] = pp; else if (num[rk][p] &lt; pp)add(rk, op[rk][p] ^ w, num[rk][p]), op[rk][p] = w, num[rk][p] = pp; else add(rk, w ^ op[rk][p], pp);&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) &#123; if (i &gt; 0)for (int j = 0; j &lt;= 30; j++)op[i][j] = op[i - 1][j], num[i][j] = num[i - 1][j]; add(i, read(), i); &#125; m = read(); while (m--) &#123; int l = read(), r = read(), ans = 0; for (int j = 30; j &gt;= 0; j--)if (num[r][j] &gt;= l &amp;&amp; (ans ^ op[r][j]) &gt; ans)ans ^= op[r][j]; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速数论变换（NTT）]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%88NTT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍快速数论变换，本文需要快速傅里叶变换前缀知识。 NTT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FFT可以很好地解决计算卷积的问题，但是它也有缺点： 精度问题：double的使用 不能取模：复数的引入 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果给定的所有系数均为整数，最后的结果又在模意义下，那么FFT没有很大优势。这时就需要快速数论变换（Number Theoretic Transform，NTT）来解决这个问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NTT的使用有一定限制，即对模数有要求，它们需要为$k2^p+1$的素数形式，比如1004535809, 998244353, 469762049这三个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在理解了FFT原理后，NTT是容易理解的。在此之前，需要先了解原根的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个数x，如果它存在原根g，那么总有下式成立： g^i\not \equiv g^j(mod\ x),0\leq i]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速傅里叶变换（FFT）]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍快速傅里叶变换（Fast Fourier Transformation，FFT），可以用来加速多项式乘法。快速傅里叶变换是多项式以及卷积问题的根本基础，是学习多项式以及卷积的前提。 多项式的点值表示&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，一个多项式可以表示成下面的形式： \sum_{i=0}^na_ix^i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时，它的系数可以组成一个向量： \vec F=(a_0,a_1,\cdots,a_n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种形式称为多项式的系数表示，通过原有系数向量得到的它们所对应多项式乘积的系数向量，称为两个向量的卷积。易知，如果要求两个多项式的乘积，需要用它们的系数去分别相乘，时间复杂度为$O(n^2)$，是很低效的。。这时，我们希望可以用另一种方式来表示多项式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个定理：任何一个最高次幂为n的多项式，可以由n+1组满足该多项式的互异点对唯一地确定出来。用这些点表示多项式的形式称为点值表示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是定理的简单证明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑点对$(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)$，那么有： \begin{bmatrix} 1&x_0&x_0^2&\cdots&x_0^{n}\\ 1&x_1&x_1^2&\cdots&x_1^{n}\\ \vdots&\vdots&\vdots &\ &\vdots\\ 1&x_n&x_n^2&\cdots&x_n^{n}\\ \end{bmatrix} \begin{bmatrix} a_0\\ a_1\\ \vdots\\ a_n \end{bmatrix}=\begin{bmatrix} y_0\\ y_1\\ \vdots\\ y_n \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最左侧的方阵对应的行列式为范德蒙行列式，其值为： \prod_{1\leq i]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化01Trie树]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%9601Trie%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍01trie树及其可持久化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trie树（字典树）在AC自动机中已经有过介绍。01trie树是一种trie树的变种：存很多二进制数。01trie树可以很好地解决异或问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定很多数，现判断哪一个数与给定的数x异或值最大。这个问题可以用01trie树快速解决。方法是将所有数化为二进制，存入trie树中，再根据给定的数从高位开始进行贪心，从而得到最大值。 异或运算的基本性质&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此之前，先来了解异或运算的基本性质。 0是异或运算中的幺元，即对于任意x，有$x \oplus 0=x$ 任何数是其本身的逆元，即有$x \oplus x=0$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些性质使得连续区间的异或和可以用前缀和维护。 01Trie树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道例题：P4551。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一道经典的异或问题。如果要求最长路径和的话，这就是求树的直径问题了。对于最大异或和，考虑如何将其与trie树联系起来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先无根树转有根树，一遍DFS求出所有点到根结点路径的异或和。这时，任意两个点这个异或和的异或值就是它们路径上的异或值。根据异或的运算性质，两点LCA到根的重叠路径部分会抵消，异或后得到的就是两点路径异或和。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123;//读优 char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;struct Node &#123;//trie树结点定义，只存左右儿子 int ch[2];&#125; node[100005 * 31];struct Edge &#123;//存边 int to, next, v;&#125; edge[100005 &lt;&lt; 1];int head[100005], cnt = 1, n, tp[100005];inline void add(int x, int y, int v) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = v, head[x] = cnt++;&#125;inline int newNode() &#123;//分配新结点，1为根 static int cnt = 2; return cnt++;&#125;inline void insert(int x) &#123;//插入元素 int now = 1; for (int i = 31; i &gt;= 0; i--) &#123;//从高位开始 if ((1 &lt;&lt; i) &amp; x) &#123; if (node[now].ch[1] == 0)node[now].ch[1] = newNode();//没有就新建 now = node[now].ch[1]; &#125; else &#123; if (node[now].ch[0] == 0)node[now].ch[0] = newNode(); now = node[now].ch[0]; &#125; &#125;&#125;inline int find(int x) &#123; int now = 1, ans = 0; for (int i = 31; i &gt;= 0; i--) &#123; if ((1 &lt;&lt; i) &amp; x) &#123; if (node[now].ch[0])now = node[now].ch[0], ans |= (1 &lt;&lt; i);//向反方向找 else now = node[now].ch[1]; &#125; else &#123; if (node[now].ch[1])now = node[now].ch[1], ans |= (1 &lt;&lt; i); else now = node[now].ch[0]; &#125; &#125; return ans;&#125;void DFS(int fa, int x, int y) &#123;//预处理 insert(y), tp[x] = y; for (int i = head[x]; i; i = edge[i].next) &#123; if (edge[i].to != fa)DFS(x, edge[i].to, y ^ edge[i].v); &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(), z = read(); add(x, y, z), add(y, x, z); &#125; DFS(0, 1, 0); int ans = -1; for (int i = 1; i &lt;= n; i++)ans = max(ans, find(tp[i])); cout &lt;&lt; ans; return 0;&#125; 可持久化01Trie树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面就是可持久化01Trie树的部分，例题一道：P4735。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先后缀转前缀。注意到$a[p]\oplus a[p+1]\oplus…\oplus a[N]\oplus x=sum[p-1]\oplus sum[N]\oplus x$。sum是异或前缀和，这样问题转化为找一个值$sum[p-1]$使得与$sum[N]\oplus x$异或值最大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是容易发现p的选取有限制（为[l-1，r-1]），普通的01trie树不能加上这个限制。这里需要借鉴主席树维护区间第k大的思想。在trie树的结点上增加指标num，记录数量。然后对于每一个i（$1\leq i\leq N$）分别建立一棵存1~i这些数的01trie树，查询时作差即可。这样需要建立N棵树，空间消耗过大，于是需要用主席树的思想来重用空间，降低空间复杂度，这一步与主席树类似。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于插入操作，由于只是末尾插入，建立一棵新版本的trie树即可。对于查询操作，本质上就是找到一个$p（l-1\leq p\leq r-1）$使得$sum[p]$与$sum[N]\oplus x$异或值最大。找到r-1和l-2这两个trie树，作差即可判断。注意当l=1时需要特判。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可持久化01trie树不要向主席树那样建立空树，否则空间开销达到指数级。对于那些空的结点，统一用0号结点代替。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，本题卡常，需要尽可能减小常数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;int root[300005 &lt;&lt; 2], n, m, la;struct Node &#123; int ch[2], num;&#125; node[300005 &lt;&lt; 6];inline int newNode() &#123; static int cnt = 1; return cnt++;&#125;inline int newTree(int pre, int x, int p) &#123;//新建一棵树 register int rt = newNode(); if (p == -1) &#123; node[rt].num = node[pre].num + 1; return rt; &#125; node[rt].ch[0] = node[pre].ch[0], node[rt].ch[1] = node[pre].ch[1], node[rt].num = node[pre].num + 1;//继承和修改 if ((1 &lt;&lt; p) &amp; x)node[rt].ch[1] = newTree(node[pre].ch[1], x, p - 1); else node[rt].ch[0] = newTree(node[pre].ch[0], x, p - 1); return rt;&#125;inline int query(int a, int b, int x) &#123; register int p = 25, ans = 0; while (p &gt;= 0) &#123; if ((1 &lt;&lt; p) &amp; x) &#123; if (node[node[b].ch[0]].num &gt; node[node[a].ch[0]].num) &#123; b = node[b].ch[0], a = node[a].ch[0], ans |= (1 &lt;&lt; p); &#125; else b = node[b].ch[1], a = node[a].ch[1]; &#125; else &#123; if (node[node[b].ch[1]].num &gt; node[node[a].ch[1]].num) &#123; b = node[b].ch[1], a = node[a].ch[1], ans |= (1 &lt;&lt; p); &#125; else b = node[b].ch[0], a = node[a].ch[0]; &#125; p--; &#125; return ans;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; register int x; scanf("%d", &amp;x), la ^= x; root[i] = newTree(root[i - 1], la, 25); &#125; for (register int i = 0; i &lt; m; i++) &#123; char e; register int a, b, c; scanf(" %c", &amp;e); if (e == 'A')scanf("%d", &amp;a), la ^= a, root[n + 1] = newTree(root[n], la, 25), n++; else &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); register int p = query(a != 1 ? root[a - 2] : 0, root[b - 1], c ^ la); printf("%d\n", a == 1 ? max(p, c ^ la) : p);//a=1时特判一步 &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化平衡树]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可持久化数据结构第二部分：可持久化平衡树和文艺平衡树。阅读本文需要前缀知识FHQ Treap。 可持久化平衡树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可持久化数据结构在前一篇文章中已经提到。fhq Treap是非旋的树堆，可以很好地实现可持久化平衡树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据前一篇文章的铺垫，可以初步理解可持久化数据结构的实现原理，那就是只要需要修改原有结点，就重建一个。旋转操作很容易破坏原树的结构，而fhq Threap没有旋转操作，在实现可持久化时有天然优势。一个模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fhq Treap的核心操作为split和merge。只要修改这两个函数就可以实现可持久化。具体实现过程如下：1234567891011121314inline int newNode(Node *p) &#123;//通过传入指针来构造一个相同内容的新结点 static int cnt = 1; node[cnt] = *p; return cnt++;&#125;void split(int rt, int &amp;a, int &amp;b, int v) &#123;//注意newNode函数的使用 if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].v &lt;= v)a = newNode(node + rt), split(node[rt].ch[1], node[a].ch[1], b, v), update(a); else b = newNode(node + rt), split(node[rt].ch[0], a, node[b].ch[0], v), update(b);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split中实现可持久化的原则是不能修改rt树上的结点。因此，当需要修改时，a和b总是需要拷贝一份rt结点，再进行修改操作。注意这里的update需要在两个分枝分别进行调用，这与普通的fhq Treap中一步update(rt)有所不同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那merge函数是不是也需要不断拷贝结点？从道理上讲，这样做完全没有问题，可以得到下面的代码：123456789void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (node[a].key &gt; node[b].key)rt = newNode(node + a), merge(node[rt].ch[1], node[a].ch[1], b); else rt = newNode(node + b), merge(node[rt].ch[0], a, node[b].ch[0]); update(rt);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里merge可持久化的原则是不能修改a和b上的结点。因此，当需要修改时，rt总是拷贝一份a或b的结点，再进行更新。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做没有什么错，只是浪费了空间。注意到我们在fhq Treap上的操作总是先split再merge，这样在merge之前，需要新建的结点已经被split过程新建出来了。可以这样做的不严格证明：split总是要按照一定指标来进行，譬如本题需要按值分离。那些新建结点与原有结点之间的交界部分姑且称之为断层，断层处体现了split的依据。无论是插入结点还是删除结点，后来merge的操作总是在断层上进行。比如插入值为x的结点，需要先将不大于x的结点树split出来，这样新的结点必然是接在这棵树的断层上的，因此原有的结点不会被修改，仅有split时新建的结点被修改。merge操作的树与之前的split均为同一版本，于是就可以省略复制结点的过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样merge过程保留原有的函数不变即可，从而降低空间消耗。后面的操作也没有什么大的变动，全代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;bits/stdc++.h&gt;#define N 500005using namespace std;struct Node &#123; int v&#123;&#125;, key&#123;&#125;, ch[2]&#123;&#125;, num; Node() : num(0) &#123; ch[0] = ch[1] = 0; &#125;&#125; node[N &lt;&lt; 6];inline void read(int &amp;s) &#123; char e = getchar(); int p = 0; s = 0; while (e &lt; '-')e = getchar(); if (e == '-')e = getchar(), p = 1; while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); if (p)s = -s;&#125;int root[N], ver[N], n, a, b, c, rcnt = 1;inline int newNode(Node *p) &#123; static int cnt = 1; node[cnt] = *p; return cnt++;&#125;inline void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + 1;&#125;void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].v &lt;= v)a = newNode(node + rt), split(node[rt].ch[1], node[a].ch[1], b, v), update(a); else b = newNode(node + rt), split(node[rt].ch[0], a, node[b].ch[0], v), update(b);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (node[a].key &gt; node[b].key)rt = a, merge(node[rt].ch[1], node[a].ch[1], b); else rt = b, merge(node[rt].ch[0], a, node[b].ch[0]); update(rt);&#125;inline int insert(int v, int x) &#123; int p = newNode(node), a, b, c; node[p].key = rand(), node[p].v = x, node[p].num = 1, split(root[ver[v]], a, b, x); merge(a, a, p), merge(c, a, b); return c;&#125;inline int delNum(int v, int x) &#123; int a, b, c; split(root[ver[v]], a, b, x), split(a, a, c, x - 1); merge(c, node[c].ch[0], node[c].ch[1]), merge(a, a, c), merge(c, a, b); return c;&#125;inline int findRank(int v, int x) &#123; int cur = root[ver[v]], nxt = 0, ans = 0; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1], ans += node[cur].num - node[nxt].num; else if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; return ans + 1;&#125;inline int preNum(int v, int x) &#123; int cur = root[ver[v]], nxt = 0, maxn = -2147483647, ans = -1; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x) &#123; nxt = node[cur].ch[1]; if (node[cur].v &gt; maxn)maxn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[0]; if (nxt != 0)cur = nxt; else break; &#125; return ans == -1 ? -2147483647 : node[ans].v;&#125;inline int nextNum(int v, int x) &#123; int cur = root[ver[v]], nxt = 0, minn = 2147483647, ans = -1; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else if (node[cur].v &gt; x) &#123; nxt = node[cur].ch[0]; if (node[cur].v &lt;= minn)minn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[1]; if (nxt != 0)cur = nxt; else break; &#125; return ans == -1 ? 2147483647 : node[ans].v;&#125;inline int findNum(int v, int x) &#123; int cur = root[ver[v]], nxt = 0; while (true) &#123; if (node[node[cur].ch[0]].num &gt;= x)nxt = node[cur].ch[0]; else if (x &gt; node[node[cur].ch[0]].num &amp;&amp; x &lt;= node[node[cur].ch[0]].num + 1)return node[cur].v; else nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + 1; if (nxt != 0)cur = nxt; else break; &#125; return -1;&#125;int main() &#123; srand(time(NULL)), read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a), read(b), read(c); if (b == 1)root[rcnt] = insert(a, c), ver[i] = rcnt++; else if (b == 2)root[rcnt] = delNum(a, c), ver[i] = rcnt++; else if (b == 3)printf("%d\n", findRank(a, c)), ver[i] = ver[a]; else if (b == 4)printf("%d\n", findNum(a, c)), ver[i] = ver[a]; else if (b == 5)printf("%d\n", preNum(a, c)), ver[i] = ver[a]; else printf("%d\n", nextNum(a, c)), ver[i] = ver[a]; &#125; return 0; 可持久化文艺平衡树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有可持久化平衡树，自然有可持久化文艺平衡树。它同样可以用fhq Treap实现，模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与上面类似：spilt时复制结点，merge时不用复制。但这里需要特别注意的是：下压标记时也需要复制结点。这是因为下压标记需要修改左右子树的标记，对结果造成影响（这个结点的两个子结点可能也属于其它版本），因此需要复制一份。1234567inline void down(int x) &#123; if (!node[x].tag)return; if (node[x].ch[0])node[x].ch[0] = newNode(node + node[x].ch[0]); if (node[x].ch[1])node[x].ch[1] = newNode(node + node[x].ch[1]); swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].tag ^= 1, node[node[x].ch[1]].tag ^= 1, node[x].tag = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在结点中添加指标sum记录子树和，之后就可以搞出来了。全代码（本题强制在线）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define N 200005using namespace std;struct Node &#123; int v&#123;&#125;, key&#123;&#125;, ch[2]&#123;&#125;, num; long long sum; short tag;&#125; node[N &lt;&lt; 6];inline long long read() &#123; char e = getchar(); int p = 0; long long s = 0; while (e &lt; '-')e = getchar(); if (e == '-')e = getchar(), p = 1; while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return p ? -s : s;&#125;int root[N], ver[N], rcnt = 1;long long n, opt, a, b, v;inline int newNode(Node *p) &#123; static int cnt = 1; node[cnt] = *p; return cnt++;&#125;inline void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + 1; node[x].sum = node[node[x].ch[0]].sum + node[node[x].ch[1]].sum + node[x].v;&#125;inline void down(int x) &#123; if (!node[x].tag)return; if (node[x].ch[0])node[x].ch[0] = newNode(node + node[x].ch[0]); if (node[x].ch[1])node[x].ch[1] = newNode(node + node[x].ch[1]); swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].tag ^= 1, node[node[x].ch[1]].tag ^= 1, node[x].tag = 0;&#125;void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; down(rt); if (node[node[rt].ch[0]].num &lt; v) a = newNode(node + rt), split(node[rt].ch[1], node[a].ch[1], b, v - node[node[rt].ch[0]].num - 1), update(a); else b = newNode(node + rt), split(node[rt].ch[0], a, node[b].ch[0], v), update(b);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; down(a), down(b); if (node[a].key &gt; node[b].key)rt = a, merge(node[rt].ch[1], node[a].ch[1], b); else rt = b, merge(node[rt].ch[0], a, node[b].ch[0]); update(rt);&#125;inline int insert(int v, int x, int y) &#123; int p = newNode(node), a, b, c; node[p].key = rand(), node[p].sum = node[p].v = y, node[p].num = 1, split(root[ver[v]], a, b, x); merge(a, a, p), merge(c, a, b); return c;&#125;inline int delNum(int v, int x) &#123; int a, b, c; split(root[ver[v]], a, b, x - 1), split(b, b, c, 1), merge(a, a, c); return a;&#125;int main() &#123; long long last = 0; srand(time(NULL)); n = read(); for (int i = 1; i &lt;= n; i++) &#123; v = read(), opt = read(), a = read() ^ last; if (opt == 1)b = read() ^ last, root[rcnt] = insert(v, a, b), ver[i] = rcnt++; else if (opt == 2)root[rcnt] = delNum(v, a), ver[i] = rcnt++; else if (opt == 3) &#123; b = read() ^ last; int x, y, z, p; split(root[ver[v]], x, y, b), split(x, x, z, a - 1), node[z].tag ^= 1, merge(p, x, z), merge(x, p, y); root[rcnt] = x, ver[i] = rcnt++; &#125; else &#123; int x, y, z, p; b = read() ^ last; split(root[ver[v]], x, y, b), split(x, x, z, a - 1), printf("%lld\n", last = node[z].sum); merge(p, x, z), merge(x, p, y); root[rcnt] = x, ver[i] = rcnt++; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>文艺平衡树</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化线段树（主席树）]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正式开始可持久化数据结构。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据结构可以维护很多信息，但是可持久化数据结构又是什么？考虑这样一个问题：现在维护一个数组，需要修改或者访问其中的某一个元素，如何维护？这问题太智障了，如果需要访问或修改某一个历史版本又如何操作？查询和修改历史版本普通的数据结构是做不到的，这时就可以祭出可持久化数据结构。可持久化数据结构可以维护历史版本信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可持久化线段树是一类重要的可持久化数据结构，又称主席树。主席树的优点是支持可持久化，时间复杂度比较好，缺点是空间占用大。 静态区间第k小问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入主席树之前，先来了解一下一个经典问题：静态区间第k小。即给定一个序列，查询某一个区间中第k小的数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果每一次查询都排一次序，这样效率极低无比。这个问题可以用主席树轻松地解决，也是引入主席树的经典问题。当然本题用树套树、分块应该也能卡过去。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题：戳这里。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，需要将原有数据离散化。离散化方法是将序列数据排序，去重。比如对于3、5、8、3、1序列，去重后得到1、3、5、8，这样这些数就可以重新标号，起到离散化效果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步的代码如下：1sort(tmp + 1, tmp + n + 1), m = unique(tmp + 1, tmp + n + 1) - tmp - 1;//tmp是原数组的拷贝 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unique函数可以将有序数列进行去重，返回不重复序列的末尾元素的下一个元素位置。m记录互不相同的元素数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的主席树其实是一棵权值线段树，即它的每一个结点记录的是某个数在区间中出现的次数。建一棵线段树，其储存区间[1,m]的信息，并表示对于原数组[1,n]，[i,j]中的数出现的次数，这里[i,j]是[1,m]的一个子集。比如说树根位置储存[1,m]的出现次数，就上面的例子而言，它的值为5，这是因为原数组[1,5]（指3、5、8、3、1）中[1,4]（指1、3、5、8）出现的次数，当然是5。同样地，其左子树根结点（储存[1,3]的信息）值应该为4。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样建树的好处是什么？设想一下现在如果要求原数组[1,p]区间中第k小的数，可以这样做：找到左子树的权值s，如果s&lt;k，说明左子树对应的数不是第k小，答案必然在右子树上，否则就在左子树上。建好这一棵线段树后，查找[1,p]的区间第k小的问题就解决了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果起始结点不为1怎么办？很明显，如果我们对于任一个元素i，都建立一棵[1,i]对应的线段树，共建n棵，这样利用区间可减性（前缀和思想）就可以找到[i,j]的对应值了，同样可以求出第k小的数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建立n棵线段树一定会MLE，从这里开始就体现出了主席树的优化方案：重用结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对比[1,i]和[1,i+1]这两棵线段树，可以发现后者只不过是在前者基础上修改了从根开始的一段路径上的结点而已，它们有大量的点是可以共用的。这样，只需要把新的结点建立出来，重复的结点直接复用上一次的结点即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主席树由许多棵线段树组成，每一个线段树有着自己独立的树根。现在来探讨如何初始化一棵主席树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，约定用root[i]数组记录不同线段树的树根标号，并用统一的内存池来管理结点的分配。op为原数组，tmp为经排序并去重后的数组，V记录结点权值。 1234567int build(int l, int r) &#123;//构造[l,r]区间的线段树，这里的区间是tmp上的 int rt = cnt++;//cnt分配结点，新分配一个，V初始化为0，由于V是全局变量，就不用再写了 if (l &lt; r)L[rt] = build(l, (l + r) &gt;&gt; 1), R[rt] = build(((l + r) &gt;&gt; 1) + 1, r);//记录左儿子、右儿子，递归进行 return rt;&#125;root[0] = build(1, m);//main函数中使用，这是第0棵线段树 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑如何建一棵新树并重用上一个版本的结点，先看构树函数。123456789int newTree(int l, int r, int pre, int s) &#123;//在区间[l,r]，前一个树（要复用的）的树根pre，修改第s个叶子结点 int rt = cnt++;//分配一个新的结点 L[rt] = L[pre], R[rt] = R[pre], V[rt] = V[pre] + 1;//默认左右儿子全部复用，但V要自加（加上新来的那一个数） if (l &lt; r) &#123;//对于可以再划分的区间 if (s &gt; ((l + r) &gt;&gt; 1))R[rt] = newTree(((l + r) &gt;&gt; 1) + 1, r, R[pre], s);//建右子树 else L[rt] = newTree(l, (l + r) &gt;&gt; 1, L[pre], s);//建左子树 &#125; return rt;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的算法是容易理解的，在主函数中需要这样使用：1for (int i = 1; i &lt;= n; i++)root[i] = newTree(1, m, root[i - 1], lower_bound(tmp + 1, tmp + m + 1, op[i]) - tmp); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次都重用上一棵线段树。lower_bound可以在升序序列中找到第一个不小于op[i]的数的位置，新树的树根存放到root中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找自然也很方便，直接二分即可：12345int query(int l, int r, int k, int a = 1, int b = m) &#123; if (a == b)return tmp[a];//找到这个数 if (V[L[r]] - V[L[l]] &lt; k)return query(R[l], R[r], k - V[L[r]] + V[L[l]], ((a + b) &gt;&gt; 1) + 1, b);//向右子树上找 return query(L[l], L[r], k, a, (a + b) &gt;&gt; 1);//向左子树上找&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define N 200005using namespace std;inline int read() &#123; char e = getchar(); int s = 0, p = 0; while (e &lt; '-')e = getchar(); if (e == '-')p = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return p ? -s : s;&#125;int n, q, m, L[N &lt;&lt; 6], R[N &lt;&lt; 6], V[N &lt;&lt; 6], op[N], tmp[N], root[N], cnt = 1, a, b, c;int build(int l, int r) &#123; int rt = cnt++; if (l &lt; r)L[rt] = build(l, (l + r) &gt;&gt; 1), R[rt] = build(((l + r) &gt;&gt; 1) + 1, r); return rt;&#125;int newTree(int l, int r, int pre, int s) &#123; int rt = cnt++; L[rt] = L[pre], R[rt] = R[pre], V[rt] = V[pre] + 1; if (l &lt; r) &#123; if (s &gt; ((l + r) &gt;&gt; 1))R[rt] = newTree(((l + r) &gt;&gt; 1) + 1, r, R[pre], s); else L[rt] = newTree(l, (l + r) &gt;&gt; 1, L[pre], s); &#125; return rt;&#125;int query(int l, int r, int k, int a = 1, int b = m) &#123; if (a == b)return tmp[a]; if (V[L[r]] - V[L[l]] &lt; k)return query(R[l], R[r], k - V[L[r]] + V[L[l]], ((a + b) &gt;&gt; 1) + 1, b); return query(L[l], L[r], k, a, (a + b) &gt;&gt; 1);&#125;int main() &#123; n = read(), q = read(); for (int i = 1; i &lt;= n; i++)tmp[i] = op[i] = read(); sort(tmp + 1, tmp + n + 1), m = unique(tmp + 1, tmp + n + 1) - tmp - 1; root[0] = build(1, m); for (int i = 1; i &lt;= n; i++)root[i] = newTree(1, m, root[i - 1], lower_bound(tmp + 1, tmp + m + 1, op[i]) - tmp); while (q--)a = read(), b = read(), c = read(), printf("%d\n", query(root[a - 1], root[b], c)); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好像到现在没有看到可持久化的意思？其实仔细观察上面的过程，可以认为上面的每一棵线段树都是一个历史版本，它维护的是后面元素尚未加入时的信息。也就是说，静态区间第k小虽然没有直接体现可持久化，但它实际上已经体现出来可持久化的思想了。 单点修改的动态区间第k小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个序列，求某一个区间的第k小值可以用主席树做出来。但是如果需要单点修改呢？这时主席树就不容易做了。如果修改x位置的值，我们需要修改x~n的所有树，效率很低。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到单点修改和前缀和，自然想到树状数组，因此可以考虑搭配树状数组和主席树来解决这个问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法比较容易实现。对于树状数组的每一个位置，都有一棵独立的权值线段树（就是主席树），它维护的范围与树状数组的定义相同。在上文的静态区间第k小中，曾用复用结点的方式来减小内存占用，但是树状数组中每一个位置所对应的权值线段树，很不容易复用结点，因此只能暴力开点。开n个线段树确实会MLE，但是如果选择动态开点，则可以将空间复杂度降低。但即使这样占用内存还是很大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个问题。一开始我们离散化原有序列，通过它们的排名来构造主席树，动态修改后可能会加入一些新的值，怎么去维护？这里确实不易做到，但仍有解决方法：离线。离线处理所有修改后的值，将它们与原序列一起进行离散化，就可以优雅地建树了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题：戳这里。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define N 100005using namespace std;int lc[N * 600], rc[N * 600], cnt, tot, value[N * 600], tmp[N &lt;&lt; 1], n, m, op[N], root[N];int xx[N], yy[N], totx, toty;struct Query &#123; bool isC; int i, j, k;&#125; q[N];void update(int &amp;rt, int l, int r, int k, int x) &#123; if (rt == 0)rt = ++cnt; value[rt] += x; if (l == r)return; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid)update(lc[rt], l, mid, k, x); else update(rc[rt], mid + 1, r, k, x);&#125;inline void modify(int x, int y) &#123; int k = static_cast&lt;int&gt;(lower_bound(tmp + 1, tmp + tot + 1, op[x]) - tmp); for (; x &lt;= n; x += (x &amp; -x))update(root[x], 1, tot, k, y);&#125;int query(int k, int l, int r) &#123;//查询 if (l == r)return l; int sum = 0, mid = (l + r) &gt;&gt; 1; for (int i = 1; i &lt;= totx; i++)sum -= value[lc[xx[i]]]; for (int i = 1; i &lt;= toty; i++)sum += value[lc[yy[i]]]; if (sum &gt;= k) &#123; for (int i = 1; i &lt;= totx; i++)xx[i] = lc[xx[i]];//一起转移 for (int i = 1; i &lt;= toty; i++)yy[i] = lc[yy[i]]; return query(k, l, mid); &#125; else &#123; for (int i = 1; i &lt;= totx; i++)xx[i] = rc[xx[i]]; for (int i = 1; i &lt;= toty; i++)yy[i] = rc[yy[i]]; return query(k - sum, mid + 1, r); &#125;&#125;int main() &#123; char e; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++)scanf("%d", tmp + i), op[i] = tmp[i]; tot = n; for (int i = 1; i &lt;= m; i++) &#123; scanf(" %c", &amp;e); if (e == 'C')q[i].isC = true, scanf("%d%d", &amp;q[i].i, &amp;q[i].j), tmp[++tot] = q[i].j; else q[i].isC = false, scanf("%d%d%d", &amp;q[i].i, &amp;q[i].j, &amp;q[i].k); &#125; sort(tmp + 1, tmp + tot + 1); tot = static_cast&lt;int&gt;(unique(tmp + 1, tmp + tot + 1) - tmp - 1); for (int i = 1; i &lt;= n; i++)modify(i, 1); for (int i = 1; i &lt;= m; i++) &#123; if (q[i].isC)modify(q[i].i, -1), op[q[i].i] = q[i].j, modify(q[i].i, 1); else &#123; totx = toty = 0; for (int j = q[i].i - 1; j &gt; 0; j -= (j &amp; -j))xx[++totx] = root[j];//存所有的树 for (int j = q[i].j; j &gt; 0; j -= (j &amp; -j))yy[++toty] = root[j]; printf("%d\n", tmp[query(q[i].k, 1, tot)]); &#125; &#125; return 0;&#125; 静态树上路径第k小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在考虑树上的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先考虑一个更简单的问题：求有根树某一子树上点权第k小。这个很容易，一遍DFS重标号就转化为区间第k小，还可以很方便地转移到单点修改的动态第k小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树上路径就比较麻烦了，但思路仍然是主席树的思路。首先无根树转有根树（通常选1号结点为根），然后在树上建立主席树。对于某一个结点的若干个子结点，让这些子结点重用父结点对应主席树上的结点，就可以大大压缩空间，空间复杂度仍然是$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主席树易建，现在主要问题是如何查询。考虑之前我们是如何求某一路径上某个数的出现次数的：先预处理树上前缀和，然后求lca之后作差得到结果。这里的主席树本身就是求前缀和的利器，我们只需要求一下lca，然后三棵主席树同时转移，就可以得到任意一个点权在这个路径上的出现次数，求第k小的方法也就显而易见了。唯一需要注意的就是lca本身的点权需要在转移时计入。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来看一道模板题：SP10628 COT。很裸（这还不够裸吗）的静态树上路径第k小，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct Node &#123; int l, r, v;&#125; node[N &lt;&lt; 6];struct Edge &#123; int to, next;&#125; edge[N &lt;&lt; 1];int cnt = 1, head[N], v[N], n, m, gr[N][25], dep[N], root[N], tmp[N], sv, ans;inline void add(int x, int y) &#123; static int c = 1; edge[c].to = y, edge[c].next = head[x], head[x] = c++;&#125;int newTree(int pre, int s, int l = 1, int r = sv) &#123; int p = cnt++, mid = (l + r) &gt;&gt; 1; node[p] = node[pre], ++node[p].v; if (l == r)return p; if (s &gt; mid)node[p].r = newTree(node[pre].r, s, mid + 1, r); else node[p].l = newTree(node[pre].l, s, l, mid); return p;&#125;void DFS(int x, int fa) &#123; root[x] = newTree(root[fa], lower_bound(tmp + 1, tmp + sv + 1, v[x]) - tmp); for (int i = head[x]; i; i = edge[i].next) &#123; if (!dep[edge[i].to]) &#123; dep[edge[i].to] = dep[x] + 1, gr[edge[i].to][0] = x; for (int j = 1; j &lt;= 24; j++)gr[edge[i].to][j] = gr[gr[edge[i].to][j - 1]][j - 1]; DFS(edge[i].to, x); &#125; &#125;&#125;inline int LCA(int x, int y) &#123;//倍增求lca if (dep[x] &gt; dep[y])swap(x, y); for (int i = 24; i &gt;= 0; i--)if (dep[gr[y][i]] &gt;= dep[x])y = gr[y][i]; if (x == y)return x; for (int i = 24; i &gt;= 0; i--)if (gr[y][i] != gr[x][i])x = gr[x][i], y = gr[y][i]; return gr[x][0];&#125;int build(int l = 1, int r = sv) &#123; if (l == r)return cnt++; int p = cnt++, mid = (l + r) &gt;&gt; 1; node[p].l = build(l, mid), node[p].r = build(mid + 1, r), node[p].v = 0; return p;&#125;int query(int lca, int a, int b, int k, int obj, int l = 1, int r = sv) &#123;//这里需要特别注意，三棵主席树同时转移 if (l == r)return tmp[l]; int mid = (l + r) &gt;&gt; 1; int p = node[node[b].l].v + node[node[a].l].v - 2 * node[node[lca].l].v + (obj &lt;= mid &amp;&amp; obj &gt;= l ? 1 : 0);//注意计入lca的点权，函数中用obj表示其离散化结果 if (p &gt;= k)return query(node[lca].l, node[a].l, node[b].l, k, obj, l, mid); return query(node[lca].r, node[a].r, node[b].r, k - p, obj, mid + 1, r);&#125;int main() &#123; ios::sync_with_stdio(false), cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; tmp[i] = v[i]; &#125; for (int i = 1, x, y; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; add(x, y), add(y, x); &#125; sort(tmp + 1, tmp + n + 1), sv = unique(tmp + 1, tmp + n + 1) - tmp - 1; root[0] = build(), dep[1] = 1, DFS(1, 0); while (m--) &#123; int a, b, c, lca; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; lca = LCA(a, b); printf("%d\n", ans = query(root[lca], root[a], root[b], c, lower_bound(tmp + 1, tmp + sv + 1, v[lca]) - tmp)); &#125; return 0;&#125; 对主席树的进一步理解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅仅会用主席树解决区间第k小问题是远远不够的，我们应该从一个更高的层次去理解主席树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主席树本质上是很多权值线段树，实质上同时维护了很多数的前缀个数和，这使得我们可以在低复杂度下求任何一个数在某一段区间中出现的次数，这一点十分有用，能解决很多实际问题，第k小只是其中之一。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，凡是涉及求任何一种数在区间中出现的次数时，都可以套一下主席树。想象一下，现在有一个$10^5$量级的数组，如果那数组维护每一种数的前缀个数，这样连数组都开不动，现在就可以拿主席树解决了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持单点修改的树状数组套主席树更加有用，比如说，它可以帮助我们求动态逆序对。看这样一道题：洛谷P3157。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当从原序列中删去一个数时，需要考虑其对答案的影响。这个影响显然就是它前面比它大的数的数目以及它后面比其小的数的数目。这里涉及求某一区间数的次数问题，就可以拿主席树解决。又因为需要将这个数去除，需要单点修改，于是用树状数组套主席树也就理所应当了。 可持久化数组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面就可以来认识真正的一种可持久化：可持久化数组。模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可持久化数组就是支持查询修改历史版本的数组，可以用主席树实现。这里的主席树其实只有叶子结点的权值有效，它们储存对应的数组中的值。直接来看初始化和构树算法：12345678910111213141516int build(int l, int r) &#123; int rt = cnt++; if (l &lt; r)L[rt] = build(l, (l + r) &gt;&gt; 1), R[rt] = build(((l + r) &gt;&gt; 1) + 1, r); else V[rt] = op[l];//记录点权 return rt;&#125;int newTree(int l, int r, int pre, int s, int what) &#123;//把s位置的值改成what int rt = cnt++; L[rt] = L[pre], R[rt] = R[pre]; if (l &lt; r) &#123; if (s &gt; ((l + r) &gt;&gt; 1))R[rt] = newTree(((l + r) &gt;&gt; 1) + 1, r, R[pre], s, what); else L[rt] = newTree(l, (l + r) &gt;&gt; 1, L[pre], s, what); &#125; else V[rt] = what;//把值改成what return rt;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询过程：12345int query(int k, int a, int b, int rk) &#123; if (a == b)return V[rk];//直接返回权值 if (((a + b) &gt;&gt; 1) &lt; k)return query(k, ((a + b) &gt;&gt; 1) + 1, b, R[rk]); return query(k, a, ((a + b) &gt;&gt; 1), L[rk]);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于每一个操作都对应一个版本，所以我们需要用一个数组来储存版本所对应的根结点标号，这个很容易实现。全代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define N 1000005using namespace std;inline int read() &#123; char e = getchar(); int s = 0, p = 0; while (e &lt; '-')e = getchar(); if (e == '-')p = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return p ? -s : s;&#125;int n, q, m, L[N &lt;&lt; 6], R[N &lt;&lt; 6], V[N &lt;&lt; 6], op[N], tmp[N], root[N], cnt = 1, v, a, b, c, ver[N];int root_cnt = 1;int build(int l, int r) &#123; int rt = cnt++; if (l &lt; r)L[rt] = build(l, (l + r) &gt;&gt; 1), R[rt] = build(((l + r) &gt;&gt; 1) + 1, r); else V[rt] = op[l]; return rt;&#125;int newTree(int l, int r, int pre, int s, int what) &#123; int rt = cnt++; L[rt] = L[pre], R[rt] = R[pre]; if (l &lt; r) &#123; if (s &gt; ((l + r) &gt;&gt; 1))R[rt] = newTree(((l + r) &gt;&gt; 1) + 1, r, R[pre], s, what); else L[rt] = newTree(l, (l + r) &gt;&gt; 1, L[pre], s, what); &#125; else V[rt] = what; return rt;&#125;int query(int k, int a, int b, int rk) &#123; if (a == b)return V[rk]; if (((a + b) &gt;&gt; 1) &lt; k)return query(k, ((a + b) &gt;&gt; 1) + 1, b, R[rk]); return query(k, a, ((a + b) &gt;&gt; 1), L[rk]);&#125;int main() &#123; n = read(), q = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); root[0] = build(1, n), ver[0] = 0; for (int i = 1; i &lt;= q; i++) &#123; v = read(), a = read(); if (a == 1)b = read(), c = read(), root[root_cnt] = newTree(1, n, root[ver[v]], b, c), ver[i] = root_cnt++; else a = read(), printf("%d\n", query(a, 1, n, root[ver[v]])), ver[i] = ver[v]; &#125; return 0;&#125; 可持久化并查集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了可持久化数组，就可以实现可持久化并查集。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于维护并查集其实就是维护一个father数组，可以利用可持久化数组的方法实现。代码如下（会TLE）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define N 1000005using namespace std;inline int read() &#123; char e = getchar(); int s = 0, p = 0; while (e &lt; '-')e = getchar(); if (e == '-')p = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return p ? -s : s;&#125;int n, q, L[N &lt;&lt; 6], R[N &lt;&lt; 6], fa[N &lt;&lt; 6], root[N], cnt = 1, now, a, b, c, ver[N];int root_cnt = 1;int build(int l, int r) &#123; int rt = cnt++; if (l &lt; r)L[rt] = build(l, (l + r) &gt;&gt; 1), R[rt] = build(((l + r) &gt;&gt; 1) + 1, r); else fa[rt] = l;//fa初始化 return rt;&#125;int newTree(int l, int r, int pre, int s, int what) &#123; int rt = cnt++; L[rt] = L[pre], R[rt] = R[pre]; if (l &lt; r) &#123; if (s &gt; ((l + r) &gt;&gt; 1))R[rt] = newTree(((l + r) &gt;&gt; 1) + 1, r, R[pre], s, what); else L[rt] = newTree(l, (l + r) &gt;&gt; 1, L[pre], s, what); &#125; else fa[rt] = what; return rt;&#125;int query(int k, int a, int b, int rk) &#123; if (a == b)return rk; if (((a + b) &gt;&gt; 1) &lt; k)return query(k, ((a + b) &gt;&gt; 1) + 1, b, R[rk]); return query(k, a, ((a + b) &gt;&gt; 1), L[rk]);&#125;int findF(int x, int v) &#123; int f = query(fa[x], 1, n, v);//这一步很重要，要找到对应树上的对应结点 if (f == x)return fa[x]; return findF(f, v);&#125;int main() &#123; int x, y; n = read(), q = read(); root[0] = build(1, n), ver[0] = 0, now = 0; for (int i = 1; i &lt;= q; i++) &#123; a = read(); if (a == 1) &#123; b = read(), c = read(); x = findF(query(b, 1, n, root[ver[now]]), root[ver[now]]); y = findF(query(c, 1, n, root[ver[now]]), root[ver[now]]); if (x != y)root[root_cnt] = newTree(1, n, root[ver[now]], x, y), ver[i] = root_cnt++; else ver[i] = ver[now]; &#125; else if (a == 2)ver[i] = ver[read()]; else &#123; b = read(), c = read(); x = findF(query(b, 1, n, root[ver[now]]), root[ver[now]]); y = findF(query(c, 1, n, root[ver[now]]), root[ver[now]]); printf("%d\n", x == y), ver[i] = ver[now]; &#125; now = i; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仍然是只利用线段树的叶子结点点权。它们只有一个权值，即father（代码中用fa），记录它的父结点的值（不是结点编号！！）。但这样在找father时会出现一个问题，那就是有很多历史版本，那就有很多值相同的结点，到底那个才是？当然选择在同一个版本下的结点，所以这里在找father时需要查询。这里容易混淆值和编号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的算法会TLE，原因显然：没有路径压缩，找father过程能直接卡到O(n)。在可持久化并查集中，我们不能进行路径压缩，这是因为路径压缩会破坏原有历史版本的信息，需要另辟蹊径。那么并查集除了路径压缩还有什么方法可以加快找father的速度？应选择按秩合并。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按秩合并很容易理解。用deep指标记录每一个等价类树的深度，那么当两个深度不等的树合并时，应将深度较小的合并到深度较大的树上，这样可以保证深度增长尽可能小。如果两者深度相同，那么合并后的树根深度需要加一。12345inline void merge(int x, int y) &#123; if (deep[x] &gt; deep[y])swap(x, y); root[root_cnt] = newTree(1, n, root[ver[now]], fa[x], fa[y]);//修改fa[x]位置结点的father为fa[y] if (deep[x] == deep[y])deep[query(fa[y], 1, n, root[root_cnt])]++;//直接修改深度&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面是可持久化并查集的合并函数。由于只有树根的deep才有用，所以只需要修改树根的deep即可。这里可能会有一个疑问：为什么只需要修改而不是新建结点？深度并不是我们需要维护的历史信息，因此修改这一个“历史信息”并不会带来实质性的影响。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define N 1000005using namespace std;inline int read() &#123; char e = getchar(); int s = 0, p = 0; while (e &lt; '-')e = getchar(); if (e == '-')p = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return p ? -s : s;&#125;int n, q, L[N &lt;&lt; 6], R[N &lt;&lt; 6], fa[N &lt;&lt; 6], root[N], cnt = 1, now, a, b, c, ver[N], deep[N&lt;&lt;6];int root_cnt = 1;int build(int l, int r) &#123; int rt = cnt++; if (l &lt; r)L[rt] = build(l, (l + r) &gt;&gt; 1), R[rt] = build(((l + r) &gt;&gt; 1) + 1, r); else fa[rt] = l, deep[rt] = 1;//注意初始化deep return rt;&#125;int newTree(int l, int r, int pre, int s, int what) &#123; int rt = cnt++; L[rt] = L[pre], R[rt] = R[pre]; if (l &lt; r) &#123; if (s &gt; ((l + r) &gt;&gt; 1))R[rt] = newTree(((l + r) &gt;&gt; 1) + 1, r, R[pre], s, what); else L[rt] = newTree(l, (l + r) &gt;&gt; 1, L[pre], s, what); &#125; else fa[rt] = what, deep[rt] = deep[pre];//继承原版本的deep值 return rt;&#125;int query(int k, int a, int b, int rk) &#123; if (a == b)return rk; if (((a + b) &gt;&gt; 1) &lt; k)return query(k, ((a + b) &gt;&gt; 1) + 1, b, R[rk]); return query(k, a, ((a + b) &gt;&gt; 1), L[rk]);&#125;int findF(int x, int v) &#123; int f = query(fa[x], 1, n, v); if (f == x)return x; return findF(f, v);&#125;inline void merge(int x, int y) &#123; if (deep[x] &gt; deep[y])swap(x, y); root[root_cnt] = newTree(1, n, root[ver[now]], fa[x], fa[y]); if (deep[x] == deep[y])deep[query(fa[y], 1, n, root[root_cnt])]++;&#125;int main() &#123; int x, y; n = read(), q = read(); root[0] = build(1, n), ver[0] = 0, now = 0; for (int i = 1; i &lt;= q; i++) &#123; a = read(); if (a == 1) &#123; b = read(), c = read(); x = findF(query(b, 1, n, root[ver[now]]), root[ver[now]]); y = findF(query(c, 1, n, root[ver[now]]), root[ver[now]]); if (fa[x] != fa[y]) merge(x, y), ver[i] = root_cnt++; else ver[i] = ver[now]; &#125; else if (a == 2)ver[i] = ver[read()]; else &#123; b = read(), c = read(); x = findF(query(b, 1, n, root[ver[now]]), root[ver[now]]); y = findF(query(c, 1, n, root[ver[now]]), root[ver[now]]); printf("%d\n", x == y), ver[i] = ver[now]; &#125; now = i; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树套树]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%A0%91%E5%A5%97%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍很基本的树套树，主要是怕自己忘了这个东西。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树套树（Tree in Tree），其实就是对于一棵树，其每一个结点也是树，由此形成的数据结构。树套树可以来维护区间、多维的信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文只涉及区间查询第k小，查询前驱、后继以及单点修改所需要的树套树方法：线段树套平衡树。这是一类很基本的树套树方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线段树维护区间信息，而平衡树维护对应区间上的有序序列。两者结合可以比较容易地解决区间上的查询问题。模板题：戳这里。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨每一个操作怎么去做： 操作一：找到每一个分区间中严格小于k的数的数目，然后输出它们的数量+1。复杂度$O(log^2n)$。 操作二：找排名对应的数。由于分区间在这个问题上没有可加性，可以考虑二分的操作。先二分某一个值，用操作一的方法找到其对应的排名，与目标排名进行比较即可。复杂度$O(log^3n)$。 操作三：找到包含这个数的所有平衡树，删掉原数，加入新数。 操作四：找到所有分区间中的前驱，取最大的一个。 操作五：找到所有分区间中的后继，取最小的一个。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作三到五的时间复杂度全为$O(log^2n)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平衡树有很多选择，有splay、treap、替罪羊树等等，这里选择splay树。另外树套树代码是真的长&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出模板题代码，常数大一点，吸个氧能过。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include&lt;bits/stdc++.h&gt;#define inf 2147483647#define N 50005using namespace std;inline int read() &#123;//读优 char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;int n, m, op[N];struct Node &#123; int f, ch[2], v, num, s; Node() &#123; s = f = ch[0] = ch[1] = v = num = 0; &#125;&#125; nodes[N * 80];struct Splay &#123;//平衡树定义 static int newNode(int v) &#123;//相当于内存池，分配新结点 static int cnt = 1; nodes[cnt].v = v, nodes[cnt].s = nodes[cnt].num = 1; return cnt++; &#125; int root = 0; static inline int identify(int x) &#123; return nodes[nodes[x].f].ch[1] == x; &#125; static inline void update(int x) &#123; if (x)nodes[x].num = nodes[nodes[x].ch[0]].num + nodes[nodes[x].ch[1]].num + nodes[x].s; &#125; static inline void change(int x, int y, int w) &#123; nodes[x].ch[w] = y, nodes[y].f = x; &#125; inline void rotate(int x) &#123; if (x == root)return; int f = nodes[x].f, g = nodes[f].f, i = identify(x), j = identify(f); change(f, nodes[x].ch[i ^ 1], i), change(x, f, i ^ 1), change(g, x, j); update(f), update(x); &#125; inline void splay(int at, int to = 0) &#123; while (nodes[at].f != to) &#123; int f = nodes[at].f, g = nodes[f].f; if (g != to) &#123; if (identify(at) == identify(f))rotate(f); else rotate(at); &#125; rotate(at); &#125; if (to == 0)root = at; &#125; inline void insert(int x) &#123; if (root == 0)root = newNode(x); else &#123; int cur = root, nxt = 0, np; while (true) &#123; if (nodes[cur].v &lt; x)nxt = nodes[cur].ch[1]; else if (nodes[cur].v &gt; x)nxt = nodes[cur].ch[0]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (nodes[cur].v == x)nodes[cur].s++, splay(cur); else if (nodes[cur].v &lt; x)change(cur, np = newNode(x), 1), splay(np); else change(cur, np = newNode(x), 0), splay(np); &#125; &#125; inline int findRink(int x) &#123; int cur = root, nxt = 0, ans = 0; while (true) &#123; if (nodes[cur].v &lt; x)nxt = nodes[cur].ch[1], ans += nodes[cur].num - nodes[nxt].num; else if (nodes[cur].v &gt; x)nxt = nodes[cur].ch[0]; else &#123; ans += nodes[nodes[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; splay(cur); return ans + 1; &#125; inline int nextNum(int x) &#123; int cur = root, nxt = 0, minn = inf, ans = -1; while (true) &#123; if (nodes[cur].v &lt; x)nxt = nodes[cur].ch[1]; else if (nodes[cur].v &gt; x) &#123; nxt = nodes[cur].ch[0]; if (nodes[cur].v &lt;= minn)minn = nodes[cur].v, ans = cur; &#125; else nxt = nodes[cur].ch[1]; if (nxt != 0)cur = nxt; else break; &#125; splay(ans); return ans; &#125; inline int preNum(int x) &#123; int cur = root, nxt = 0, maxn = -inf, ans = -1; while (true) &#123; if (nodes[cur].v &gt; x)nxt = nodes[cur].ch[0]; else if (nodes[cur].v &lt; x) &#123; nxt = nodes[cur].ch[1]; if (nodes[cur].v &gt;= maxn)maxn = nodes[cur].v, ans = cur; &#125; else nxt = nodes[cur].ch[0]; if (nxt != 0)cur = nxt; else break; &#125; splay(ans); return ans; &#125; int delNum(int x) &#123; int pre = preNum(x), nxt = nextNum(x); splay(pre), splay(nxt, pre); if (nodes[nodes[nxt].ch[0]].s &gt; 1)nodes[nodes[nxt].ch[0]].s--, splay(nodes[nxt].ch[0]); else nodes[nxt].ch[0] = 0, splay(nxt); return 1; &#125;&#125; splay[N &lt;&lt; 2];void build(int l, int r, int k) &#123;//构造树 if (l == r) &#123; splay[k].insert(op[l]), splay[k].insert(-inf), splay[k].insert(inf); return; &#125; for (int i = l; i &lt;= r; i++)splay[k].insert(op[i]); splay[k].insert(-inf), splay[k].insert(inf);//手动加入无穷大和无穷小点 build(l, ((l + r) &gt;&gt; 1), k &lt;&lt; 1), build((((l + r) &gt;&gt; 1) + 1), r, k &lt;&lt; 1 | 1);&#125;int queryRank(int a, int b, int s, int l = 1, int r = n, int k = 1) &#123; if (l &gt;= a &amp;&amp; r &lt;= b)return splay[k].findRink(s) - 2; int mid = (l + r) &gt;&gt; 1; if (b &lt;= mid)return queryRank(a, b, s, l, mid, k &lt;&lt; 1); else if (mid + 1 &lt;= a)return queryRank(a, b, s, mid + 1, r, k &lt;&lt; 1 | 1); return queryRank(a, mid, s, l, mid, k &lt;&lt; 1) + queryRank(mid + 1, b, s, mid + 1, r, k &lt;&lt; 1 | 1);&#125;void modify(int x, int y, int l = 1, int r = n, int k = 1) &#123; if (l &gt; r)return; if (x &gt;= l &amp;&amp; x &lt;= r)splay[k].delNum(op[x]), splay[k].insert(y); int mid = (l + r) &gt;&gt; 1; if (x &gt; mid)modify(x, y, mid + 1, r, k &lt;&lt; 1 | 1); else if (mid != r)modify(x, y, l, mid, k &lt;&lt; 1);&#125;int queryPre(int a, int b, int s, int l = 1, int r = n, int k = 1) &#123; if (l &gt;= a &amp;&amp; r &lt;= b)return nodes[splay[k].preNum(s)].v; int mid = (l + r) &gt;&gt; 1; if (b &lt;= mid)return queryPre(a, b, s, l, mid, k &lt;&lt; 1); else if (a &gt; mid)return queryPre(a, b, s, mid + 1, r, k &lt;&lt; 1 | 1); return max(queryPre(a, mid, s, l, mid, k &lt;&lt; 1), queryPre(mid + 1, b, s, mid + 1, r, k &lt;&lt; 1 | 1));&#125;int queryNext(int a, int b, int s, int l = 1, int r = n, int k = 1) &#123; if (l &gt;= a &amp;&amp; r &lt;= b)return nodes[splay[k].nextNum(s)].v; int mid = (l + r) &gt;&gt; 1; if (b &lt;= mid)return queryNext(a, b, s, l, mid, k &lt;&lt; 1); else if (a &gt; mid)return queryNext(a, b, s, mid + 1, r, k &lt;&lt; 1 | 1); return min(queryNext(a, mid, s, l, mid, k &lt;&lt; 1), queryNext(mid + 1, b, s, mid + 1, r, k &lt;&lt; 1 | 1));&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); build(1, n, 1); for (int i = 0; i &lt; m; i++) &#123; int opt = read(), a, b, c; if (opt == 1)a = read(), b = read(), c = read(), printf("%d\n", queryRank(a, b, c) + 1); else if (opt == 2) &#123; a = read(), b = read(), c = read(); int l = 0, r = inf, mid, s;//[,)，注意这里的二分细节 while (l &lt; r) &#123; if (l == r - 1) &#123; printf("%d\n", l); break; &#125; mid = (l + r) &gt;&gt; 1, s = queryRank(a, b, mid) + 1; if (s &gt; c)r = mid; else l = mid; &#125; &#125; else if (opt == 3)a = read(), b = read(), modify(a, b), op[a] = b; else if (opt == 4)a = read(), b = read(), c = read(), printf("%d\n", queryPre(a, b, c)); else a = read(), b = read(), c = read(), printf("%d\n", queryNext(a, b, c)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P4332]三叉神经树]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%B4%9B%E8%B0%B7P4332-%E4%B8%89%E5%8F%89%E7%A5%9E%E7%BB%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[难度：NOI/NOI+/CTSC 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算神经学作为新兴的交叉学科近些年来一直是学术界的热点。一种叫做SHOI 的神经组织因为其和近日发现的化合物 SHTSC 的密切联系引起了人们的极大关注。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHOI 组织由若干个 SHOI 细胞构成,SHOI 细胞之间形成严密的树形结构。每个SHOI细胞都有且只有一个输出端,被称为轴突,除了一个特殊的、被称为根细胞的 SHOI 细胞的输出作为整个组织的输出以外,其余细胞的轴突均连向其上级 SHOI 细胞；并且有且只有三个接收端,被称为树突,从其下级细胞或者其它神经组织那里接收信息。SHOI 细胞的信号机制较为简单,仅有0和1两种。每个 SHOI 细胞根据三个输入端中0和1信号的多寡输出较多的那一种。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给出了一段 SHOI 组织的信息,以及外部神经组织的输入变化情况。请你模拟 SHOI 组织的输出结果。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行包含一个整数 n。表示 SHOI 组织的总细胞个数。SHOI 细胞由 1~n 编号,编号为 1 的是根细胞。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从第二行开始的n行,每行三个整数$x_1, x_2, x_3$,分别表示编号为 1~n 的 SHOI 细胞的树突连接。$1 &lt; x_i \leq n$，表示连向编号为 $x_i$的细胞的轴突, $n &lt; x_i \leq 3n+1$表示连向编号为 $x_i$的外界输入。输入数据保证给出的SHOI组织是合法的，且所有的 $x_i$两两不同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来一行包含2n+1个0/1的整数,表示初始时的外界输入。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第n+3行有一个整数q,表示总操作数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后q行每行一个整数x,表示编号为x的外界输入发生了变化。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出q行，每行一个整数,对应第i次外界输入变化后的根细胞的输出。 输入输出样例Sample input 32 3 45 6 78 9 100 0 0 0 1 1 1544568 Sample output 10011 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，$n \leq 500000, q \leq 500000$。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难度较大的LCT应用题。思路很巧妙，强烈推荐。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到每一次修改都会使从叶子结点开始向根结点的一段序列发生改变。规定每一个点的点权为其来自子结点的1的数目，这样点权就有0~3四种情况。并且可以发现如果某个叶子结点的值从0变为1，则向上连续一段点权为1的点将连锁发生改变；从1变为0则向上连续一段点权为2的点将连锁发生改变。总结起来，如果从0变为1，则向上第一个不为1的点到叶子结点的点权都需要修改；从1变为0，则向上第一个不为2的点到叶子结点的点权都需要修改。这样问题简化为如何维护树链上点权的问题，可以用LCT搞出来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果用朴素LCT写法，会发现翻转时不容易维护信息。因此可以采用非换根式的写法，一开始便指定1为根结点，之后不再更换。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义v[x]为点权，num[x][i]表示以x结点为根的splay树上最深的不为i的点的编号，plusTAG为加法懒标记。这样可以写出函数：12345678910111213141516171819202122232425262728inline void pushr(int x, int y) &#123;//以x为根的树上结点点权加上y if (x) &#123; v[x] += y, plusTAG[x] += y;//更新点权，打上标记 if (y &gt; 0)for (int i = 3; i &gt;= 0; i--)num[x][i] = (i - y &gt;= 0 ? num[x][i - y] : 0);//更新num else if (y &lt; 0)for (int i = 0; i &lt; 4; i++)num[x][i] = (i - y &lt;= 3 ? num[x][i - y] : 0); &#125;&#125;inline void pushdown(int x) &#123;//下压加法懒标记，这里没有翻转标记 if (plusTAG[x])pushr(son[x][0], plusTAG[x]), pushr(son[x][1], plusTAG[x]), plusTAG[x] = 0;&#125;inline void update(int x) &#123;//更新信息 if (v[x] == 1) &#123; if (num[son[x][1]][1] == 0)num[x][1] = num[son[x][0]][1];//没有右儿子，去左儿子找 else num[x][1] = num[son[x][1]][1];//继承右儿子 &#125; else &#123; if (num[son[x][1]][1] == 0)num[x][1] = x;//右儿子没有，则x本身就是 else num[x][1] = num[son[x][1]][1]; &#125; if (v[x] == 2) &#123; if (num[son[x][1]][2] == 0)num[x][2] = num[son[x][0]][2]; else num[x][2] = num[son[x][1]][2]; &#125; else &#123; if (num[son[x][1]][2] == 0)num[x][2] = x; else num[x][2] = num[son[x][1]][2]; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就是基本的链上修改操作。下面考虑在不换根的情况下如何建立LCT。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到点的关系是按照继承顺序给出的，可以直接如下修改：1234567for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; scanf("%d", &amp;x), add(x, i), add(i, x);//这里是链式前向星存图使用的 if (x &gt; n)to[x - n] = i;//对于大于n的结点，记录一下其父结点，即输出结点 else fa[x] = i;//LCT构造使用，直接虚边相连 &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再然后，DFS出每一个点的初始点权，容易知道此时所有点独立成为一棵splay树，我们先建树再单独修改每一个点的点权是没有问题的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的查询修改操作就是重点：12345678910111213for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;x); if (v[x] == 3) &#123;//我这里规定叶子结点为1权值就是3，为0就是0 v[x] = 0; access(to[x - n]), splay(to[x - n]), access(realF[num[to[x - n]][2]]), splay(to[x - n]);//realF为原树中的父结点，DFS时候求出 pushr(to[x - n], -1); &#125; else &#123; v[x] = 3; access(to[x - n]), splay(to[x - n]), access(realF[num[to[x - n]][1]]), splay(to[x - n]); pushr(to[x - n], 1); &#125; splay(1), printf("%d\n", v[1] &gt; 1); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中演示了如何在不换根的情况下把一条链剖出来。首先access到叶子结点，再splay，然后将其树上第一个不为1(2)的点的父结点access出来，剩下的就是我们需要的树链了。这里再进行一步splay，然后更新结点信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询时，先splay(1)，然后输出结果即可。我们在讨论LCT的文章末尾曾提及，split出来的splay树，其根结点信息必然是经过更新的。这里根就是1，所以makeRoot(1)和access(1)本质上是没有效果的，因此这里一步splay就可以更新信息。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;#define N 500005using namespace std;int n, q, son[N][2], fa[N], sta[N], v[N * 3], plusTAG[N], to[N &lt;&lt; 1 | 1], realF[N];int num[N][3];struct Edge &#123; int to, next;&#125; edge[N * 6];int head[N * 3], cnt = 1;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;inline void pushr(int x, int y) &#123; if (x) &#123; v[x] += y, plusTAG[x] += y; if (y &gt; 0)for (int i = 3; i &gt;= 0; i--)num[x][i] = (i - y &gt;= 0 ? num[x][i - y] : 0); else if (y &lt; 0)for (int i = 0; i &lt; 4; i++)num[x][i] = (i - y &lt;= 3 ? num[x][i - y] : 0); &#125;&#125;inline void pushdown(int x) &#123; if (plusTAG[x])pushr(son[x][0], plusTAG[x]), pushr(son[x][1], plusTAG[x]), plusTAG[x] = 0;&#125;inline void update(int x) &#123; if (v[x] == 1) &#123; if (num[son[x][1]][1] == 0)num[x][1] = num[son[x][0]][1]; else num[x][1] = num[son[x][1]][1]; &#125; else &#123; if (num[son[x][1]][1] == 0)num[x][1] = x; else num[x][1] = num[son[x][1]][1]; &#125; if (v[x] == 2) &#123; if (num[son[x][1]][2] == 0)num[x][2] = num[son[x][0]][2]; else num[x][2] = num[son[x][1]][2]; &#125; else &#123; if (num[son[x][1]][2] == 0)num[x][2] = x; else num[x][2] = num[son[x][1]][2]; &#125;&#125;inline bool isNotRoot(int x) &#123; return son[fa[x]][0] == x || son[fa[x]][1] == x;&#125;inline int identify(int x) &#123; return son[fa[x]][1] == x;&#125;inline void change(int f, int s, int w) &#123; fa[s] = f, son[f][w] = s;&#125;inline void rotate(int x) &#123; int f = fa[x], g = fa[f], i = identify(x), j = identify(f); if (!isNotRoot(f))fa[x] = g; else change(g, x, j); change(f, son[x][i ^ 1], i), change(x, f, i ^ 1), update(f), update(x);&#125;inline void splay(int x) &#123; int i = 0, y = x; sta[++i] = y; while (isNotRoot(y))sta[++i] = y = fa[y]; while (i)pushdown(sta[i--]); while (isNotRoot(x)) &#123; int f = fa[x]; if (isNotRoot(f)) &#123; if (identify(x) == identify(f))rotate(f); else rotate(x); &#125; rotate(x); &#125;&#125;inline void access(int x) &#123; for (int i = 0; x; x = fa[i = x])splay(x), son[x][1] = i, update(x);&#125;void DFS(int x, int fa) &#123; if (x &gt; n)return; realF[x] = fa; for (int i = head[x]; i; i = edge[i].next)if (edge[i].to != fa)DFS(edge[i].to, x), v[x] += (v[edge[i].to] &gt; 1);&#125;int main() &#123; int x; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; scanf("%d", &amp;x), add(x, i), add(i, x); if (x &gt; n)to[x - n] = i; else fa[x] = i; &#125; &#125; for (int i = 1; i &lt;= (n &lt;&lt; 1 | 1); i++)scanf("%d", &amp;x), v[i + n] = (x ? 3 : 0); DFS(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;x); if (v[x] == 3) &#123; v[x] = 0; access(to[x - n]), splay(to[x - n]), access(realF[num[to[x - n]][2]]), splay(to[x - n]); pushr(to[x - n], -1); &#125; else &#123; v[x] = 3; access(to[x - n]), splay(to[x - n]), access(realF[num[to[x - n]][1]]), splay(to[x - n]); pushr(to[x - n], 1); &#125; splay(1), printf("%d\n", v[1] &gt; 1); &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题影射了LCT中结点的更新规律，并且有着不换根剖树链的黑科技操作，强烈推荐一做。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT（动态树）]]></title>
    <url>%2F2019%2F04%2F05%2FLCT%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍超强数据结构：LCT，这也是博客中目前为止最高级的数据结构。LCT需要前缀知识：树链剖分、Splay。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树链剖分可以很好地维护树中两条链之间的路径信息，但是它的前提是树是静态的。如果树中有断边，连边和换根操作，那么树链剖分就不能再起它的作用。这时就需要动态树（Link-Cut-Tree，LCT）来解决这个问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCT的思想仍然是链的划分。在树链剖分中，曾经根据儿子的轻重关系来进行划分，LCT中也有类似的操作。在LCT中，边分为实边和虚边，其中实边所成的链称为实链。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实边中，父子都保留彼此的信息，但是虚边中仅有儿子保留父结点的信息，但父结点不保留儿子的信息，即认父不认子。实链和虚边满足以下性质： 每一个结点存在且仅存在一个实链中。 不同的实链之间通过虚边相连，对于一棵splay，它的根结点会与另一棵splay树上的某个结点建立虚边关系。 实边和虚边是可以动态修改的。 LCT中的结点信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与认识平衡树相同，这里当然也有LCT结点的结构定义。但是为了方便起见，不再使用结构体定义，直接应用数组。1int son[N][2], fa[N];//N是事先定义好的结点数目 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有两个信息：son表示结点的儿子，其中son[x][0]表示x的左儿子，son[x][1]为右儿子。fa[x]为结点x的父结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时就有疑问：为什么这时一棵二叉树的结点定义？显然给定的树并不一定为二叉树。这里就是LCT的一个思想：将树中的所有实链变成一棵splay树，并让这些splay树通过虚边相连。splay树是二叉树，那么这里的结点定义就是二叉树的定义形式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到这里，需要引入LCT中splay的性质：LCT中，任何splay树中的结点相对根结点的深度必定互不相同，而且是连续的，并且splay树上左结点深度小于该结点深度，该结点深度小于右结点深度，即满足二叉查找树的性质。这样一来，splay的前序遍历序列就是按深度排列的树链结点序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是一些基本操作函数的定义，这些都是splay上面的操作。1234567inline int identify(int x) &#123;//判别儿子性质 return son[fa[x]][1] == x;&#125;inline void change(int f, int s, int w) &#123;//建立父子关系，即连一条实边 fa[s] = f, son[f][w] = s;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里还需要一个特别的函数：isNotRoot()函数，它的作用是判断某一个结点是否为该结点所在的splay树的根结点。由前文可知，每一个结点都在唯一的实链中，并且这个实链用一棵splay树维护。123inline bool isNotRoot(int x) &#123; return son[fa[x]][0] == x || son[fa[x]][1] == x;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判别方法比较简单，如果该结点的父结点不认这个儿子结点，就说明这是一条虚边，那么该结点就是splay上的根结点。在这个问题上，不推荐定义等价的isRoot()函数，这是因为LCT中判别非根的操作更多，而频繁逻辑取反相当费时。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解了上面的内容，可能一个很大的疑惑是：实边和虚边究竟是什么？它们对应原树上的什么？对于后者，前文已经提及，所有实边集和虚边集加起来就是树上的所有边的集合，即每一条边唯一地划分为虚边和实边中的一种。对于一棵splay树，有许多其它splay的根结点与该splay树上的某一结点建立虚边关系，该splay树的根结点也会与另一棵splay树上的结点建立虚边关系。如果结点x和结点y建立了虚边关系，并有fa[x]=y，那么在原树上y是x所在splay树上深度最小的结点的父结点。 ratote和splay操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splay树上的旋转和伸展操作与普通splay类似。1234567891011121314151617inline void rotate(int x) &#123;//旋转 int f = fa[x], g = fa[f], i = identify(x), j = identify(f); if (!isNotRoot(f))fa[x] = g;//注意这里！！f为根时不能直接建立父子关系，因为这是虚边 else change(g, x, j);//否则建立实边关系 change(f, son[x][i ^ 1], i), change(x, f, i ^ 1);&#125;inline void splay(int x) &#123;//伸展，这不是LCT的最终版splay操作，需要修改，下面会继续介绍。默认旋转到根，因此仅有一个参数 while (isNotRoot(x)) &#123; int f = fa[x]; if (isNotRoot(f)) &#123; if (identify(x) == identify(f))rotate(f);//双旋 else rotate(x); &#125; rotate(x); &#125;&#125; access操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access操作是LCT的核心操作，它的作用是将整棵树的根结点到某个结点之间的路径转变为实边，其余边断为虚边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在原树中对于任意一个结点，它到根结点的路径必然是唯一的。access操作就是将这个唯一路径上的结点单独剥离出来形成一条实链，原先与该链上结点连接的实边断为虚边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们要access(x)。首先将x结点splay到其所在splay树的根结点位置，这时结点x的右子树上的结点深度大于x，必然不在路径中，直接将边断为虚边；而对于左子树上的结点，其深度都小于结点x，必然都在结点x到根结点的路径上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是找到结点x的父结点（虚边连接），继续递归操作。这样就可以得到下面的代码：123inline void access(int x) &#123; for (int i = 0; x; x = fa[i = x])splay(x), son[x][1] = i;//换儿子，即不认子，断实边为虚边&#125; makeRoot操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换根操作。它的作用是更换原树的树根，并保持LCT的性质不变。换根也是重要操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想让x变成树根，那么需要先access(x)打通根结点到x的路径，然后splay(x)，将x伸展到根，这时x必定没有右儿子。如果需要将变为根，那么只需要将这棵splay左右翻转过来即可。这里就需要用到文艺平衡树中的翻转标记，它的作用是标记以某一个结点为根的splay树需要翻转，注意打标记时这个结点的左右子树已经交换了。123inline void pushr(int x) &#123;//翻转函数 swap(son[x][0], son[x][1]), lazy[x] ^= 1;//交换左右儿子，并且更新标记&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lazy就是翻转标记，是一种懒操作。那么makeRoot函数就可以写出了：123inline void makeRoot(int x) &#123; access(x), splay(x), pushr(x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何下压标记？注意到在splay时，如果我们想要将x伸展到根位置，但是其到根的路径上有一些翻转标记，那么此时直接splay一定会出问题。于是在splay之前，我们需要把从splay的根结点到该结点之间路径上的所有结点从上到下依次下压标记，之后再进行伸展操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要一个下压标记的函数。123inline void pushdown(int x) &#123; if (lazy[x])pushr(son[x][0]), pushr(son[x][1]), lazy[x] = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后splay函数需要修改成这样：1234567891011121314inline void splay(int x) &#123; int i = 0, y = x; sta[++i] = y;//手写一个栈 while (isNotRoot(y))sta[++i] = y = fa[y];//将路径结点记录下来 while (i)pushdown(sta[i--]);//利用栈的性质，从上而下依次放标记 while (isNotRoot(x)) &#123; int f = fa[x]; if (isNotRoot(f)) &#123; if (identify(x) == identify(f))rotate(f); else rotate(x); &#125; rotate(x); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了：换根后能不能保证所有splay仍然满足对于新的树根，其深度互不相同？答案是可以保证，请读者自行思考。 findRoot操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：通过某一个结点x找到整棵树的根。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做法比较简单。首先access(x)，然后在这一棵splay上不断找左儿子即可，最左侧的结点深度最小，就是整棵树的根结点。123456inline int findRoot(int x) &#123; access(x), splay(x); while (son[x][0])pushdown(x), x = son[x][0]; splay(x);//保证复杂度 return x;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到这里有下压标记操作，这是使用LCT中需要特别注意的一个地方：任何情况下，只要在splay树上通过左右儿子结点来找某一个结点，都不能保证标记成功下放。于是需要不断下压标记。 link操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link作用：当两个结点不在同一棵树上时连接两个结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设要连接x和y。首先将x变成其所在树的根，然后从x向y连一条虚边。1234inline void link(int x, int y) &#123; makeRoot(x); if (x != findRoot(y))fa[x] = y;//之前要判别是否在一棵树中，根据相同的根结点判断&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果保证连边合法，则可以简化为：1234inline void link(int x, int y) &#123; makeRoot(x); fa[x] = y;&#125; cut操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cut作用：当两个结点相连时，断开两点之间的边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设要断开x和y。首先将x变成根，然后access(y)，并且将x伸展到根，断开实边即可。12345inline void cut(int x, int y) &#123; makeRoot(x); if (findRoot(y) == x &amp;&amp; fa[y] == x &amp;&amp; !son[y][0])fa[y] = 0, son[x][1] = 0;//断实边 //判定合法三要素：在同一棵树中，父结点是x并且y没有左儿子（没有中间的结点）&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里findRoot操作内含了splay和access，不用再重复写出来。如果保证合法，则代码简化为：1234inline void cut(int x, int y) &#123; makeRoot(x), access(y), splay(x); fa[y] = 0, son[x][1] = 0;&#125; split操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split作用：将x到y的路径剥离出来，形成一棵splay树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法比较容易，先换根，再access，最后splay。123inline void split(int x, int y) &#123; makeRoot(x), access(y), splay(y);//最后splay(x)也是可以的&#125; 关于LCT的构造&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上面的讨论，可能还会有一个疑惑：给定一棵树，按照link进行操作，此时没有指定哪一个结点是根，怎么理解？这里需要注意到一个问题，起初未连任何边时，可以认为每一个结点都是一个独立的splay树，它们自己就是自己所在树的根。不断link后，整棵树的根结点就会隐式确定，也就是说，虽然我们没有指定谁是根结点，但是根结点已经在link中确定了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果确定根结点，并且可以按照点的深度排布给出点的连接次序，那么我们可以采用另一种不换根的方式来进行link。比如说指定1为根结点，与结点2相连，那么直接fa[2]=1就可以完成link操作。同样地，此时如果2与3相连，可以直接fa[3]=2。这样的link操作没有出现任何换根和access操作，但同样可以构造出合法的LCT。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，LCT的构造相当灵活。只要满足上面所说的LCT性质，构造出的LCT就是合法的。通常情况下，可以通过朴素的link操作来构造LCT，某些特殊情况下可以通过直接连虚边的方式进行构造。 用LCT维护路径信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文这么多东西，还没有具体描述LCT维护路径信息的方法！这里其实就有各种搞法了，需要根据待维护的信息来进行变换。这里先以模板题为例，它需要维护路径上点权的异或值，并且需要单点修改。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义v[x]为结点x的点权，val[x]表示以x为根的splay树上所有结点的异或值，然后可以得到更新函数：123inline void update(int x) &#123;//在其它地方也称为pushup函数 val[x] = v[x] ^ val[son[x][0]] ^ val[son[x][1]];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步update需要在rotate函数中体现出来：1234567inline void rotate(int x) &#123; int f = fa[x], g = fa[f], i = identify(x), j = identify(f); if (!isNotRoot(f))fa[x] = g; else change(g, x, j); change(f, son[x][i ^ 1], i), change(x, f, i ^ 1); update(f), update(x);//由于修改了结点连接，需要进行更新&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有哪些函数需要修改呢？注意到access函数重新划分了实边，需要进行update：123inline void access(int x) &#123; for (int i = 0; x; x = fa[i = x])splay(x), son[x][1] = i, update(x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然还有cut函数：1234inline void cut(int x, int y) &#123; makeRoot(x); if (findRoot(y) == x &amp;&amp; fa[y] == x &amp;&amp; !son[y][0])fa[y] = 0, son[x][1] = 0, update(x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link函数是不需要的。这是因为link函数连的是虚边，不影响splay树上的结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样似乎就比较完美了，那如何查询结果？如果需要查询x到y的异或结果，需要先split(x,y)，然后val[y]就是答案。（如果split最后一步是splay(x)，那么答案是val[x]）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要单点修改时，需要先splay(x)，然后直接修改v[x]的值，然后update(x)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出模板题全部代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define N 300005using namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;int n, m, v[N], son[N][2], fa[N], lazy[N], sta[N], val[N];inline void update(int x) &#123; val[x] = v[x] ^ val[son[x][0]] ^ val[son[x][1]];&#125;inline bool isNotRoot(int x) &#123; return son[fa[x]][0] == x || son[fa[x]][1] == x;&#125;inline int identify(int x) &#123; return son[fa[x]][1] == x;&#125;inline void change(int f, int s, int w) &#123; fa[s] = f, son[f][w] = s;&#125;inline void rotate(int x) &#123; int f = fa[x], g = fa[f], i = identify(x), j = identify(f); if (!isNotRoot(f))fa[x] = g; else change(g, x, j); change(f, son[x][i ^ 1], i), change(x, f, i ^ 1); update(f), update(x);&#125;inline void pushr(int x) &#123; swap(son[x][0], son[x][1]), lazy[x] ^= 1;&#125;inline void pushdown(int x) &#123; if (lazy[x])pushr(son[x][0]), pushr(son[x][1]), lazy[x] = 0;&#125;inline void splay(int x) &#123; int i = 0, y = x; sta[++i] = y; while (isNotRoot(y))sta[++i] = y = fa[y]; while (i)pushdown(sta[i--]); while (isNotRoot(x)) &#123; int f = fa[x]; if (isNotRoot(f)) &#123; if (identify(x) == identify(f))rotate(f); else rotate(x); &#125; rotate(x); &#125;&#125;inline void access(int x) &#123; for (int i = 0; x; x = fa[i = x])splay(x), son[x][1] = i, update(x);&#125;inline void makeRoot(int x) &#123; access(x), splay(x), pushr(x);&#125;inline int findRoot(int x) &#123; access(x), splay(x); while (son[x][0])pushdown(x), x = son[x][0]; splay(x); return x;&#125;inline void link(int x, int y) &#123; makeRoot(x); if (x != findRoot(y))fa[x] = y;&#125;inline void cut(int x, int y) &#123; makeRoot(x); if (findRoot(y) == x &amp;&amp; fa[y] == x &amp;&amp; !son[y][0])fa[y] = 0, son[x][1] = 0, update(x);&#125;inline void split(int x, int y) &#123; makeRoot(x), access(y), splay(y);&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)v[i] = read(); for (int i = 1; i &lt;= m; i++) &#123; int p = read(), x = read(), y = read(); if (p == 0)split(x, y), printf("%d\n", val[y]); else if (p == 1)link(x, y); else if (p == 2)cut(x, y); else splay(x), v[x] = y, update(x); &#125; return 0;&#125; 其它重要的事&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCT中如果需要修改区间怎么办？仍然先split，然后利用懒标记思想打上标记即可。下压操作可以合并到pushdown中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCT中各种修改，换根，下压标记，怎样才能知道通过访问val[x]得到的结果是已经得到更新的？这是一个很实用而且重要的问题。为了简化这个问题，我们记住并遵循下面的一些规则即可： 对点彻底更新。当我们修改信息（pushr函数）或者直接更新（update函数）时，做到彻底更新。对于单点修改，要将所有需要修改的地方都修改过来，对于链上修改，需要彻底修改点，然后打上标记。对于所在splay只有本身一个点的结点，可以只指明点权而不更新其额外信息，这是因为在这棵splay上的旋转操作可以自然更新信息。 经过split得到的splay树的根结点信息是最新的。 不要轻易修改0号结点的点权。0号结点表示没有结点，在更新时常常用到，如果盲目修改，很可能会出问题。 经过split得到的splay树除了根结点外的结点不一定是最新的（即可能有标记未下压）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反观上面单点修改的过程，这里就做到了对点彻底更新：将x的val值同样进行更新，不更新就会出错。另外必须先经过splay，才能修改，这是因为splay后只需要修改那一个点即可，否则不能做到完全修改。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面看一道洛谷P2486 染色。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题涉及链上信息查询和链信息修改两个操作，定义val[x]表示该splay树上颜色段的数目，并定义修改颜色懒标记cl。用c[x]表示结点x的颜色，l[x]表示该splay树上深度最小点的颜色，r[x]为深度最大点的颜色。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更换颜色操作：123inline void color_pushdown(int x, int y) &#123; if (x)c[x] = l[x] = r[x] = y, val[x] = 1, cl[x] = y;//注意彻底更新：l和r、val也同时得到了更新，并且不要修改0结点，事实证明这是全部WA和AC的区别&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外翻转操作：123inline void pushdown(int x) &#123; swap(l[x], r[x]), swap(son[x][0], son[x][1]), lazy[x] ^= 1;//注意第一个swap&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下压操作：1234inline void down(int x) &#123; if (lazy[x])pushdown(son[x][0]), pushdown(son[x][1]), lazy[x] = 0; if (cl[x])color_pushdown(son[x][0], cl[x]), color_pushdown(son[x][1], cl[x]), cl[x] = 0;//多一个颜色下压&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面三步可以看出，所有点信息的更新都是彻底更新。然后实际操作中：12if (e == 'Q')scanf("%d%d", &amp;x, &amp;y), split(x, y), printf("%d\n", val[y]);//split得到的splay树根结点信息是得到更新的 else scanf("%d%d%d", &amp;x, &amp;y, &amp;z), split(x, y), color_pushdown(y, z);//对点进行彻底修改并打上标记 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于LCT应用，另外的文章来介绍。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵求逆]]></title>
    <url>%2F2019%2F04%2F03%2F%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍矩阵求逆算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个方阵$A$和$B$，若有$AB=E$，$E$为单位阵，则称$A$与$B$互为逆矩阵。一个方阵不一定有逆矩阵，它可逆的充要条件是矩阵满秩。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知道，若公式$AB=E$成立，则这里的A与B必定满秩，且A可以看做一系列初等矩阵的乘积，它左乘矩阵B，相当于对B做了初等行变换。于是可以构造矩阵： P=\begin{bmatrix} B&E\end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么有： AP=A\begin{bmatrix}B&E\end{bmatrix}=\begin{bmatrix}AB&AE\end{bmatrix}=\begin{bmatrix}E&A\end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可以构造矩阵P，对其进行初等行变换，使其前n列部分成为单位矩阵，则剩下的部分就是逆矩阵。这种方法称为初等行变换法，算法上可以通过高斯消元实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题。注意这里需要求模，于是可以在进行除法时利用乘法逆元来进行计算，乘法逆元可以通过费马小定理来求。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define MOD static_cast&lt;long long&gt;(1e9+7)using namespace std;long long op[450][850];int n;long long qPow(long long x, long long y = MOD - 2) &#123; long long ans = 1l, s = x; while (y) &#123; if (y &amp; 1)ans *= s, ans %= MOD; s *= s, s %= MOD, y &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++)cin &gt;&gt; op[i][j]; for (int i = n + 1; i &lt;= (n &lt;&lt; 1); i++)op[i - n][i] = 1;//补充矩阵 for (int i = 1; i &lt;= n; i++) &#123; int maxn = i; for (int j = i + 1; j &lt;= n; j++)if (abs(op[j][i]) &gt; abs(op[maxn][i]))maxn = j; if (!op[maxn][i]) &#123;//不满秩，输出不可逆 cout &lt;&lt; "No Solution"; return 0; &#125; swap(op[maxn], op[i]); long long div = qPow(op[i][i]);//费马小定理+快速幂求乘法逆元 for (int j = i; j &lt;= (n &lt;&lt; 1); j++)op[i][j] = op[i][j] * div % MOD;//处理本行 for (int j = i + 1; j &lt;= n; j++) &#123; div = op[j][i]; for (int p = i; p &lt;= (n &lt;&lt; 1); p++)op[j][p] = (op[j][p] - div * op[i][p]) % MOD;//处理其它行 &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123;//化为单位阵 for (int j = 1; j &lt; i; j++) &#123; long long div = op[j][i]; for (int p = 1; p &lt;= (n &lt;&lt; 1); p++)op[j][p] = (op[j][p] - div * op[i][p]) % MOD; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123;//输出结果 for (int j = n + 1; j &lt;= (n &lt;&lt; 1); j++)cout &lt;&lt; (op[i][j] % MOD + MOD) % MOD &lt;&lt; " "; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matrix-Tree定理]]></title>
    <url>%2F2019%2F04%2F03%2FMatrix-Tree%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix-Tree是无向图生成树计数的利器，本文需要线性代数的前缀知识。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外：第100篇博客纪念XD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个图，如何统计这个图生成树的数目？这就是Matrix-Tree解决的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在了解这个定理之前，先介绍高斯消元。 高斯消元&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道矩阵可以用来求解线性方程组。但是对于一个给定的矩阵，如何去求解？高斯消元法利用了矩阵初等行变换的性质，将矩阵化为行阶梯型矩阵，再求解方程组。 \begin{bmatrix} 1&3&4\\ 1&4&7\\ 9&3&2 \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于上面的矩阵，可以将其化为下面的形式： \begin{bmatrix} 1&3&4\\ 0&1&3\\ 0&0&1 \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行这样操作的算法就是高斯消元法，该算法时间复杂度为$O(n^3)$，对于模板题，它的算法代码如下：1234567891011121314151617inline void Guess() &#123; for (int i = 1; i &lt;= n; i++) &#123;//枚举列数，总列数为n int maxn = i;//假设当前行（第i列对应第i行） for (int j = i + 1; j &lt;= n; j++)if (fabs(op[j][i]) &gt; fabs(op[maxn][i]))maxn = j;//找向下的行中对应列元素绝对值最大的一个，绝对值大有利于减小误差 if (i != maxn)swap(op[i], op[maxn]);//不同的话，交换两行，swap可以直接交换两个数组 if (fabs(op[maxn][i]) &lt; EPS) &#123;//绝对值最大的为0，说明不满秩，方程组没有唯一解，结束程序。EPS用来消浮点误差。 cout &lt;&lt; "No Solution"; exit(0); &#125; double div = op[i][i];//找到除法因子 for (int j = i; j &lt;= n + 1; j++)op[i][j] /= div;//这一行先全部除以该值，此时首元素应为1 for (int j = i + 1; j &lt;= n; j++) &#123;//其余行减掉该行的倍数 div = op[j][i]; for (int z = 1; z &lt;= n + 1; z++)op[j][z] -= op[i][z] * div; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高斯消元就是这样了，原理上的东西见线性代数教材。注意这里的高斯消元会将主对角线上的元素同一化为1。 Kirchhoff（基比霍夫）矩阵&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍基比霍夫矩阵之前需要先了解邻接矩阵和度数矩阵。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;邻接矩阵中，$A[i][j]$表示结点i和结点j之间边的数目；度数矩阵中若$i≠j$则$D[i][j]=0$，否则为点i的度数（即连接该点的边的数目）。基比霍夫矩阵定义为$K=D-A$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图，其邻接矩阵和度数矩阵分别为： A=\begin{bmatrix} 0&1&1&1\\ 1&0&1&0\\ 1&1&0&1\\ 1&0&1&0 \end{bmatrix}\ \ \ D=\begin{bmatrix} 3&0&0&0\\ 0&2&0&0\\ 0&0&3&0\\ 0&0&0&2 \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可以得到基比霍夫矩阵： K=D-A=\begin{bmatrix} 3&-1&-1&-1\\ -1&2&-1&0\\ -1&-1&3&-1\\ -1&0&-1&2 \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基比霍夫矩阵有一些性质如下： 性质一：对于任意无向图，其基比霍夫矩阵行列式必为0即有$|K|=0$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知矩阵K中每一行元素之和必为0，因此行列式为0。 性质二：对于不连通的无向图，其基比霍夫矩阵的任意n-1阶主子式必为0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识到调整行列式中行的顺序不会影响行列式是否为0这个问题的结果，因此可以调整行列式中行的顺序关系，使属于同一个连通分量中的点在相邻的两行。这样$|K|$就成为下面的对角形式： |K|=\begin{vmatrix} A_1&{\cdots}&0\\ {\vdots}&{\ddots}&{\vdots}\\ 0&{\cdots}&{A_k} \end{vmatrix} =|A_1|\cdots |A_k|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图不连通时，去除一行一列后再求n-1阶主子式，必然使得其中至少一个连通分量是完整的。根据性质一，其行列式为0，因此乘积为0。 性质三：如果图是一棵树，则其基比霍夫矩阵的任意n-1阶主子式必为1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明略。 Matrix-Tree（矩阵树）定理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【Matrix-Tree】矩阵树定理：对于一个无向图，其生成树数目为其基比霍夫矩阵任意n-1阶主子式的绝对值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵树定理给出了生成树计数的方法。那么如何求行列式？一种方法是将行列式化为上三角形式，然后主对角线上的元素的乘积即为行列式的值，对角化过程可以用高斯消元实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看一个模板题。很明显是生成树计数问题，直接用矩阵树定理即可。注意要用高精度计算，这里用python配decimal消精度误差偷个懒。123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python3from decimal import Decimal, getcontextgetcontext().prec = 45n = int(input())if n == 1 or n == 2: if n == 1: print(1) else: print(5) exit(0)op = []ans = Decimal('1')for i in range(0, n): # 构造基比霍夫矩阵 op.append([]) for j in range(0, n + 1): if i == j: op[i].append(Decimal('3')) elif j == (i - 1 + n) % n or j == (i + 1 + n) % n: op[i].append(Decimal('-1')) else: op[i].append(Decimal('0'))for i in range(0, n): # 高斯消元 p = i for j in range(i + 1, n): if op[j][i] &gt; op[p][i]: p = j if p != i: op[p], op[i] = op[i], op[p] # Swap for j in range(i + 1, n): # 这里和上面高斯消元不同，省略了当前行首元素化为1的步骤 div = op[j][i] / op[i][i] for z in range(i, n): op[j][z] -= div * op[i][z]for i in range(0, n): ans *= op[i][i]print("&#123;:.0f&#125;".format(ans))]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左偏树（可并堆）]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%88%E5%8F%AF%E5%B9%B6%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可并堆就是可以快速合并的堆，可用左偏树来实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉堆，这是一个很熟悉的数据结构。但是如何将两个二叉堆合并起来？STL中的优先队列并没有提供这个方法，手写堆合并复杂度达到$O(nlogn)$，效率很低。左偏树可以在对数时间复杂度下完成合并操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识左偏树的性质，以小根堆为例。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义距离的概念：外结点（左儿子或右儿子为空的结点）距离定义为0，其余结点距离定义为该点到离它最近的叶子结点的距离（就是边的数量）。左偏树满足： 【堆性质】任意结点的权值必不大于其两个子结点的权值。 【左偏性质】任意结点左儿子的距离必不小于右儿子 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左偏树不再是完全二叉树，但仍是二叉树，满足堆的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样可以得到两个推论： 任意结点距离为其右儿子距离加一 有n个结点的左偏树，其最大距离为$log(n+1)-1$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于第二个推论的证明：假定最大距离为d，那么结点数最少时就是完全二叉树的情况，即有$n\geq 2^{d+1}-1$，那么有$d\leq log(n+1)-1$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个推论保证了左偏树的时间复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何合并呢？这个过程类似FHQ Treap的合并过程，以递归的方式进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设要合并以a和b为根的两棵左偏树，如果a结点的权值更大，那么交换两棵树。这一步是为了使a结点作为新树的根。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时结点a必为根，此时合并树a的右儿子（这里合并左儿子也是可以的）和树b，递归进行。将合并后的新树根作为右儿子（左儿子）。根据左偏树推论二，这一步合并的时间复杂度在对数级别。这一步之后，左偏树的性质可能会被破坏，需要调整左右子树位置，更新距离。代码如下：123456789int merge(int a, int b) &#123; if (!a || !b)return a + b; if (val[root[a].d] &gt; val[root[b].d] || (val[root[a].d] == val[root[b].d] &amp;&amp; root[a].d &gt; root[b].d))swap(a, b); int p = merge(root[a].ch[0], b); father[p] = a, root[a].ch[0] = p;//father是并查集使用的，暂且不用管它 if (root[root[a].ch[0]].dict &lt; root[root[b].ch[1]].dict)swap(root[a].ch[0], root[a].ch[1]); root[a].dict = root[root[a].ch[1]].dict + 1; return a;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么不直接用二叉堆进行上面的过程呢？这是由于二叉堆是完全二叉树，合并后很难再去维护它的结构。左偏树一方面结构比较灵活，另一方面还可以保证时间复杂度，于是可以很好地实现堆的合并。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左偏树的插入操作就是将左偏树和一棵只有一个结点的左偏树合并，删除最小值只需删掉最小值结点再合并两棵子树即可。这些都是容易实现的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在洛谷模板题中，结点关系需要用并查集去维护。两棵树合并就是两个并查集等价类合并，删除时重新处理父子关系即可。比如树a和树b合并，合并后树根为b，只需将a的父亲换为b即可，删除时合并两棵子树同理。这样的好处是思维难度小，但不允许路径压缩，容易被卡成$O(n)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要降低时间复杂度当然就是用允许路径压缩的方法。具体区别体现在删除上。当删除一棵树的树根时，将树根（即使被删除）的父亲换为新树的树根，这样子结点就可以通过原有的树根来访问新的树根了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define N 100010using namespace std;int father[N], n, m, val[N];struct Node &#123; int d, dict, ch[2]; Node() &#123; ch[0] = ch[1] = 0, dict = 0; &#125;&#125; root[N];int find(int x) &#123;//并查集 if (father[x] == x)return x; return father[x] = find(father[x]);//路径压缩&#125;int merge(int a, int b) &#123;//合并操作 if (!a || !b)return a + b; if (val[root[a].d] &gt; val[root[b].d] || (val[root[a].d] == val[root[b].d] &amp;&amp; root[a].d &gt; root[b].d))swap(a, b); int p = merge(root[a].ch[1], b); father[p] = a, root[a].ch[1] = p; if (root[root[a].ch[0]].dict &lt; root[root[b].ch[1]].dict)swap(root[a].ch[0], root[a].ch[1]); root[a].dict = root[root[a].ch[1]].dict + 1; return a;&#125;int pop(int a) &#123;//删除操作 int t = val[a]; father[root[a].ch[1]] = root[a].ch[1], father[root[a].ch[0]] = root[a].ch[0];//两棵子树独立 father[a] = merge(root[a].ch[0], root[a].ch[1]), val[a] = -1;//修改旧树根父子关系 return t;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; root-&gt;dict = -1; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; val[i], root[i].d = i, father[i] = i; for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; cin &gt;&gt; a; if (a == 1) &#123; cin &gt;&gt; b &gt;&gt; c; if (val[b] == -1 || val[c] == -1 || find(b) == find(c))continue; merge(find(b), find(c)); &#125; else &#123; cin &gt;&gt; b; if (val[b] == -1)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; pop(find(b)) &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A*算法]]></title>
    <url>%2F2019%2F03%2F26%2FA-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简要介绍两类启发式搜索算法：A*和IDA*算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，DFS和BFS是两类盲目搜索算法。所谓盲目，就是根据当前状态毫无目标性地进行扩展。想像一下，如果你正在操场上，你如何找到一条尽可能短的路走向旗杆？显然根据视觉上的提示，旗杆所在的方向就是行进的方向，很快就找到了一条路径。如果蒙上眼睛，你可能就会漫无目的的随处寻找了。这种视觉上的提示就称为“启发”，普通的搜索算法没有启发的引导，因此搜索过程冗杂，需要各种剪枝，效率比较低下。如果能够给搜索过程加上合适的启发方向，那么搜索过程将会大大简化，效率也会得到提升。这里所说的A*和IDA*算法就是两种启发式搜索算法。 A*算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何给状态设置搜索方向呢？A*算法引入了估价函数的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于状态n，我们可以求出从这个状态开始到目标状态的预估代价h(n)，这个h(n)函数称为估价函数。另外对于每一个状态，有到这个状态的实际代价g(n)。那么就可以求出从初始状态到目标状态的预估代价f(n)，它满足： f(n)=g(n)+h(n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;估价函数的选取稍后再提，这里先介绍A*算法流程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A*算法中存在一个开启列表和关闭列表，开启列表中储存当前转移的状态，关闭列表中储存当前已经经过转移的状态。一个状态只要进入关闭列表就不会再重新进入开启列表。A*算法步骤如下： 将初始状态加入开启列表，设置其g和h函数值。 从开启列表中选择f值最小的一个状态，从这个状态开始转移。如果转移后的状态在关闭列表中，则忽略，如果在开启列表中，则检查该状态的g值是否可以更新，若可以则更新g值。如果转移后的状态不在开启列表也不再关闭列表中，则将其加入开启列表，计算其g值和h值。 当从开启列表中选择出状态正好是目标状态时，结束算法。如果开启列表已空，则不存在到目标状态的路径。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要记录路径，在每一个状态上加入前驱指标即可递归找到路径。由于需要在开启列表中找最小值，故开启列表常常用堆或优先队列实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出，A*算法很像是将BFS中的队列换成优先队列，它的算法思路也是比较清晰的。如果存在路径，A*算法一定可以找到该路径，但最优性与估价函数选取有关，设实际最小代价为d(n)，则有以下规律： 若$h(n) &lt; d(n)$，只要找到路径，该路径一定是最优解，$h(n)$越小效率越差。 若$h(n)=d(n)$，只要找到路径，该路径一定是最优解，此时效率最高。 若$h(n)&gt;d(n)$，可以找到路径，但不保证最优。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可见估价函数的正确选取对效率和最优性有着很大的影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出，对于转移代价恒定的情况，若h(n)恒为0，则A*算法退化为BFS，对于代价不定的情况，若h(n)恒为0，则退化为Dijkstra算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然A*算法可以比Dijkstra算法更好地求最短路，为何不用该算法代替Dijkstra算法呢？这是因为在给定的图中，预估当前结点到目标结点的转移代价是十分困难的，A*算法在这个问题上不实用。但是，对于方格图上转移（比如八数码问题），A*算法就大有用武之地。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看这样一道题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显是一道搜索题，可以考虑用A*算法解决。首先注意到如果想让特殊方格移动，空白方格必须在其附近。那么我们可以先抽离这些状态先进行BFS预处理。预处理后，将会得到数组dist[x][y][i][j]表示特殊方格在坐标(x，y)处，空白方格从其i方向移动到其j方向的最小代价（方向定义为0上1下2右3左）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一组询问，用BFS预处理将空白结点移动到特殊方格附近的转移代价（最多4个，分别对应4个方向），这几个对应的状态就是初始状态，将它们加入开启列表，计算h值和g值（g值就是BFS预处理的转移代价）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了，如何计算h值？在这种问题上，我们通常用曼哈顿距离法来估计转移代价。对于平面上两点，它们的曼哈顿距离定义为： d=|x_2-x_2|+|y_1-y_2|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然以曼哈顿距离作估价函数一定满足前文所说的$h(n)\leq d(n)$，可以保证得到最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面就可以开始进行A*算法了。用小根堆维护开启列表，和Dijkstra算法手写堆版本相似，这里要构造一个哈希表来记录每一个状态在堆中的位置，若未入堆置为0，在关闭列表中置为-1。转移时最多有4个转移方向，若空白方格在特殊方格左侧，则它可以转移到上、下、右侧，也可以直接与特殊方格交换。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码，比较长：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;//定义几个宏来简化代码#define OK(x, y) ((x)&gt;=1&amp;&amp;(x)&lt;=n&amp;&amp;(y)&gt;=1&amp;&amp;(y)&lt;=m&amp;&amp;op[(x)][(y)])#define H(x, y) (abs((x)-tx)+abs((y)-ty))#define SUM(x) (g[(x).s][(x).sx][(x).sy]+h[(x).s][(x).sx][(x).sy])#define RK(x) (rk[tree[x].s][tree[x].sx][tree[x].sy])using namespace std;struct Point &#123; int x, y; Point(int x, int y) : x(x), y(y) &#123;&#125;&#125;;struct Node &#123; int s, sx, sy; Node() &#123;&#125; Node(int a, int b, int c) &#123; s = a, sx = b, sy = c; &#125;&#125; tree[31 * 31 * 31 * 31];queue&lt;Point&gt; que;int n, m, q, op[35][35], tx, ty, TMP[35][35], dict[35][35][4][4], size = 0;const int mx[4] = &#123;-1, 1, 0, 0&#125;, my[4] = &#123;0, 0, 1, -1&#125;;int rk[4][31][31], g[4][31][31], h[4][31][31];inline void BFS(int ex, int ey, int sx, int sy, int d) &#123; memset(TMP, -1, sizeof(TMP)); TMP[ex][ey] = 0, TMP[sx][sy] = 1; que.push(Point(ex, ey)); while (!que.empty()) &#123; Point p = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int xx = p.x + mx[i], yy = p.y + my[i]; if (OK(xx, yy) &amp;&amp; TMP[xx][yy] == -1)TMP[xx][yy] = TMP[p.x][p.y] + 1, que.push(Point(xx, yy)); &#125; &#125; if (d == -1)return; for (int i = 0; i &lt; 4; i++)dict[sx][sy][d][i] = TMP[sx + mx[i]][sy + my[i]];&#125;void solve(int x) &#123; int x1 = x &lt;&lt; 1, x2 = x &lt;&lt; 1 | 1, minn = x; if (x1 &lt;= size &amp;&amp; SUM(tree[x1]) &lt; SUM(tree[minn]))minn = x1; if (x2 &lt;= size &amp;&amp; SUM(tree[x2]) &lt; SUM(tree[minn]))minn = x2; if (minn != x)swap(tree[x], tree[minn]), swap(RK(x), RK(minn)), solve(minn);&#125;void up(int x) &#123; if (x == 1)return; if (SUM(tree[x &gt;&gt; 1]) &gt; SUM(tree[x]))swap(tree[x &gt;&gt; 1], tree[x]), swap(RK(x &gt;&gt; 1), RK(x)), up(x &gt;&gt; 1);&#125;inline void add(Node p) &#123; tree[++size] = p, rk[p.s][p.sx][p.sy] = size, up(size);&#125;inline Node top() &#123; Node p = tree[1]; rk[p.s][p.sx][p.sy] = -1; if (size &gt; 1)tree[1] = tree[size--], RK(1) = 1, solve(1); else size = 0; return p;&#125;inline void clear() &#123; size = 0, memset(rk, 0, sizeof(rk)); memset(g, 127, sizeof(g));//置为无穷大&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++)for (int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int z = 0; z &lt; 4; z++)if (OK(i, j) &amp;&amp; OK(i + mx[z], j + my[z]))BFS(i + mx[z], j + my[z], i, j, z); for (int i = 1; i &lt;= q; i++) &#123; int ex, ey, sx, sy, tx, ty, flag = 0; cin &gt;&gt; ex &gt;&gt; ey &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty; BFS(ex, ey, sx, sy, -1), clear(); if (sx == tx &amp;&amp; sy == ty) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; for (int j = 0; j &lt; 4; j++) &#123; if (OK(sx + mx[j], sy + my[j]) &amp;&amp; TMP[sx + mx[j]][sy + my[j]] != -1) &#123; g[j][sx][sy] = TMP[sx + mx[j]][sy + my[j]], h[j][sx][sy] = H(sx, sy), add(Node(j, sx, sy)); &#125; &#125; while (size &gt; 0) &#123; Node p = top(); if (p.sx == tx &amp;&amp; p.sy == ty) &#123; cout &lt;&lt; g[p.s][p.sx][p.sy] &lt;&lt; endl, flag = 1; break; &#125; for (int j = 0; j &lt; 4; j++) &#123;//不改变特殊方格位置的转移 int xx = p.sx + mx[j], yy = p.sy + my[j], G; if (j == p.s || !OK(xx, yy) || dict[p.sx][p.sy][p.s][j] == -1)continue; G = dict[p.sx][p.sy][p.s][j] + g[p.s][p.sx][p.sy]; if (G &lt; g[j][p.sx][p.sy]) &#123; if (rk[j][p.sx][p.sy] == -1)continue; if (!rk[j][p.sx][p.sy]) &#123; g[j][p.sx][p.sy] = G, h[j][p.sx][p.sy] = H(sx, sy), add(Node(j, p.sx, p.sy)); &#125; else g[j][p.sx][p.sy] = G, up(rk[j][p.sx][p.sy]); &#125; &#125; int G = g[p.s][p.sx][p.sy] + 1;//与特殊方格交换的转移 if (G &lt; g[p.s ^ 1][p.sx + mx[p.s]][p.sy + my[p.s]]) &#123; if (rk[p.s ^ 1][p.sx + mx[p.s]][p.sy + my[p.s]] == -1)continue; if (!rk[p.s ^ 1][p.sx + mx[p.s]][p.sy + my[p.s]]) &#123; g[p.s ^ 1][p.sx + mx[p.s]][p.sy + my[p.s]] = G; h[p.s ^ 1][p.sx + mx[p.s]][p.sy + my[p.s]] = H(p.sx + mx[p.s], p.sy + my[p.s]); add(Node(p.s ^ 1, p.sx + mx[p.s], p.sy + my[p.s])); &#125; else &#123; g[p.s ^ 1][p.sx + mx[p.s]][p.sy + my[p.s]] = G; up(rk[p.s ^ 1][p.sx + mx[p.s]][p.sy + my[p.s]]); &#125; &#125; &#125; if (!flag)cout &lt;&lt; -1 &lt;&lt; endl; &#125; return 0;&#125; IDA*算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是IDA*算法，这其实是基于迭代加深的A*算法，个人感觉比A*算法简洁。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IDA*算法类似于DFS，但是它的搜索深度有要求。所谓迭代加深就是每次搜索规定最大搜索深度，如果当前代价与预估代价之和高于最大搜索深度，则进行剪枝。IDA*算法的估价函数性质与A*算法类似。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看这么一道题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案深度最大为15，很有利于IDA*算法。首先从0到15枚举搜索深度，对于每一个深度进行搜索，搜索代码如下：123456789101112131415void IDA_star(int x, int y, int d) &#123; if (d == maxDepth) &#123; if (getH() == 0)ans = d;//找到答案，由于是从小到大枚举深度，故答案一定是在最大深度处取到的 return; &#125; if (ans != -1)return; for (int i = 0; i &lt; 8; i++) &#123;//枚举8个跳转方向 int xx = x + mx[i], yy = y + my[i]; if (OK(xx, yy)) &#123; swap(op[x][y], op[xx][yy]);//交换 if (d + getH() &lt;= maxDepth) IDA_star(xx, yy, d + 1);//只要f(n)=g(n)+h(n)的值不大于最大深度，就进行转移 swap(op[x][y], op[xx][yy]); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要可以保证h(n)始终不大于实际最小代价，就可以得到最优解。但是h(n)如何选取？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个问题上，规定h(n)为当前状态与目标状态不同的方格数目，可以证明这种h(n)的选取方式满足上述条件。简单证明如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察到代码中的表达式d + getH()，其实这里的getH()计算的是已经进行了一次转移（就是上一行的swap）后的预估代价。如果实际最小代价为d(n)，能够证明getH()≤d(n)+1即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getH()表示当前有多少方格与目标格不同，假设有p个。由于方格的交换必定是连续的（每一次都有空白方格的参与），故要想把p个方格的位置都移动到正确的位置，至少需要移动p-1次，那么有d(n)≥p-1，即d(n)+1≥p=h(n)，证毕。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样直接进行IDA*算法即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define OK(x, y) (x&gt;=1&amp;&amp;x&lt;=5&amp;&amp;y&gt;=1&amp;&amp;y&lt;=5)using namespace std;const int ANS[6][6] = &#123; &#123;0, 0, 0, 0, 0, 0&#125;, &#123;0, 1, 1, 1, 1, 1&#125;, &#123;0, 0, 1, 1, 1, 1&#125;, &#123;0, 0, 0, 2, 1, 1&#125;, &#123;0, 0, 0, 0, 0, 1&#125;, &#123;0, 0, 0, 0, 0, 0&#125;&#125;, mx[] = &#123;-1, -2, -2, -1, 1, 2, 2, 1&#125;, my[] = &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;int op[10][10], maxDepth, ans;inline int getH() &#123; int h = 0; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;= 5; j++)if (op[i][j] != ANS[i][j])h++; &#125; return h;&#125;void IDA_star(int x, int y, int d) &#123; if (d == maxDepth) &#123; if (getH() == 0)ans = d; return; &#125; if (ans != -1)return; for (int i = 0; i &lt; 8; i++) &#123; int xx = x + mx[i], yy = y + my[i]; if (OK(xx, yy)) &#123; swap(op[x][y], op[xx][yy]); if (d + getH() &lt;= maxDepth) IDA_star(xx, yy, d + 1); swap(op[x][y], op[xx][yy]); &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); int q, x, y; cin &gt;&gt; q; for (int z = 1; z &lt;= q; z++) &#123; char e; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;= 5; j++) &#123; cin &gt;&gt; e; if (e == '0' || e == '1')op[i][j] = e - '0'; else op[i][j] = 2, x = i, y = j; &#125; &#125; for (int i = 0; i &lt; 16; i++) &#123; maxDepth = i, ans = -1, IDA_star(x, y, 0); if (ans != -1) &#123; cout &lt;&lt; ans &lt;&lt; endl; break; &#125; &#125; if (ans == -1)cout &lt;&lt; -1 &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们下面尝试用IDA*算法解决八数码问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置最大深度1000（自行预估），进行IDA*算法即可。注意这里需要一处最优性剪枝：下一个状态的转移方向不能是上一个状态转移方向的反方向。举例来说，如果通过向下移动得到了一个状态，那么这个状态就不能再向上移动，因为这一定不是最优解。如果移动方向设置巧妙的话，可以用异或运算迅速求出反方向。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define OK(x, y) (x&gt;=1&amp;&amp;x&lt;=3&amp;&amp;y&gt;=1&amp;&amp;y&lt;=3)using namespace std;int mp[5][5], depth, ans = -1;const int mx[4] = &#123;-1, 1, 0, 0&#125;, my[4] = &#123;0, 0, 1, -1&#125;;const int ANS[4][4] = &#123; &#123;0, 0, 0, 0&#125;, &#123;0, 1, 2, 3&#125;, &#123;0, 8, 0, 4&#125;, &#123;0, 7, 6, 5&#125;&#125;;inline int getH() &#123; int h = 0; for (int i = 1; i &lt;= 3; i++) for (int j = 1; j &lt;= 3; j++)if (mp[i][j] != ANS[i][j])h++; return h;&#125;void IDA_star(int x, int y, int d, int pre) &#123;//pre是上一个的移动方向 if (d == depth) &#123; if (getH() == 0)ans = d; return; &#125; if (ans != -1)return; for (int i = 0; i &lt; 4; i++) &#123; int xx = x + mx[i], yy = y + my[i]; if (OK(xx, yy) &amp;&amp; pre != (i ^ 1)) &#123; swap(mp[x][y], mp[xx][yy]); if (getH() + d &lt;= depth)IDA_star(xx, yy, d + 1, i); swap(mp[x][y], mp[xx][yy]); &#125; &#125;&#125;int main() &#123; int x, y; for (int i = 0; i &lt; 9; i++) &#123; char e; cin &gt;&gt; e; mp[i / 3 + 1][i % 3 + 1] = e - '0'; if (mp[i / 3 + 1][i % 3 + 1] == 0)x = i / 3 + 1, y = i % 3 + 1; &#125; for (int i = 0; i &lt;= 1000; i++) &#123; ans = -1, depth = i, IDA_star(x, y, 0, -1); if (ans != -1) &#123; cout &lt;&lt; ans; return 0; &#125; &#125;&#125; A*算法应用：图的第k短路&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A*算法的一个应用是求给定图的第k短路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求最短路是很容易的，用Dijkstra或者SPFA就能求出来，但第k短却不是那么容易。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上面的讨论可以发现，如果h(n)≤d(n)，A*一定可以找到最有解（即最短路），当找到路时结束算法。如果不结束呢？如果对于出优先队列状态我们不将其加入结束列表，而是将其恢复成未进入过队列的状态以做到点可以重复入队，那这样找到最短路后再找的就是次短路，进而求出第k短路。当目标状态出队列达k次时，得到的就是第k短路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;估价函数如何规定呢？为了找到最优解，必须满足h(n)≤d(n)，显然h(n)取这个点到目标点的最小距离即可。这个最小距离可以通过建反向图跑一遍Dijkstra或SPFA求出来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，边权非负的无向图一定有第k短路，有向图可能没有，这时根据队列已空但目标状态出队次数未到k这个指标来判断。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题：POJ2446，注意坑点：s=t时k要自增1，因为0不算最短路。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//常年手写堆的我终于用优先队列了，因为这题手写堆过于复杂#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;struct Edge &#123; int to, next, v;&#125; edge[100005], edge_opp[100005];struct DNode &#123; int t, dis; DNode(int x, int y) : t(x), dis(y) &#123;&#125; bool operator&lt;(DNode x) const &#123; return dis &gt; x.dis; &#125;&#125;;struct ANode &#123; int t, g, h; ANode(int x, int y, int z) : t(x), g(y), h(z) &#123;&#125; bool operator&lt;(ANode x) const &#123; return g + h &gt; x.g + x.h; &#125;&#125;;int head[1005], head_opp[1005], cnt = 1, cnt_opp = 1, dict[1005], n, m, s, t, k, times[1005];inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;inline void add_opp(int x, int y, int z) &#123; edge_opp[cnt_opp].to = y, edge_opp[cnt_opp].next = head_opp[x], edge_opp[cnt_opp].v = z, head_opp[x] = cnt_opp++;&#125;inline void Dijkstra() &#123; priority_queue&lt;DNode&gt; Q; memset(dict, 127, sizeof(dict)), dict[t] = 0, Q.push(DNode(t, 0)); while (!Q.empty()) &#123; DNode t = Q.top(); Q.pop(); if (t.dis &gt; dict[t.t])continue; for (int i = head_opp[t.t]; i; i = edge_opp[i].next) &#123; if (dict[edge_opp[i].to] &gt; dict[t.t] + edge_opp[i].v) &#123; dict[edge_opp[i].to] = dict[t.t] + edge_opp[i].v; Q.push(DNode(edge_opp[i].to, dict[edge_opp[i].to])); &#125; &#125; &#125;&#125;inline int AStar(int a, int b) &#123; priority_queue&lt;ANode&gt; Q; Q.push(ANode(a, 0, dict[a])); while (!Q.empty()) &#123; ANode t = Q.top(); Q.pop(), times[t.t]++; if (t.t == b &amp;&amp; times[t.t] == k)return t.g; for (int i = head[t.t]; i; i = edge[i].next) &#123; Q.push(ANode(edge[i].to, t.g + edge[i].v, dict[edge[i].to])); &#125; &#125; return -1;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z), add_opp(y, x, z); &#125; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; if (s == t)k++; Dijkstra(), cout &lt;&lt; AStar(s, t); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新：这里有一个优化。当求k短路时，若某一个点访问次数已经大于k，则可以直接continue，这是因为通过该点得到的路径一定不会排名在前k。这个优化可以减小时空消耗。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher算法]]></title>
    <url>%2F2019%2F03%2F24%2FManacher%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manacher算法是一种求字符串中最长回文子串的高效算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回文字符串，就是将字符串倒置后与原字符串完全相同的字符串，如a、aba、abcba等等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的求回文子串的方法是$O(n^2)$的，那样的算法比较低效。Mnacher可以在线性时间内求出最长回文子串，这个算法充分利用了回文的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到回文子串有奇数个和偶数个之分，这为我们的算法造成了困难，因此在算法进行之前，先对字符串进行一步预处理。预处理的方法就是在每两个相邻字符之间和字符串首尾加一个新的字符。注意这个字符不能在原字符串中出现过，这里我们选择’%’为例。对于字符串abcd，预处理后得到%a%b%c%d%。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做的好处是，无论奇数个还是偶数个数目的回文子串，都可以找到一个对称中心。也就是说，预处理后的字符串的回文子串都是以某个字符为对称中心轴对称的，这样我们求出每一个字符的最长对称长度即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用p[i]表示第i个字符的最长对称长度（对称长度是指这个字符向右或者向左最大能延伸的距离，含该字符本身）。并且容易知道实际的回文串长度为p[i]-1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若下标从0开始，则初始化p[0]=1，接下来就是Manacher算法核心步骤。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从小到大枚举下标i，这个过程中用一个变量r表示目前回文串最右延伸位置的下一个位置，pos记录这个最右延伸位置回文串所对应的对称中心在字符串中的下标，然后分情况讨论。r初始化为1，pos初始化为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果i &lt; r。找到i关于pos的对称点2pos-i，易知2pos-i这个字符位于pos对应的回文串中，因此有两段字符串相同：$[2pos-r+1,2pos-i]=[i,r-1]$，当然也有$[2pos-i,pos]=[pos,i]$。这说明i的临近部分与2pos-i的临近部分是相同的，若$p[2pos-i]≤r-i$，则p[i]至少为p[2pos-i]，这是一个显然的结论；如果$p[2pos-i] &gt;r-i$，p[i]应至少为r-i，这是因为我们并不清楚r右侧的情况，只能得到r左侧回文串的长度。综合来看，有$p[i]=\min(p[2pos-i],r-i)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面只是得到了“至少”的长度，还需扩展，下面用for循环延伸这个长度。对于i≥r的情况直接令p[i]=1，然后for循环延伸。最后要注意更新r和pos。12345678int pos = 0, r = 1;p[0] = 1;for (int i = 1; i &lt; l; i++) &#123; if (i &lt; r)p[i] = min(p[2 * pos - i], r - i); else p[i] = 1; for (; i - p[i] &gt;= 0 &amp;&amp; i + p[i] &lt; l &amp;&amp; op1[i - p[i]] == op1[i + p[i]]; ++p[i]); if (p[i] + i &gt; r)r = p[i] + i, pos = i;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后统计答案即可，完整代码，洛谷模板题：1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;char op1[(11000000 &lt;&lt; 1) + 5], op2[11000000];int p[(11000000 &lt;&lt; 1) + 5];int l;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; op2; l = strlen(op2); for (int j = 0, i = 0, k = 0; j &lt; l; k ^= 1) &#123; if (!k)op1[i++] = '%'; else op1[i++] = op2[j++]; &#125; l = strlen(op1), op1[l++] = '%'; int pos = 0, r = 1; p[0] = 1; for (int i = 1; i &lt; l; i++) &#123; if (i &lt; r)p[i] = min(p[2 * pos - i], r - i); else p[i] = 1; for (; i - p[i] &gt;= 0 &amp;&amp; i + p[i] &lt; l &amp;&amp; op1[i - p[i]] == op1[i + p[i]]; ++p[i]); if (p[i] + i &gt; r)r = p[i] + i, pos = i; &#125; int ans = -1; for (int i = 0; i &lt; l; i++)ans = max(ans, p[i] - 1); cout &lt;&lt; ans; return 0;&#125; Manacher算法应用：判定二叉树的对称性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果将一棵二叉树的所有结点左右儿子翻转，可以得到这棵二叉树的镜像对称树，如果两棵树结构相同，则称二叉树满足对称性。现在对于有根二叉树，需要找到上面所有对称子树，传统的判定对称性算法需要$O(n^2)$，应用Manacher算法能直接降至$O(n)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法是先应用一遍DFS将所有点的子结点数目统计出来，再来一遍中序遍历，得到遍历序列，序列元素是结点的子结点数目。易知一棵对称二叉树与中序遍历序列中的一个回文串对应，在其上应用Manacher算法即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来一道水题：洛谷P5018，这里不仅需要判结构对称还需要权值对称，后者本质相同，总时间复杂度$O(n)$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define N 10000005using namespace std;int ch[N][2], v[N], n, num[N], check[N];int rk[N &lt;&lt; 1], tot, rk2[N &lt;&lt; 1], p1[N &lt;&lt; 1], p2[N &lt;&lt; 1], to[N];inline int read() &#123; char e = getchar(); int s = 0, g = 0; while (e &lt; '-')e = getchar(); if (e == '-')g = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return g ? -s : s;&#125;void preDFS(int x) &#123; if (x == 0)return; preDFS(ch[x][0]), preDFS(ch[x][1]); if (num[ch[x][0]] == num[ch[x][1]])check[x] = num[ch[x][0]]; num[x] = num[ch[x][0]] + num[ch[x][1]] + 1;&#125;void DFS(int x) &#123; if (x == 0)return; DFS(ch[x][0]); rk[++tot] = num[x], rk2[tot] = v[x], to[tot] = x; rk[++tot] = -1, rk2[tot] = -1; DFS(ch[x][1]);&#125;int main() &#123; //freopen("text.in", "r", stdin); n = read(); for (int i = 1; i &lt;= n; i++)v[i] = read(); for (int i = 1; i &lt;= n; i++) &#123; int x = read(), y = read(); if (x != -1)ch[i][0] = x; if (y != -1)ch[i][1] = y; check[i] = -1; &#125; preDFS(1), rk[++tot] = -1, rk2[tot] = -1, DFS(1); int pos = 1, r = 2, ans = 0; p1[1] = 1; for (int i = 2; i &lt;= tot; i++) &#123;//结构Manacher if (i &lt; r)p1[i] = min(p1[2 * pos - i], r - i); else p1[i] = 1; for (; i &gt; p1[i] &amp;&amp; i + p1[i] &lt;= tot &amp;&amp; rk[i - p1[i]] == rk[i + p1[i]]; ++p1[i]); if (p1[i] + i &gt; r)r = p1[i] + i, pos = i; &#125; pos = 1, r = 2, p2[1] = 1; for (int i = 2; i &lt;= tot; i++) &#123;//权值Manacher if (i &lt; r)p2[i] = min(p2[2 * pos - i], r - i); else p2[i] = 1; for (; i &gt; p2[i] &amp;&amp; i + p2[i] &lt;= tot &amp;&amp; rk2[i - p2[i]] == rk2[i + p2[i]]; ++p2[i]); if (p2[i] + i &gt; r)r = p2[i] + i, pos = i; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if (rk[i] != -1 &amp;&amp; check[to[i]] != -1) &#123; if (check[to[i]] &lt;= ((p1[i] - 2) &gt;&gt; 1) &amp;&amp; check[to[i]] &lt;= ((p2[i] - 2) &gt;&gt; 1)) ans = max(ans, num[to[i]]); &#125; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F03%2F22%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文探讨AC自动机的相关内容，注意AC自动机并不能自动让你AC。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机在1975年诞生于贝尔实验室的多模匹配算法。之前的文章曾介绍过KMP匹配算法，它用于单模式串匹配。对于多模式串匹配，我们当然可以多次用KMP匹配算法去解决，但那样时间复杂度为$O(m+kn))$，k为模式串数量，比较低效。而在多模匹配中应用AC自动机可以达到$O(m+n)$，m为所有模式串长度之和。 有限状态自动机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里只粗略地谈谈自动机这个东西。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在有限状态自动机（Deterministic finite automation, DFA）中，状态有有限个，它们彼此用有向边连接，表示状态的转移。当一个动作发生时，自动机会从一个状态转移到另一个状态，并做出相应的反应，这里的AC自动机便是一种有限状态自动机。 Trie树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机的结构是一棵trie树，如下图所示：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trie树又称字典树，常用于快速求字典序。在trie树中，根结点不记录字符串信息，所有的字符串信息只记录在子结点中。上图所示的trie树表示记录了he、is、she、shr四个字符串。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要同时记录she和sh两个字符串怎么办？trie树上每一个结点都拥有一个指标变量，它记录这个结点对应的字符是否表示有个字符串的结尾，这样在相应结点处打上标记就可以同时表示she和sh。 AC自动机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍AC自动机进行的过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要将所有模式串加入trie树，并做每一个串到对应结点的标记。如果字符串中只有小写字母，那么我们可以这样建立trie树：123456789int tr[N][26], ct = 1;//N是结点预估数量void insert(const char *p, int j) &#123;//将编号为j的模式串p加入到trie树中 int i = 0, now = 1; while (p[i]) &#123; if (tr[now][p[i] - 'a'] == 0)tr[now][p[i] - 'a'] = ++ct;//没有就新建 now = tr[now][p[i] - 'a'], i++;//有就继续向下走 &#125; to[j] = now;//记录末尾编号&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建完trie树后，我们可以这样理解trie树：树上的每一个结点都对应一种状态，它表示到根结点的字符均匹配，这样trie树可以看成是一个状态机的雏形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如当前匹配到了某个结点，它表示的字符为’a’，并且下一个字符需要匹配’b’，而该结点正好有对应’b’的子结点，那此时状态直接转移到对应’b’的子结点即可。但是如果不存在对应’b’的子结点呢？如何转移？这就需要引入失配指针的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当某个结点发生失配时（指它不存在满足匹配的子结点），应该由这个状态转移至另一个状态，描述这个失配转移关系的指针称为失配指针，它是AC自动机中的重要概念。和KMP算法类似，失配指针应该指向与它目前匹配子串拥有最长相同前后缀的子串的末尾结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先考虑在根结点如何转移。对于一个字符，如果根结点存在对应这个字符的结点，转移到该结点即可；而对于根结点不存在对应子结点的情况（比如上文图中根结点不存在表示’a’的子结点），也应该规定一个转移方向，这时应当转移至根，因为没有可以匹配的模式串。这一步的示例代码如下：1234for (int i = 0; i &lt; 26; i++) &#123;//规定1号结点为根 if (tree[1][i])fail[tree[1][i]] = 1, que.push(tree[1][i]);//fail记录失配指向编号,que是队列 else tree[1][i] = 1;//转移到根，直接记在trie树上 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也可以这样做：12for (int i = 0; i &lt; 26; i++)tree[0][i] = 1;que.push(1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里将结点加入队列，以进行之后的求失配指针的过程。在这里，我们不断从队列中取点，然后遍历它的所有子结点，对于它存在的子结点，子结点的失配指针指向为其父结点（就是当前取出的结点）失配指针指向结点相对应的子结点；对于不存在的结点，转移方向也是父结点失配指针指向结点相对应的子结点。这个过程可以感性地理解一下，它其实是对父结点失配后子串的延伸。12345678while (!que.empty()) &#123; int p = que.front(); que.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (tree[p][i])fail[tree[p][i]] = tree[fail[p]][i], que.push(tree[p][i]); else tree[p][i] = tree[fail[p]][i]; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后就是匹配的过程，十分简洁，不断转移状态即可。途中需要记录每一个状态被访问到的次数。1for (int i = 0, now = 1; str[i]; ++i)now = tree[now][str[i] - 'a'], ++vis[now];//str是主串，vis记录次数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那现在如何求每一个模式串匹配的次数呢？这就需要fail树。 fail树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于trie树上的每一个非根结点，单独建立一张fail[x]-&gt;x的图，容易证明这个图是一棵树，称为fail树。fail树满足一个性质：对于fail树的一个子树，若其子树上某一个结点的状态成立，则子树根结点状态必成立。这样建立fail树，然后进行一遍DFS，求出子树上状态vis的值之和即可。12345678inline void add(int x, int y) &#123; static int cnt = 1; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS(int x) &#123; for (int i = head[x]; i; i = edge[i].next)DFS(edge[i].to), vis[x] += vis[edge[i].to];&#125; 代码模板&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;洛谷上三道模板题。 模板一&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很水，直接计数判是否为0即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;char str[1000005], op[1000005];int vis[1000005], to[1000005], ct = 1, fail[1000005], tr[1000005][26];struct Edge &#123; int next, to;&#125; edge[1000005];int head[1000005];inline void add(int x, int y) &#123; static int cnt = 1; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;queue&lt;int&gt; que;void insert(const char *p, int j) &#123; int i = 0, now = 1; while (p[i]) &#123; if (tr[now][p[i] - 'a'] == 0)tr[now][p[i] - 'a'] = ++ct; now = tr[now][p[i] - 'a'], i++; &#125; to[j] = now;&#125;void DFS(int x) &#123; for (int i = head[x]; i; i = edge[i].next)DFS(edge[i].to), vis[x] += vis[edge[i].to];&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)scanf("%s", op), insert(op, i); for (int i = 0; i &lt; 26; i++)tr[0][i] = 1; que.push(1); while (!que.empty()) &#123; int p = que.front(); que.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (tr[p][i])fail[tr[p][i]] = tr[fail[p]][i], que.push(tr[p][i]); else tr[p][i] = tr[fail[p]][i]; &#125; &#125; scanf("%s", str); for (int i = 0, now = 1; str[i]; ++i)now = tr[now][str[i] - 'a'], ++vis[now]; for (int i = 2; i &lt;= ct; i++)add(fail[i], i); DFS(1); int ans = 0; for (int i = 1; i &lt;= n; i++)ans += vis[to[i]] &gt; 0; cout &lt;&lt; ans; return 0;&#125; 模板二&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据匹配次数输出最大的字符串。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;char str[1000005], op[151][80];int vis[1000005], to[1000005], ct = 1, fail[1000005], tr[1000005][26], cnt = 1;struct Edge &#123; int next, to;&#125; edge[1000005];int head[1000005];inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;queue&lt;int&gt; que;void insert(const char *p, int j) &#123; int i = 0, now = 1; while (p[i]) &#123; if (tr[now][p[i] - 'a'] == 0)tr[now][p[i] - 'a'] = ++ct; now = tr[now][p[i] - 'a'], i++; &#125; to[j] = now;&#125;void DFS(int x) &#123; for (int i = head[x]; i; i = edge[i].next)DFS(edge[i].to), vis[x] += vis[edge[i].to];&#125;int main() &#123; int n; while (scanf("%d", &amp;n) == 1) &#123; if (n == 0)return 0; cnt = ct = 1, memset(tr, 0, sizeof(tr)), memset(head, 0, sizeof(head)); memset(vis, 0, sizeof(vis)), memset(fail, 0, sizeof(fail)); for (int i = 1; i &lt;= n; i++)scanf("%s", op[i]), insert(op[i], i); for (int i = 0; i &lt; 26; i++)tr[0][i] = 1; que.push(1); while (!que.empty()) &#123; int p = que.front(); que.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (tr[p][i])fail[tr[p][i]] = tr[fail[p]][i], que.push(tr[p][i]); else tr[p][i] = tr[fail[p]][i]; &#125; &#125; scanf("%s", str); for (int i = 0, now = 1; str[i]; ++i)now = tr[now][str[i] - 'a'], ++vis[now]; for (int i = 1; i &lt;= ct; i++)head[i] = 0; for (int i = 2; i &lt;= ct; i++)add(fail[i], i); DFS(1); int maxn = 0; for (int i = 1; i &lt;= n; i++)maxn = max(maxn, vis[to[i]]); cout &lt;&lt; maxn &lt;&lt; endl; for (int i = 1; i &lt;= n; i++)if (vis[to[i]] == maxn)cout &lt;&lt; op[i] &lt;&lt; endl; &#125;&#125; 模板三&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出匹配数目。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;char str[2000010], op[200005];int vis[500000], to[200005], ct = 1, fail[500000], tree[500000][26];struct Edge &#123; int next, to;&#125; edge[500000];int head[500000];inline void add(int x, int y) &#123; static int cnt = 1; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;queue&lt;int&gt; que;void insert(const char *p, int j) &#123; int i = 0, now = 1; while (p[i]) &#123; if (tree[now][p[i] - 'a'] == 0)tree[now][p[i] - 'a'] = ++ct; now = tree[now][p[i] - 'a'], i++; &#125; to[j] = now;&#125;void DFS(int x) &#123; for (int i = head[x]; i; i = edge[i].next)DFS(edge[i].to), vis[x] += vis[edge[i].to];&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)scanf("%s", op), insert(op, i); for (int i = 0; i &lt; 26; i++) &#123; if (tree[1][i])fail[tree[1][i]] = 1, que.push(tree[1][i]); else tree[1][i] = 1; &#125; while (!que.empty()) &#123; int p = que.front(); que.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (tree[p][i])fail[tree[p][i]] = tree[fail[p]][i], que.push(tree[p][i]); else tree[p][i] = tree[fail[p]][i]; &#125; &#125; scanf("%s", str); for (int i = 0, now = 1; str[i]; ++i)now = tree[now][str[i] - 'a'], ++vis[now]; for (int i = 2; i &lt;= ct; i++)add(fail[i], i); DFS(1); for (int i = 1; i &lt;= n; i++)cout &lt;&lt; vis[to[i]] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调栈与最大矩形面积]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近博客比较高能，然而突然来了一个单调栈2333，其实这是为了补充之前的知识漏洞。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈是什么就不说了。单调栈是指满足严格单调性的栈，它的元素满足递增或者递减的性质，与单调队列一样，单调栈也可以进行优化操作。现在来看一道经典问题：最大矩形面积。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定若干矩形如图一（来源网络，侵删）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求其中最大面积的矩形，图二中阴影部分便是答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求解呢？如果$O(n^2)$扫一遍效率太低，可以考虑单调栈的做法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个矩形，它向左向右延伸的最大距离就是它的高度能够延伸的最大宽度，如果向左能够延伸到l，那么l的下一个矩形高度一定小于该矩形高度，否则就可以继续延伸。我们的重点就是利用这个性质来求出每一个矩形向左、向右的最大延伸距离，这个过程可以用单调栈来完成。这和悬线法有些类似，但又有所不同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和单调队列一样，栈中存的是下标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求最左位置和最右位置分别需要一个单调递增的栈，具体做法如下（以最左位置为例）： 假设第x个矩形要进栈。 若栈顶元素下标所对应的矩形高度不小于x的高度，弹出该元素，直到栈空或栈顶元素对应高度小于x高度。 若此时栈已空，令l[x]=1，否则l[x]置为栈顶元素加一。 x进栈。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法正确性证明：只需证明l求解的正确性即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于栈非空的情况，由于此时栈顶元素对应高度已经小于x的高度，栈顶元素以及其左方的元素都不能成为l值，这时栈顶元素v的右侧第一个元素p一定为x的最左值。倘若p的高度小于x的高度，如果p没有被弹出，那么栈顶元素应该是p而不是v，矛盾。如果p已经被弹出，这说明在p到x之间有一个比p更小的元素q进栈，这样栈顶元素应该为q而非v，矛盾。因此p的高度不小于x的高度，即p是x的最左值。如果栈为空，说明之前没有出现过比x高度更小的元素，l显然为1，得证。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求最右值时反方向进栈，r[x]要置为栈顶元素减一，证明同上。单调栈时间复杂度可达到$O(n)$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面例题一道：洛谷(P3804)。 给定一个只包含小写字母的字符串S,请你求出 S 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;咦？这好像是后缀自动机的模板题？这里选此题便是为了用后缀数组和单调栈来解决后缀自动机的问题，后缀自动机以后的博客更新。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据后缀数组中的有关性质可以发现，出现次数不止一次的子串必然是至少两个后缀的公共前驱，为了得到最大值，我们应该取最长公共前驱，这个可以用height数组来完成。对于height值组成的序列，容易知道答案就是： \max\{(b-a+2)\min\{height[k]\}\},a\leq k \leq b,2\leq a\leq b\leq n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这恰好就是上面所说的最大矩形面积问题，用单调栈解决即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define N 1000000+20using namespace std;int n, sa[N], tp[N], rk[N], tax[N], h[N], M, L[N], R[N];long long ans;char op[N] = &#123;'\0'&#125;;stack&lt;int&gt; sta1, sta2;inline void mySort() &#123; for (int i = 0; i &lt;= M; i++)tax[i] = 0; for (int i = 1; i &lt;= n; i++)tax[rk[i]]++; for (int i = 1; i &lt;= M; i++)tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; i--)sa[tax[rk[tp[i]]]--] = tp[i];&#125;inline void solve() &#123; M = 30; for (int i = 1; i &lt;= n; i++)rk[i] = op[i] - 'a' + 1, tp[i] = i; mySort(); for (int w = 1, p = 0; p &lt; n; M = p, w &lt;&lt;= 1) &#123; p = 0; for (int i = 1; i &lt;= w; i++)tp[++p] = n - w + i; for (int i = 1; i &lt;= n; i++)if (sa[i] &gt; w)tp[++p] = sa[i] - w; mySort(); for (int i = 1; i &lt;= n; i++)tp[i] = rk[i]; rk[sa[1]] = p = 1; for (int i = 2; i &lt;= n; i++) &#123; rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; &#125; &#125;&#125;inline void getHeight() &#123; int k = 0, j; for (int i = 1; i &lt;= n; i++) &#123; if (rk[i] == 1)h[rk[i]] = k = 0; else &#123; if (k)k--; j = sa[rk[i] - 1]; while (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k; h[rk[i]] = k; &#125; &#125;&#125;inline void add1(int x) &#123; while (!sta1.empty() &amp;&amp; h[sta1.top()] &gt;= h[x])sta1.pop(); if (sta1.empty())L[x] = 2; else L[x] = sta1.top() + 1; sta1.push(x);&#125;inline void add2(int x) &#123; while (!sta2.empty() &amp;&amp; h[sta2.top()] &gt;= h[x])sta2.pop(); if (sta2.empty())R[x] = n; else R[x] = sta2.top() - 1; sta2.push(x);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; (op + 1); n = strlen(op + 1); solve(), getHeight(); for (int i = 2; i &lt;= n; i++)add1(i); for (int i = n; i &gt;= 2; i--)add2(i); for (int i = 2; i &lt;= n; i++)ans = max(ans, (long long) (R[i] - L[i] + 2) * h[i]); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>单调栈</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后缀数组是一类应用在字符串中的算法。本文改自这篇博客，下面的代码基于这个题目。 后缀&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在KMP匹配算法中已经提及。对于字符串abcde，它的后缀为abcde、bcde、…、de、e，这里的后缀是可以含本身的。 后缀字典序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字典序排列是两个字符串之间进行排列比较的手段，它的做法是从左到右依次比较两个字符串的对应位置，ascii码较小的一个字典序更小。如果到某一个字符串已经比较到结尾，则长度较小的一个字典序更小。例如ab&lt;ac，ab&lt;abc。 后缀数组及其求法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是后缀数组。对于一个字符串的所有后缀，我们将它们按照字典序从小到大排列，并开一个数组sa使得sa[i]为排名为i的后缀在原字符串中的起始位置（为简便起见，在下文中称为位置。排名从1开始，原字符串下标也从1开始），这个sa数组就称为后缀数组（Suffix Array ，SA）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于后缀的长度各不相同，它们的字典序序号必然各不相同。此时构造一个数组rk为sa数组的反射，即rk[i]表示位置为i的后缀的排名。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨后缀数组的构造方法，这里只介绍倍增方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种简单粗暴的方法就是直接快排，时间复杂度为$O(n^2logn)$，显然不可行，倍增算法可以将其优化到$O(nlogn)$复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倍增的思想：将字符串看成两部分：前半部分和后半部分。这样字符串就成为了一个二元组，前半部分为第一关键字，后半部分为第二关键字。如果我们已经求出第一关键字的排名，并求出了第二关键字的相对位置，那么总的排序序列就可以被求出了。之后再将前后两部分看成一个整体，作为下一次运算的前半部分，依次递归进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，采用数组tp来当做第二关键字，它的作用与sa类似：tp[i]表示第二关键字排名为i的后缀的位置。第一关键字用rk数组来充当。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先第一步：将每一个后缀按首位字符排序，第一关键字为首字符ascii码，第二关键字为首字符的下标。这里的第二关键字就是tp数组，事实上只要tp数组构成{1..n}-&gt;{1..n}的双射即可。1for (int i = 1; i &lt;= n; i++)rk[i] = op[i] - '0', tp[i] = n - i + 1;//op是原字符串 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面进行排序，排序即是根据rk和tp数组对sa数组进行修改。对于排序的详细操作留在文末，继续看倍增操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里sa中已经记录了按照首字符排列的序列信息，下面考虑倍增。123for (int w = 1, p = 0; p &lt; n;w &lt;&lt;= 1) &#123; //...&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w是指目前已经按照w大小进行排序（比如一开始只按首字符排序，故w=1），p暂且不用管它。每一次循环之后都需要w自乘2。123p = 0;for (int i = 1; i &lt;= w; i++)tp[++p] = n - w + i;for (int i = 1; i &lt;= n; i++)if (sa[i] &gt; w)tp[++p] = sa[i] - w; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面是循环体中的第一部分代码，这里p用来记录排名。这三行代码的作用是求出第二关键字的相对排名，根据倍增思想，充当第二关键字的字符串长度也应为w。对于一个后缀，我们已经求出了它前w的字符作为关键字的排名，现在要求再向后w个字符的相对排名。这时可以发现有些后缀是没有第二关键字的，比如位置为n、n-1、…、n-w+1的后缀就没有第二关键字。这里的没有是指完全没有，部分没有的后缀不计入其中。对于这些没有第二关键字的后缀，根据字典序的定义，它们在按照第二关键字排序时应该排到前面，因次第一个for循环将末尾那些不存在第二关键字的后缀首先进行了排名。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步是很精妙的操作。容易发现位置为i的后缀的第二关键字恰好就是位置为i+w的后缀的第一关键字，而后者的相对位置已经确定，那么不妨就根据这个关系更新第二关键字的相对位置。第二个for循环中，从排名第1的后缀开始遍历，凡是满足sa[i]&gt;w的后缀（sa[i]&gt;w表示这个后缀的前面必有一个第二关键字与它第一关键字相同的后缀），更新它的第二关键字排名。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样第二关键字的tp数组也被求出，在利用已经求出的rk数组，可以再进行一步排序来更新sa，排序的详细步骤仍然留到最后。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是下一次倍增中需要rk数组，rk数组还没有更新，因此下面需要更新rk数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面已经提到，rk数组是sa数组的反射，其实这种说法并不准确。在整个过程结束后，rk数组确实是sa数组的反射，但在求解过程中并不是。sa数组储存排名为i的后缀的位置，这是一个从排名到后缀的双射。也就是说，对于我们目前的排序关键字，可能存在“完全相同”的两个后缀，它们在sa数组中是得不到体现的（虽然排名一定靠着），在更新rk数组时要留意这一点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新rk数组时需要留意相同的后缀，并给它们相同的排名，即两个后缀的rk值可能相同。容易发现，当所有后缀的rk值两两不同时，说明后缀数组构造完毕，此时结束循环，这也是判断后缀数组构造完成的指标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定两个后缀相同可以用如下方法判定：第一关键字排名（rk）值相同并且第二关键字排名（rk）值相同，这样就可以判定它们第一关键字和第二关键字都相同，两个后缀在当前关键字下便相同。这里需要上一次的rk数组，但同时又要更新rk数组，为了防止混淆，我们将rk数组复制到tp中，此时tp数组已经没用了。1for (int i = 1; i &lt;= n; i++)tp[i] = rk[i]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是更新rk的核心代码：1234rk[sa[1]] = p = 1;//初始化for (int i = 2; i &lt;= n; i++) &#123; rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里p的意义是记录互不相同的排名数量，当p=n时所有后缀排名互不相同，结束循环，这也是上文中for循环的终止条件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的for循环利用相同后缀排名必相同的性质，将每一个后缀都与前一个后缀进行比较，如果第一关键字排名相同并且第二关键字排名相同则与上一个后缀的排名相同，否则分配一个新排名。这里的第二关键字排名仍然用上文所说的性质。 基数排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在可以来探讨排序的方法，这里采用基数排序。123456void mySort() &#123; for (int i = 0; i &lt;= M; i++)tax[i] = 0; for (int i = 1; i &lt;= n; i++)tax[rk[i]]++; for (int i = 1; i &lt;= M; i++)tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; i--)sa[tax[rk[tp[i]]]--] = tp[i];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tax是基数排序用的桶，M是第一关键字的最大取值，由于第一关键字是排名信息，可以设置成1e6+5（按照题目条件）。第一个for循环将桶清空。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个for循环将第一关键字的信息放入桶中，统计数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个for循环求前缀和，这是为了方便求排名。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四个for循环较难理解。倒序遍历后缀，由于已经求了前缀和，这时的tax值就是排名，之后用自减一的方式将其从桶中取出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外这里有一处优化。M由于是第一关键字的最大值，因此可以根据每一次循环的p值来修改M，以降低时间复杂度。注意一开始第一关键字的最大值是’z’-‘0’。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就得到了求后缀数组的完整步骤，下面给出模板题代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define N 1000000+20using namespace std;int n, sa[N], tp[N], rk[N], tax[N], M;char op[N];inline void mySort() &#123; for (int i = 0; i &lt;= M; i++)tax[i] = 0; for (int i = 1; i &lt;= n; i++)tax[rk[i]]++; for (int i = 1; i &lt;= M; i++)tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; i--)sa[tax[rk[tp[i]]]--] = tp[i];&#125;inline void solve() &#123; M = 80; for (int i = 1; i &lt;= n; i++)rk[i] = op[i] - '0' + 1, tp[i] = i; mySort(); for (int w = 1, p = 0; p &lt; n; M = p, w &lt;&lt;= 1) &#123; p = 0; for (int i = 1; i &lt;= w; i++)tp[++p] = n - w + i; for (int i = 1; i &lt;= n; i++)if (sa[i] &gt; w)tp[++p] = sa[i] - w; mySort(); for (int i = 1; i &lt;= n; i++)tp[i] = rk[i]; rk[sa[1]] = p = 1; for (int i = 2; i &lt;= n; i++) &#123; rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; sa[i] &lt;&lt; " "; &#125;&#125;int main() &#123; cin &gt;&gt; op + 1; n = strlen(op + 1); solve(); return 0;&#125; height数组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height数组是应用后缀数组的利器。首先定义最长公共前缀lcp(i,j)：位置为i和位置为j的后缀的最长公共前缀长度。于是有height数组： height[i]=lcp(sa[i],sa[i-1])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，height[i]表示排名为i和排名为i-1的后缀的最长公共前缀长度。规定height[1]=0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求height数组？这需要利用一个重要性质（证明略）： height[rk[i]]\geq height[rk[i-1]]-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以此递推，不难写出代码：123456789101112inline void getHeight() &#123; int k = 0, j; for (int i = 1; i &lt;= n; i++) &#123; if (rk[i] == 1)h[rk[i]] = k = 0; else &#123; if (k)k--; j = sa[rk[i] - 1]; while (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; op[j + k] == op[i + k])++k; h[rk[i]] = k; &#125; &#125;&#125; 后缀数组的应用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对后缀进行字典序排序实质上是利用了排序后相邻后缀差异尽可能小的性质，利用这个性质可以解决很多问题。 两个后缀的最大公共前缀&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于位置为i、j的两个后缀，其最大公共前缀长度为： \min\{height[rk[i]+1],height[rk[i]+2],...,height[rk[j]]\},rk[i]]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增算法]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍倍增算法+三道例题，题目来自洛谷，难度至少提高+/省选-。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倍增算法在之前的快速幂、求LCA算法、ST表中都有体现，它基于下面的基本原理： \forall x\in \mathbb {N},x=2^{p_1}+2^{p_2}+\cdots +2^{p_n},0\leq p_1 < p_2 < \cdots < p_n,p_i\in \mathbb {N}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，对于任意一个自然数，它都可以唯一地表示成若干个互异的2的方幂相加的形式。利用这个原理，我们可以将x的求得过程降至对数级别。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际操作中，通常采用“跳跃式行进”的方法去应用倍增，具体做法是：从2的高幂次方幂开始进行跳跃，如果越过目标，则将方幂减少一倍（即下一个方幂）；如果未越过，可以证明该方幂一定在上面给出的二进制拆分表达式中，进行跳跃操作，之后也需要将方幂减少一倍。重复这个过程直到取尽2的所有自然数方幂，此时就已经跳跃到目标位置。这样可以在$O(logn)$复杂度下完成跳跃操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面三道例题，点击题目标题可进行跳转。样例及说明略，见洛谷原题。 例题一 货车运输(P1967)难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有两个用一个空格隔开的整数 n,m，表示A国有n座城市和 m 条道路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来m行每行 3 个整数 x, y, z，每两个整数之间用一个空格隔开，表示从 x 号城市到y号城市有一条限重为z的道路。注意： x 不等于 y，两座城市之间可能有多条道路 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来一行有一个整数 q，表示有 q 辆货车需要运货。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题本质上是求图中任意两点可能路径中最小边权值的最大值。看到最小值的最大值首先想到二分答案，二分答案比暴力快，但是免不了每次都要遍历一遍图，效率低下一定TLE。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑其它方法。可以证明任意两点最大值出现的路径一定在该图的最大生成树上，于是用Kruskal算法配合并查集求出最大生成树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树构造完毕后，两点的路径显然就是经过两个点LCA的路径，这里改一下倍增法求LCA的步骤就可以轻易求出答案。查询时间复杂度$O(logn)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define N 10005#define inf 0x7ffffffusing namespace std;inline int read() &#123;//神奇的读入优化 char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;struct Edge &#123; int to, v, next;&#125; edge[N];struct Temp &#123; int from, to, v; bool operator&lt;(Temp t) &#123; return v &gt; t.v; &#125;&#125; temp[5 * N];int n, m, head[N], cnt = 1, father[N], grand[N][16], minn[N][16], depth[N];inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;int find(int x) &#123; return father[x] == x ? x : father[x] = find(father[x]);&#125;void DFS(int x) &#123; for (int i = head[x]; i; i = edge[i].next) if (!depth[edge[i].to]) &#123; grand[edge[i].to][0] = x, minn[edge[i].to][0] = edge[i].v, depth[edge[i].to] = depth[x] + 1; for (int j = 1; j &lt;= 15; j++) &#123; grand[edge[i].to][j] = grand[grand[edge[i].to][j - 1]][j - 1]; minn[edge[i].to][j] = min(minn[edge[i].to][j - 1], minn[grand[edge[i].to][j - 1]][j - 1]); &#125; DFS(edge[i].to); &#125;&#125;int findAns(int x, int y) &#123; if (x == y)return inf; if (find(x) != find(y))return -1; int ans = inf; if (depth[x] == depth[y]) &#123; for (int i = 15; i &gt;= 0; i--) &#123; if (grand[x][i] != grand[y][i]) ans = min(ans, min(minn[x][i], minn[y][i])), x = grand[x][i], y = grand[y][i]; &#125; return min(ans, min(minn[x][0], minn[y][0])); &#125; else &#123; if (depth[x] &lt; depth[y]) &#123; for (int i = 15; i &gt;= 0; i--) &#123; if (depth[grand[y][i]] &gt;= depth[x])ans = min(ans, minn[y][i]), y = grand[y][i]; &#125; return min(ans, findAns(x, y)); &#125; else &#123; for (int i = 15; i &gt;= 0; i--) &#123; if (depth[grand[x][i]] &gt;= depth[y])ans = min(ans, minn[x][i]), x = grand[x][i]; &#125; return min(ans, findAns(x, y)); &#125; &#125;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) &#123; father[i] = i; for (int j = 0; j &lt;= 15; j++)minn[i][j] = inf; &#125; for (int i = 1; i &lt;= m; i++)temp[i].from = read(), temp[i].to = read(), temp[i].v = read(); sort(temp + 1, temp + m + 1); for (int i = 1; i &lt;= m; i++) if (find(temp[i].from) != find(temp[i].to)) &#123; father[find(temp[i].from)] = find(temp[i].to); add(temp[i].from, temp[i].to, temp[i].v); add(temp[i].to, temp[i].from, temp[i].v); &#125; for (int i = 1; i &lt;= n; i++)if (!depth[i])depth[i] = 1, DFS(i); int q = read(); for (int i = 1; i &lt;= q; i++) &#123; int x = read(), y = read(); cout &lt;&lt; findAns(x, y) &lt;&lt; endl; &#125; return 0;&#125; 例题二 开车旅行(P1081)难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小A和小B决定利用假期外出旅行，他们将想去的城市从1到N编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市i的海拔高度为$H_i$ ，城市i和城市j之间的距离$d_{ij}$恰好是这两个城市海拔高度之差的绝对值，即$d_{ij}=|H_i-H_j|$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;旅行过程中，小 A和小B 轮流开车，第一天小 A 开车，之后每天轮换一次。他们计划选择一个城市 S 作为起点，一直向东行驶，并且最多行驶 X公里就结束旅行。小 A 和小 B的驾驶风格不同，小 B总是沿着前进方向选择一个最近的城市作为目的地，而小 A总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 X 公里，他们就会结束旅行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在启程之前，小 A想知道两个问题：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个给定的 $X=X_0$，从哪一个城市出发，小 A开车行驶的路程总数与小 B 行驶的路程总数的比值最小（如果小 B 的行驶路程为 0，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对任意给定的 $X=X_i$和出发城市 $S_i$，小 A开车行驶的路程总数以及小 B 行驶的路程总数。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数N，表示城市的数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行有 N个整数，每两个整数之间用一个空格隔开，依次表示城市 1 到城市 N的海拔高度，即$H_1,H_2,\cdots,H_n$，且每个$H_i$都是不同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行包含一个整数$X_0$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四行为一个整数M，表示给定M组$S_i$和$X_i$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的 M 行，每行包含 2 个整数$S_i$和$X_i$，表示从城市$S_i$出发，最多行驶$X_i$公里。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共 M+1行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数$S_0$ ，表示对于给定的$X_0$，从编号为$S_0$的城市出发，小A开车行驶的路程总数与小B行驶的路程总数的比值最小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的M行，每行包含 2个整数，之间用一个空格隔开，依次表示在给定的$S_i$和$X_i$下小 A 行驶的里程总数和小 B 行驶的里程总数。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题有一定难度。首先应该考虑预处理出每一个城市小A的目标和小B的目标。最直接的方法是暴力扫一遍找出最小和第二小，时间复杂度$O(n^2)$。在这样的数据量下，仅这个步骤就已经TLE了，显然不可取。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个较好的方法是从右向左进行预处理，每一次保证待求城市右侧的城市的高度升序（降序也可），然后二分求最小和次小。这样需要向有序序列中不断插入元素，还要保证能够二分，可以选择用平衡树这个数据结构完成这个操作，这里用fhq treap。平衡树操作求第二小可以先求最小再将其最小值删除，再求的最小值就是实际的第二小，紧接着把最小值重新插入即可。预处理时间复杂度$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑后面的操作。对于小A的第一个问题，一种想法是遍历出发城市进行判断，这样做的时间复杂度仍然为$O(n^2)$，会TLE，于是采用倍增算法将其优化至$O(nlogn)$。预处理出从某个城市开始走$2^k$步的目标城市和小A、小B的驾驶距离，进行倍增即可。第二个问题也可以用倍增的方法解决。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;#define N 100005#define ABS(x) ((x)&gt;=0?(x):-(x))using namespace std;struct Node &#123; int v, ch[2], key, rk;&#125; node[N &lt;&lt; 1];int cnt = 1, root, to[N][2], op[N], n;int A[N][2][19], B[N][2][19], TO[N][2][19];inline int read() &#123; char e = getchar(); int s = 0, f = 0; while (e &lt; '-')e = getchar(); if (e == '-')f = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return f ? -s : s;&#125;void split(int rt, int &amp;a, int &amp;b, int k) &#123; if (rt == 0)a = b = 0; else &#123; if (node[rt].v &lt;= k)a = rt, split(node[rt].ch[1], node[a].ch[1], b, k); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], k); &#125;&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0)rt = a + b; else if (node[a].key &lt; node[b].key)rt = b, merge(node[rt].ch[0], a, node[b].ch[0]); else rt = a, merge(node[rt].ch[1], node[a].ch[1], b);&#125;int newNode(int x, int rk) &#123; node[cnt].v = x, node[cnt].key = rand(), node[cnt].rk = rk; return cnt++;&#125;void insert(int x, int rk) &#123; int p = newNode(x, rk), a, b; split(root, a, b, x), merge(a, a, p), merge(root, a, b);&#125;void del(int x) &#123; int a, b, c; split(root, a, b, x), split(a, a, c, x - 1), merge(root, a, b);&#125;int findMin(int rt, int x) &#123; if (rt == 0)return 0; int ans; if (node[rt].v &lt; x)ans = findMin(node[rt].ch[1], x); else ans = findMin(node[rt].ch[0], x); if (ans == 0)return rt; if (ABS(node[ans].v - x) &lt; ABS(node[rt].v - x))return ans; else if (ABS(node[ans].v - x) &gt; ABS(node[rt].v - x))return rt; else return node[ans].v &lt; node[rt].v ? ans : rt;&#125;int findMin2(int x, int a) &#123; del(node[a].v); int ans = findMin(root, x); insert(node[a].v, node[a].rk); return ans;&#125;inline void solve() &#123; int x0 = read(), ans = 1, m; double minn = 1e9, tp; for (int i = 1; i &lt;= n; i++) &#123; int p = i, a = 0, b = 0; for (int j = 18; j &gt;= 0; j--) if (TO[p][0][j] != 0 &amp;&amp; a + b + A[p][0][j] + B[p][0][j] &lt;= x0) a += A[p][0][j], b += B[p][0][j], p = TO[p][0][j]; tp = (b == 0 ? 1e9 : (double) a / b); if (tp &lt; minn)ans = i, minn = tp; else if (tp == minn &amp;&amp; op[i] &gt; op[ans])ans = i; &#125; cout &lt;&lt; ans &lt;&lt; endl; m = read(); for (int i = 1; i &lt;= m; i++) &#123; int S = read(), X = read(), a = 0, b = 0; for (int j = 18; j &gt;= 0; j--) &#123; if (TO[S][0][j] != 0 &amp;&amp; a + b + A[S][0][j] + B[S][0][j] &lt;= X) &#123; a += A[S][0][j], b += B[S][0][j], S = TO[S][0][j]; &#125; &#125; cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; &#125;&#125;int main() &#123; srand(time(NULL)); n = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); insert(op[n], n); for (int i = n - 1; i &gt;= 1; i--) to[i][1] = findMin(root, op[i]), to[i][0] = findMin2(op[i], to[i][1]), insert(op[i], i); for (int i = 1; i &lt;= n; i++)to[i][0] = node[to[i][0]].rk, to[i][1] = node[to[i][1]].rk; for (int i = n - 1; i &gt;= 1; i--) &#123; A[i][0][0] = ABS(op[i] - op[to[i][0]]), B[i][1][0] = ABS(op[i] - op[to[i][1]]); TO[i][0][0] = to[i][0], TO[i][1][0] = to[i][1]; for (int j = 1; j &lt;= 18; j++) &#123; TO[i][0][j] = TO[TO[i][0][j - 1]][j == 1][j - 1]; TO[i][1][j] = TO[TO[i][0][j - 1]][j != 1][j - 1]; A[i][0][j] = A[i][0][j - 1] + (j == 1 ? 0 : A[TO[i][0][j - 1]][0][j - 1]); B[i][1][j] = B[i][1][j - 1] + (j == 1 ? 0 : B[TO[i][1][j - 1]][1][j - 1]); A[i][1][j] = A[i][1][j - 1] + (j == 1 ? A[TO[i][1][0]][0][0] : A[TO[i][1][j - 1]][1][j - 1]); B[i][0][j] = B[i][0][j - 1] + (j == 1 ? B[TO[i][0][0]][1][0] : B[TO[i][0][j - 1]][0][j - 1]); &#125; &#125; solve(); return 0;&#125; 例题三 跑路(P1613)难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小A的工作不仅繁琐，更有苛刻的规定，要求小A每天早上在6：00之前到达公司，否则这个月工资清零。可是小A偏偏又有赖床的坏毛病。于是为了保住自己的工资，小A买了一个十分牛B的空间跑路器，每秒钟可以跑2^k千米（k是任意自然数）。当然，这个机器是用longint存的，所以总跑路长度不能超过maxlongint千米。小A的家到公司的路可以看做一个有向图，小A家为点1，公司为点n，每条边长度均为一千米。小A想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证1到n至少有一条路径。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个整数n，m，表示点的个数和边的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来m行每行两个数字u，v，表示一条u到v的边。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行一个数字，表示到公司的最少秒数。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实是一道水题，能想出来方法则这题很简单，想不出来…就想不出来了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预处理任意两点间是否存在长度为$2^k$的路径，可以使用邻接矩阵快速幂。对于存在该路径的点对，显然可以用1s的时间在两点间“穿越”，相当于两点间有一条权为1的有向边。以此加边构图，最后结点1到结点n的最短路径就是答案，这里可以用Floyd算法求出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;int n, m;long long dict[51][51];struct Matrix &#123; int op[51][51]; void operator*=(Matrix p) &#123; int t[51][51] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int z = 1; z &lt;= n; z++)t[i][j] += this-&gt;op[i][z] * p.op[z][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++)this-&gt;op[i][j] = t[i][j] &gt;= 1; &#125;&#125;a;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++)dict[i][j] = i == j ? 0 : (1l &lt;&lt; 52); &#125; for (int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; a.op[x][y] = 1, dict[x][y] = 1; &#125; for (int i = 2; i &lt;= 63; i++) &#123; a *= a; for (int j = 1; j &lt;= n; j++) &#123; for (int z = 1; z &lt;= n; z++)if (a.op[j][z])dict[j][z] = 1; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (k != i &amp;&amp; i != j &amp;&amp; k != j) &#123; dict[i][j] = min(dict[i][k] + dict[k][j], dict[i][j]); &#125; &#125; &#125; &#125; cout &lt;&lt; dict[1][n]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>倍增算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2F2019%2F03%2F06%2F%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍简单的莫队算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫队算法是一种优雅的暴力方法，由前国家队队长莫涛提出，故称莫队算法。本文只探讨基本的莫队算法。值得注意的是，莫队算法必须离线，而且最好用来处理查询问题（尽可能不修改）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑一个问题：给定一个区间，求子区间中互异数的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最暴力的方法是每一次都遍历一遍子区间，求出互异数，时间复杂度为$O(nm)$，效率很低。莫队算法就是在暴力方法的基础上改进提出的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不变的序列和m个询问，考虑离线。置两个指针指向某个区间的首末位置，对于每一个询问区间，将两个指针移动到询问区间的两端，移动过程中修改答案数据。这样在指针移动到目标位置时就得到了答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显，这样并没有多少效率的提升。指针有可能从头指向尾，再从尾指向头，时间复杂度还是$O(nm)$，效率可能比暴力还低。这时，莫队算法的一个重要思想就体现出来了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对区间分块，分成t块。通常置每一块的长度为$\sqrt n$，这样t就大致为$\sqrt n$。当最后的序列长度不足组成一个块时，将它们视为一个。比如对于长度为10的序列，可将其分成3+3+3+1四个块。12int base = static_cast&lt;int&gt;(sqrt(n));for (int i = 1; i &lt;= n; i++)belong[i] = (i - 1) / base + 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码可以来完成分块操作。belong存每一个点所处块的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，对所有询问进行排序。当询问区间的左端点在同一块中时，按右端点升序排列，否则按左端点升序排列。1234bool operator&lt;(Node x) &#123; if (belong[l] == belong[x.l])return r &lt; x.r; return l &lt; x.l;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面是结点重载&lt;的形式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样排序有什么好处？下面分析排序后指针移动次数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在同一块中时，左指针最大移动$\sqrt n$，右指针只能升序移动，最大移动$n$；当跨块时，左指针最大移动$2\sqrt n$，右指针仍然为$n$。这样来看，对于每一次询问，左指针平均移动$\sqrt n$次；对于每一个块，右指针移动n次，于是时间复杂度为$O((n+m)\sqrt n)$，相比$O(nm)效率得到很大提升$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题：洛谷P1972。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题目就是本文一开始提出的问题，值得注意的是，莫队算法在本题中可得80分左右，但思想很重要，文末介绍本题正解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;int belong[500005], n, vis[1000000], op[500005], ans, m;struct Node &#123; int l, r, rk, ans; bool operator&lt;(Node x) &#123; if (belong[l] == belong[x.l])return r &lt; x.r; return l &lt; x.l; &#125;&#125; node[500005];inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar();//神奇的读入优化 return s;&#125;bool cmp(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;inline void moveL(int &amp;p, int to) &#123;//移动左指针 if (p &lt; to) &#123; do &#123; vis[op[p]]--; if (vis[op[p]] == 0)ans--; p++; &#125; while (p &lt; to); &#125; else if (p &gt; to) &#123; do &#123; p--; vis[op[p]]++; if (vis[op[p]] == 1)ans++; &#125; while (p &gt; to); &#125;&#125;inline void moveR(int &amp;p, int to) &#123;//移动右指针 if (p &lt; to) &#123; do &#123; p++; vis[op[p]]++; if (vis[op[p]] == 1)ans++; &#125; while (p &lt; to); &#125; else if (p &gt; to) &#123; do &#123; vis[op[p]]--; if (vis[op[p]] == 0)ans--; p--; &#125; while (p &gt; to); &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); int base = static_cast&lt;int&gt;(sqrt(n)), l = 1, r = 1; for (int i = 1; i &lt;= n; i++)belong[i] = (i - 1) / base + 1; m = read(); for (int i = 1; i &lt;= m; i++)node[i].l = read(), node[i].r = read(), node[i].rk = i; sort(node + 1, node + m + 1); vis[op[1]] = 1, ans = 1; for (int i = 1; i &lt;= m; i++)moveL(l, node[i].l), moveR(r, node[i].r), node[i].ans = ans; sort(node + 1, node + m + 1, cmp); for (int i = 1; i &lt;= m; i++)cout &lt;&lt; node[i].ans &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二道例题：TJU某ACM冬季训练竞赛最后一题。 【排队接水】有n个小朋友需要接水，其中第i个小朋友接水需要ai分钟。由于水龙头有限，小Hi需要知道如果为第l个到第r个小朋友分配一个水龙头，如何安排他们的接水顺序才能使得他们等待加接水的时间总和最小。小Hi总共会有m次询问，你能帮助他解决这个问题吗？假设3个小朋友接水的时间分别是2，3，4。如果他们依次接水，第一位小朋友等待加接水的时间是2，第二位小朋友是5，第三位小朋友是9。时间总和是16。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心策略很容易知道将这些结点排序，求前缀和相加就是答案。本题用莫队算法可以比较容易地解决。一个难点是如何在指针移动时更新答案，这个过程需要维护两个树状数组。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (e &amp; 15), e = getchar(); return s;&#125;int n, m, op[20005], belong[20005], l, r;long long tree[20005], tree2[20005], ans;struct Node &#123; int l, r, rk; long long ans; bool operator&lt;(Node x) &#123; if (belong[l] == belong[x.l])return r &lt; x.r; return l &lt; x.l; &#125;&#125; node[20005];inline void add(int x, int y, long long *tr) &#123; for (; x &lt;= n; x += (x &amp; -x))tr[x] += y;&#125;inline long long sum(int x, const long long *tr) &#123; long long s = 0; for (; x &gt;= 1; x -= (x &amp; -x))s += tr[x]; return s;&#125;inline void moveL(int &amp;at, int to) &#123; long long p, s = r - l + 1; if (at &lt; to) &#123; do &#123; p = sum(op[at], tree), ans -= sum(op[at], tree2) + (s - p) * op[at]; add(op[at], -1, tree), add(op[at], -op[at], tree2), at++, s--; &#125; while (at &lt; to); &#125; else if (at &gt; to) &#123; do &#123; at--, p = sum(op[at], tree), ans += (s - p) * op[at] + sum(op[at], tree2) + op[at]; add(op[at], 1, tree), add(op[at], op[at], tree2), s++; &#125; while (at &gt; to); &#125;&#125;inline void moveR(int &amp;at, int to) &#123; long long p, s = r - l + 1; if (at &lt; to) &#123; do &#123; at++, p = sum(op[at], tree), ans += (s - p) * op[at] + sum(op[at], tree2) + op[at]; add(op[at], 1, tree), add(op[at], op[at], tree2), s++; &#125; while (at &lt; to); &#125; else if (at &gt; to) &#123; do &#123; p = sum(op[at], tree), ans -= sum(op[at], tree2) + (s - p) * op[at]; add(op[at], -1, tree), add(op[at], -op[at], tree2), at--, s--; &#125; while (at &gt; to); &#125;&#125;bool cmp(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;int main() &#123; int t = read(); while (t--) &#123; n = read(), m = read(); int base = static_cast&lt;int&gt;(sqrt(n)); for (int i = 1; i &lt;= n; i++)op[i] = read(), tree2[i] = tree[i] = 0, belong[i] = (i - 1) / base + 1; for (int i = 1; i &lt;= m; i++)node[i].l = read(), node[i].r = read(), node[i].rk = i; sort(node + 1, node + m + 1); l = r = 1, ans = op[1], add(op[1], 1, tree), add(op[1], op[1], tree2); for (int i = 1; i &lt;= m; i++)moveL(l, node[i].l), moveR(r, node[i].r), node[i].ans = ans; sort(node + 1, node + m + 1, cmp); for (int i = 1; i &lt;= m; i++)cout &lt;&lt; node[i].ans &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;入门经典：小z的袜子，这个题直接莫队算法水过去就行。具体做法是移动指针时统计各种颜色出现过的次数，然后用组合数更新答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;#define N 50005inline int read() &#123; int s = 0; char e = getchar(); while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;long long gcd(long long x, long long y) &#123; return y == 0 ? x : gcd(y, x % y);&#125;long long n, m, op[N], vis[N], belong[N], ans, sum;struct Node &#123; long long l, r, ans1, ans2, rk;&#125; node[N];bool cmp(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;bool cmp1(Node x, Node y) &#123; if (belong[x.l] == belong[y.l])return x.r &lt; y.r; return x.l &lt; y.l;&#125;inline void moveL(long long &amp;from, long long to) &#123; if (from &gt; to) &#123; --from; while (from &gt;= to)ans += vis[op[from]], ++vis[op[from]], --from; &#125; else if (from &lt; to) &#123; while (from &lt; to)ans -= vis[op[from]] - 1, --vis[op[from]], ++from; &#125; from = to;&#125;inline void moveR(long long &amp;from, long long to) &#123; if (from &gt; to) &#123; while (from &gt; to)ans -= vis[op[from]] - 1, --vis[op[from]], --from; &#125; else if (from &lt; to) &#123; ++from; while (from &lt;= to)ans += vis[op[from]], ++vis[op[from]], ++from; &#125; from = to;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); long long base = sqrt(n), l = 1, r = 1, d; for (int i = 1; i &lt;= n; i++)belong[i] = (i - 1) / base + 1; for (int i = 1; i &lt;= m; i++)node[i].l = read(), node[i].r = read(), node[i].rk = i; sort(node + 1, node + m + 1, cmp1), vis[op[1]] = 1; for (int i = 1; i &lt;= m; i++) &#123; if (node[i].l == node[i].r) &#123; node[i].ans1 = 0, node[i].ans2 = 1; continue; &#125; sum = node[i].r - node[i].l + 1, sum = static_cast&lt;int&gt;(1ll * sum * (sum - 1) / 2); moveR(r, node[i].r), moveL(l, node[i].l), d = gcd(ans, sum); node[i].ans1 = ans / d, node[i].ans2 = sum / d; &#125; sort(node + 1, node + m + 1, cmp); for (int i = 1; i &lt;= m; i++)printf("%lld/%lld\n", node[i].ans1, node[i].ans2); return 0;&#125; 带修莫队&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;朴素莫队算法不支持修改，如果需要修改就需要带修莫队算法。模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板题也是记录区间互异数的数目的，不过加入了单点修改。这时我们需要将查询和修改两个操作分开，并在查询中加入指标time表示这是在那一次修改后进行的查询，然后排序：12345bool cmp1(Node x, Node y) &#123; if (belong[x.l] != belong[y.l])return belong[x.l] &lt; belong[y.l]; if (belong[x.r] != belong[y.r])return belong[x.r] &lt; belong[y.r]; return x.t &lt; y.t;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现先按照左端点分块处理，再按照右端点，最后考虑时间。这样引入了第三个指针：time指针，在指针移动时需要移动time指针，更新答案。下面是时间复杂度分析。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设一个块的大小是base，一共有m次修改，s次询问。左端点在一个块中时，左指针移动距离不大于base，右指针一直向右移，移动n次（n为序列长度），但对于时间指针的移动，最坏可能移动m次。这样总移动次数为$O(s*base+(\frac {n} {base})^2m+\frac {n^2} {base}+s*base)$，在$base=n^{\frac {2} {3}}$时可以达到$O(n^{\frac {5} {3}})$的复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define N 50005using namespace std;int op[N], vis[1000005], tmp[N], belong[N];struct Node &#123; int l, r, t, rk, ans;&#125; node[N];struct Change &#123; int pos, from, to;&#125; change[N];int n, m, m1, m2, l, r, ans, t;bool cmp1(Node x, Node y) &#123; if (belong[x.l] != belong[y.l])return belong[x.l] &lt; belong[y.l]; if (belong[x.r] != belong[y.r])return belong[x.r] &lt; belong[y.r]; return x.t &lt; y.t;&#125;bool cmp2(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;inline void moveT(int &amp;from, int to) &#123;//移动时间指针 if (from &gt; to) &#123; while (from &gt; to) &#123; op[change[from].pos] = change[from].from; if (l &lt;= change[from].pos &amp;&amp; r &gt;= change[from].pos) &#123; --vis[change[from].to], ++vis[change[from].from]; if (vis[change[from].to] == 0)--ans; if (vis[change[from].from] == 1)++ans; &#125; --from; &#125; &#125; else if (from &lt; to) &#123; ++from; while (from &lt;= to) &#123; op[change[from].pos] = change[from].to; if (l &lt;= change[from].pos &amp;&amp; r &gt;= change[from].pos) &#123; ++vis[change[from].to], --vis[change[from].from]; if (vis[change[from].to] == 1)++ans; if (vis[change[from].from] == 0)--ans; &#125; ++from; &#125; &#125; from = to;&#125;inline void moveR(int &amp;from, int to) &#123;//移动右指针 if (from &lt; to) &#123; ++from; while (from &lt;= to) &#123; if (vis[op[from]] == 0)++ans; ++vis[op[from]], ++from; &#125; &#125; else if (from &gt; to) &#123; while (from &gt; to) &#123; if (vis[op[from]] == 1)--ans; --vis[op[from]], --from; &#125; &#125; from = to;&#125;inline void moveL(int &amp;from, int to) &#123;//移动左指针 if (from &lt; to) &#123; while (from &lt; to) &#123; if (vis[op[from]] == 1)--ans; --vis[op[from]], ++from; &#125; &#125; else if (from &gt; to) &#123; --from; while (from &gt;= to) &#123; if (vis[op[from]] == 0)++ans; ++vis[op[from]], --from; &#125; &#125; from = to;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (register int i = 1; i &lt;= n; i++)scanf("%d", op + i), tmp[i] = op[i]; for (register int i = 1; i &lt;= m; i++) &#123; register char e; register int l, r; scanf(" %c%d%d", &amp;e, &amp;l, &amp;r); if (e == 'Q')node[++m1].l = l, node[m1].r = r, node[m1].t = m2, node[m1].rk = i; else if (tmp[l] != r)change[++m2].pos = l, change[m2].from = tmp[l], change[m2].to = r, tmp[l] = r; &#125; register int base = pow(n, 0.66666666); for (register int i = 1; i &lt;= n; i++)belong[i] = (i - 1) / base + 1; sort(node + 1, node + m1 + 1, cmp1); l = r = 1, vis[op[1]] = 1, ans = 1; for (register int i = 1; i &lt;= m1; i++) moveT(t, node[i].t), moveR(r, node[i].r), moveL(l, node[i].l), node[i].ans = ans; sort(node + 1, node + m1 + 1, cmp2); for (register int i = 1; i &lt;= m1; i++)printf("%d\n", node[i].ans); return 0;&#125; 树上莫队&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树上莫队算法顾名思义就是将莫队算法搬到树上来，如果有树链剖分的基础，就可以知道其实树上路径可以化归为区间序列。如果需要统计子树上的信息，直接DFS序划分就可以将树上的问题转化为区间上的问题，直接上莫队算法即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要在路径上统计呢？我们很难将一条路径上的点都化到一个连续的区间中，只能另辟蹊径。这里需要引入欧拉序的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对树进行一遍DFS，进入某结点时记录一次编号，出该结点时再记录一次，这样每一个结点在遍历得到的序列中分别出现两次，这种序列称为欧拉序。若记$st[x]$表示结点x第一次出现在欧拉序中的位置，$ed[x]$表示第二次出现的位置，那么对于两个结点a、b，在欧拉序中有如下结论（假设$st[a]&lt;st[b]$）： 若a与b的lca是a，则序列$[st[a], st[b]]$中仅出现一次的结点为a到b路径上的结点。 若lca不是a，则序列$[ed[a], st[b]]$中仅出现一次的结点以及lca为a到b路径上的结点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意第二条中需要对lca特殊处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过欧拉序就可以将树上的问题转化为连续区间上的问题，于是就可以用莫队算法了，模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在移动指针时，需要同时记录每一个结点出现过的次数，出现过两次的结点是无效的。lca可以通过在线的倍增法或者离线的tarjan算法求解，下面代码采用前者。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;#define N 50005using namespace std;inline int read() &#123;//读优 char e = getchar(); int s = 0, g = 0; while (e &lt; '-')e = getchar(); if (e == '-')g = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return g ? -s : s;&#125;struct Edge &#123; int to, next;&#125; edge[N &lt;&lt; 1];struct Node &#123; int l, r, ans, rk, lca;&#125; node[100005];int head[N], n, m, op[N], tmp[N], depth[N], grand[N][19], op2[N &lt;&lt; 1], ct = 1, vis[N], be[N &lt;&lt; 1];int st[N], ed[N], num[N], ans;bool cmp1(Node x, Node y) &#123; return be[x.l] == be[y.l] ? x.r &lt; y.r : be[x.l] &lt; be[y.l];&#125;bool cmp2(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;inline void add(int x, int y) &#123; static int cnt = 1; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS(int x) &#123; st[x] = ct, op2[ct++] = x; for (int i = head[x]; i; i = edge[i].next) &#123; if (depth[edge[i].to] == 0) &#123; depth[edge[i].to] = depth[x] + 1, grand[edge[i].to][0] = x; for (int j = 1; j &lt;= 18; j++)grand[edge[i].to][j] = grand[grand[edge[i].to][j - 1]][j - 1]; DFS(edge[i].to); &#125; &#125; ed[x] = ct, op2[ct++] = x;&#125;inline int LCA(int x, int y) &#123;//倍增LCA if (depth[x] &gt; depth[y])swap(x, y);//认为y更深 for (int i = 18; i &gt;= 0; i--)if (depth[grand[y][i]] &gt;= depth[x])y = grand[y][i]; if (x == y)return x; for (int i = 18; i &gt;= 0; i--)if (grand[x][i] != grand[y][i])x = grand[x][i], y = grand[y][i]; return grand[x][0];&#125;inline void moveR(int &amp;from, int to) &#123; if (from &lt; to) &#123; ++from; while (from &lt;= to) &#123; if (num[op2[from]]) &#123; if (vis[op[op2[from]]] == 1)--ans; --vis[op[op2[from]]]; &#125; else &#123; if (vis[op[op2[from]]] == 0)++ans; ++vis[op[op2[from]]]; &#125; ++num[op2[from]], ++from; &#125; &#125; else if (from &gt; to) &#123; while (from &gt; to) &#123; if (num[op2[from]] == 2) &#123; if (vis[op[op2[from]]] == 0)++ans; ++vis[op[op2[from]]]; &#125; else if (num[op2[from]] == 1) &#123; if (vis[op[op2[from]]] == 1)--ans; --vis[op[op2[from]]]; &#125; --num[op2[from]], --from; &#125; &#125; from = to;&#125;inline void moveL(int &amp;from, int to) &#123; if (from &lt; to) &#123; while (from &lt; to) &#123; if (num[op2[from]] == 2) &#123; if (vis[op[op2[from]]] == 0)++ans; ++vis[op[op2[from]]]; &#125; else if (num[op2[from]] == 1) &#123; if (vis[op[op2[from]]] == 1)--ans; --vis[op[op2[from]]]; &#125; --num[op2[from]], ++from; &#125; &#125; else if (from &gt; to) &#123; --from; while (from &gt;= to) &#123; if (num[op2[from]]) &#123; if (vis[op[op2[from]]] == 1)--ans; --vis[op[op2[from]]]; &#125; else &#123; if (vis[op[op2[from]]] == 0)++ans; ++vis[op[op2[from]]]; &#125; ++num[op2[from]], --from; &#125; &#125; from = to;&#125;map&lt;int, int&gt; mmp;int main() &#123; int ID = 1; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)tmp[i] = op[i] = read(); sort(tmp + 1, tmp + n + 1); for (int i = 1; i &lt;= n; i++)if (mmp.count(tmp[i]) == 0)mmp[tmp[i]] = ID++;//离散化 for (int i = 1; i &lt;= n; i++)op[i] = mmp[op[i]]; for (int i = 1; i &lt; n; i++) &#123;//建树 int x = read(), y = read(); add(x, y), add(y, x); &#125; depth[1] = 1, DFS(1);//形成欧拉序并且预处理倍增LCA for (int i = 1; i &lt;= m; i++) &#123;//处理查询信息 int a = read(), b = read(), lca = LCA(a, b); if (st[a] &gt; st[b])swap(a, b); if (lca == a)node[i].l = st[a], node[i].r = st[b], node[i].lca = 0;//分类处理 else node[i].l = ed[a], node[i].r = st[b], node[i].lca = lca; node[i].rk = i; &#125; int base = sqrt(2.0 * n), l = 1, r = 1; ans = vis[op[op2[1]]] = num[op2[1]] = 1; for (int i = 1; i &lt;= (n &lt;&lt; 1); i++)be[i] = (i - 1) / base + 1;//分块 sort(node + 1, node + m + 1, cmp1);//莫队离线处理 for (int i = 1; i &lt;= m; i++) &#123; moveR(r, node[i].r), moveL(l, node[i].l);//莫队算法主体 if (node[i].lca &amp;&amp; vis[op[node[i].lca]] == 0)node[i].ans = ans + 1;//对lca特殊处理 else node[i].ans = ans; &#125; sort(node + 1, node + m + 1, cmp2); for (int i = 1; i &lt;= m; i++)printf("%d\n", node[i].ans); return 0;&#125; 一些处理方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫队算法在移动指针时可以更新答案，但是有时候必须移动完才可以更新答案。为了不TLE，我们需要在$O(\sqrt n)$的复杂度下更新完答案，这样总的时间复杂度为$O(m\sqrt n)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题链接：这里。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次k都不一样，需要移动完指针再更新答案。这里我们的更新策略是：记录出现次数小于$\sqrt n$的数有多少种，而对于大于或等于$\sqrt n$的暴力计数。这样做的好处是前者数量显然不超过$\sqrt n$，后者也不会超过，保证了更新的复杂度。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define MOD 1000000007#define N 100005using namespace std;inline int read() &#123; char e = getchar(); int s = 0, g = 0; while (e &lt; '-')e = getchar(); if (e == '-')g = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return g ? -s : s;&#125;struct Query &#123; int l, r, k, rk; long long ans;&#125; q[N];int n, op[N], tmp[N], m, be[N], vis[N], poi[N][101], vis2[N], base;long long ans, ans0[N];unordered_set&lt;int&gt; ssp;//集合存出现次数大于根号n的数bool cmp1(Query a, Query b) &#123; return be[a.l] != be[b.l] ? be[a.l] &lt; be[b.l] : be[a.r] &lt; be[b.r];&#125;bool cmp2(Query a, Query b) &#123; return a.rk &lt; b.rk;&#125;inline void moveR(int &amp;from, int to) &#123; if (from &lt; to) &#123; ++from; while (from &lt;= to) &#123; --vis2[vis[op[from]]], ++vis2[++vis[op[from]]]; if (vis[op[from]] == base)ssp.insert(op[from]); ++from; &#125; &#125; else if (from &gt; to) &#123; while (from &gt; to) &#123; if (vis[op[from]] == base)ssp.erase(op[from]); --vis2[vis[op[from]]], ++vis2[--vis[op[from]]], --from; &#125; &#125; from = to;&#125;inline void moveL(int &amp;from, int to) &#123; if (from &lt; to) &#123; while (from &lt; to) &#123; if (vis[op[from]] == base)ssp.erase(op[from]); --vis2[vis[op[from]]], ++vis2[--vis[op[from]]], ++from; &#125; &#125; else if (from &gt; to) &#123; --from; while (from &gt;= to) &#123; --vis2[vis[op[from]]], ++vis2[++vis[op[from]]]; if (vis[op[from]] == base)ssp.insert(op[from]); --from; &#125; &#125; from = to;&#125;int main() &#123; for (register int i = 1; i &lt;= 100000; i++) &#123; poi[i][0] = 1; for (register int j = 1; j &lt;= 100; j++)poi[i][j] = 1ll * poi[i][j - 1] * i % MOD; &#125; int qt = read(); while (qt--) &#123; n = read(), m = read(), ssp.clear(); memset(vis, 0, sizeof(vis)), memset(vis2, 0, sizeof(vis2)); for (int i = 1; i &lt;= n; i++)tmp[i] = op[i] = read(); int sb; sort(tmp + 1, tmp + n + 1), sb = unique(tmp + 1, tmp + n + 1) - tmp - 1; for (int i = 1; i &lt;= n; i++)op[i] = lower_bound(tmp + 1, tmp + sb + 1, op[i]) - tmp; for (register int i = 1; i &lt;= m; i++)q[i].l = read(), q[i].r = read(), q[i].k = read(), q[i].rk = i; base = sqrt(n); for (register int i = 1; i &lt;= n; i++)be[i] = (i - 1) / base + 1; sort(q + 1, q + m + 1, cmp1); int l = 1, r = 1; vis[op[1]] = 1, vis2[1] = 1; for (register int i = 1; i &lt;= m; i++) &#123; moveR(r, q[i].r), moveL(l, q[i].l), ans = 0; for (int j = 1; j &lt; base; j++)ans = (ans + vis2[j] * 1ll * poi[j][q[i].k]) % MOD; for (int sp:ssp)ans = (ans + poi[vis[sp]][q[i].k]) % MOD; ans0[q[i].rk] = ans; &#125; for (register int i = 1; i &lt;= m; i++)printf("%lld\n", (ans0[i] % MOD + MOD) % MOD); &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文末补充洛谷P1972正解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法仍然是离线。将所有询问按右结点升序排列，用树状数组维护最右侧某个数出现的第一个位置，使该位置+1，答案就是树状数组的区间和。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define N 500005using namespace std;int last[1000005];int tree[N], n, m, op[N];struct Node &#123; int l, r, rk, ans; bool operator&lt;(Node x) &#123; return r &lt; x.r; &#125;&#125; node[N];bool cmp(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;inline void add(int x, int y) &#123; for (int i = x; i &lt;= n; i += (i &amp; -i))tree[i] += y;&#125;inline int sum(int x) &#123; int s = 0; for (int i = x; i &gt;= 1; i -= (i &amp; -i))s += tree[i]; return s;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; last[op[i]] = -1; &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; i++)cin &gt;&gt; node[i].l &gt;&gt; node[i].r, node[i].rk = i; sort(node + 1, node + m + 1); for (int i = node[1].r; i &gt;= 1; i--)if (last[op[i]] == -1)last[op[i]] = i, add(i, 1); node[1].ans = sum(node[1].r) - sum(node[1].l - 1); for (int i = 2; i &lt;= m; i++) &#123; for (int j = node[i].r; j &gt; node[i - 1].r; j--) &#123; if (last[op[j]] == -1)last[op[j]] = j, add(j, 1); else if (last[op[j]] &lt;= node[i - 1].r)add(last[op[j]], -1), last[op[j]] = j, add(j, 1); &#125; node[i].ans = sum(node[i].r) - sum(node[i].l - 1); &#125; sort(node + 1, node + m + 1, cmp); for (int i = 1; i &lt;= m; i++)cout &lt;&lt; node[i].ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[替罪羊树]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;替罪羊树是博客里提到的第三种平衡树，前两种分别是Splay和Treap（含fhq Treap）。它更易写，也容易理解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;替罪羊树的目的同样是使树尽可能平衡，它的思路很简单粗暴：当某棵树不平衡时，拍掉重建。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国际惯例，先看结点结构体定义：1234struct Node &#123; int size, ch[2], v, s, num;&#125; node[500005]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有很多已经熟悉的变量，只是多了一个size。size记录子树中的有效结点数目，下文会提到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么会有有效结点这种说法呢？替罪羊树中删除某个结点，并不是直接删除，而是打上标记（即允许s=0的结点存在）。此时这个结点就是无效结点，不能计入size。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;何为拍掉重建？首先需要知道如何判定一棵树已经不平衡，这就需要引入平衡因子的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当左子树的size或着右子树的size大于整棵树的size乘以平衡因子时，我们认为这棵树不平衡。很明显左子树size和右子树size中一定有一个不小于整棵树size的一半，即平衡因子至少为0.5，而最大显然为1。平均来看，我们取平衡因子为0.75，记alpha=0.75。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update定义：1234void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s; node[x].size = node[node[x].ch[0]].size + node[node[x].ch[1]].size + (node[x].s &gt; 0);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检验函数：123bool check(int x) &#123; return node[node[x].ch[0]].size &gt; node[x].size * alpha || node[node[x].ch[1]].size &gt; node[x].size * alpha;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何重建？首先对树进行一次中序遍历，记得要剔除所有无效结点，将遍历编号序列存在数组中。然后新树的树根就是这个序列的中点，两棵子树递归进行，易知这样建树符合BST定义。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中序遍历代码：123456void serach(int x) &#123; if (x == 0)return; serach(node[x].ch[0]); if (node[x].s &gt; 0)temp[++ct] = x; serach(node[x].ch[1]);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重建函数：1234void rebuild(int &amp;x) &#123;//引用！！因为要修改值 ct = 0, serach(x); solve(x, 1, ct);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve就是负责建树的递归函数，这里记得传进来的x是引用。1234567891011void solve(int &amp;x, int l, int r) &#123;//引用！！ if (r &lt; l) &#123; x = 0; return; &#125; int mid = (l + r) / 2; x = temp[mid]; solve(node[x].ch[0], l, mid - 1); solve(node[x].ch[1], mid + 1, r); update(x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入元素与BST基本相同：123456789101112void insert(int &amp;x, int y) &#123;//仍然是引用，与treap的思想类似 if (x == 0) &#123; x = ++cnt;//新建一个点 node[x].v = y, node[x].s = node[x].size = node[x].num = 1, node[x].ch[0] = node[x].ch[1] = 0; return; &#125; if (node[x].v == y)node[x].s++;//直接更新 else if (node[x].v &lt; y)insert(node[x].ch[1], y); else insert(node[x].ch[0], y); update(x);//更新信息 if (check(x))rebuild(x);//重建&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除函数：12345678void del(int &amp;x, int y) &#123;//也是引用 if (x == 0)return; if (node[x].v &lt; y) del(node[x].ch[1], y); else if (node[x].v &gt; y)del(node[x].ch[0], y); else node[x].s--;//不需要检验s&gt;1，s=0就意味着这个点无效 update(x);//更新 if (check(x))rebuild(x);//重建&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找排名和根据排名找元素与Splay和Treap都相同，但是求前驱后继的方法有所不同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于无效结点的存在，无法判定前驱后继究竟在左子树上还是右子树上（以往是确定的，但替罪羊树上可能某一侧全部是无效结点），这就造成了麻烦。在替罪羊树中，可以用下面的思路求前驱和后继： 求x的前驱：插入x，找到x的排名p，删掉x，找到排名p-1的值即为前驱。 求x的后继：插入x+1，找到x+1的排名p，删掉x+1，找到排名p的值即为后继。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个算法很容易理解，代码如下：12345678910111213int preNum(int x) &#123; insert(root, x); int p = findRank(x); del(root, x); return findNum(p - 1);&#125;int nextNum(int x) &#123; insert(root, x + 1); int p = findRank(x + 1); del(root, x + 1); return findNum(p);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下附模板题AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;const double alpha = 0.75;struct Node &#123; int size, ch[2], v, s, num;&#125; node[500005];int root = 0, cnt = 0, ct = 0, temp[100005];void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s; node[x].size = node[node[x].ch[0]].size + node[node[x].ch[1]].size + (node[x].s &gt; 0);&#125;bool check(int x) &#123; return node[node[x].ch[0]].size &gt; node[x].size * alpha || node[node[x].ch[1]].size &gt; node[x].size * alpha;&#125;void serach(int x) &#123; if (x == 0)return; serach(node[x].ch[0]); if (node[x].s &gt; 0)temp[++ct] = x; serach(node[x].ch[1]);&#125;void solve(int &amp;x, int l, int r) &#123; if (r &lt; l) &#123; x = 0; return; &#125; int mid = (l + r) / 2; x = temp[mid]; solve(node[x].ch[0], l, mid - 1); solve(node[x].ch[1], mid + 1, r); update(x);&#125;void rebuild(int &amp;x) &#123; ct = 0, serach(x); solve(x, 1, ct);&#125;void insert(int &amp;x, int y) &#123; if (x == 0) &#123; x = ++cnt; node[x].v = y, node[x].s = node[x].size = node[x].num = 1, node[x].ch[0] = node[x].ch[1] = 0; return; &#125; if (node[x].v == y)node[x].s++; else if (node[x].v &lt; y)insert(node[x].ch[1], y); else insert(node[x].ch[0], y); update(x); if (check(x))rebuild(x);&#125;void del(int &amp;x, int y) &#123; if (x == 0)return; if (node[x].v &lt; y) del(node[x].ch[1], y); else if (node[x].v &gt; y)del(node[x].ch[0], y); else node[x].s--; update(x); if (check(x))rebuild(x);&#125;inline int findNum(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[node[cur].ch[0]].num &gt;= x)nxt = node[cur].ch[0]; else if (x &gt; node[node[cur].ch[0]].num &amp;&amp; x &lt;= node[node[cur].ch[0]].num + node[cur].s) &#123; return cur; &#125; else nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + node[cur].s; if (nxt != 0)cur = nxt; else break; &#125; return -1;&#125;inline int findRank(int x) &#123; int cur = root, nxt = 0, ans = 0; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1], ans += node[cur].num - node[nxt].num; else if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; return ans + 1;&#125;inline int preNum(int x) &#123; insert(root, x); int p = findRank(x); del(root, x); return findNum(p - 1);&#125;inline int nextNum(int x) &#123; insert(root, x + 1); int p = findRank(x + 1); del(root, x + 1); return findNum(p);&#125;int main() &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int opt, x; cin &gt;&gt; opt &gt;&gt; x; if (opt == 1)insert(root, x); else if (opt == 2)del(root, x); else if (opt == 3)cout &lt;&lt; findRank(x) &lt;&lt; endl; else if (opt == 4)cout &lt;&lt; node[findNum(x)].v &lt;&lt; endl; else if (opt == 5)cout &lt;&lt; node[preNum(x)].v &lt;&lt; endl; else cout &lt;&lt; node[nextNum(x)].v &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FHQ Treap]]></title>
    <url>%2F2019%2F03%2F03%2FFHQTreap%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍fhq Treap的相关内容，是Treap（树堆）的延伸。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外本文仅涉及普通平衡树和文艺平衡树的内容，暂不涉及可持久化平衡树，关于可持久化会有单独的文章（以后更新）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fhq Treap是非旋的树堆，具有易实现，功能强大的优点，支持可持久化和文艺平衡树操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fhq Treap中允许有相同权值的两个结点，因此每个结点不再有标记数量的s，也可以理解成每个结点的s一定为1。此时BST可以定义为左子树结点的值都不大于该结点，右子树都不小于该结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇文章中提到了Treap（树堆）的原理：利用优先级的随机性来保持树结构的随机性。fhq Treap是非旋的树堆，它自然没有旋转操作，而有另外的两个核心操作：分离（split）和合并（merge）。 分离操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分离是指将一个treap分成两个treap，常用的分离标准有两种：按值分离和按数量分离。 按值分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按值分离常常用于普通平衡树（普通平衡树就是上一篇文章提到的那些操作）。给定一个值val，需要将treap分离成两个，其中一个树中所有点权值都不大于val（称树a），另一个全都大于val（称树b）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如现在需要分离以rt结点为根的treap，分离后的treap的根是a和b（a和b一开始是未赋值的）。如果rt的权值不大于val，说明rt结点应该在树a中，容易知道rt结点的左子树也应该在树a中，那么不妨将rt作为树a的根结点。此时rt结点及其左子树已经得到了“归属”，下面的问题就是求树b的根，求树a的右子树，于是继续分离rt结点的右子树，这是一个递归过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是就可以得到下面的分离代码：123456789void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123;//不需分离时，a和b都是空树 a = b = 0; return; &#125; if (node[rt].v &lt;= v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是分离的函数实现，注意最后需要更新rt的num。split函数巧妙地利用了引用使得代码十分优雅。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出分离过程不会破坏BST的性质和堆的性质。 按数量分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定数量v，将treap中前v小的数分离到树a中，其余分离到树b中，这就是按数量分离。为什么还要学按数量分离呢？因为这是文艺平衡树的关键实现原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和按值分离原理类似。假设现在需要分离以rt为根的treap，如果rt左子树的结点数量（由于s为1，故结点数量就是数的数量）小于v，那么易知rt结点及其左子树都应该分到树a中，然后进行递归分离。如果左子树结点数量不小于v，那么rt结点及其右子树应该分到树b中。123456789void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; if (node[node[rt].ch[0]].num &lt; v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v - node[node[rt].ch[0]].num - 1); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一处需要注意：在分离右子树时，v需要进行更新。 合并操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;合并操作就是将树a和树b合并为一个treap，合并操作有一个前提：树a中的所有值不能大于树b中的值。无论采用按值分离方法还是按数量分离方法都是满足这个条件的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于树b上的数一定不小于树a，那么也不小于树a的根结点，那么合并a和b的问题就是把b合并到a的右子树上。当然也可以选择把a合并到b的左子树上，这于是就是一个递归问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择任何一个都可以吗？显然不是，因为还要满足堆的性质。两棵树都是满足堆的性质的，此时如果树a的根节点优先级更高，则应合并a的右子树和b，否则合并b的左子树和a。123456789void merge(int &amp;rt, int a, int b) &#123;//rt是合并后的树根 if (a == 0 || b == 0) &#123;//其中任何一个为0直接赋值即可 rt = a + b;//赋值不为0的那一个，这是一处巧妙的写法 return; &#125; if (node[a].key &gt; node[b].key)rt = a, merge(node[rt].ch[1], node[a].ch[1], b); else rt = b, merge(node[rt].ch[0], a, node[b].ch[0]); update(rt);&#125; 插入元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了split和merge就可以很容易地实现插入、删除操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要插入值为val的点，需要先新建一个值为val的点，假设新结点编号为p。在原treap上按val的值进行分离，分离成不大于val的treap和大于val的treap，然后合并树a和p，再合并树a和树b即可。1234567891011int addNode(int x) &#123;//分配新结点编号 node[++cnt].v = x, node[cnt].ch[0] = node[cnt].ch[1] = 0; node[cnt].num = 1, node[cnt].key = rand(); return cnt;&#125;void insert(int x) &#123;//插入元素 int p = addNode(x), a, b; split(root, a, b, x); merge(a, a, p); merge(root, a, b);&#125; 删除元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将原treap按val值分离成树a和树b，再将树a按值val-1分离成树c和树d。这样树d就是由全体val值结点组成的，合并树d的左子树和右子树（相当于删除根结点），再与树c和树b合并即可。12345678void delNum(int x) &#123; int a, b, c;//这里没有建变量d，为了重用变量 split(root, a, b, x);//分离root产生树a和树b split(a, a, c, x - 1);//分离a产生a和c（重用变量a） merge(c, node[c].ch[0], node[c].ch[1]);//合并c的左右子树到c中 merge(a, a, c);//将c合并到a中 merge(root, a, b);//将a、b合并到root中&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后的操作（如查找前驱后继等等）与普通treap相比没有变化。这里提供一种递归版求解方法，更加优雅：1234567891011121314151617181920212223int findRank(int rt, int x) &#123;//查找排名 if (rt == 0)return 1; if (node[rt].v &lt; x)return node[node[rt].ch[0]].num + 1 + findRank(node[rt].ch[1], x); return findRank(node[rt].ch[0], x);&#125;int findNum(int rt, int x) &#123;//根据排名找数 if (node[node[rt].ch[0]].num + 1 == x)return node[rt].v; if (node[node[rt].ch[0]].num + 1 &lt; x)return findNum(node[rt].ch[1], x - node[node[rt].ch[0]].num - 1); return findNum(node[rt].ch[0], x);&#125;int findPre(int rt, int x) &#123;//查找前驱 if (rt == 0)return -0x7fffffff; if (node[rt].v &gt;= x)return findPre(node[rt].ch[0], x); return max(findPre(node[rt].ch[1], x), node[rt].v);&#125;int findNext(int rt, int x) &#123;//查找后继 if (rt == 0)return 0x7fffffff; if (node[rt].v &lt;= x)return findNext(node[rt].ch[1], x); return min(findNext(node[rt].ch[0], x), node[rt].v);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍fhq Treap的另一个功能：文艺平衡树。有洛谷模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓文艺平衡树就是实现这样一个功能：给定一个区间，不断翻转其中的某一段子区间，求最后的区间序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们需要翻转[l,r]区间时，首先按数量分离原有treap，分离成[1,l-1]、[l,r]、[r+1,n]三段区间，然后给[l,r]打上翻转标记，再将它们合并。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;翻转标记如同线段树中的lazy标记，表示以这个点为根的树需要翻转，该标记仅有0和1两种取值。它同时也有down函数来完成下压标记操作：123456inline void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]);//交换左右子树 node[node[x].ch[0]].lazy ^= 1;//打上标记 node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;//清空标记&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样我们的split和merge函数也应该带上下压操作：12345678910111213141516171819202122232425void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].lazy)down(rt);//下压标记 if (node[node[rt].ch[0]].num &lt; v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v - node[node[rt].ch[0]].num - 1); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (node[a].key &gt; node[b].key) &#123; if (node[a].lazy)down(a);//下压标记 rt = a, merge(node[a].ch[1], node[a].ch[1], b); &#125; else &#123; if (node[b].lazy)down(b);//下压标记 rt = b, merge(node[b].ch[0], a, node[b].ch[0]); &#125; update(rt);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了：交换左右子树难道不会违反BST性质？答案是肯定会违反的，但我们应该从一个更高的高度去理解BST。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BST左子树权值不大于该结点实质上是左子树结点的权重不大于该结点，权值不一定代表权重。因此翻转左右子树实质上就是认为左右结点的权重发生了调换。我们的merge函数和按数量分离的split函数不会改变原有的权重关系，而不是权值关系，因此翻转后再进行split或者merge等操作并不会影响翻转的结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但容易看出，按值分离函数是按照权值关系进行的，所以在文艺平衡树进行中不能有按值分离操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出最后的结果相当容易，只需一次中序遍历即可，记得下压标记：1234567void print(int x) &#123; if (!x)return; if (node[x].lazy)down(x); print(node[x].ch[0]); cout &lt;&lt; node[x].v &lt;&lt; " "; print(node[x].ch[1]);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩展：洛谷模板题中原有的序列是1~n，这个序列很特殊以至于我们可以先插入这几个元素再按文艺平衡树进行操作。但是如果原有序列是随机的呢？由于插入操作需要按值分离split函数，这个函数基于权值关系，插入后原有序列关系就被打乱了。洛谷模板题之所以可以直接插入是因为权值正好就是权重。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种方法是构造1~n到原有序列的映射，再将1~n插入treap中，进行区间操作，输出时映射回来即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下附洛谷模板题AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; int ch[2], v, num, key, lazy; Node() : num(0) &#123; lazy = ch[0] = ch[1] = 0; &#125;&#125; node[100005];int root = 0, cnt = 0;inline void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + 1;&#125;inline int addNode(int x) &#123; node[++cnt].v = x, node[cnt].ch[0] = node[cnt].ch[1] = 0; node[cnt].num = 1, node[cnt].key = rand(); return cnt;&#125;inline void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].lazy ^= 1; node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;&#125;void split(int rt, int &amp;a, int &amp;b, int v) &#123;//按数量分离 if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].lazy)down(rt); if (node[node[rt].ch[0]].num &lt; v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v - node[node[rt].ch[0]].num - 1); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (node[a].key &gt; node[b].key) &#123; if (node[a].lazy)down(a); rt = a, merge(node[a].ch[1], node[a].ch[1], b); &#125; else &#123; if (node[b].lazy)down(b); rt = b, merge(node[b].ch[0], a, node[b].ch[0]); &#125; update(rt);&#125;void solve(int l, int r) &#123;//翻转函数 int a, b, c; split(root, a, b, l - 1); split(b, b, c, r - l + 1); node[b].lazy ^= 1; merge(a, a, b), merge(root, a, c);&#125;void split2(int rt, int &amp;a, int &amp;b, int v) &#123;//按值分离 if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].v &lt;= v)a = rt, split2(node[rt].ch[1], node[a].ch[1], b, v); else b = rt, split2(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125;inline void insert(int x) &#123;//插入 int p = addNode(x), a, b; split2(root, a, b, x); merge(a, a, p); merge(root, a, b);&#125;void print(int x) &#123;//输出 if (!x)return; if (node[x].lazy)down(x); print(node[x].ch[0]); cout &lt;&lt; node[x].v &lt;&lt; " "; print(node[x].ch[1]);&#125;int main() &#123; ios::sync_with_stdio(false); srand(static_cast&lt;unsigned int&gt;(time(nullptr))); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)insert(i);//把1~n插入到treap中 for (int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; solve(x, y); &#125; print(root); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>文艺平衡树</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Treap（树堆）]]></title>
    <url>%2F2019%2F03%2F03%2FTreap%EF%BC%88%E6%A0%91%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文是Splay（伸展树）的后续。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍Splay时，已经提及了BST的概念。BST在最坏情况下会达到$O(n)$复杂度，于是有各种使其平衡的方法，Treap就是一种，它也属于平衡树，比Splay要更易实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splay是通过伸展操作来使树的结构随机化，以达到均摊$O(logn)$的复杂度。Treap是通过在维护BST时同时维护堆来实现结构的随机化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓Treap就是Tree+Heap，故称树堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看看Treap的结点结构体定义，和Splay类似：1234567struct Node &#123; int v&#123;&#125;, key&#123;&#125;, ch[2]&#123;&#125;, s, num; Node() : num(0), s(0) &#123; ch[0] = ch[1] = 0; &#125;&#125; node[100005]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没记录父结点？是的，在Treap中不需要记录父结点信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外还可以发现多了一个key，key记录这个结点的优先级。刚才已经提到，Treap是树与堆的结合（这里的堆不再是完全二叉树，只要有堆的性质即可），所谓堆的性质就是：所有结点的优先级不得小于其子结点优先级。这当然是大根堆，用小根堆也是可以的，本文中使用大根堆。我们在维护BST的同时还要满足堆的要求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key应该如何赋值？在插入一个新结点时，会给它分配一个随机的优先值，这个可以通过rand()函数来实现。从这里就可以看出Treap的原理：通过优先级的随机性来保持树结构的随机性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的函数，若无特殊说明，函数都采用与Splay中相同的命名。 旋转操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap中同样有旋转操作。当某结点不满足堆的性质时（比如它的优先级大于父结点），就需要进行一次旋转，将其旋转到父结点的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap中只有左旋和右旋，没有Splay中双旋的概念。1234void rotate(int &amp;x, int w) &#123; int c1 = node[x].ch[w], c2 = node[c1].ch[w ^ 1]; node[x].ch[w] = c2, node[c1].ch[w ^ 1] = x, node[c1].num = node[x].num, update(x), x = c1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面就是旋转函数的定义，它的作用是将编号为x的结点旋转下去，方向为w（1为左旋），这和splay中的旋转上去有所不同。但事实上将子结点旋转上去就是把父结点旋转下来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一些值得注意的细节。一处是node[c1].num = node[x].num，这其实就是update(c1)的简略写法。另外还有x=c1，这里巧妙地使用引用来实现我们在Splay中旋转的第三步。 插入操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap中的插入是基于递归的，代码如下：1234567891011121314151617void insert(int &amp;x, int v) &#123; if (!x) &#123;//空结点，新建结点 x = cnt++; node[x].v = v, node[x].s = 1, node[x].num = 1, node[x].key = rand(); node[x].ch[0] = node[x].ch[1] = 0; return; &#125; node[x].num++;//路过的结点都要更新num if (node[x].v == v)node[x].s++;//找到直接更新s else if (node[x].v &lt; v) &#123;//找右树 insert(node[x].ch[1], v); if (node[node[x].ch[1]].key &gt; node[x].key)rotate(x, 1);//旋转，维护堆的性质 &#125; else &#123;//找左树 insert(node[x].ch[0], v); if (node[node[x].ch[0]].key &gt; node[x].key)rotate(x, 0); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的作用是在以结点x为根的子树上插入值为v的结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当x为0时，说明这里是一个空结点，此时新建结点，更新信息，分配优先级。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，所有经过的结点都需要更新num。其次在递归回溯后需要检查堆的性质是否满足，如果不满足就需要旋转来调整。从这里可以看出引用的技巧性。 删除操作1234567891011121314void del(int &amp;x, int v) &#123; if (!x)return;//空结点无需继续 if (node[x].v == v) &#123;//找到该结点 if (node[x].s &gt; 1) node[x].num--, node[x].s--;//直接更新值 else &#123;//需要删除结点 if (!node[x].ch[0] &amp;&amp; !node[x].ch[1])x = 0;//没有儿子，直接赋值0 else if (!node[x].ch[0])x = node[x].ch[1];//有右儿子，将右儿子移过来 else if (!node[x].ch[1])x = node[x].ch[0];//有左儿子，将左儿子移过来 else if (node[node[x].ch[0]].key &lt; node[node[x].ch[1]].key)rotate(x, 1), del(x, v);//将优先级大的旋转上去，递归 else rotate(x, 0), del(x, v); &#125; &#125; else if (node[x].v &gt; v)node[x].num--, del(node[x].ch[0], v);//找左树 else node[x].num--, del(node[x].ch[1], v);//找右树&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap的删除操作基于分类讨论，有这几种情况（只考虑完全删除的情况，s自减一不考虑）： 若该结点没有儿子，直接删除 若结点仅有右儿子，则左儿子代替其位置。仅有左儿子同理。 若结点有两个儿子，则将优先级大的一个旋转到该结点位置，再递归进行删除。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的一个易错点是每一个经过的结点需要更新num，但是上面的分类讨论中不需要更新，因为上面的分类讨论过程只是更改了一下树的结构。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其余的操作与Splay完全相同。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay（伸展树）]]></title>
    <url>%2F2019%2F03%2F02%2FSplay%EF%BC%88%E4%BC%B8%E5%B1%95%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍Splay树的用法与实现。 二叉排序树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splay本质上是平衡二叉排序树（Binary Sort Tree，BST），是平衡树的一种。因此在了解Splay前必须先了解二叉排序树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉排序树是指满足以下性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于根结点。 若右子树不空，则右子树上所有结点的值均大于根结点。 左右子树也是BST。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出了一个BST的例子：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文的splay中不允许有相同的数，因此每一个结点都有自己的计数变量（在本文中用s表示）来记录这个数的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，BST的左右子树性质不同，因此不能向往常一样把树当图来存，必须基于一定储存结构。这里用结构体来定义树的每一个结点：1234567struct Node &#123; int v, ch[2], s, num, f; Node() : s(0), num(0) &#123; ch[0] = ch[1] = 0; &#125;&#125; node[500005]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v表示该结点表示的数，ch[0]和ch[1]是左右子树根结点编号，s是数的重数，num是该树所有数的总数量（计入重数），f是其父结点编号。然后开一个数组储存这些结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了，BST有什么用呢？如果我们需要不断加入删除数据，不断地询问某个数的排序序号，查找某个数的前驱或者后继等操作，普通的顺序表效率过低，而链表查找效率硬伤，此时我们就需要BST来完成这些工作。平衡的BST可以在$O(logn)$复杂度下完成这些操作，这是容易理解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但如果不平衡呢？当二叉排序树退化成一条链时，各种操作都会退化成$O(n)$复杂度，这是我们不希望看到的，于是就有了各种使BST平衡的方法，Splay就是其中之一。 旋转操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;旋转操作是Splay中很重要的操作。旋转的意思就是：将某个结点移动到其父结点的位置，保持BST性质不变。旋转只是树的结构变形，没有实质性改变。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当目标结点是其父结点的左儿子时，需要右旋（称为Zig操作），若为右儿子，需要左旋（称为Zag操作）。下面以右旋为例探讨旋转规律。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们想把值为3的结点移动到其父结点位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现4比5小，5应该接管以值为4的结点为根的子树，于是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5比3大，将值为5的结点移动下来作值为3的结点的左儿子（父结点变儿子结点）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后以3为值的结点替代原父结点位置：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;旋转完成，这就是一次zig操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论左旋还是右旋，都可以发现旋转分为三步。 父结点接管目标结点反边上的子树。（接管反边是指：若目标结点为左儿子，则接管右子树，右儿子反之）。 父结点作目标结点反边上的子树。 目标结点代替父结点位置（父结点是爷爷结点的什么儿子，目标结点就作什么儿子）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在就来编写实现旋转操作的函数，在这之前先写一个重建父子关系的函数：123void change(int father, int son, int w) &#123; node[father].ch[w] = son, node[son].f = father;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change函数的作用就是让son编号去作father编号结点的w儿子（0为左，1为右）。然后还需要一个判别父子关系的函数：1234int identify(int x) &#123; int f = node[x].f; return node[f].ch[0] == x ? 0 : 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数用来判断编号为x的结点是其父结点的什么儿子。最后需要一个update函数：123void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是更新一下编号为x的结点的num值。由于旋转后结点间关系发生改变，因此需要更新num。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以写出旋转函数：123456void rotate(int x) &#123; if (x == root)return; int f = node[x].f, g = node[f].f, i = identify(x), j = identify(f); change(f, node[x].ch[i ^ 1], i), change(x, f, i ^ 1), change(g, x, j); update(f), update(x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根结点不能旋转。根据三个步骤重建父子关系，然后更新目标结点和父结点的num。这里用i^1来取反边，这是一个技巧，在网络流中也用到了这个技巧。 伸展操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伸展树之所以叫伸展树就是因为伸展。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓伸展，就是将某个结点（本文中称为at）通过一系列旋转移动到另一个结点（称为to）下方（也就是儿子）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果to本身就在at的下方怎么办？在常规的splay操作中不会碰到这种情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要认识到一个问题：如果需要移动到根结点位置怎么办？根结点不是任何结点的儿子，其实从上面的叙述中的确无法做到，因此有个东西叫虚拟根结点，它是根结点的父结点。在本文中，虚拟根结点编号为0，根结点作其右儿子。这样就可以通过移动到虚拟根结点下面来移动到根结点位置了。在后文中可以看到引入虚拟根结点的很多好处。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当at的父结点正好就是to时无需伸展。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若at的爷爷结点正好是to时，一步旋转（zig或zag）就可以做到伸展效果。问题就是其余情况怎么处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当at的子结点性质和其父结点不同时（不同是指at是左儿子而父结点是右儿子或者反之）可以通过两次旋转（zig-zag或者zag-zig）at结点来将其旋转到爷爷结点的位置。这称为之字形旋转。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当at的子结点性质与其父结点相同时，同样两次旋转（zig-zig或者zag-zag）at结点来将其旋转到爷爷结点的位置。这称为一字形旋转。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但实际情况中可以发现，对于一字形旋转，树的结构并没有得到很好的改善。通常我们这样处理一子形旋转的情况：先旋转父结点再旋转at结点。这种用先旋转父结点再旋转子结点来代替旋转两次子结点的操作称为双旋，普通的一子形方法就称为单旋。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以写出伸展操作的函数了：1234567891011void splay(int at, int to = 0) &#123;//to默认为0表示默认移动到根结点 while (node[at].f != to) &#123; int f = node[at].f, g = node[f].f; if (g != to) &#123; if (identify(at) == identify(f))rotate(f);//双旋操作 else rotate(at); &#125; rotate(at); &#125; if (to == 0)root = at;//不要忘记修改根结点&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伸展有什么用呢？可以理解成保持树结构的随机性，也就是在一种平均意义上保持树的平衡。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伸展的另一个作用是更新经过结点的num值，这是旋转时所做的。 插入元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个不用多说，直接看代码就可以：12345678910111213141516void insert(int x) &#123; if (root == 0)change(0, cnt, 1), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, root = cnt++;//无根要建根 else &#123; int cur = root, nxt = 0; while (true) &#123; if (x &gt; node[cur].v)nxt = node[cur].ch[1]; else if (x &lt; node[cur].v)nxt = node[cur].ch[0]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x)node[cur].s++, splay(cur);//已经有了，s直接加一 else if (node[cur].v &gt; x)change(cur, cnt, 0), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); else change(cur, cnt, 1), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt是当出现新结点时的编号计数器，这样每有一个新的点加入都会分配一个新编号。这样导致的一个问题是不能重用空间，但是对于大多数情况空间都是够用的。如果希望重用空间可以选择每次重建根（为什么会多次重建根？因为可能会删元素啊）时重新从1编号，但是这样做一定要记得将已经被删除的结点完全清空（比如子结点编号设成0等等）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次插入元素后都要把已经插入的元素对应结点伸展到根结点以保持结构随机性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么没有看到更新num？伸展的时候顺便更新了，上文已经提到。 查找某数的编号123456789101112131415int find(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x) &#123; splay(cur); return cur; &#125; return -1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易理解，没有返回-1，最后将该结点伸展到根结点。 查找排名为k的数（第k小）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第k小就是指计入重数后的排序为k的数，直接看代码吧：12345678910111213int findNum(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[node[cur].ch[0]].num &gt;= x)nxt = node[cur].ch[0];//找左树 else if (x &gt; node[node[cur].ch[0]].num &amp;&amp; x &lt;= node[node[cur].ch[0]].num + node[cur].s) &#123; splay(cur); return cur; &#125; else nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + node[cur].s;//找右树 if (nxt != 0)cur = nxt; else break; &#125; return -1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数返回的是结点编号，如果没有返回-1。要把最后的结点伸展到根结点。 查询某元素排名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于相同的元素，这里的排名是指最小的排名。123456789101112131415int findRank(int x) &#123; int cur = root, nxt = 0, ans = 0; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1], ans += node[cur].num - node[nxt].num; else if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; splay(cur); return ans + 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码是容易理解的，最后仍然需要伸展。 查找前驱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前驱是指小于某个数中的最大的那一个。值得注意的是该数不一定是已经插入的元素，即使之前没有插入也是可以查找前驱的。12345678910111213int preNum(int x) &#123; int cur = root, nxt = 0, maxn = -0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x) &#123; nxt = node[cur].ch[1]; if (node[cur].v &gt; maxn)maxn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[0];//相等向小了找 if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样只返回编号，没有返回-1。 查找后继12345678910111213int nextNum(int x) &#123; int cur = root, nxt = 0, minn = 0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else if (node[cur].v &gt; x) &#123; nxt = node[cur].ch[0]; if (node[cur].v &lt; minn)minn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[1]; if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和前驱基本相同。 删除操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除是比较麻烦的一个，这里介绍两种实现方式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种：通过前驱和后继删除。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将前驱伸展到根结点然后将后继伸展到根结点（就是前驱）下方（作右儿子），那么待删除结点一定是后继的右儿子并且它没有任何子树。从这个结点上删除即可。如果其s&gt;1那么直接s减去一，否则删除该结点，最后进行一步伸展，还可以顺便更新一下num。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有前驱或后继怎么办？需要手动加入无穷小和无穷大两个数，这样所有数就都有前驱和后继了。12345678int delNum(int x) &#123; if (find(x) == -1)return 0;//没有该数就不能删除，如果保证存在该数，则该句可以忽略以提高效率 int pre = preNum(x), nxt = nextNum(x); splay(pre), splay(nxt, pre);//作伸展 if (node[node[nxt].ch[0]].s &gt; 1)node[node[nxt].ch[0]].s--, splay(node[nxt].ch[0]); else node[nxt].ch[0] = 0, splay(nxt); return 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种方法就是分类讨论。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将待删除结点伸展到根结点，然后分类讨论（只探讨完全删除结点的情况，s自减一的情况不探讨）： 根结点没有子树，直接删除，重置root=0。 根结点有右子树无左子树，将右子树根作为根。仅有左子树相似操作。 既有左子树又有右子树，按照方法一进行（因为这时候该数一定有前驱和后继）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上没有前驱和后继的情况仅有删除最小值最大值的时候才会出现，所以第二种方法常常会比第一种方法多一次splay，效率低一些。12345678910111213141516171819int delNum(int x) &#123; splay(find(x));//默认有该数 if (!node[root].ch[0] &amp;&amp; !node[root].ch[1]) &#123; if (node[root].s &gt; 1)node[root].s--; else root = 0, node[0].ch[1] = 0; &#125; else if (!node[root].ch[0]) &#123; if (node[root].s &gt; 1)node[root].s--; else change(0, node[root].ch[1], 1), root = node[root].ch[1]; &#125; else if (!node[root].ch[1]) &#123; if (node[root].s &gt; 1)node[root].s--; else change(0, node[root].ch[0], 1), root = node[root].ch[0]; &#125; else &#123; int pre = preNum(x), nxt = nextNum(x); splay(pre), splay(nxt, pre); if (node[node[nxt].ch[0]].s &gt; 1)node[node[nxt].ch[0]].s--, splay(node[nxt].ch[0]); else node[nxt].ch[0] = 0, splay(nxt); &#125; return 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推荐洛谷P3369模板题。AC代码就是上面的组合。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splay的操作函数尽量不要用递归写，因为splay操作的存在，递归时树的结构可能发生变化，极易出错。下面给出洛谷AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;iostream&gt;using namespace std;struct Node &#123; int v, ch[2], s, num, f; Node() : s(0), num(0) &#123; ch[0] = ch[1] = 0; &#125;&#125; node[100005];int root = 0, n, cnt;inline int identify(int x) &#123; int f = node[x].f; return node[f].ch[0] == x ? 0 : 1;&#125;inline void change(int t, int s, int w) &#123; node[t].ch[w] = s, node[s].f = t;&#125;inline void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s;&#125;inline void rotate(int x) &#123; if (x == root)return; int f = node[x].f, g = node[f].f, i = identify(x), j = identify(f); change(f, node[x].ch[i ^ 1], i), change(x, f, i ^ 1), change(g, x, j); update(f), update(x);&#125;inline void splay(int at, int to = 0) &#123; while (node[at].f != to) &#123; int f = node[at].f, g = node[f].f; if (g != to) &#123; if (identify(at) == identify(f))rotate(f); else rotate(at); &#125; rotate(at); &#125; if (to == 0)root = at;&#125;inline int find(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x) &#123; splay(cur); return cur; &#125; return -1;&#125;inline int findRank(int x) &#123; int cur = root, nxt = 0, ans = 0; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1], ans += node[cur].num - node[nxt].num; else if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; splay(cur); return ans + 1;&#125;inline int findNum(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[node[cur].ch[0]].num &gt;= x)nxt = node[cur].ch[0]; else if (x &gt; node[node[cur].ch[0]].num &amp;&amp; x &lt;= node[node[cur].ch[0]].num + node[cur].s) &#123; splay(cur); return cur; &#125; else nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + node[cur].s; if (nxt != 0)cur = nxt; else break; &#125; return -1;&#125;inline int preNum(int x) &#123; int cur = root, nxt = 0, maxn = -0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x) &#123; nxt = node[cur].ch[1]; if (node[cur].v &gt; maxn)maxn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[0]; if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125;inline int nextNum(int x) &#123; int cur = root, nxt = 0, minn = 0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else if (node[cur].v &gt; x) &#123; nxt = node[cur].ch[0]; if (node[cur].v &lt; minn)minn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[1]; if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125;inline void insert(int x) &#123; if (root == 0)change(0, 1, 1), node[1].v = x, node[1].s = 1, node[1].num = 1, root = 1, cnt = 2; else &#123; int cur = root, nxt = 0; while (true) &#123; if (x &gt; node[cur].v)nxt = node[cur].ch[1]; else if (x &lt; node[cur].v)nxt = node[cur].ch[0]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x)node[cur].s++, splay(cur); else if (node[cur].v &gt; x)change(cur, cnt, 0), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); else change(cur, cnt, 1), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); &#125;&#125;inline int delNum(int x) &#123; int pre = preNum(x), nxt = nextNum(x); splay(pre), splay(nxt, pre); if (node[node[nxt].ch[0]].s &gt; 1)node[node[nxt].ch[0]].s--, splay(node[nxt].ch[0]); else node[nxt].ch[0] = 0, splay(nxt); return 1;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; insert(-(1 &lt;&lt; 30)), insert(1 &lt;&lt; 30); for (int i = 1; i &lt;= n; i++) &#123; int opt, x; cin &gt;&gt; opt &gt;&gt; x; if (opt == 1)insert(x); else if (opt == 2)delNum(x); else if (opt == 3)cout &lt;&lt; findRank(x) - 1 &lt;&lt; endl; else if (opt == 4)cout &lt;&lt; node[findNum(x + 1)].v &lt;&lt; endl; else if (opt == 5)cout &lt;&lt; node[preNum(x)].v &lt;&lt; endl; else cout &lt;&lt; node[nextNum(x)].v &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新文艺平衡树的splay版本，建议先阅读这篇文章的后半部分，这里其实是它的扩展。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间，需要不断翻转其中某一段子区间，如何用Splay完成这项操作？以洛谷模板题为例。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以先将1~n加入splay，这样splay的中序遍历序列就是原序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加入无穷小点和无穷大点，保证所有值都有前驱和后继。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要翻转[l,r]时，找到排名为l和r+2的两个结点(为什么是l和r+2？不要忘记之前加入了无穷小点！)，这是区间的前驱和后继。将前驱splay到根结点，后继splay到根结点下方，然后后继的左子树就是目标区间，在其根结点上打上翻转标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;翻转标记表明这个树需要翻转，它自然有自己的下压函数：123456void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].lazy ^= 1; node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每当rotate或者通过排名找数时都需要下压标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个疑问：翻转子树难道不会破坏BST性质？从权值的角度讲当然会破坏，但是可以从更高的角度去理解。BST维护的是权重的大小关系，左树权重比右树小。在这里权重就意味着在区间中的位置，从这个角度看，BST的性质没有被破坏。寻找排名为k的数是一个基于权重的算法而非权值，因此这里需要通过排名来寻找结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果洛谷模板题的原始序列是随机的，问题就会更复杂一些。这是因为1~n序列很特殊，它的权值就是权重。我们可以通过一些基于权值的算法（比如insert）来构树，但是对于随机的序列，再用这种方法就不能保证原有的顺序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下附模板题AC代码，注意这里没有s变量，这是因为1~n一定不会重。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; int v, ch[2], f, lazy, num;&#125; node[100005];int cnt, n, m, root, p = 0;void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + 1;&#125;void change(int x, int y, int w) &#123; node[x].ch[w] = y, node[y].f = x;&#125;inline int identify(int x) &#123; return node[node[x].f].ch[0] != x;&#125;inline void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].lazy ^= 1; node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;&#125;void rotate(int x) &#123; if (x == root)return; if (node[x].lazy)down(x); int f = node[x].f, g = node[f].f, w = identify(x), w1 = identify(f); change(f, node[x].ch[w ^ 1], w); change(x, f, w ^ 1); change(g, x, w1); update(x), update(f);&#125;void splay(int at, int to = 0) &#123; while (node[at].f != to) &#123; int f = node[at].f, g = node[f].f; if (g != to) &#123; if (identify(f) == identify(at))rotate(f); else rotate(at); &#125; rotate(at); &#125; if (to == 0)root = at;&#125;void insert(int x) &#123; cnt++, node[cnt].v = x, node[cnt].ch[0] = node[cnt].ch[1] = 0, node[cnt].lazy = 0, node[cnt].num = 1; if (root == 0) &#123; change(0, cnt, 1), root = cnt; return; &#125; int cur = root, nxt; while (true) &#123; if (node[cur].v &lt;= x)nxt = node[cur].ch[1]; else nxt = node[cur].ch[0]; if (nxt == 0)break; else cur = nxt; &#125; if (node[cur].v &lt;= x)change(cur, cnt, 1); else change(cur, cnt, 0); splay(cur);&#125;int findNum(int x) &#123; int cur = root, nxt; while (true) &#123; if (node[cur].lazy)down(cur); if (node[node[cur].ch[0]].num + 1 == x) &#123; splay(cur); return cur; &#125; else if (node[node[cur].ch[0]].num &lt; x)nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + 1; else nxt = node[cur].ch[0]; if (nxt == 0)break; else cur = nxt; &#125; return -1;&#125;void print(int x) &#123; if (x == 0)return; if (node[x].lazy)down(x); print(node[x].ch[0]); if (p &gt;= 1 &amp;&amp; p &lt;= n)cout &lt;&lt; node[x].v &lt;&lt; " "; p++; print(node[x].ch[1]);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; insert(-0x7ffffff), insert(0x7ffffff); for (int i = 1; i &lt;= n; i++)insert(i); for (int i = 1; i &lt;= m; i++) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; l = findNum(l), r = findNum(r + 2); splay(l), splay(r, l); node[node[node[root].ch[1]].ch[0]].lazy ^= 1; &#125; print(root); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>文艺平衡树</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2634]聪聪可可]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%B4%9B%E8%B0%B7P2634-%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以即约分数形式输出这个概率（即“a/b”的形式，其中a和b必须互质。如果概率为1，输出“1/1”）。 输入输出样例Sample input 51 2 11 3 21 4 12 5 3 Sample output 13/25 说明【样例说明】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13组点对分别是(1,1) (2,2) (2,3) (2,5) (3,2) (3,3) (3,4) (3,5) (4,3) (4,4) (5,2) (5,3) (5,5)。【数据规模】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，n≤20000。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难度较低的省选题，考察点分治。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目实质上是求所有距离为3的倍数的点对数目，用点分治求即可，时间复杂度$O(nlog^2n)$。注意点分治时的距离都需要对3取模，这样直接根据距离为0即可判断合法的点对。另外每个点与自身形成的点对也是合法点对。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在操作中需要实现点分治的work函数，这里的work函数可以在线性时间内解决：统计距离为0、1、2的点的数目，再用排列组合来求点对数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出数量来，用欧几里得算法去一下最大公因数输出即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define N 20005using namespace std;struct Edge &#123; int to, next, v;&#125; edge[N * 2];int n, head[N], cnt = 1, vis[N] = &#123;0&#125;, size[N], f[N], minn, root, ans = 0, num[3];inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS(int x, int fa, int p) &#123; size[x] = 1, f[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS(edge[i].to, x, p), size[x] += size[edge[i].to], f[x] = max(f[x], size[edge[i].to]); &#125; f[x] = max(f[x], p - size[x]); if (f[x] &lt; minn)minn = f[x], root = x;&#125;void findRoot(int x, int s) &#123; minn = 0x7fffffff, DFS(x, 0, s);&#125;void DFS2(int x, int fa, int v) &#123; num[(v % 3 + 3) % 3]++; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS2(edge[i].to, x, v + edge[i].v); &#125;&#125;void work(int x, int f, int w) &#123; num[0] = num[1] = num[2] = 0, DFS2(x, 0, 0); if (f == 0)ans += num[0] * (num[0] - 1) / 2 * w + num[1] * num[2] * w; else if (f == 1)ans += num[0] * num[1] * w + num[2] * (num[2] - 1) / 2 * w; else ans += num[0] * num[2] * w + num[1] * (num[1] - 1) / 2 * w;&#125;void divide(int x) &#123; vis[x] = 1, work(x, 0, 1); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (!vis[edge[i].to]) &#123; work(edge[i].to, (6 - 2 * edge[i].v) % 3, -1); findRoot(edge[i].to, size[edge[i].to]); divide(root); &#125; &#125;&#125;int gcd(int x, int y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, (z % 3 + 3) % 3), add(y, x, (z % 3 + 3) % 3); &#125; findRoot(1, n), divide(root); int g = gcd(2 * ans + n, n * n); cout &lt;&lt; (2 * ans + n) / g &lt;&lt; "/" &lt;&lt; n * n / g; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题还有一个更优雅的做法，那就是用树型DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(x,y)表示在以x为根的子树上，经过x并且距离总和对3的模为y的点对路径总数（每一个点对都要求两点互异），那么有状态转移方程： dp(x,y)=\sum^s_{i=1} \{dp[c_i,(y-v(x,c_i))mod\ 3]+\delta_{y,v(x,c_i)}\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$c_1,\cdots ,c_s$是x结点的s个子结点，$v(x,c_i)$是两点连边的边权。$\delta_{i,j}$是克罗内克符号，它在i=j时为1，否则为0。克罗内克符号的作用就是计入父结点与子结点连边本身就成立的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树型DP也需要去重，去重方法与点分治类似。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define N 20005using namespace std;struct Edge &#123; int to, next, v;&#125; edge[N * 2];int n, head[N], cnt = 1, dp[N][3], ans = 0;inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;int gcd(int x, int y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;int DP(int x, int p, int fa) &#123; if (dp[x][p] != -1)return dp[x][p]; dp[x][p] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa)dp[x][p] += DP(edge[i].to, (p - edge[i].v + 3) % 3, x) + (edge[i].v == p ? 1 : 0); &#125; return dp[x][p];&#125;inline void solve(int x, int p, int fa) &#123;//用来去重的函数 if (p == 0)ans -= DP(x, 0, fa) * (DP(x, 0, fa) - 1) / 2 + DP(x, 1, fa) * DP(x, 2, fa) + DP(x, 0, fa); else if (p == 1)ans -= DP(x, 2, fa) * (DP(x, 2, fa) - 1) / 2 + DP(x, 0, fa) * DP(x, 1, fa) + DP(x, 1, fa); else ans -= DP(x, 1, fa) * (DP(x, 1, fa) - 1) / 2 + DP(x, 0, fa) * DP(x, 2, fa) + DP(x, 2, fa);&#125;void DFS(int x, int fa) &#123; ans += DP(x, 0, fa) * (DP(x, 0, fa) + 1) / 2 + DP(x, 1, fa) * DP(x, 2, fa); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa)solve(edge[i].to, (6 - 2 * edge[i].v) % 3, x), DFS(edge[i].to, x); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1, dp[i][0] = dp[i][1] = dp[i][2] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, (z % 3 + 3) % 3), add(y, x, (z % 3 + 3) % 3); &#125; DFS(1, 0); int g = gcd(2 * ans + n, n * n); cout &lt;&lt; (2 * ans + n) / g &lt;&lt; "/" &lt;&lt; n * n / g; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>动态规划</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治]]></title>
    <url>%2F2019%2F02%2F28%2F%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点分治是一类解决树上路径问题的算法，下面以判断树中是否存在长度为k的路径这一问题来介绍点分治算法。点分治是树分治算法的一部分，另一部分是边分治。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是一棵树（边权未标出）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个路径，我们可以把它归结为两类：经过根节点和不经过根节点。对于不经过根节点的路径，总可以找到一个新的根节点使之经过根节点。比如图中EBF这一路径没有经过根节点A，但是它经过了子树的根节点B。因此所有路径都可以归结到第一种（也就是经过根节点），于是可以通过不同根结点来判别各种路径。这里体现了分治的思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面来看看点分治的操作： 确定树根&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们一开始得到的树通常是无根树，即使是有根树也可以发现答案与树根的选取无关。不妨选取一个点为根使得树尽量平衡，递归次数尽量少。这个点显然是树的重心。重心可以通过一遍DFS求出。关于树的重心见这篇文章。 从树根开始进行分治&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里就是点分治的核心了，先来看看代码模板：12345678910void divide(int x) &#123; work();//第一个work vis[x] = 1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to])continue; work();//第二个work findRoot(edge[i].to); divide(root); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该函数中x为现在树的树根编号。vis[x]=1标记该点已经被使用，下面遍历出边。当前函数处理的是经过点x的路径，所以对于出点（也就是子树的树根），我们需要对其进行递归处理（也就是处理经过子树树根的路径），发现这与原树是一个性质的问题，因此可以递归处理：先找重心（这里就相当于对子树重新选根构造）再递归。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样分治会不会重呢？也就是同一条路径被多次处理？答案当然是不会，因为我们的路径处理只是在以该点为根的子树上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个work函数做什么？这就是处理经过点x的路径的函数。此时可能会有疑问：按理说只需要开头有一个work函数处理就可以了，为什么还要对每一个子结点再work一次？后一个work函数并不是子树的递归处理，而是去重。work函数与问题的性质有关，需要自己设计。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来讨论本问题中如何处理work函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本问题中我们需要找有没有长度为k的路径。那么在work函数中先求出所有点（包括本身，路径长当然是0）到根节点x的路径长，然后如果两个互异点的路径长之和等于k，那么就可以判定存在长度为k的路径。求长度需要$O(n)$，互异点枚举需要$O(n^2)$。效率太低如何解决？先在$O(nlogn)$复杂度下对路径长进行排序，然后枚举每一个点进行二分，可以降低时间复杂度为$O(nlogn)$。当然还有更好的解决方法，那就是双指针扫描，时间复杂度$O(n)$，关于该技巧见本文末。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就完了吗？当然不会，还有前面提到的去重操作！注意到上面给出的图中，当处理点A时，若E到A的距离和F到A的距离之和是k，我们会认为这是一条合法的路径，但事实上它有重边，并不合法，因此需要将这条非法边去除。在第一个work函数中肯定无法知晓哪些点对是合法的，哪些是非法的，因此只能通过容斥原理来将非法边去除，这就是第二个work所做的事情。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何在第二个work中统计非法边个数呢？注意到非法点对一定在同一子树中，并且凡是来源于子树B的非法点对（x,y），它们都满足： dict[x]+dict[y]+2v(A,B)=k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(A,B)是A点与B点之间连边的权值。这样我们在B子树中找到距离和（这里的距离就是到B的距离了，需要重求）为k-2v(A,B)的点对数量，再在答案中减去就可以了。由于两个work拥有同样的功能（都是求符合条件的点对数），因此这两个work可以用一个函数去处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出洛谷P3806点分治模板题的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define N 10005using namespace std;struct Edge &#123; int to, next, v;&#125; edge[N * 2];int head[N], vis[N], cnt = 1, n, m, ans[105], a, b, c, root, minn, size[N], f[N], dict[N], cntDFS;int query[105];inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].v = z, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS1(int x, int fa, int num) &#123; size[x] = 1, f[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS1(edge[i].to, x, num), size[x] += size[edge[i].to], f[x] = max(f[x], size[edge[i].to]); &#125; f[x] = max(f[x], num - f[x]); if (f[x] &lt; minn)minn = f[x], root = x;&#125;inline void findRoot(int x, int num) &#123; minn = 0x7fffffff; DFS1(x, 0, num);&#125;void DFS2(int x, int fa, int v) &#123; dict[cntDFS++] = v; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS2(edge[i].to, x, v + edge[i].v); &#125;&#125;int find1(int l, int r, int p) &#123;//(,] if (l + 1 &gt; r)return -1; if (r == l + 1) &#123; if (dict[r] == p)return r; return -1; &#125; int mid = (l + r) &gt;&gt; 1; if (dict[mid] &gt;= p)return find1(l, mid, p); return find1(mid, r, p);&#125;int find2(int l, int r, int p) &#123;//[,) if (l + 1 &gt; r)return -1; if (r == l + 1) &#123; if (dict[l] == p)return l; return -1; &#125; int mid = (l + r) &gt;&gt; 1; if (dict[mid] &lt;= p)return find2(mid, r, p); return find2(l, mid, p);&#125;inline void work(int x, int p, int w) &#123; cntDFS = 1, DFS2(x, 0, 0), sort(dict + 1, dict + cntDFS); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt; cntDFS; j++) &#123; int l = find1(0, j - 1, query[i] - p - dict[j]), r = find2(1, j, query[i] - p - dict[j]); if (l != -1 &amp;&amp; r != -1)ans[i] += (r - l + 1) * w; &#125; &#125;&#125;void divide(int x) &#123; work(x, 0, 1), vis[x] = 1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to])continue; work(edge[i].to, 2 * edge[i].v, -1); findRoot(edge[i].to, size[edge[i].to]), divide(root); &#125;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++)a = read(), b = read(), c = read(), add(a, b, c), add(b, a, c); for (int i = 1; i &lt;= m; i++)query[i] = read(); findRoot(1, n), divide(root); for (int i = 1; i &lt;= m; i++) &#123; if (ans[i] &gt; 0)cout &lt;&lt; "AYE" &lt;&lt; endl; else cout &lt;&lt; "NAY" &lt;&lt; endl; &#125; return 0;&#125; 其它重要的事&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点分治是一个很有用的算法，它将很不好优化的树上点对问题$O(n^2)$的复杂度直接降到$O(nlogn)$。这是如何做到的？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在向子树分治时，我们重新选取了子树的根，将其定为重心，这样可以保证每一次分治后，问题规模减小一半。如果每一次分治处理的时间复杂度为$O(n)$，那么最终复杂度当然是$O(nlogn)$。也正是因为这个原因，如果程序中求重心的部分出现了问题，那么时间复杂度很可能会退化到$O(n^2)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上文点分治中，曾提到一个很重要的divide函数。这个函数在整个过程中会调用$n$次，但是每一次分治后，这个函数处理的问题规模减半，故即使其中再执行$O(n)$的操作，也能够保证时间复杂度。这启示我们：在某一次分治的操作中，只能在该分治子树上进行$O(n)$或者$O(nlogn)$的操作。否则，复杂度会很快退化。这里提出这个问题，一来可以帮助我们选取合适的算法来进行处理，二来可以避免一些玄学TLE。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些时候，我们可能会在divide函数中用memset来清空一些东西。要注意，这是一个非常错误的做法！memset函数会对所有值进行均等的处理，即使问题规模已经减半，那些多余的部分也被memset处理。这样做不会有什么结果上的影响，但是却导致了时间复杂度退化为$O(n^2)$。事实证明，在divide中使用memset会使复杂度严重退化，极容易导致TLE。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里就可以看出点分治降复杂度的本质了：通过合理地划分子树来使问题规模不断减半。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到了双指针扫描法，这其实是一种技巧。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一串数，如何找是否存在某个数对之和为k？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先排序然后枚举二分在$O(nlogn)$下解决当然可以，但我们也可以这样做：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先取两个指针l、r分别指向第一个元素和最后一个元素，然后判断： 若两个指针所指元素之和小于k，l++ 若两个指针所指元素之和大于k，r— 若两个指针所指元素之和等于k，找到答案 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法对于是否存在的问题是很高效的，但计数并不易做到。快速排序中也有双指针的应用。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的直径与重心]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E4%B8%8E%E9%87%8D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍树的直径与重心的性质与求法。 树的直径&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一棵树，该树中最远的两点间距离称为该树的直径。有两种求解方法： 两次搜索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任选一点开始搜索，找到最大距离的点s，再从s开始搜索，找到最大距离的点t。s和t间距离就是树的直径。这种方法只适用与边权非负的情况，证明略。 树型DP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp[x]表示从x开始，向以x为根的子树上前进可以得到的最大距离。有状态转移方程： dp[x]=\max\{dp[y]+v(x,y)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里y是x的子结点，v是边权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样并不能得出最终的结果，因为最长路有可能跨根结点，这时我们需要在DP过程中记录一下答案。注意到在更新dp[x]时（也就是在其下一个子结点之前），dp[x]已经记录了目前的最大长度，这时可以这样更新答案： ans=\max\{ans,dp[x]+dp[y]+v(x,y)\} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两种方法时间复杂度都是$O(n)$，但两次搜索版可以找到路径，DP版不易找。下面给出树型DP的示例代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;struct Edge &#123; int to, next, v;&#125; edge[20000];int head[10000], n, cnt = 1, dp[10000], ans = -1;inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;int DP(int x, int fa) &#123; dp[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to == fa)continue;//防止向父结点回溯 ans = max(ans, dp[x] + DP(edge[i].to, x) + edge[i].v), dp[x] = max(dp[edge[i].to] + edge[i].v, dp[x]); &#125; return dp[x];&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z), add(y, x, z); &#125; DP(1, 0); cout &lt;&lt; ans &lt;&lt; endl;&#125; 树的重心&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是重心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一棵无根树，我们需要选一个点作为根节点将其转化为有根树。如果以某一个点为根可以使得其最大的子树结点数最小，那么这个点称为树的重心。重心可以有多个。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以重心为根可以得到尽可能平衡的有根树，下面是重心的其它性质： 树中所有点到某个点的距离和中，到重心的距离和是最小的。有两个重心时，它们的距离和一样。 把两个树通过一条边相连得到一个新的树，新的树的重心在连接原来两个树的重心的路径上。 把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求重心呢？先随便选一点为根，然后用一遍DFS来在$O(n)$复杂度下求出每一个点的子树结点树和最大子树结点树，更新答案即可。下面用size记录子树结点数，f记录最大结点数。12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;struct Edge &#123; int to, next;&#125; edge[20000];int head[10000], n, cnt = 1, size[10000], f[10000], ans = -1, minn = 0x7fffffff;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS(int x, int fa) &#123; size[x] = 1, f[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to == fa)continue; DFS(edge[i].to, x), size[x] += size[edge[i].to], f[x] = max(f[x], size[edge[i].to]); &#125; f[x] = max(f[x], n - size[x]);//注意！！还要考虑上面的树 if (f[x] &lt; minn)minn = f[x], ans = x;//更新答案，这里只求一个重心&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y), add(y, x); &#125; DFS(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zkw线段树]]></title>
    <url>%2F2019%2F02%2F24%2Fzkw%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：本文不会专门探讨zkw线段树，关于该数据结构见这篇文章。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zkw线段树是不基于递归的线段树，效率在树状数组和递归线段树之间。下面给出可以AC洛谷模板题的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#define N 100005using namespace std;long long tree[N &lt;&lt; 2] = &#123;0&#125;, add[N &lt;&lt; 2] = &#123;0&#125;;int n, m, bit;inline long long read() &#123; char e = getchar(); long long s = 0, k = 0; while ((e &lt; '0' || e &gt; '9') &amp;&amp; e != '-')e = getchar(); if (e == '-')k = 1, e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return k ? -s : s;&#125;inline void build(int x) &#123; for (bit = 1; bit &lt;= x + 1; bit &lt;&lt;= 1); for (int i = bit + 1; i &lt;= bit + x; i++)tree[i] = read(); for (int i = bit - 1; i; i--)tree[i] = tree[i &lt;&lt; 1] + tree[i &lt;&lt; 1 | 1];&#125;inline void modify(int x, long long k) &#123; for (int i = bit + x; i; i &gt;&gt;= 1)tree[i] += k;&#125;inline void modify(int l, int r, long long k) &#123; if (l == r) &#123; modify(l, k); return; &#125; int lNum = 0, rNum = 0, num = 1, s, t; for (s = bit + l - 1, t = bit + r + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1, num &lt;&lt;= 1) &#123; tree[s] += k * lNum, tree[t] += k * rNum; if (~s &amp; 1)add[s ^ 1] += k, tree[s ^ 1] += k * num, lNum += num; if (t &amp; 1)add[t ^ 1] += k, tree[t ^ 1] += k * num, rNum += num; &#125; for (; s; s &gt;&gt;= 1, t &gt;&gt;= 1)tree[s] += lNum * k, tree[t] += rNum * k;&#125;inline long long query(int l, int r) &#123; long long ans = 0; int lNum = 0, rNum = 0, num = 1, s, t; for (s = bit + l - 1, t = bit + r + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1, num &lt;&lt;= 1) &#123; if (add[s])ans += add[s] * lNum; if (add[t])ans += add[t] * rNum; if (~s &amp; 1)ans += tree[s ^ 1], lNum += num; if (t &amp; 1)ans += tree[t ^ 1], rNum += num; &#125; for (; s; s &gt;&gt;= 1, t &gt;&gt;= 1)ans += add[s] * lNum, ans += add[t] * rNum; return ans;&#125;int main() &#123; n = read(), m = read(); build(n); for (int i = 1; i &lt;= m; i++) &#123; long long a, b, c; if (read() == 1)a = read(), b = read(), c = read(), modify(a, b, c); else a = read(), b = read(), cout &lt;&lt; query(a, b) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HLPP算法]]></title>
    <url>%2F2019%2F02%2F24%2FHLPP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍一种求网络流最大流的高效算法：最高标号预流推进算法(HLPP)。这篇文章是网络流的延伸。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法并不是基于增广路的，它的思想是不断进行推流直到除了源点汇点外的点流量平衡，要了解这个算法需要先理解以下几个概念： 额外流：这个点得到但未流出的总流量，存在额外流说明该点没有达到流量平衡。 高度标号：HLPP算法采用的也是分层图思想。它要求结点只能将流推向比它高度小一的结点。这个要求的引入是因为不加限制可能会出现两个点轮番推流最后死循环的局面。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法中允许结点流量不平衡，即流入多于流出，这样的结点称为活动结点。算法中不断将结点中多余的流量推给其余的结点，将活动结点变成非活动结点。如果某个结点无法通过推流变成非活动结点，我们就需要更换其高度标号，这一步称为重贴标签。当所有非汇点源点均为非活动结点时算法结束，得到的就是最大流。普通预留推进算法用队列进行这个过程，但如果将队列换为优先队列（每次取高度最大的结点），就得到效率更高的最高标号预流推进算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是HLPP算法步骤，HLPP算法同样在残量网络上进行。 用BFS算法从汇点开始进行标号（从0开始），这一步与ISAP算法基本相同。 将源点高度标记成n（n为结点数量）。 遍历源点每一条出边，将这些边的容量尽可能地利用，进行最大程度的推流，更新源点与出点的额外流，将其中额外流不为0并且不是源点汇点的结点入队。 不断取优先队列首元素并进行如下操作：遍历所有出边，对出边权值非0并且高度恰好减一的出点进行推流，推流量不得大于边权和额外流，更新两点的额外流和边权，新结点（不为源点汇点时）入队；当遍历完所有出边后若额外流仍存在，进行重新标号：遍历所有边权非0的出边，找到最小出点高度，该点高度更新成最小高度加一，重新入队。 队列为空时结束算法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是几点理解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们第3步进行了源点最大程度的推流，易知最大流不可能多于这些流量，并且这些流量很可能有多余。但不必担心推流过多，这是因为多余的流会逆推回源点。也就是说，源点仅在第三步时向图中“释放了”尽可能多的流量，它们会尽可能多地流向汇点，多余的流量将被回推到源点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将源点高度标记为n（是当时的最高高度）是为了防止过早的回推。我们第三步时的推流是没有高度限制的，如果不修改源点高度可能会导致过早回推，但这些流量不可能再从源点流出（源点只在第3步推流），导致得到的答案往往小于实际答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在任何情况下，源点和汇点都不会入队。这是因为源点在第三步已经完成了推流使命，它只需要等待接收多余的流即可，而汇点根本不需要推流（它本来就是吸收流量的）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这里就可以理解HLPP算法的整体思想了：先尽可能地释放更多的流量，尽可能地推流，多余的推回源点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法又是怎么实现推回源点的呢？当某个结点无法实现推流时，我们会修改它的高度标号以提高它的高度，最终使得这些无法推流的结点高度高于源点的高度n，从而实现回推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法也有GAP优化。我们记录每一个高度对应的结点数量，当某一个高度没有结点（即出现断层时，理解与ISAP算法相同），说明断层两侧的汇点源点不可能再实现联系，这时像ISAP算法一样直接退出算法？并不，虽然断层两侧（源点所在的一侧和汇点所在的一侧）已经不可能有联系，位于源点所在侧的结点不可能再将流推到汇点所在的一侧，但是队列中可能还有能够推到汇点的结点（它们位于汇点所在的一侧），因此算法不能直接结束。那么如何实现优化？既然源点所在的一侧无法再向汇点推流，那么只能向源点逆推，我们不妨将它们其中高度不到n+1的结点的高度标号全部改成n+1，以加快逆推速度。这就是HLPP算法的GAP优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出加强模板题洛谷P4722的HLPP算法代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define inf 0x7fffffffusing namespace std;struct &#123; int to, next; int v;&#125; edge[200005 * 2 + 10000];int head[20000 + 5], cnt = 0, n, m, s, t, h[20000 + 5], gap[20005 * 3] = &#123;0&#125;, vis[20000 + 5];int e[20000 + 5], tree[200005 * 2], size = 0;//下面是堆的部分void solve(int x) &#123; int x1 = 2 * x, x2 = 2 * x + 1, maxnn = x; if (x1 &lt;= size &amp;&amp; h[tree[x1]] &gt; h[tree[maxnn]])maxnn = x1; if (x2 &lt;= size &amp;&amp; h[tree[x2]] &gt; h[tree[maxnn]])maxnn = x2; if (maxnn != x)swap(tree[maxnn], tree[x]), solve(maxnn);&#125;void up(int x) &#123; if (x == 1)return; if (h[tree[x / 2]] &lt; h[tree[x]])swap(tree[x / 2], tree[x]), up(x / 2);&#125;void addHeap(int x) &#123; tree[++size] = x; up(size);&#125;int top() &#123; int t = tree[1]; tree[1] = tree[size--]; solve(1); return t;&#125;//上面是堆的部分int read() &#123;//读入优化 char e = getchar(); int s = 0; while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y, int z) &#123;//加边 edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int HLPP() &#123; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++)h[i] = inf;//高度初始化 h[t] = 0;//汇点为0 Q.push(t); while (!Q.empty()) &#123; int now = Q.front(); Q.pop(); for (int i = head[now]; i != -1; i = edge[i].next) &#123; if (edge[i ^ 1].v &gt; 0 &amp;&amp; h[edge[i].to] == inf)h[edge[i].to] = h[now] + 1, Q.push(edge[i].to);//BFS部分 &#125; &#125; if (h[s] == inf)return 0;//源点高度未更新，说明不连通，返回0 h[s] = n;//更新源点高度 for (int i = 1; i &lt;= n; i++)if (h[i] &lt; inf)++gap[h[i]];//统计结点高度数目 for (int i = head[s]; i != -1; i = edge[i].next) &#123;//源点推流 int d = edge[i].v;//找到这条边的权值 if (d &gt; 0) &#123;//权值大于0 edge[i].v -= d, edge[i ^ 1].v += d, e[s] -= d, e[edge[i].to] += d;//更新额外流和权值，别忘了反边 if (edge[i].to != s &amp;&amp; edge[i].to != t &amp;&amp; !vis[edge[i].to])//入堆 addHeap(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; while (size &gt; 0) &#123;//堆非空时 int now = top(); vis[now] = 0; for (int i = head[now]; i != -1; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; h[edge[i].to] + 1 == h[now]) &#123; int d = min(e[now], edge[i].v);//找到最大推流量 edge[i].v -= d, edge[i ^ 1].v += d, e[now] -= d, e[edge[i].to] += d;//更新 if (edge[i].to != s &amp;&amp; edge[i].to != t &amp;&amp; !vis[edge[i].to])addHeap(edge[i].to), vis[edge[i].to] = 1;//入堆 if (!e[now])break;//推流完成，结束 &#125; &#125; if (e[now]) &#123;//推流未成功，更新标号 if (!--gap[h[now]]) &#123;//如果出现断层 for (int i = 1; i &lt;= n; i++) &#123; if (i != s &amp;&amp; i != t &amp;&amp; h[i] &gt; h[now] &amp;&amp; h[i] &lt; n + 1)//高于h[now]的点（就是断层中源点所在的一侧）更新高度 h[i] = n + 1; &#125; &#125; h[now] = inf; for (int i = head[now]; i != -1; i = edge[i].next) &#123;//更新高度 if (edge[i].v &gt; 0)h[now] = min(h[edge[i].to] + 1, h[now]); &#125; gap[h[now]]++, addHeap(now), vis[now] = 1;//重新入堆 &#125; &#125; return e[t];//汇点额外流就是答案&#125;int main() &#123; n = read(), m = read(), s = read(), t = read(); for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int j = 1; j &lt;= m; j++) &#123; int x, y, z; x = read(), y = read(), z = read(); add(x, y, z), add(y, x, 0); &#125; cout &lt;&lt; HLPP(); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2019%2F02%2F22%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍简单的网络流模型和相关算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定源点s和汇点t，中间有若干条结点做中转，有向边表示转运方向，权值代表最大容量。在这样的图下，汇点最多能够接收到的流量最大值是多少？这就是网络流的最大流问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图就是一个网络流的模型图（来自刘汝佳紫书，有改动）： 网络流最大流问题的三个性质&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一条边，它的最大流量转运上限称为容量（capacity），而这条边上的实际转运量称为流量（flow）。在最大流问题中，有三个基本性质： 容量限制：对于任意一条边(u,v)，总是有f(u,v)≤c(u,v)，即流量不可大于容量。 反对称性：f(u,v)=-f(v,u)。理解：把x个物品从u送到v就是把-x个物品从v送到u，-x可以用来描述有多少流量流到该结点。 流量平衡：对于除了源点和汇点的点，总有$\sum f(u,v)=0$（流入流出均衡）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一种转运方案都需要满足上面三个性质。 残量网络&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出了一种转运方案，红色代表实际流量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易验证，这个流量设置满足前文提到的三个性质，这时汇点总流量为16，但是这不一定是最大流量。将每一条边权值变成容量与实际流量之差，可以得到：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的边权代表“这条边还可以流过多少”，一个很直观的想法是：找到一条从s到t的路径，如果这条路上所有边的边权都大于0，那么总流量还可以加上路径上边权的最小值（注：这种路称为增广路）。比如我们发现走上面的三条边（边权为4、4、8）可以从s走到t，故总流量再加上4成为20，更新网络图，变成：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不断这样找，直到找不到增广路，得到的就是最大流吗？事实证明这种方法是错的。这是因为，我们的思路是尽可能地利用每一条边的价值，让它的流量尽可能地接近容量。因此在某一条边的流量确定时，它的流量就只能只增不降了。比如，按照这个算法，我们不可能让V1-&gt;V3的流量减小（也就是残量增大）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了，我们为什么要让好好的流量减小？让流量尽可能大不是更优吗？这只是直观上的感受，但事实上是错的，比如下面这个图（从网上找的图）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大流显然是沿s-&gt;V1-&gt;t和s-&gt;V2-&gt;t时得到的2。可以发现，V1-&gt;V2的边连用都没用上，如果我们上来就把这条边用了（也就是流量为１），而它不能被减小，就只能得到错误的答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以应该有一个可以将边流量减小（也就是怼回去）的机制。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何解决？方法是给每一条边引入对应的反向边，反向边权值就是正向边已用的流量。上文已经说明反对称性，可以把反向边权值理解成反向的残量（反向走不通，容量为0，而流量为负）。原边（原有的边）权值表示这条路还可以走多少流量，反边权值表示这条路最多可以“反悔”多少流量。走正向边就是给这条边增加流量，走反向边就是给这条边减少流量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给每一条边建立与之对应的反向边，并规定正向边权值为容量与流量之差，反向边权值为正向边流量，就得到了残量网络(residual network)。对于重边，我们可以不将它们合并，得到的结果是一样的。一开始的例子可以建立如下的残量网络：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是有著名的增广路定理： 【增广路定理】当且仅当残量网络中不存在增广路时，此时的流是s-&gt;t的最大流。 EK算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出一个图，我们建立它的残量网络图，不断寻找增广路更新最大流即可。如何寻求增广路？一个方法是BFS，这就是Edmonds-Karp算法（EK算法）。它的思想是不断用BFS找增广路，直到找不到为止。凡是找到一条，立即更新最大流和对应的边权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面有一个小技巧：每找到一条边，立即建立它对应的反向边。将边从0开始标号，那么0和1是一对正向边和反向边，2和3也是一对…这样对于编号为x的边，它对应的反向边编号就是x^1，反向边找正向边也是这种方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出洛谷P3376模板题的EK算法代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[10005], cnt = 0, n, m, b, e, pre[10005], flow[10005], ans = 0;//pre是点的前导边标号queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int BFS() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)pre[i] = -1; pre[b] = 0; que.push(b), flow[b] = 0x7fffffff;//flow是到这个流的最小边权 while (!que.empty()) &#123;//BFS每次只找一个增广路 int f = que.front(); if (f == e)break;//到达汇点，立即结束 que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; pre[edge[i].to] == -1) &#123; pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v), que.push(edge[i].to); &#125; &#125; &#125; if (pre[e] == -1)return -1;//没有增广路 return flow[e];//返回途径的最小权值&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0);//加边，后边是反向边，权值为0 &#125; int increase; while ((increase = BFS()) != -1) &#123;//直到找不到反向边 int p = e; while (p != b) &#123;//回退找路 edge[pre[p]].v -= increase, edge[pre[p] ^ 1].v += increase; p = edge[pre[p] ^ 1].to;//更新边权值：前导边减去流量，对应的反边加上流量 &#125; ans += increase;//更新答案 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Dinic算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现EK算法效率的确不高，原因就在于进行了太多次BFS，每次只找一条增广路。这于是就有了Dinic算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dinic算法基于分层图思想，它的算法步骤是： 从源点开始给图用BFS分层。每一次只能走边权大于0的边，得到到源点的最小边距。（源点层次序号为0） 从源点开始DFS，找到在当前分层图下的所有增广路。在当前分层图下的含义是：只能走边权大于0的边并且出点深度必须为该点深度加一。每找到一条更新权值和流量。 回到第一步继续分层，直到汇点不再与源点连通（也就是没法从源点开始获得汇点深度）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;queue&gt;#define N 10005using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[N], cnt = 0, n, m, b, e, ans = 0, deep[N];queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int DFS(int x, int limit) &#123;//DFS找增广路，x是当前结点编号，limit是目前的最小边权。返回能够得到的流值（就是还可以扩展多少） if (limit == 0 || x == e)return limit;//最小边权为0或者到汇点，不能再继续走，直接返回。 int f, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (deep[edge[i].to] == deep[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123;//深度满足并且出点能够找到的流值非0，这里已经排除掉了权值为0的边 edge[i].v -= f, edge[i ^ 1].v += f, flow += f, limit -= f;//修改限制，flow加上这个分枝的流值 if (!limit)break;//最小值到0，无法再继续 &#125; &#125; return flow;//返回流值&#125;bool BFS() &#123;//用于分层 while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)deep[i] = n;//全部初始化为n deep[b] = 0, que.push(b);//源点入队，深度为0 while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; deep[edge[i].to] == n) &#123; deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); if (edge[i].to == e)return true;//汇点找到，返回true &#125; &#125; &#125; return deep[e] != n;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; ans = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0); &#125; while (BFS())ans += DFS(b, 0x7fffffff);//每一次都加上可以得到的流值 cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dinic算法就比较高效了，它可以AC掉上面提到的网络流模板题。这里还有一个优化：当前弧优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现上面DFS代码中的break条件是limit==0。如果循环成功地进入了下一条边，说明上一条边的limit没有用完！这说明上一条边“费尽全力”地找增广路已经达到了极限，那么从这条边再找就不可能有增广路了。于是这条边应该被“废弃”以提高效率。我们用cur记录应该从哪一条边开始以优化算法，注意每次BFS时应重置cur。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是加入当前弧优化的Dinic算法代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;queue&gt;#define N 10005using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[N], cnt = 0, n, m, b, e, ans = 0, deep[N], cur[N] = &#123;0&#125;;queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int DFS(int x, int limit) &#123; if (limit == 0 || x == e)return limit; int f, flow = 0; for (int i = cur[x]; ~i; i = edge[i].next) &#123;//从cur开始 cur[x] = i;//记录当前的边 if (deep[edge[i].to] == deep[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, flow += f, limit -= f; if (!limit)break; &#125; &#125; return flow;&#125;bool BFS() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)deep[i] = n, cur[i] = head[i];//重置cur deep[b] = 0, que.push(b); while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; deep[edge[i].to] == n) &#123; deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); if (edge[i].to == e)return true; &#125; &#125; &#125; return deep[e] != n;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; ans = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0); &#125; while (BFS())ans += DFS(b, 0x7fffffff); cout &lt;&lt; ans; return 0;&#125; ISAP算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍另一种算法：ISAP算法。这也是一种高效的求最大流的方法。Dinic算法不停地进行BFS重新分层，能不能便DFS边更新深度呢？这就是ISAP算法的思想。它的算法步骤是： BFS分层（这里是从汇点开始），只能走其反向边权值非0的边，相当于逆着正边走，得到深度。 从源点开始找增广路。事实上，我们经常用循环来进行这个过程。每次只能走边权非0并且深度为自身深度减一的出点，走到汇点时更新答案和边权。当该点没有任何合法出点时更新其深度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当源点深度大于或等于n（n为总结点数）时，不存在增广路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新深度的方法：找到该点所有边权非0的出点，在它们的深度中取最小值，那么点深度更新为这个最小值加一。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISAP算法中有一个重要的优化：GAP优化。易知点的深度更新只能让深度不断变大，不可能变小。因此如果深度出现了断层（比如不存在深度为3的点，但是有深度为4和2的点），那么这个断层就不可能接上了（只有某深度为2的点找到一个深度也为2的出点并且边权非0才可能把深度更新成3，然而这种情况不可能发生）。根据我们点前进的顺序（深度递减）可知，源点必然在这个断层的前面，于是源点不可能再走到汇点了，判断出增广路不存在，直接break。这就是GAP优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码不理解就当板子记吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;queue&gt;#define N 10005#define inf 1000000using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[N], cnt = 0, n, m, b, e, ans = 0, deep[N], cur[N] = &#123;0&#125;, pre[N] = &#123;0&#125;, num[N] = &#123;0&#125;;queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;inline void BFS() &#123;//判深度 for (int i = 1; i &lt;= n; i++)deep[i] = n, cur[i] = head[i]; que.push(e), deep[e] = 0; while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i ^ 1].v &gt; 0 &amp;&amp; deep[edge[i].to] == n)deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); &#125; &#125;&#125;int maxFlow() &#123;//最大流统计 int flow = inf, p = e; while (p != b) &#123; flow = min(flow, edge[pre[p]].v), p = edge[pre[p] ^ 1].to; &#125; p = e; while (p != b) &#123; edge[pre[p]].v -= flow, edge[pre[p] ^ 1].v += flow, p = edge[pre[p] ^ 1].to; &#125; return flow;&#125;inline void ISPA() &#123; int now = b; BFS(); for (int i = 1; i &lt;= n; i++)num[deep[i]]++;//深度数量统计 while (deep[b] &lt; n) &#123; if (now == e) &#123;//找到一条增广路 ans += maxFlow();//更新 now = b;//回到源点再找 &#125; bool flag = false; for (int i = cur[now]; ~i; i = edge[i].next) &#123; if (deep[edge[i].to] == deep[now] - 1 &amp;&amp; edge[i].v &gt; 0) &#123; flag = true, cur[now] = i, pre[edge[i].to] = i, now = edge[i].to; break; &#125; &#125; if (!flag) &#123;//没有合法出点，更新深度 int minn = n; for (int i = head[now]; ~i; i = edge[i].next)if (edge[i].v &gt; 0)minn = min(minn, deep[edge[i].to]); num[deep[now]]--; if (num[deep[now]] == 0)break;//GAP优化！！ deep[now] = minn + 1, num[deep[now]]++, cur[now] = head[now];//更新cur if (now != b)now = edge[pre[now] ^ 1].to;//更新完深度，回退到这个点的前继，源点不用回退。 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; ans = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0); &#125; ISPA(); cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出了最大流，怎么得到最佳方案？通过每一条原边（所有偶数边）的权值代表残量（也可以反向边直接得出流量），然后就可以得到最优时的流量分配方案了。 最小割问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将网络流分成两个不相交点集S、T，使得s（源点）在S中，t（汇点）在T中。断开连接起点在S中终点在T中的所有原边，这时s和t不再连通，称这样的集合划分为一个割。割的容量定义为被断开边的容量之和，求最小割是一个与最大流联系紧密的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有定理： 【最小割最大流定理】最小割容量等于最大流。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样我们就可以求最小割容量了，但是如何求最小割呢？EK算法结束时，我们得到了很多flow，它们当中大于0的点就是S集，剩下的是T集。注意这种方法要求在每次BFS前要清空一下flow（全部初始化成0）。Dinic算法和ISAP算法的方案求法待以后更新。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个待验证的假说：求完最大流之后边权变为0的原边就是被割掉的边。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最小割点数量也是经典问题，但是最小割最大流定理只适用于割边。我们可以将每一个点分成两个点，一个连接点的入边，另一个连接点的出边，并在两点间加一条容量为1的边（注意源点和汇点中间边的边权为无穷大，因为通常不能割这两个点），这样就把割点问题转化为割边问题。 费用流问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在原有图的基础上加入“费用”，总费用为单位费用乘以这条边的流量。得到最大流的方案很多，但是其中有一种花费最少。最小费用最大流问题也是一类重要问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法是将EK算法中的BFS改成SPFA，根据最短路径（将费用看成边权）来找增广路。它和普通的EK算法相比，有以下几点区别： 边的属性增加了一个费用，反边的费用是正边的相反数 普通EK算法的BFS中，pre一旦确定便不再改变。但费用流下需要改变。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样优先选择最短路增广，得到的一定是最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出EK算法费用流问题的模板代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct &#123; int to, next, v, price;&#125; edge[100000 * 2];int head[10005], cnt = 0, n, m, b, e, pre[10005], flow[10005], ans = 0, dict[10005], vis[10005], minCost = 0;queue&lt;int&gt; que;inline void add(int x, int y, int z, int p) &#123; edge[cnt].price = p, edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int SPFA() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)flow[i] = dict[i] = 0x7ffffff, vis[i] = 0, pre[i] = -1;//初始化 pre[b] = -1, vis[b] = 1, dict[b] = 0, que.push(b); while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].price) &#123;//注意：这里没有要求pre[edge[i].to]==-1的限制，因为前导边需要根据最短路径的改变而改变 dict[edge[i].to] = edge[i].price + dict[f]; pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v); if (vis[edge[i].to] == 0)que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; if (pre[e] == -1)return -1; return flow[e];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w, p; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; p; add(u, v, w, p), add(v, u, 0, -p); &#125; int increase; while ((increase = SPFA()) != -1) &#123; int p = e; while (p != b) &#123; edge[pre[p]].v -= increase, edge[pre[p] ^ 1].v += increase; p = edge[pre[p] ^ 1].to; &#125; ans += increase; minCost += increase * dict[e];//加上费用 &#125; cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; minCost; return 0;&#125; zkw费用流&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了EK+SPFA的费用流算法，还有另一种算法比较常用，那就是zkw费用流算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EK+SPFA是EK算法的修改版，每次只进行一次增广，效率比较低下。这里可以借鉴Dinic的多次增广思路得到zkw费用流算法，它在一些情况下比EK+SPFA更高效。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zkw费用流很像Dinic算法。它将BFS改成SPFA并修改了标号过程，代码如下：123456789101112131415inline bool SPFA() &#123; for (int i = 1; i &lt;= n; i++)vis[i] = 0, dict[i] = 0x7fffffff; que.push(t), dict[t] = 0, vis[t] = 1;//与Dinic不同的是，zkw费用流反向编号，即从汇点开始 while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i ^ 1].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i ^ 1].price) &#123;//走反边 dict[edge[i].to] = dict[f] + edge[i ^ 1].price; if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; return dict[s] != 0x7fffffff;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按道理，DFS过程就应该修改成：1234567891011int DFS(int x, int limit) &#123; if (x == t || limit == 0)return limit; int f, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (dict[edge[i].to] == dict[x] - edge[i].price &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, limit -= f, flow += f, ans += f * edge[i].price;//ans记答案 if (limit == 0)break; &#125; &#125; return flow;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做没什么错，只是会导致DFS递归次数过多，可能会RE或MLE。为解决这个问题，我们在DFS时规定每一个点只能遍历一次，这样就可以得到下面的代码：123456789101112131415int DFS(int x, int limit) &#123; if (x == t || limit == 0) &#123; vis[x] = 1; return limit; &#125; int f, flow = 0; vis[x] = 1;//用vis数组标记已被访问 for (int i = head[x]; ~i; i = edge[i].next) &#123; if (vis[edge[i].to] == 0 &amp;&amp; dict[edge[i].to] == dict[x] - edge[i].price &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, limit -= f, flow += f, ans += f * edge[i].price; if (limit == 0)break; &#125; &#125; return flow;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和Dinic相同，在主函数中，这样去用：1while (SPFA()) flow += DFS(s, 0x7fffffff); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为进一步提高效率，可以使用下面的方式：1234while (SPFA()) &#123; do memset(vis, 0, sizeof(vis)), flow += DFS(s, 0x7fffffff); while (vis[t]);&#125; 最大流与二分图匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前的博客提到了二分图匹配的匈牙利算法，其实这种问题可以用网络流解决。 二分图最大基数匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图不带权值，只是单纯的匹配，既可以用网络流也可以用匈牙利算法解决。对于二分图的两个点集A、B，我们建立起点在A中，终点在B中的有向边，权值均为1（这里相当于改造原二分图）；再建立一个源点s，指向所有A中的点，权值为1，建立汇点t，所有B中的点都指向t，权值也为1。在这个图上求得的最大流就是最大匹配数。 二分图最大权完美匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图带权值，需要找到权值和最大的匹配方案，完美匹配是指所有点都需要被匹配进去，这时匈牙利算法便不再适用了。这种问题可以用费用流解决：将原图的费用设置成权值的相反数，其余我们自己加的边费用设为0，求最小费用最大流即可。显然最小费用的相反数就是最大权值。如果从源点s出发的点不是全部满载，则完美匹配不存在，否则原图中流量为1的边为最佳匹配边。 二分图最大权匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要求完美匹配时（即对匹配数不要求）也可以用费用流解决。引入一个新结点P，所有A集合上的点增加一条指向P的边，容量为1，费用为0，同时P引一条边指向汇点t，容量无穷大，费用为0。建完图后求最小费用最大流。这样最大流一定是A中点的个数，但我们给了每个点一个不走B集合点的机会（即从P流向t），这样就得到了最大权。原图中流量为1的边为最佳匹配边。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配与匈牙利算法]]></title>
    <url>%2F2019%2F02%2F22%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E4%B8%8E%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：本文不会介绍匈牙利算法本身，关于该算法见这一篇博客。本文不写是因为这一篇写得实在是很好。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文是这篇文章的延伸。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图匹配是一类图论问题，首先需要认识什么是匹配。 【匹配】给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。(来自百度百科) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在所有匹配中，边数最多的匹配称为二分图最大匹配。求最大匹配的算法便是匈牙利算法，下面用洛谷P2055假期的宿舍来应用匈牙利算法。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学校放假了 · · · · · · 有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已知一共有 n 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个数 T 表示数据组数。接下来 T 组数据，每组数据第一行一个数n 表示涉及到的总人数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来一行 n 个数，第 i 个数表示第 i 个人是否是在校学生 (0 表示不是，1 表示是)。再接下来一行 n 个数，第 i 个数表示第 i 个人是否回家 (0 表示不回家，1 表示回家，注意如果第 i 个人不是在校学生，那么这个位置上的数是一个随机的数，你应该在读入以后忽略它)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 n 行每行 n 个数，第 i 行第 j 个数表示 i 和 j 是否认识 (1 表示认识，0 表示不认识，第 i 行 i 个的值为 0，但是显然自己还是可以睡自己的床)，认识的关系是相互的。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每组数据，如果存在一个方案则输出 “^_^”(不含引号) 否则输出“T_T”(不含引号)。(注意输出的都是半角字符，即三个符号的 ASCII 码分别为94,84,95) 输入输出样例Sample input 131 1 00 1 00 1 11 0 01 0 0 Sample output ^_^ 说明对于 30% 的数据满足 1 ≤ n ≤ 12。 对于 100% 的数据满足 1 ≤ n ≤ 50,1 ≤ T ≤ 20。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是一道二分图最大匹配问题了，匹配是指人与床的匹配。根据认识关系建立二分图，在上面应用匈牙利算法即可找到最大匹配边数，进而判断是否可以为每一个人找到床位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;struct &#123; int to, next;&#125; edge[5000];int head[55], cnt = 1, n, x, vis[5005] = &#123;0&#125;, isSchool[55] = &#123;0&#125;, isHome[55] = &#123;0&#125;, bed[55] = &#123;0&#125;, ans, maxn;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;bool f(int x) &#123;//匈牙利算法部分 for (int i = head[x]; ~i; i = edge[i].next) &#123; if (!vis[edge[i].to]) &#123; vis[edge[i].to] = 1;//可以理解成暂时占用 if (!bed[edge[i].to] || f(bed[edge[i].to])) &#123; bed[edge[i].to] = x; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n, cnt = 1, ans = 0, maxn = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1, bed[i] = 0; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; isSchool[i]; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; isHome[i]; for (int i = 1; i &lt;= n; i++)if (!(isSchool[i] &amp;&amp; isHome[i]))maxn++; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; x; if (isSchool[j] &amp;&amp; x)add(i, j); else if (i == j &amp;&amp; isSchool[i])add(i, i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++)vis[j] = 0; if (!(isSchool[i] &amp;&amp; isHome[i]) &amp;&amp; f(i))ans++; &#125; if (ans &lt; maxn)cout &lt;&lt; "T_T" &lt;&lt; endl; else cout &lt;&lt; "^_^" &lt;&lt; endl; &#125; return 0;&#125; 扩展&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图除了最大匹配之外，还有两类问题比较常见，一是最小点覆盖问题，另一个是最大独立集问题。 最小点覆盖&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在二分图中选取若干个点，每选取一个就相当于覆盖了以其为端点的边，求使得所有边都被覆盖的最小点数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求法：最小点覆盖数目就是最大匹配。 最大独立集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在二分图中选取若干个点，使得它们两两不相邻，则称这样的点的集合为一个独立集，求独立集点的最大数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求法：最大独立集点的数目就是总点数与最小点覆盖的差。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP匹配算法]]></title>
    <url>%2F2019%2F02%2F21%2FKMP%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP字符串匹配算法是一种快速检索字符串的算法。本文探讨KMP算法原理及实现。注意下文中的字符串下标均从0开始。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP匹配算法解决的问题是：如何快速判断字符串A（称主串）中是否包含字符串B（称模式串），如果包含，出现在哪些位置？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法是从暴力匹配算法的不足改进而来。判断某个字符串中是否包含另一个字符串通常设置两个变量i、j，分别指向串A和串B的某个位置，依次检索。如果失配，则令j=0重新检索。这种算法时间复杂度O(nm)，不足在于每一次都重新检索，没有利用好之前匹配成功的信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP算法便是在失配后的做法上进行了优化：当发生失配时，串A的检索位置i不动，j指向一个特定的数next[j]，之后再进行匹配。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next数组是KMP算法的精髓，它储存的是模式串第i位（从0开始）失配后的跳转位置。要理解这个概念需要先理解前缀和后缀。对于字符串abcd： 前缀：a、ab、abc 后缀：d、cd、bcd &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是很容易理解的。值得注意的是，这里的前后缀都不能包含字符串本身。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个长度为p的前缀与等长的后缀完全相同，则它们为一对相同前后缀。例如字符串abcdab中，由于前两个ab与后两个ab相同，因此这是一对相同前后缀。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next数组定义即为：next[i]储存模式串的子串[0，i-1]的最长相同前后缀长度。由于abcdab的最长相同前后缀长度为2，因此对于字符串abcdabe，它的next[6]=2（6是末尾e的下标）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面证明当i位失配时，跳转到next[i]的算法正确性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的匹配过程中，模式串第i位失配，说明第0~i-1位都是匹配的。这时我们要做的是固定主串不动，将模式串右移若干位，假设右移p位可以使模式串完全匹配，并假设第i位失配时，主串在第j位。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原有的模式串首端指向主串第j-i位，右移后指向j-i+p位，这时应该有主串第j-i+p位等于模式串第0位，…，主串第j-i+p+l-1位等于模式串第l-1位（l为模式串长度）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下证p ≥ i-next[i]。假设p &lt; i-next[i]：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经知道主串[j-i+p，j-i+p+l-1]部分与模式串[0，l-1]部分完全相同，那么主串[j-i+p，j-1]部分和模式串[0，i-p-1]部分也应该是相同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于第i位前是匹配的，所以主串[j-i+p，j-1]就是模式串[p，i-1]。那么模式串[0，i-p-1]=模式串[p，i-1]，于是我们找到了模式串第0到i-1位的一个相同前后缀，长度为i-p。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而根据假设：i-p &gt; i-(i-next[i]) = next[i]。这与next[i]的最大性矛盾！于是p≥i-next[i]是正确的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p≥i-next[i]说明什么呢？说明至少要向右移动i-next[i]位才可能匹配，从而避免了很多次无意义的移动。从程序角度讲，模式串向右移动i-next[i]位就是将下标换成next[i]，然后与主串第j位比较。至此证明了算法正确性。1234567891011int i = 0, j = 0;//i是主串下标，j是模式串下标 while (i &lt; l1) &#123;//l1是主串长度 if (str1[i] == str2[j]) &#123;//匹配 if (j == l2 - 1) &#123; cout &lt;&lt; i - j + 1 &lt;&lt; endl; if (j != 0)j = next[j];//完全匹配，输出位置，令j=next[j]（相当于假设这一位没有匹配以开始新的一轮） else i++; &#125; else i++, j++;//否则继续比较 &#125; else if (j == 0)i++;//没有匹配并且j=0，i++以开始新的一轮 else j = next[j];//j=next[j]进行跳转 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP算法时间复杂度O(n+m)。下面是next数组的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next数组当然可以用最暴力的方法求出，但是也有更好的方法，那就是令模式串自己与自己匹配。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知next[0]=next[1]=0，现考虑能不能用前面已知的next值求后面的next值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设要求next[i]。令j=next[i-1]，拿另一个相同模式串（称拷贝模式串）的第j位对齐到模式串第i-1位上。为什么要这样做呢？此时拷贝模式串的[0，j-1]位与模式串对应位置完全相同，并且容易知道如果将拷贝模式串左移几位，一定是不匹配的（证明与上面类似）。从这里开始进行匹配，如果str[j]==str[i-1]，那么匹配成功，next[i]=j+1；如果失配，注意到前面均匹配，所以可以采用跳转的方式：令j=next[j]，继续判断str[j]是否等于str[i-1]，只要出现相等的情况立即令next[i]=j+1并进行下一个next值的求解。如果直到j=0都没能匹配，那么next[i]=0。由于是从最大可能的长度找过来，所以结果一定是最大长度。123456789void findNext() &#123; next[0] = next[1] = 0; int j = 0, i = 2; while (i &lt; l2) &#123; if (str2[j] == str2[i - 1])next[i++] = ++j; else if (j == 0)next[i++] = 0, j = 0; else j = next[j]; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合这两步即可得到完整的KMP匹配算法代码。 KMP算法的改进：nextval数组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP算法已经十分优秀了，但还是有一些不足。例如当i位不匹配时，我们会选择从i位跳转到next[i]位，但是如果此时next[i]位对应的字符与i位相同，那么这一次显然也是不匹配的，之后就需要继续移动。当模式串很长且重复较多时，会引起很多无用的移动。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时我们希望next数组可以指向一个与第i位字符不同的一个位置，这就是nextval数组。nextval数组可以从next数组递推过来，只需要加上几行语句即可：12345678910111213void findNext() &#123; next[0] = next[1] = nextval[0] = nextval[1] = 0;//初始化，全为0 int j = 0, i = 2; while (i &lt;= l2) &#123; if (str2[j] == str2[i - 1]) &#123; next[i] = ++j; if (str2[i] == str2[next[i]])nextval[i] = nextval[next[i]];//与next[i]对应相同时，就是nextval[next[i]] else nextval[i] = next[i];//否则就是next[i] ++i; &#125; else if (j == 0)next[i++] = 0, j = 0; else j = next[j]; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用时直接将next数组换为nextval数组即可。但是这样需要注意一个问题：当需要统计模式串出现过的所有位置时，需要用next数组跳转。这是因为匹配成功时的跳转是一种“假设”，实际上是匹配的，如果用nextval跳转会造成少答案的现象。1234567891011int i = 0, j = 0;while (i &lt; l1) &#123; if (str1[i] == str2[j]) &#123; if (j == l2 - 1) &#123; cout &lt;&lt; i - j + 1 &lt;&lt; endl; if (j != 0)j = next[j];//用next跳转 else i++; &#125; else i++, j++; &#125; else if (j == 0)i++; else j = nextval[j];//换成nextval &#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2024]食物链]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%B4%9B%E8%B0%B7P2024-%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题是加权并查集模板题。 难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B吃 C，C 吃 A。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有人用两种说法对这 N 个动物所构成的食物链关系进行描述： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种说法是“1 X Y”，表示 X 和 Y 是同类。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种说法是“2 X Y”，表示 X 吃 Y 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话 当前的话中 X 或 Y 比 N 大，就是假话 当前的话表示 X 吃 X，就是假话 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 eat.in 中输入数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个整数，N，K，表示有 N 个动物，K 句话。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行开始每行一句话（按照题目要求，见样例） 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行，一个整数，表示假话的总数。 输入输出样例Sample input 100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5 Sample output 3 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 ≤ N ≤ 5 ∗ 10^4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 ≤ K ≤ 10^5 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察加权并查集。做法：按照每一句话进行操作，推出矛盾。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并查集可以很好地处理相联性问题，在大多数情况下，这种关系是一定的。但是对于多种关系，正常的并查集就不能满足需求。加权并查集用于关系种类多于1时的情景。比如本题中有三个关系：同类、吃、被吃，并查集中的结点通过这三种关系中的任意一种联系起来，并用权值描述具体的关系种类。简单来说，普通并查集维护关系，加权并查集维护相对关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;权值通常描述该结点与父结点的关系。在路径压缩后结点指向根节点，这个法则同样成立，我们需要在路径压缩时修改结点关系值（毕竟父结点被修改了），修改模板如下：123456int find(x) &#123; if (father[x] == x)return x; int r = find(father[x]);//获得根结点，此时父结点以上通过递归调用已经指向了根结点并更新了关系 //更新关系... return father[x] = r;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果父结点与根结点关系是a，子结点与父结点关系为b，那么子结点和根结点关系是可以求得的（需要具体分析）。另外加权并查集只能来维护传递关系唯一的情景。这句话的意思是，如果我们知道A是B的子结点，关系为a，B是C的子结点，关系为b，那么A与C的关系应该是确定而唯一的。这种性质可以使我们通过任意一个第三者判别两个结点的关系，这是加权并查集的原理（第三者就是通过B和A的关系以及B和C的关系来推断A与C的关系，B就是第三者）。关系传递唯一性保证了路径压缩是等价变形，并且在加权并查集的一个等价类中，保证了任意两点的关系都可以推断出来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单概括如下： 加权并查集的任意一个等价类中任意两点相对关系都可以确定；取两个点，分别来自两个不同等价类，它们的关系无法确定。也就是说，只有在一个等价类中的点对才可以确定关系。 当等价类中任意一个点被具体化时，等价类中其余点都会根据关系具体化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于本题，规定权值0表示子结点与父结点为同类，1表示子结点吃父结点，2表示子结点被父结点吃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的关系进行传递的话，是否具有唯一性？答案是肯定的，如果父结点被它的父结点吃（权值为2），而子结点又吃父结点（权值为1），那么子结点与父结点的父结点什么关系？显然是同类（权值为0）。其余情况都可以由此推断出来，把所有的情况全部列出，可以发现： rela[x]=(rela[x]+rela[father[x]])\%3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然关系的传递具有唯一性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目解决起来就很容易了。首先初始化并查集，令所有点权值为0（自己与自己是同类），然后进行合并。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何合并呢？根据上文的讨论，如果将并查集的两个等价类用一条边（合并就是加边的过程）联系起来，那么这两个等价类成为一个等价类，其中所有点对关系就会确定了。如何加边成为问题的重点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在并查集中，合并通常是令其中一个等价类的根节点去作为另一个等价类根节点的子结点。我们只需要选择合适的关系就可以了。假设要合并x和y（x和y分属两个等价类）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路径压缩后，rela[x]是x到其根节点的关系，rela[y]是y到其根节点的关系，这时x与y的关系又已知（假设为p）。从上文的讨论中可见，如果x根节点与y根节点关系为q，那么： rela[x]+q\equiv rela[y]+p(mod\ 3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解：x通过其根节点这个第三者和通过y这个第三者得到的与y根节点的关系应该是相同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此建立x根节点到y根节点的边，修改x根节点权值为(rela[y]+p-rela[x]+3)%3，便把两个等价类合并成一个等价类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了：合并两个等价类会不会本身就会出现矛盾？或者说合并这两个等价类会不会使某些点对关系矛盾？答案是否定的。前文已经说明，只有一个等价类中的两两点对关系确定，但分属两个等价类中的点对一点关系都没有。在两个等价类上连一条边，权值为多少都不会出现矛盾。我们加了一条边，这本身就是在建立这两个等价类点对的相对关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果发现x和y就在一个等价类中，还需要合并吗？显然不需要，这时两点关系已经确定，再修改关系就真的会出现矛盾了。这时需要做的就是找到两点关系并判断，如果不符，则这句话是假话。1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int n, m, ans = 0, father[50005], rela[50005] = &#123;0&#125;;int find(int x) &#123; if (father[x] == x)return x; int r = find(father[x]); rela[x] = (rela[father[x]] + rela[x]) % 3; return father[x] = r;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)father[i] = i; for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; if (y &gt; n || z &gt; n)ans++; else if (x == 2 &amp;&amp; y == z)ans++; else &#123; int fy = find(y), fz = find(z); if (fy != fz)father[fy] = fz, rela[fy] = (rela[z] - rela[y] + (x == 2) + 3) % 3; else &#123; if (x == 1 &amp;&amp; rela[y] != rela[z])ans++; else if (x == 2 &amp;&amp; (1 + rela[z]) % 3 != rela[y])ans++; &#125; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图判定]]></title>
    <url>%2F2019%2F02%2F20%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图是一种常用的图论模型。如果一个图的顶点可以分成两个不相交子集，并且所有边关联的顶点分属于这两个不同的集合，则称这个图为二分图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图判定具有简洁的方法。 一个图是二分图的充要条件是图中没有奇数环。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际操作中，这个方法可以用染色法代替： 一个图是二分图当且仅当这个图可以被染成两种颜色，并且相邻两点颜色不同。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用DFS/BFS即可进行染色分析。下面用洛谷P1525 关押罪犯来应用二分图。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S城现有两座监狱，一共关押着N名罪犯，编号分别为1-N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为c的冲突事件。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在详细考察了N名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行中两个数之间用一个空格隔开。第一行为两个正整数N,M分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$ 。数据保证$1&lt;a_j≤b_j≤N ,0 &lt; c_j≤ 1,000,000,000$，且每对罪犯组合只出现一次。对于%100的数据有$N≤ 20000,M≤ 100000$。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共1行，为Z市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。 输入输出样例Sample input 4 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884 Sample output 3512 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显需要二分答案。对于一个值mid，从图中找出边权大于mid的所有边，容易知道如果此时的图是一个二分图则可以将大于mid的组合全部分开。DFS染色判断即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct &#123; int to, next, v;&#125; edge[200000 + 5];int head[20000 + 5], cnt = 1, n, m, maxn = -1, vis[20000 + 5], color[20000 + 5];inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;bool DFS(int x, int y) &#123; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; y) &#123; if (color[edge[i].to] == color[x])return false; else if (color[edge[i].to] == 0) &#123; color[edge[i].to] = -color[x]; if (!DFS(edge[i].to, y))return false; &#125; &#125; &#125; return true;&#125;bool check(int x) &#123; for (int i = 1; i &lt;= n; i++)color[i] = 0; for (int i = 1; i &lt;= n; i++) if (!color[i]) &#123; color[i] = 1; if (!DFS(i, x))return false; &#125; return true;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; x = read(), y = read(), z = read(), maxn = max(maxn, z); add(x, y, z), add(y, x, z); &#125; int l = 0, r = maxn; while (l &lt; r) &#123; int mid = (l + r) / 2; if (check(mid))r = mid; else l = mid + 1; &#125; cout &lt;&lt; l; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;差分约束系统是很多问题求解的模型，这一类问题可以转化为图的单源最短路径问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓差分约束系统是指如下的若干不等式组成的约束系统： x_i-x_j\leq w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$x_i,x_j$均为变量，w为常数。不等式组要么无解要么有无数种解，这是因为如果存在一组解，易知它们分别加上同样的数d得到的仍是一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将不等式变形： x_i\leq x_j+w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现这与单源最短路径的松弛操作十分类似： dict[i]\leq dict[j]+w(i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此可知，如果将每一个变量看做点，不等关系看做边建图，求单源最短路径，它们的最短路径值一定满足所有的不等关系。这样差分约束问题就可以转化为图的单源最短路径问题。对于不等式$x_i-x_j\leq w$，需要建立j到i，边权为w的有向边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源点如何找呢？我们需要引入一个新变量$x_0$，并建立$x_0$到其余所有变量的有向边，边权为0，这样相当于加了下面几个约束关系： x_1-x_0\leq 0\\ x_2-x_0\leq 0\\ \cdots\\ x_n-x_0\leq 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然加入这些不等式不会影响原不等式的实际结果，可以认为$x_0$是所有变量的上界。这样以$x_0$为源点求单源最短路径即可。在求单源最短路径时，通常令源点的路径长即dict[0]=0，这样相当于规定了$x_0=0$，所有变量的取值便成为非正数。同样地，如果规定dict[0]=p，这样所有变量取值都不会超过p。源点的dict值可以作为变量取值的上界。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不等式组的无解判定：当单源最短路不存在时（即图中有负环），不等式组无解。基于此，常常用SPFA解决差分约束问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，当不等式给出$x_i-x_j\geq w$形式不等式时，两边乘一个-1，即可化为标准形式。如果给出$x_i-x_j&lt;w$形式，可以化为$x_i-x_j\leq w-1$（因为变量取值通常只取整数）。$x_i-x_j=w$可以化为$x_i-x_j\geq w$和$x_i-x_j\leq w$两个不等式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终得出的解只是一组特解，这组特解不一定符合题意，通常需要将所有值同时加上合适的d来使它们都达到合理的范围。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;差分约束还有另一种解决方法，就是求最长路，这种方法针对形如$x_i-x_j\geq w$的方程。仍然建立j到i边权为w的有向边，但是要求最长路，此时dict[0]是所有变量的下界。求最长路方法与最短路类似，都用SPFA算法。无解判定：当图中存在正权环时无解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题：HDU1384 Intervals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道裸的差分约束题目。规定$d_i$为0~i中已经被选的数的个数，那么可以列出不等式： d_{b_i}-d_{a_i-1}\geq c_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决此类问题时需要善于找到隐藏不等关系，比如每一个数最多选一次，因此还有： 0\leq d_i-d_{i-1}\leq 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建图跑最短（长）路即可，然后找到最小的合法解。题目特点决定了差分约束系统一定有解，不用判定无解情况。另外注意这题有多组测试样例，题干中未提及。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#define MAX (50000+5)#define inf (int)1e9using namespace std;struct &#123; int to, next, v;&#125; edge[MAX * 4 + 10000];int head[MAX], cnt = 1, vis[MAX] = &#123;0&#125;, n, a[MAX], b[MAX], c[MAX], dict[MAX], minn, maxn;inline void add(int x, int y, int z) &#123;//建边 edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;queue&lt;int&gt; que;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; cnt = 1, minn = inf, maxn = -inf; for (int i = 0; i &lt;= 50002; i++)dict[i] = inf, head[i] = -1, vis[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i], cin &gt;&gt; b[i], cin &gt;&gt; c[i]; a[i] += 2, b[i] += 2; add(b[i], a[i] - 1, -c[i]), maxn = max(maxn, b[i]), minn = min(minn, a[i] - 1); &#125; for (int i = 2; i &lt;= maxn; i++)add(i - 1, i, 1), add(i, i - 1, 0);//补充约束关系 dict[0] = 0; for (int i = 1; i &lt;= maxn; i++)add(0, i, 0);//补充x0 que.push(0), vis[0] = 1; while (!que.empty()) &#123;//SPFA算法 int p = que.front(); que.pop(), vis[p] = 0; for (int i = head[p]; ~i; i = edge[i].next) &#123; if (dict[edge[i].to] &gt; dict[p] + edge[i].v) &#123; dict[edge[i].to] = dict[p] + edge[i].v; if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; cout &lt;&lt; -dict[minn] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>图论</tag>
        <tag>图的最短路</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分]]></title>
    <url>%2F2019%2F02%2F19%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树链剖分是树上的重要的算法，阅读本文需要先了解线段树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树链剖分主要解决维护并求树上最短路径和，子树和的问题，它的思想是将树划分为一条条链，再用数据结构来维护这些链。树链剖分需要保证每一个结点存在且仅存在于一条链中。下面用洛谷P3384来介绍树链剖分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要清楚以下几个概念： 结点数size：这个结点对应子树的总结点数（含自己）。 父结点编号father：这个结点的父结点 重儿子son：某个结点所有子结点中size最大的一个。叶子结点没有重儿子，其余结点有且仅有一个重儿子。 重边：连接父结点和其重儿子的边。 重链：顺次连接重边所得到的链边 深度depth：结点深度 DFS序：结点在DFS中被首次访问的顺序编号 链顶编号top：该结点所在链的顶端（depth最小的结点）标号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍树链剖分步骤。 第一遍DFS：求father、size、son和depth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一遍DFS，求出基础数据，一遍DFS可以完成。12345678910void DFS1(int x, int fa) &#123; int maxn = -1, r = -1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa) &#123;//防止向父结点回溯 father[edge[i].to] = x, depth[edge[i].to] = depth[x] + 1, DFS1(edge[i].to, x), size[x] += size[edge[i].to]; if (size[edge[i].to] &gt; maxn)maxn = size[edge[i].to], r = edge[i].to;//更新son &#125; &#125; son[x] = r, size[x]++;//含自己，size要自加&#125; 第二遍DFS：求top、DFS序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步是关键。这一步的主要目的是建立树链，规则如下： 如果结点存在重儿子，则优先连接重边，继承已有的树链。 所有轻儿子（除了重儿子就是轻儿子）均分别作一条新链的首端，继续向下延伸。 12345678void DFS2(int x, int t) &#123;//现在访问的结点编号、该结点所在树链的顶端编号 id[x] = dCnt, rk[dCnt] = x, dCnt++, top[x] = t;//构造双向映射（id和rk），进行DFS序重新编号并更新top值 if (size[x] == 1)return;//叶子结点直接return if (son[x])DFS2(son[x], t);//存在重儿子优先选重儿子 for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != son[x] &amp;&amp; edge[i].to != father[x])DFS2(edge[i].to, edge[i].to);//所有轻儿子作新的树链起点 &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里可能会有一个疑惑，为什么要重新编号呢？其实这才是树链剖分的目的：将每一条树链上的点编号都变成连续的，这样就可以用数据结构（比如线段树）维护它们的和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步完成后，可以发现，每一个结点（比如x）的所有子树结点编号都成为连续的了，它们的新编号区间为[id[x],id[x]+size[x]-1]。这样有利于我们用线段树解决子树修改求和问题。 最短路径的划分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求两个结点之间最短路径和呢？在树链剖分后容易发现如果两个结点在同一条树链中，它们之间的结点新编号必然是连续的，这样求和和修改就转化为区间求和修改问题，用线段树维护即可。如果两个结点不在一条树链中，就需要采用下面的方法来将它们分到同一个树链中：（原题要取模，这里为了方便省略取模过程）1234567891011121314inline int queL(int x, int y) &#123; int tx = top[x], ty = top[y], ans = 0;//找到两条链的top while (tx != ty) &#123;//top不同说明不在一条链上 if (depth[tx] &gt;= depth[ty]) &#123;//对于更深的top ans += query(id[tx], id[x], 1, n, 1);//从top开始到这个结点的路径必然都在最短路径上，加上它的影响 x = father[tx], tx = top[x]; &#125; else &#123; ans += query(id[ty], id[y], 1, n, 1); y = father[ty], ty = top[y]; &#125; &#125; if (depth[x] &lt;= depth[y])return ans + query(id[x], id[y], 1, n, 1);//划分到同一条链上之后直接处理 return ans + query(id[y], id[x], 1, n, 1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改类比即可。这里可以发现树链剖分的本质是将树上的问题转化为区间上的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出全部代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define MAX (100000+5)using namespace std;struct &#123; int to, next;&#125; edge[MAX * 2];int head[MAX], father[MAX], son[MAX] = &#123;0&#125;, size[MAX] = &#123;0&#125;;int top[MAX], depth[MAX], cnt = 1, dCnt = 1, n, m, root, mod, x, y, z;int id[MAX] = &#123;0&#125;, rk[MAX] = &#123;0&#125;, init[MAX], tree[4 * MAX], lazy[4 * MAX] = &#123;0&#125;;inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS1(int x, int fa) &#123; int maxn = -1, r = -1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa) &#123; father[edge[i].to] = x, depth[edge[i].to] = depth[x] + 1, DFS1(edge[i].to, x), size[x] += size[edge[i].to]; if (size[edge[i].to] &gt; maxn)maxn = size[edge[i].to], r = edge[i].to; &#125; &#125; son[x] = r, size[x]++;&#125;void DFS2(int x, int t) &#123; id[x] = dCnt, rk[dCnt] = x, dCnt++, top[x] = t; if (size[x] == 1)return; if (son[x])DFS2(son[x], t); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != son[x] &amp;&amp; edge[i].to != father[x])DFS2(edge[i].to, edge[i].to); &#125;&#125;void make(int l, int r, int k) &#123; if (l == r) &#123; tree[k] = init[rk[l]]; return; &#125; int mid = (l + r) &gt;&gt; 1; make(l, mid, 2 * k), make(mid + 1, r, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;inline void down(int k, int l, int r) &#123; int mid = (l + r) &gt;&gt; 1; tree[2 * k] = (tree[2 * k] + (mid - l + 1) * lazy[k] % mod) % mod; tree[2 * k + 1] = (tree[2 * k + 1] + (r - mid) * lazy[k] % mod) % mod; lazy[2 * k] += lazy[k], lazy[2 * k + 1] += lazy[k], lazy[2 * k] %= mod, lazy[2 * k + 1] %= mod, lazy[k] = 0;&#125;int query(int x, int y, int l, int r, int k) &#123; int mid = (l + r) &gt;&gt; 1; if (l &lt; r &amp;&amp; lazy[k] != 0)down(k, l, r); if (x == l &amp;&amp; y == r)return tree[k]; if (mid + 1 &lt;= x)return query(x, y, mid + 1, r, 2 * k + 1); if (mid &gt;= y)return query(x, y, l, mid, 2 * k); return (query(x, mid, l, mid, 2 * k) + query(mid + 1, y, mid + 1, r, 2 * k + 1)) % mod;&#125;void change(int x, int y, int l, int r, int s, int k) &#123; int mid = (l + r) &gt;&gt; 1; if (l &lt; r &amp;&amp; lazy[k] != 0)down(k, l, r); if (x == l &amp;&amp; y == r) &#123; tree[k] = (tree[k] + (r - l + 1) * s % mod) % mod; lazy[k] += s; return; &#125; if (mid + 1 &lt;= x)change(x, y, mid + 1, r, s, 2 * k + 1); else if (mid &gt;= y)change(x, y, l, mid, s, 2 * k); else change(x, mid, l, mid, s, 2 * k), change(mid + 1, y, mid + 1, r, s, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;inline void addL(int x, int y, int s) &#123; int tx = top[x], ty = top[y]; while (tx != ty) &#123; if (depth[tx] &gt;= depth[ty]) &#123; change(id[tx], id[x], 1, n, s, 1); x = father[tx], tx = top[x]; &#125; else &#123; change(id[ty], id[y], 1, n, s, 1); y = father[ty], ty = top[y]; &#125; &#125; if (depth[x] &lt;= depth[y])change(id[x], id[y], 1, n, s, 1); else change(id[y], id[x], 1, n, s, 1);&#125;inline int queL(int x, int y) &#123; int tx = top[x], ty = top[y], ans = 0; while (tx != ty) &#123; if (depth[tx] &gt;= depth[ty]) &#123; ans += query(id[tx], id[x], 1, n, 1), ans %= mod; x = father[tx], tx = top[x]; &#125; else &#123; ans += query(id[ty], id[y], 1, n, 1), ans %= mod; y = father[ty], ty = top[y]; &#125; &#125; if (depth[x] &lt;= depth[y])return (ans + query(id[x], id[y], 1, n, 1)) % mod; return (ans + query(id[y], id[x], 1, n, 1)) % mod;&#125;int main() &#123; n = read(), m = read(), root = read(), mod = read(); for (int i = 1; i &lt;= n; i++)init[i] = read(), head[i] = -1; for (int i = 1; i &lt; n; i++)x = read(), y = read(), add(x, y), add(y, x); depth[root] = 1, DFS1(root, 0), DFS2(root, root), make(1, n, 1); int cmd; for (int i = 0; i &lt; m; i++) &#123; cmd = read(); if (cmd == 1) &#123; x = read(), y = read(), z = read(); addL(x, y, z); &#125; else if (cmd == 2) &#123; x = read(), y = read(); cout &lt;&lt; queL(x, y) &lt;&lt; endl; &#125; else if (cmd == 3) &#123; x = read(), y = read(); change(id[x], id[x] + size[x] - 1, 1, n, y, 1); &#125; else &#123; x = read(); cout &lt;&lt; query(id[x], id[x] + size[x] - 1, 1, n, 1) &lt;&lt; endl; &#125; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后记：最短路径和也可以通过LCA来完成，做法是预处理每一个结点到根结点的前缀和，求出LCA后即可计算出。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan算法(LCA)]]></title>
    <url>%2F2019%2F02%2F19%2FTarjan%E7%AE%97%E6%B3%95(LCA)%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍Tarjan算法求LCA的原理和过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCA已经在之前的日志中提及，当时使用的倍增算法，见这篇文章。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法是基于并查集求LCA的离线算法。所谓离线，是指读入所有的查询，然后在一次遍历中处理所有查询并得出结果。这种算法不能边读入查询边计算，遍历完成后不能再处理额外的查询。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法巧妙地利用了树的遍历规律。在树的DFS遍历中，容易发现当我们在遍历一棵树时，如果它的所有子树结点尚未被完全访问，这棵子树的根结点状态是不能更新的。也就是说，只有访问了所有子结点后，该结点的状态才可以更新。Tarjan算法便是利用了这一点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法可以描述如下，从根结点开始： 遍历所有子结点，每遍历完一个，将子结点合并到该结点上（并查集操作），并标记该结点已被访问。 遍历完成后，找到与该结点有关的所有查询。如果另一个结点v已经被访问，那么这个查询的结果就是find(v)（并查集操作），否则忽略。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法正确性是易于理解的。对于一个刚刚完成访问操作的结点，我们找到所有与之相关的查询。如果此时另一个结点也被访问了，可以肯定两个结点在一个子树下，并且这棵子树的访问操作没有完全完成（毕竟我们正在访问的就是它的一个子结点或者孙子结点等等），根结点（也就是LCA）的并查集属性（也就是father）尚未被更改（如前文所说，只有遍历完所有子结点才能更改）。注意到每访问一个子结点后我们都将其与父结点合并，那么LCA就可以通过find()函数向上追溯的方法找到了，期间可以使用并查集的路径压缩算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法中的并查集算法与普通的并查集几乎完全相同，唯一不同点是合并的顺序。普通并查集合并两个点时合并顺序是随意的，但是Tarjan算法中必须是子结点合并到父结点上。其实这里的并查集可以看做以前树上常用的记录父结点关系的parent数组。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX (500000+5)using namespace std;struct &#123; int to, next;&#125; edge[MAX * 2];struct &#123;//将查询视为图 int to, next, r;//r是查询编号&#125; qEdge[MAX * 2];int head[MAX], qHead[MAX], father[MAX], ans[MAX] = &#123;0&#125;, cnt = 1, qCnt = 1, n, m, root;bool vis[MAX] = &#123;false&#125;;inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y) &#123;//树的图构建 edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;inline void qAdd(int x, int y, int r) &#123;//查询关系图构建 qEdge[qCnt].to = y, qEdge[qCnt].next = qHead[x], qEdge[qCnt].r = r, qHead[x] = qCnt++;&#125;int find(int x) &#123; if (father[x] == x)return x; return father[x] = find(father[x]);&#125;inline void merge(int x, int y) &#123;//x合并到它的父结点y上! father[x] = find(y);//就是father[find(x)]=find(y)，因为find(x)就是x //father[y]=find(x)是错的&#125;void Tarjan(int x, int fa) &#123; for (int i = head[x]; i != -1; i = edge[i].next) &#123;//访问所有子结点 if (edge[i].to != fa) Tarjan(edge[i].to, x), merge(edge[i].to, x), vis[edge[i].to] = true; &#125; for (int i = qHead[x]; i != -1; i = qEdge[i].next) &#123;//找到所有相关查询 if (!ans[qEdge[i].r] &amp;&amp; vis[qEdge[i].to])ans[qEdge[i].r] = find(qEdge[i].to); &#125;&#125;int main() &#123; int x, y; n = read(), m = read(), root = read(); for (int i = 1; i &lt;= n; i++)qHead[i] = head[i] = -1, father[i] = i; for (int i = 1; i &lt; n; i++)x = read(), y = read(), add(x, y), add(y, x); for (int i = 0; i &lt; m; i++)x = read(), y = read(), qAdd(x, y, i), qAdd(y, x, i); vis[root] = true, Tarjan(root, 0); for (int i = 0; i &lt; m; i++)cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan算法(割点&割边)]]></title>
    <url>%2F2019%2F02%2F19%2FTarjan%E7%AE%97%E6%B3%95(%E5%89%B2%E7%82%B9%26%E5%89%B2%E8%BE%B9)%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节探讨另一种Tarjan算法来求无向图的割点和割边。本文是这篇文章的延伸。 割点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是割点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个连通无向图中，如果删去某一个点以及与其相连的边后图不再联通，则称这个点为一个割点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法可以用来求割点，它的步骤与求强联通分量的算法十分相似，只是多了下面几个判断： 如果该点为搜索树的根结点（一个连通图搜索树有且仅有一个根结点），判断其子结点数目。如果子结点数目多于一个，说明两个子树只能通过根结点来往，由此判断根结点为割点。也就是说，根结点为割点的充要条件是子结点多于一个。 对于非根结点u，如果其有子结点并且存在某个子结点v的LOW值满足LOW[v]≥DFN[u]，则说明该子树上的结点不能访问父结点以上的结点，即父结点为割点。也就是说，非根结点为割点的充要条件是存在至少一个子结点满足LOW[v]≥DFN[u]。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求割点时不需要开栈，如果子结点已经被访问过，直接更新即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在求割点时，事实证明子结点是可以回溯到父结点的。但仍然建议在无向图中不允许子结点回溯父结点，这是为了与割边算法统一（见下文）。1234567891011void tarjan(int x, int last) &#123; DFN[x] = LOW[x] = cunt++; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (!DFN[edge[i].to]) &#123; tarjan(edge[i].to, x), LOW[x] = min(LOW[x], LOW[edge[i].to]); if (x != root &amp;&amp; LOW[edge[i].to] &gt;= DFN[x])Ans[x] = 1; else if (x == root)c++; &#125; else if (edge[i].to != last)LOW[x] = min(LOW[x], DFN[edge[i].to]); &#125; if (x == root &amp;&amp; c &gt;= 2)Ans[x] = 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：Tarjan算法得出的割点可能会重复。 割边&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个连通无向图中，如果删去一条边后图不再连通，则该边为一条割边，也称为桥。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找割边的算法比割点容易，因为它不需要考虑根结点的问题。对于一条边(u，v)，u为父结点，则该边是割边的充要条件是LOW[v]&gt;DFN[u]。这说明子结点不能通过其它边访问包含父结点在内的所有祖先结点，即父子边为割边。值得注意的是，判割边时，子结点不能回溯到父结点。12345678910void tarjan(int x, int last) &#123; DFN[x] = LOW[x] = cunt++; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to == last) continue;//不能回溯到父结点 if (!DFN[edge[i].to]) &#123; tarjan(edge[i].to, x), LOW[x] = min(LOW[x], LOW[edge[i].to]); if (LOW[edge[i].to] &gt; DFN[x])Ans[i] = 1;//标记边序号 &#125; else if (edge[i].to != last)LOW[x] = min(LOW[x], DFN[edge[i].to]); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：如果一条边有重边，那么它一定不是割边。Tarjan算法不能排除重边的干扰，需要特判。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan算法(强连通)]]></title>
    <url>%2F2019%2F02%2F18%2FTarjan%E7%AE%97%E6%B3%95(%E5%BC%BA%E8%BF%9E%E9%80%9A)%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍一种求解有向图强连通分量的算法—Tarjan算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是强连通分量的定义：一个有向图的满足强连通性的子图。所谓强连通性是指这个有向图中任意两点都可以相互联通的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法基于DFS，要理解这个算法需要先认清一个事实：在强连通图中一定存在一条回路能够遍历所有的点。这也是判定强连通图的充要条件。Tarjan算法就是通过找环来判定强连通性的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是Tarjan算法的实现过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用栈储存搜索树结点路径。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于图中每一个结点，它都有两个量：DFN与LOW。 DFN ：这个结点被访问的次序编号，也就是时间戳。 LOW ：在搜索树中，这个结点的子树中最小的结点编号（也就是最小的DFN值）。LOW保证了求出的是极大强连通子图。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：每访问一个新结点，首先进行初始化：DFN=LOW=cnt++（cnt是时间戳计数器）并入栈。这是因为新的结点尚未向下扩展，这个结点在搜索树中没有子树，LOW即为自身的DFN。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每访问到一个结点，遍历该点所有的出边。这时对于每一个出点，有以下几种情况： 该点从未被访问：对该点进行新的Tarjan算法（递归进行），以更新该点的DFN与LOW值。由于该点是原结点在搜索树中的子结点，以此更新原结点LOW值。若原结点为u，该结点为v，那么LOW[u]=min(LOW[u],LOW[v])。 该点已在栈中：直接更新原结点LOW值。需要注意的是，更新方法是LOW[u]=min(LOW[u],DFN[v])。这是因为出点已在栈中，但它也是搜索树的子结点，需要用它的DFN值来更新原结点。 其余情况忽略该结点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回溯后，如果一个结点的DFN=LOW，说明自己就在以自己为根的搜索树上，即为一个环。此时退栈，直到该点（含该点），得到的序列就是一个强连通分量。12345678910111213void tarjan(int x) &#123; DFN[x] = LOW[x] = index++, vis[x] = 1, sta.push(x); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to])LOW[x] = min(DFN[edge[i].to], LOW[x]); else if (!DFN[edge[i].to])tarjan(edge[i].to), LOW[x] = min(LOW[x], LOW[edge[i].to]); &#125; if (DFN[x] == LOW[x]) &#123; int t; do cout &lt;&lt; (t = sta.top()) &lt;&lt; " ", vis[t] = 0, sta.pop(); while (t != x); cout &lt;&lt; endl; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题一道：洛谷P2341。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜&gt;欢”是可以传递的——如果A喜欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。 输入输出格式输入格式： 第一行：两个用空格分开的整数：N和M。 第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B。 输出格式：一行：单独一个整数，表示明星奶牛的数量。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题实质上给定了一个有向图，判断有多少点可以让所有点都能连通到该点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于环的出现，本题不能直接用拓扑排序方法去做。首先应认识到，一个环（即一个强连通分量）与一个点等价，于是可以将图中所有强连通分量都分别缩至一个点，这样就得到有向无环图，拓扑排序便可解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缩点方法是染色法，将同一个强连通分量中的点染成同一种颜色。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct Edge &#123; int to, next;&#125; edge[50005];int head[N], cnt = 1, id[N], n, m, vis[N], x, y, DFNt = 1, DFN[N], LOW[N], ID = 1;int all[N], in[N], rk[N], in2[N];//in是点的入度，in2是强连通分量的入度，rk是强连通分量的拓扑序stack&lt;int&gt; sta;queue&lt;int&gt; que;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void tarjan(int x) &#123; if (DFN[x])return;//已经求出的直接return DFN[x] = LOW[x] = DFNt++, vis[x] = 1, sta.push(x); for (int i = head[x]; i; i = edge[i].next) &#123; if (vis[edge[i].to])LOW[x] = min(LOW[x], DFN[edge[i].to]); else tarjan(edge[i].to), LOW[x] = min(LOW[x], LOW[edge[i].to]); &#125; if (DFN[x] == LOW[x]) &#123; int t; do vis[sta.top()] = 0, id[t = sta.top()] = ID, sta.pop(), all[ID]++;//all计数该强连通分量有几个点 while (t != x); ID++; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x &gt;&gt; y; add(x, y); &#125; for (int i = 1; i &lt;= n; i++)tarjan(i); for (int i = 1; i &lt;= n; i++) &#123; for (int j = head[i]; j; j = edge[j].next) &#123; if (id[i] != id[edge[j].to])in[edge[j].to]++, in2[id[edge[j].to]]++; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!in[i]) &#123; que.push(i);//没有入度的点入队 if (!in2[id[i]])rk[id[i]] = 1;//若强连通分量也没有入度，则标记其拓扑序为1（最低） &#125; &#125; while (!que.empty()) &#123; int t = que.front(); que.pop(); for (int i = head[t]; i; i = edge[i].next) &#123; if (id[edge[i].to] != id[t]) &#123;//同一个强连通分量的点不考虑 in[edge[i].to]--, in2[id[edge[i].to]]--;//出度减少一 if (in[edge[i].to] == 0)que.push(edge[i].to);//入度为0的点入队 if (in2[edge[i].to] == 0)rk[id[edge[i].to]] = rk[id[t]] + 1;//强连通分量入度为0，得出拓扑序 &#125; &#125; &#125; int maxn = 0, tot = 0, ans; for (int i = 1; i &lt; ID; i++) &#123;//找到最大拓扑序 if (rk[i] &gt; maxn)maxn = rk[i], tot = 1, ans = i; else if (rk[i] == maxn)tot++; vis[i] = 0; &#125; if (tot &gt; 1) &#123;//最大拓扑序数量比一个多，一定不成立 cout &lt;&lt; "0"; return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (rk[id[i]] == maxn)continue; for (int j = head[i]; j; j = edge[j].next)if (id[edge[j].to] != id[i])vis[id[i]] = 1; &#125; for (int i = 1; i &lt; ID; i++) &#123; if (rk[i] &lt; maxn &amp;&amp; !vis[i]) &#123;//拓扑序低于最大拓扑序但没有出度，一定不成立 cout &lt;&lt; "0"; return 0; &#125; &#125; cout &lt;&lt; all[ans];//最后输出该强连通分量的点数 return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重背包问题及其优化]]></title>
    <url>%2F2019%2F02%2F04%2F%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文探讨多重背包问题。要认识这个问题需要先熟悉01背包和完全背包的状态转移方程。 01背包 dp(a,p)=\begin{cases} \max\{dp(a-1，p)，dp(a-1，p-v_a)+w_a\}\ \ \ & p\geq w_a\\ dp(a-1,p) \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组降维时需要从大到小遍历来更新状态。 完全背包 dp(a,p)=\begin{cases} \max\{dp(a-1，p)，dp(a，p-v_a)+w_a\}\ \ \ & p\geq w_a\\ dp(a-1,p) \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组降维时需要从小到大遍历来更新状态。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多重背包是指每一个物品有着数量限制时的背包问题，这也是一类经典动态规划问题，解法主要有以下几种。 朴素解法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果第i个物品有ci个，我们可以将这ci个物品看做不同的物品，从而化为01背包问题。这种方法十分简单，但时间复杂度为$O(V\displaystyle\sum_{i=1}^n w_ic_i)$，时间消耗很大。 二进制拆分 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制拆分的做法也是将多重背包转化为01背包，但是二进制拆分更为高效，它基于以下数学原理：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一个自然数x都可以写成如下形式： x=2^0+2^1+\cdots+2^k+p,\ p]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论]中国剩余定理]]></title>
    <url>%2F2019%2F02%2F02%2F%E6%95%B0%E8%AE%BA-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中国剩余定理（又名孙子定理）是数论四大定理（威尔逊定理、中国剩余定理、欧拉定理、费马小定理）之一，这里介绍中国剩余定理以及扩展后的定理内容以及在OI中的应用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先介绍中国剩余定理的内容。 【中国剩余定理】对于一次线性同余方程组： \begin{cases} x\equiv a_1(mod\ m_1)\\ x\equiv a_2(mod\ m_2)\\ \cdots \\ x\equiv a_n(mod\ m_n) \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果$gcd(m_i,m_j)=1,1\leq i&lt;j\leq n$，则$x$在模$M=\displaystyle \prod_{i=1}^n m_i$意义下有唯一解。该解可以通过下面方法得到：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定$M_i=\displaystyle\frac {M} {m_i}$，并设$M_i^{-1}为M_i在模m_i下的乘法逆元$，那么解为： x\equiv \sum_{i=1}^n a_iM_iM_i^{-1}(mod\ M) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明参考数论相关书目，这里略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于乘法逆元可以见这篇文章。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中国剩余定理可以帮助求一次线性同余方程组的解。但是当模数m不满足两两互素时，定理便不再适用，于是需要引入更一般化的定理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先给出一个一次线性同余方程组： \begin{cases} x\equiv a_1(mod\ m_1)\\ x\equiv a_2(mod\ m_2)\end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化同余式为： x=a_1+k_1m_1=a_2+k_2m_2,(k_1,k_2\in \mathbb {Z})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记这个式子为①式，化①为同余式： k_1m_1\equiv a_2-a_1(mod\ m_2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$d=gcd(m_1,m_2)$，由上式可得$d|(a_2-a_1)$，若否则方程组无解。下面仅讨论有解的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上式等价于： k_1\frac {m_1} {d}\equiv \frac{a_2-a_1} {d}(mod\ \frac {m_2} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然$\displaystyle\frac {m_1} {d}$与$\displaystyle\frac {m_2} {d}$互质，于是$\displaystyle\frac {m_1} {d}$在模$\displaystyle\frac {m_2} {d}$意义下存在乘法逆元，那么： k_1\equiv \frac {a_2-a_1} {d} (\frac {m_1} {d})^{-1}(mod\ \frac {m_2} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化上式为： k_1=\frac {a_2-a_1} {d} (\frac {m_1} {d})^{-1}+k\frac {m_2} {d},(k\in \mathbb {Z})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上式代入①式： x=a_1+m_1(\frac {a_2-a_1} {d})(\frac {m_1} {d})^{-1}+k\frac {m_1m_2} {d}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化为同余式： x\equiv a_1+m_1(\frac {a_2-a_1} {d})(\frac {m_1} {d})^{-1}(mod\ \frac {m_1m_2} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是得到了一个同余式。易见上面的变形都是等价变形，故该同余式的解与原方程组相同，这样就将两个同余方程合并成一个，并且这个同余方程的解是显见的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反复利用这个公式，可以将n个方程化为一个同余方程。中国剩余定理可以认为是这个公式的特例，这样就得到了一般化的定理。下面用HDU 1573(X问题)来应用这个公式。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求在小于等于N的正整数中有多少个X满足：X mod a[0] = b[0], X mod a[1] = b[1], X mod a[2] = b[2], …, X mod a[i] = b[i], … (0 &lt; a[i] &lt;= 10,0 &lt; N &lt;= 1000,000,000 , 0 &lt; M &lt;= 10) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这个问题很裸地考察上面推导出的公式，直接应用即可。代码中用扩展欧几里得算法求逆元。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;int N, M, a[15], b[15], flag = 1;int gcd(int x, int y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;int egcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int p = egcd(b, a % b, y, x); y -= a / b * x; return p;&#125;int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; flag = 1; cin &gt;&gt; N &gt;&gt; M; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; a[i];//模数 for (int i = 1; i &lt;= M; i++)cin &gt;&gt; b[i]; for (int i = 2; i &lt;= M; i++) &#123;//全部合并到a[1],b[1]中 int d = gcd(a[1], a[i]), e = b[i] - b[1], x, y; if (e % d != 0) &#123;//无解 cout &lt;&lt; 0 &lt;&lt; endl, flag = 0; break; &#125; egcd(a[1], a[i], x, y);//扩展欧几里得求逆元 b[1] = b[1] + a[1] * e / d * x; a[1] = a[1] * a[i] / d; b[1] = (b[1] % a[1] + a[1]) % a[1]; &#125; if (flag) &#123; if (b[1] &gt; 0)cout &lt;&lt; (N &gt;= b[1] ? (N - b[1]) / a[1] + 1 : 0) &lt;&lt; endl; else if (b[1] == 0)cout &lt;&lt; N / a[1] &lt;&lt; endl; &#125; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个常用的技巧：C++中的%运算符得到的并不一定是数学上的模（要求非负），可以用表达式$(a\%p+p)\%p$将其化为数学上非负的模。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;康托展开可以建立1~n全排列到n!的一一映射，常用于字符串哈希，这也是优化时间空间的一种方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;康托展开只能用于全排列的映射。对于1~n的一个排列，康托展开可以得到这个排列在全排列中按字典序的序号(12…n序号为0)，这样便可以建立字符串到[0,n!)的一个映射。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设序列为$s_1s_2…s_n$，具体做法如下： 从左到右依次求出$s_i$的逆序数$a_i$，需要两遍循环。 康托展开的值为$\displaystyle\sum_{i=1}^na_i(n-i)!$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要预处理出0~n-1的阶乘，注意0!=1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;康托展开的原理是易于理解的，他通过找逆序数并乘以排列数的方式来求小于已知序列的排列有多少种，这样便得到已知序列在全排列中的序号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么根据康托展开的值如何得到原排列呢？这就是逆康托展开。设值为x，逆展开算法如下： 开一个数组记录哪些数已经被选了，初始化全未被选。 对于序列的第i位（从1开始），计算$x/(n-i)!$（带余除法）的值p。 从未被选的数中找到第p+1小的数m，序列的第i位便为m。标记m已被选，更新$x=x\ mod\ (n-i)!$。 重复2和3步，直到序列的所有数均被求出。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逆展开原理也是易于理解的。易知每一次求出的p就是逆序数，通过逆序数可以方便地推知第i位的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面通过经典八数码问题（洛谷P1379）来应用康托展开。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入初始状态，一行九个数字，空格用0表示 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数(测试数据中无特殊无法到达目标状态数据) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;八数码问题是经典的搜索类问题，难度在于状态的描述（这是一个排列），康托展开可以很好地解决这个问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用康托展开将每一个排列化为数字，用于判重和搜索，必要时再逆展开为排列，可以降低时间空间复杂度。另外需要注意的是本题需要用BFS（因为要求最少步数）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int jc[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;//预处理阶乘bool vis[362880] = &#123;false&#125;;inline int Hash(const char *op) &#123;//康托展开 int ans = 0; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = 0; for (int j = i + 1; j &lt; 9; j++)if (op[j] &lt; op[i])s++; ans += s * jc[p]; &#125; return ans;&#125;inline void cal(int h, char *op) &#123;//逆展开 bool vis[10] = &#123;false&#125;; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = h / jc[p]; for (int z = 0; z &lt; 9; z++) if (!vis[z]) &#123; if (s == 0) &#123; op[i] = static_cast&lt;char&gt;(z + '0'), vis[z] = true; break; &#125; else s--; &#125; h %= jc[p]; &#125;&#125;struct Node &#123; int h, step, begin; Node(int a, int b, int c) : h(a), step(b), begin(c) &#123;&#125;&#125;;char b[9];queue&lt;Node&gt; que;int main() &#123; cin &gt;&gt; b; for (int i = 0; i &lt; 9; i++) &#123; if (b[i] == '0') &#123; que.push(Node(Hash(b), 0, i)), vis[Hash(b)] = true; break; &#125; &#125; Node p(0, 0, 0); int h; while (!que.empty()) &#123; p = que.front(), que.pop(), cal(p.h, b); if (p.h == 46685) &#123;//46685是目标状态的康托展开值 cout &lt;&lt; p.step; return 0; &#125;//下面分四个状态转移 if (p.begin % 3 != 0) &#123; swap(b[p.begin], b[p.begin - 1]), h = Hash(b), swap(b[p.begin], b[p.begin - 1]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin - 1)), vis[h] = true; &#125; if ((p.begin + 1) % 3 != 0) &#123; swap(b[p.begin], b[p.begin + 1]), h = Hash(b), swap(b[p.begin], b[p.begin + 1]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin + 1)), vis[h] = true; &#125; if (p.begin &gt; 2) &#123; swap(b[p.begin], b[p.begin - 3]), h = Hash(b), swap(b[p.begin], b[p.begin - 3]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin - 3)), vis[h] = true; &#125; if (p.begin &lt; 6) &#123; swap(b[p.begin], b[p.begin + 3]), h = Hash(b), swap(b[p.begin], b[p.begin + 3]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin + 3)), vis[h] = true; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地降低时间复杂度，本题最好用双向BFS。双向BFS只适用于目标状态已知的情况（比如本题）。做法是开两个队列，分别从初始状态和目标状态转移，直到两个队列中出现重合状态。在某些情况下，这种方法可以大大提升效率。需要注意双向BFS时,visited数组需要额外记录这个状态是哪一个分枝访问到的。在转移时如果发现下一个状态已经被另一个分枝访问到了，则可以得出答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;using namespace std;int jc[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int vis[362880] = &#123;0&#125;, step1[362880] = &#123;0&#125;, step2[362800] = &#123;0&#125;;inline int Hash(const char *op) &#123; int ans = 0; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = 0; for (int j = i + 1; j &lt; 9; j++)if (op[j] &lt; op[i])s++; ans += s * jc[p]; &#125; return ans;&#125;inline void cal(int h, char *op) &#123; bool vis[10] = &#123;false&#125;; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = h / jc[p]; for (int z = 0; z &lt; 9; z++) if (!vis[z]) &#123; if (s == 0) &#123; op[i] = static_cast&lt;char&gt;(z + '0'), vis[z] = true; break; &#125; else s--; &#125; h %= jc[p]; &#125;&#125;inline void print(int x) &#123; cout &lt;&lt; step1[x] + step2[x]; exit(0);&#125;struct Node &#123; int h, begin; Node(int a, int c) : h(a), begin(c) &#123;&#125;&#125;;char b[9];queue&lt;Node&gt; que, que2;int main() &#123; cin &gt;&gt; b; for (int i = 0; i &lt; 9; i++) &#123; if (b[i] == '0') &#123; que.push(Node(Hash(b), i)), vis[Hash(b)] = 1; break; &#125; &#125; if (Hash(b) == 46685) &#123; cout &lt;&lt; 0; return 0; &#125; que2.push(Node(46685, 4)), vis[46658] = 2; Node p(0, 0); int h; while (!que.empty() || !que2.empty()) &#123; if (!que.empty()) &#123;//第一个队列转移 p = que.front(), que.pop(), cal(p.h, b); if (p.begin % 3 != 0) &#123; swap(b[p.begin], b[p.begin - 1]), h = Hash(b), swap(b[p.begin], b[p.begin - 1]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin - 1)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; if ((p.begin + 1) % 3 != 0) &#123; swap(b[p.begin], b[p.begin + 1]), h = Hash(b), swap(b[p.begin], b[p.begin + 1]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin + 1)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; if (p.begin &gt; 2) &#123; swap(b[p.begin], b[p.begin - 3]), h = Hash(b), swap(b[p.begin], b[p.begin - 3]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin - 3)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; if (p.begin &lt; 6) &#123; swap(b[p.begin], b[p.begin + 3]), h = Hash(b), swap(b[p.begin], b[p.begin + 3]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin + 3)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; &#125; if (!que2.empty()) &#123;//第二个队列转移 p = que2.front(), que2.pop(), cal(p.h, b); if (p.begin % 3 != 0) &#123; swap(b[p.begin], b[p.begin - 1]), h = Hash(b), swap(b[p.begin], b[p.begin - 1]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin - 1)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; if ((p.begin + 1) % 3 != 0) &#123; swap(b[p.begin], b[p.begin + 1]), h = Hash(b), swap(b[p.begin], b[p.begin + 1]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin + 1)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; if (p.begin &gt; 2) &#123; swap(b[p.begin], b[p.begin - 3]), h = Hash(b), swap(b[p.begin], b[p.begin - 3]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin - 3)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; if (p.begin &lt; 6) &#123; swap(b[p.begin], b[p.begin + 3]), h = Hash(b), swap(b[p.begin], b[p.begin + 3]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin + 3)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2154]虔诚的墓主人]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B4%9B%E8%B0%B7P2154-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小W是一片新造公墓的管理人。公墓可以看成一块N×M的矩形，矩形的每个格点，要么种着一棵常青树，要么是一块还没有归属的墓地。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当地的居民都是非常虔诚的基督徒，他们愿意提前为自己找一块合适墓地。为了体现自己对主的真诚，他们希望自己的墓地拥有着较高的虔诚度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一块墓地的虔诚度是指以这块墓地为中心的十字架的数目。一个十字架可以看成中间是墓地，墓地的正上、正下、正左、正右都有恰好k棵常青树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小W希望知道他所管理的这片公墓中所有墓地的虔诚度总和是多少。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件religious.in的第一行包含两个用空格分隔的正整数N和M，表示公墓的宽和长，因此这个矩形公墓共有(N+1) ×(M+1)个格点，左下角的坐标为(0, 0)，右上角的坐标为(N, M)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含一个正整数W，表示公墓中常青树的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行起共W行，每行包含两个用空格分隔的非负整数xi和yi，表示一棵常青树的坐标。输入保证没有两棵常青树拥有相同的坐标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行包含一个正整数k，意义如题目所示。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件religious.out仅包含一个非负整数，表示这片公墓中所有墓地的虔诚度总和。为了方便起见，答案对2,147,483,648取模。 输入输出样例Sample input 5 6130 20 31 21 32 02 12 42 52 63 23 34 35 22 Sample output 6 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图中，以墓地(2, 2)和(2, 3)为中心的十字架各有3个，即它们的虔诚度均为3。其他墓地的虔诚度为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，满足1 ≤ N, M ≤ 1,000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于60%的数据，满足1 ≤ N, M ≤ 1,000,000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，满足1 ≤ N, M ≤ 1,000,000,000，0 ≤ xi ≤ N，0 ≤ yi ≤ M，1 ≤ W ≤ 100,000，1 ≤ k ≤ 10。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在50%的数据，满足1 ≤ k ≤ 2。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在25%的数据，满足1 ≤ W ≤ 10000。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识到如果一个墓地上、下、左、右各有a、b、c、d棵常青树，则虔诚度为$C_a^kC_b^kC_c^kC_d^k$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从数据范围想思路。发现N和M特别大，所以需要离散化坐标。具体做法是将没有树的行列去除，再对坐标重新编号，这样N，M就降至1e5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使经过了离散化，如果枚举每一个墓地坐标，也需要相当的时间消耗。注意到如果一个墓地的上方或下方没有常青树，那么这个墓地的虔诚度一定为0，不用考虑。所以只需要考虑第一棵常青树和最后一棵常青树之间的部分即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做这个题的思想是：固定一维（横坐标），移动另一位（纵坐标）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先预处理出组合数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离散化之后，将常青树坐标按横坐标为第一关键字，纵坐标为第二关键字升序排序。这样坐标点就按照横坐标进行了分类，并且每一类中纵坐标升序。用数组记录当前每一个纵坐标已经有的树的数量，再用一个变量记录当前横坐标已经有的树的数量，还需要记录每一个纵坐标横坐标的常青树总数。在每一类中，找到相邻的两个坐标点，枚举它们中间部分的墓地坐标点，依次求它们的虔诚度，最后再求和即可。对于每一个遍历到的常青树，更新其纵坐标横坐标已有的常青藤数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这样仍不是最佳策略。注意到两个相邻常青树之间的所有墓地上下的树的数量是不变的，只有左右的树的数量在随纵坐标的变化而变化。对于每一个纵坐标，它都有自己的$C_c^kC_d^k$值，这样求两个相邻常青树之间墓地虔诚度的和就相当于求一个区间和，再乘以一个$C_a^kC_b^k$。每遍历到一棵常青树，需要更新这个节点的值，因此需要一种可以修改节点值又能求区间和的数据结构，肯定首选树状数组。于是用树状数组维护前缀和，这样时间复杂度降至O(wlogw)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 100000using namespace std;struct Point &#123; int x, y, t;&#125; op[MAX];int n, m, w, k, C[MAX + 1][11] = &#123;0&#125;, ySum[MAX + 1] = &#123;0&#125;, xSum[MAX + 1] = &#123;0&#125;, now[MAX + 1] = &#123;0&#125;;int cnt = 0;int tree[MAX + 1] = &#123;0&#125;;//树状数组bool cmp1(Point x, Point y) &#123; if (x.x == y.x)return x.y &lt; y.y; return x.x &lt; y.x;&#125;bool cmp2(Point x, Point y) &#123; return x.y &lt; y.y;&#125;inline void add(int x, int y) &#123; for (int i = x; i &lt;= m; i += (i &amp; -i))tree[i] += y;&#125;inline int get(int x) &#123; int s = 0; for (int i = x; i &gt; 0; i -= (i &amp; -i))s += tree[i]; return s;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; w; for (int i = 0; i &lt; w; i++)cin &gt;&gt; op[i].x &gt;&gt; op[i].y; cin &gt;&gt; k; C[1][0] = C[1][1] = 1; for (int i = 2; i &lt;= w; i++) &#123;//求组合数 C[i][0] = 1; for (int j = 1; j &lt;= min(k, i); j++)C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; sort(op, op + w, cmp2);//y升序排序，离散化纵坐标 for (int i = 0; i &lt; w; i++) &#123; if (i == 0 || op[i].y != op[i - 1].y)cnt++; op[i].t = cnt; ySum[cnt]++; &#125; m = cnt; for (int i = 0; i &lt; w; i++)op[i].y = op[i].t; sort(op, op + w, cmp1), cnt = 0;//离散化横坐标 for (int i = 0; i &lt; w; i++) &#123; if (i == 0 || op[i].x != op[i - 1].x)cnt++; op[i].t = cnt; xSum[cnt]++; &#125; n = cnt; for (int i = 0; i &lt; w; i++)op[i].x = op[i].t; int ans = 0, np = 0; for (int i = 0; i &lt; w; i++) &#123; add(op[i].y, C[now[op[i].y] + 1][k] * C[ySum[op[i].y] - now[op[i].y] - 1][k] - C[now[op[i].y]][k] * C[ySum[op[i].y] - now[op[i].y]][k]); now[op[i].y]++; if (i == 0 || op[i].x != op[i - 1].x)np = 0; else ans += (get(op[i].y - 1) - get(op[i - 1].y)) * C[np][k] * C[xSum[op[i].x] - np][k]; np++; &#125; cout &lt;&lt; (ans &amp; ((1 &lt;&lt; 31) - 1)); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个小技巧：如果结果是通过加减乘三种运算得到的并且需要对2147483648（即231）取模，可以利用int的自然溢出来完成这个操作。具体做法是不用每一步都取模，最后让答案与(1&lt;&lt;31)-1取按位与，这是一个优化常数的常用方法。该方法可行性可用补码性质证明。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
        <tag>树状数组</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1641]生成字符串]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%B4%9B%E8%B0%B7P1641-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lxhgww最近接到了一个生成字符串的任务，任务需要他把n个1和m个0组成字符串，但是任务还要求在组成的字符串中，在任意的前k个字符中，1的个数不能少于0的个数。现在lxhgww想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据是一行，包括2个数字n和m。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出数据是一行，包括1个数字，表示满足要求的字符串数目，这个数可能会很大，只需输出这个数除以20100403的余数。 输入输出样例Sample input 2 2 Sample output 2 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每点2秒&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，保证1≤m≤n≤1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，保证1≤m≤n≤1000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来源：SCOI 2010 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更让人头秃的计数题（前一个是这个）…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符序号（从1开始）看做横坐标x，前x个字符中1的数目与0的数目之差为纵坐标y，那么字符的选取可以看做坐标系上从点(0，0)开始的一条条连续的折线，它的终点为(n+m，n-m)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据这个思路，从点(0，0)开始，选1就向右上方走，选0向右下方走，直到点(n+m，n-m)。这样的总的连线便对应一个字符串，容易知道若折线终点为(n+m，n-m)，那么整个过程1的数量一定为n，0的数量一定为m，不可能超出这个限制。显然在这种情况下方案数为$C^m_{n+m}$（从n+m步中选m步向下走）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何限制前k个字符中1的数量不小于0的数量呢？如果1的数量小于0的数量，则纵坐标应小于0，连线一定与y=-1有所交集。下面证明与y=-1有交集的方案数与从(0，-2)开始到(n+m，n-m)方案数相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个从(0，0)开始且与y=-1有交集的连线（称之为非法连线），取其与y=-1的第一个交点p，将[0，p]的部分折到y=-1的下方。这样得到的连线显然是唯一的并且起点成为(0，-2)，这还是一个从(0，-2)开始结束于(n+m，n-m)的连线。同样对于一个从(0，-2)开始结束于(n+m，n-m)的连线，它与y=-1必然有交集，取其第一个交点p，将[0，p]的部分折到上方，得到一条从(0，0)开始的非法连线。从上面的讨论可以看出，非法连线与从(0，-2)开始在(n+m，n-m)结束的连线有着一一对应关系，它们的方案数必然是相同的，证毕。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那从(0，-2)到(n+m，n-m)有多少方案呢？由于每一次都一定向右走，但是不一定向上还是向下，不妨假设向上走了x步，则向下走了m+n-x步，由于最后停在了(n+m，n-m)上，故有： x-(m+n-x)=n-m+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解得x=n+1，所以方案数为$C_{n+m}^{n+1}$，这个数也等于$C_{n+m}^{m-1}$。于是题目实质上是求$C_{m+n}^m-C_{m+n}^{m-1}$对20100403的模。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先想到的是杨辉三角递推法，但那样一定会超时。注意到组合数的阶乘公式为： C_n^m=\frac {n!} {m!(n-m)!}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分子分母的模很易求，但除法的模并不那样易求，这里需要乘法逆元来求除法的模（20100403是一个大质数）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需预处理出阶乘，再用费马小定理或者扩展欧几里得算法求出逆元，利用逆元求出除法的模，问题便得以解决。123456789101112131415161718192021222324252627282930//费马小定理求逆元#include&lt;iostream&gt;#define MOD 20100403using namespace std;long long op[2000001], n, m;inline long long find(long long x) &#123;//快速幂 int p = MOD - 2; long long ans = 1; while (p &gt; 0) &#123; if ((p &amp; 1) &gt; 0)ans *= x, ans %= MOD; x *= x; x %= MOD; p &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; op[0] = 1; for (int i = 1; i &lt;= n + m; i++)op[i] = op[i - 1] * i % MOD; long long a = find(op[m] * op[n] % MOD), b = find(op[m - 1] * op[n + 1] % MOD);//a和b是逆元 long long c = op[n + m] * a % MOD, d = op[n + m] * b % MOD; long long ans = c - d; if (ans &lt; 0)ans += MOD; cout &lt;&lt; ans; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435//扩展欧几里得算法求逆元#include&lt;iostream&gt;#define MOD 20100403using namespace std;long long op[2000001], n, m;int exGcd(int a, int b, long long &amp;x, long long &amp;y) &#123;//扩展欧几里得算法 if (b == 0) &#123; x = 1, y = 0; return a; &#125; int t = exGcd(b, a % b, y, x); y -= a / b * x; return t;&#125;inline long long find(int p) &#123; long long x, y; exGcd(MOD, p, x, y); while (y &lt; 0)y += MOD; return y % MOD;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; op[0] = 1; for (int i = 1; i &lt;= n + m; i++)op[i] = op[i - 1] * i % MOD; long long a = find(op[m] * op[n] % MOD), b = find(op[m - 1] * op[n + 1] % MOD); long long c = op[n + m] * a % MOD, d = op[n + m] * b % MOD; long long ans = c - d; if (ans &lt; 0)ans += MOD; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乘法逆元在OI中常用于在除法运算取模，这是一个重要方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先认识什么是乘法逆元，对于整数a，若存在整数x使得$ax\equiv1(mod\ p)$，则称x为a关于1模p的乘法逆元。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将同余式化为整除式可得$ax+py=1$，根据裴蜀定理可知a与p互质，即$gcd(a,p)=1$。这说明当且仅当a与p互质时，a关于模p的乘法逆元才存在。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乘法逆元有什么作用呢？它常用于除法的取模，已知： (a+b)\ mod\ p=(a\ mod\ p+b\ mod\ p)\ mod\ p\\ (a-b)\ mod\ p=(a\ mod\ p-b\ mod\ p)\ mod\ p\\ ab\ mod\ p=(a\ mod\ p)(b\ mod\ p)\ mod\ p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是除法并没有： \frac a b\ mod\ p=\frac {a\ mod\ p} {b\ mod\ p}\ mod\ p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这对计算除法的模带来困难，乘法逆元可以解决这个问题，假设最后结果为x，则有： \frac a b\equiv x(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当b与p互质时，上式等价于： a\equiv bx(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设b的乘法逆元为b-1，即有： bb^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么有： ab^{-1}\equiv b^{-1}bx\equiv x(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以如果要算a/b对p的模，只需计算ab-1对p的模即可，关键在于求b的逆元。下面先介绍两种通用方法。 用费马小定理求解逆元 【费马(Fermat)小定理】当p为质数且a与p互质时，有$a^{p-1}\equiv 1(mod\ p)$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;费马小定理变形一下得到$aa^{p-2}\equiv 1(mod\ p)$，那么逆元就是ap-2。用快速幂算法求出ap-2并取模就是逆元。这个方法需要p为质数，并且a与p互质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;费马小定理其实是欧拉定理的特殊情况，p不为质数时，用欧拉函数值代替p-1然后求逆元也是可以的，这样便不要求p为质数。 用扩展欧几里得算法求解逆元 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当a与p互质时，可以用扩展欧几里得算法求出一个特解x、y使得$ax+bp=1$，也就是$ax\equiv 1(mod\ p)$，这样x就是逆元。本方法只需要a与p互质（这也是逆元存在的条件），缺点是求出的x可能为负数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若用inv(x)来表示x的乘法逆元，则有： inv(ab)\equiv inv(a)inv(b)(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这说明逆元是积性的，很容易证明，这是逆元的一个重要性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后介绍逆元的递推求法。对于一个数a，现欲求a在模p意义下的逆元，根据带余除法原理，可以将p表示为ak+b。假设b的逆元为b-1，那么： bb^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是： (p-ak)b^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即： pb^{-1}-akb^{-1}\equiv -akb^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此： -kb^{-1}\equiv a^{-1}(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就得到了一个递推式： inv(a)\equiv -(p/a)inv(p\ mod\ a)(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个递推式可以帮助我们在O(n)复杂度下求出1~n的逆元。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1357]花园]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%B4%9B%E8%B0%B7P1357-%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小L有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为1~N(2≤N≤1015)。他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则，任意相邻M(2≤M≤5,M≤N)个花圃中有不超过K(1≤K&lt;M)个C形的花圃，其余花圃均为P形的花圃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，N=10,M=5,K=3。则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCPCPPPPCC 是一种不符合规则的花圃；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCPPPPCPCP 是一种符合规则的花圃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请帮小L求出符合规则的花园种数Mod 1000000007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现请您编写一个程序解决此题。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行，三个数N,M,K。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花园种数Mod 1000000007 输入输出样例Sample input#1 10 5 3 Sample output#1 458 Sample input#2 6 2 1 Sample output#2 18 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道让人头秃的计数题，考察图论、矩阵快速幂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到m和k都很小，十分有利于状态压缩，可以用一个二进制数表示花园的种类序列。比如对于题目中给出的CCPPPPCPCP序列，可以写成：1100001010。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在样例一下，m=5，发现上面给出的例子便是样例一的一个合法解，将它拆成若干个长度为5的连续子序列，得到：11000、10000、00001、00010、00101、01010，由于是环，故还有后面的部分：10101、01011、10110、01100。这里每一个子序列都是合法的，易知它们的种类是有限的，这样总的序列可以看做是这些子序列的一个排列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现这些序列有很明确的后继关系：后一个序列总是前一个序列去掉最高位再在末尾加上0或1得到的。将每一个合法子序列看作节点，这种后继关系看作有向边，可以建立一个图。那么要求的序列就是这个图上的一条路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目要求是环也不影响做法。在上文给出的01序列的最后补充一个11000，这样序列首尾相同，将它们首尾连接得到的一定是一个合法的环。因此题目等价于求图上所有边数为n的回路数量，这是因为回路与要求的环有着一一对应的关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求长度固定的回路条数便成问题的重点，这里需要邻接矩阵来完成这项操作。有一个基本事实： 设一个图的邻接矩阵为S，则Sn中第i行第j列的元素表示节点i到节点j长度为n的路的数量。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个结论很重要，它是求路数量问题的一个重要解法原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于图的规模很小，邻接矩阵空间占用不大，因此可以对矩阵求n次幂，从而找到路的数量。求幂当然选择矩阵快速幂，而回路怎么找呢？回路可以看作节点i到节点i本身的路，也就是主对角线上的元素，求完幂后将主对角线上的元素加起来再取模就是答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#define MOD 1000000007using namespace std;int m, k, cnt = 0;long long n;int to1[100], to2[100];struct Matrix &#123; long long op[100][100] = &#123;0&#125;; void operator*=(Matrix x) &#123; long long temp[100][100] = &#123;0&#125;; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++) &#123; for (int k = 1; k &lt;= cnt; k++)temp[i][j] += op[i][k] * x.op[k][j], temp[i][j] %= MOD; &#125; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++)op[i][j] = temp[i][j]; &#125; &#125;&#125;;inline int check(int x) &#123; int ans = 0; while (x &gt; 0) &#123; if ((x &amp; 1) &gt; 0)ans++; x &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; (1 &lt;&lt; m); i++) &#123; int tp = check(i); if (tp &lt;= k)cnt++, to1[cnt] = i, to2[i] = cnt;//构造双向映射 &#125; Matrix sta, E; for (int i = 1; i &lt;= cnt; i++) &#123; int temp = (to1[i] &amp; ((1 &lt;&lt; (m - 1)) - 1)) &lt;&lt; 1;//去首并左移 if (check(temp) == k)sta.op[i][to2[temp]] = 1;//填邻接矩阵 else sta.op[i][to2[temp]] = sta.op[i][to2[temp + 1]] = 1; &#125; for (int i = 1; i &lt;= cnt; i++)E.op[i][i] = 1;//单位阵 while (n &gt; 0) &#123;//矩阵快速幂 if ((n &amp; 1) &gt; 0)E *= sta; sta *= sta; n &gt;&gt;= 1; &#125; long long ans0 = 0; for (int i = 1; i &lt;= cnt; i++)ans0 += E.op[i][i], ans0 %= MOD;//对角线求和取模 cout &lt;&lt; ans0; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶梯Nim]]></title>
    <url>%2F2019%2F01%2F23%2F%E9%98%B6%E6%A2%AFNim%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章是简单博弈论和SG定理的延伸。本次介绍博弈论中阶梯Nim游戏及其转化性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是阶梯Nim游戏。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定几个阶梯，编号为1~n，每一个阶梯上有若干个石子。你和队手轮流任意选取一个有石子的阶梯，将任意数量（至少为1）个石子移动到下一个阶梯上（从编号为i的阶梯拿到i-1阶梯上，如果i=1，则直接拿走石子），首先拿走所有石子的一方胜利。给定阶梯数和每一个阶梯上的石子数，若你先手，如何判断你是否必胜策略？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阶梯Nim游戏有一个简洁的性质：阶梯Nim游戏的必胜必败性质（P/N性质）与在奇数编号阶梯上做Nim游戏的性质相同。以操作为证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在奇数阶梯上Nim游戏必胜，那么你可以采取以下策略： 按照Nim游戏的必胜策略将某一奇数阶梯上的一些石子移动到其下的偶数阶梯上（相当于丢弃）。 若对手也移动奇数阶梯上的石子，他的做法也相当于“配合你做Nim游戏”，即将奇数堆上的石子“丢弃”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几轮后，你一定可以移动走某个奇数堆上的最后若干颗石子，这时如果偶数堆上没有石子，那么你已经获胜了，否则所有石子都应该在偶数堆上。对于后者的情况，由于之后对手要再进行操作，他只能将某偶数堆上的石子移动到其下的奇数堆上，你只需要把它们再移动到再其下的偶数堆上即可，若如此做，则游戏又回到仅有偶数堆上有石子的局面，然后对手继续移动……经过这样的操作，对手只能将石子从偶数堆移到奇数堆，而你一直将石子从奇数堆移动到偶数堆。而获胜的局面是什么呢？显然是仅有第一堆上有石子，然后将它们拿走（相当于移动到第0堆），这是一个从奇数堆移动石子到偶数堆的操作，这个操作显然只有你（先手）能做，因此先手必胜。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对手在操作中将偶数堆石子移到奇数堆中又如何做呢？这时只需要将这些石子再移动到再其下的偶数堆即可。两次操作没有影响奇数堆的石子数量，只是影响了偶数堆上石子数目，最终仍可化为上文所述的局面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;必败的等价性质类似证明即可。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2575]高手过招]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%B4%9B%E8%B0%B7P2575-%E9%AB%98%E6%89%8B%E8%BF%87%E6%8B%9B%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AKN玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个n*20的棋盘，以及棋盘上有若干个棋子，问谁赢？akn先手！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏规则是这样的：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个棋子，能将它向右移动一格，如果右边有棋子，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个T，表示T组数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每组数据第一行n，表示n*20的棋盘&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n行每行第一个数m表示第i行有m个棋子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后跟着m个数pj表示第i行的棋子布局 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果AKN能赢，则输出”YES”，否则输出”NO”。 输入输出样例Sample input 212 19 2021 191 18 Sample output NOYES 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10%的数据T≤1，n≤1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外10%的数据m≤1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据T≤100，n≤1000，m≤20，1≤pj≤20 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较裸的状态压缩类博弈论。注意到跳棋只能在一行内操作，不能跨行，于是就可以将每一行都看成是一个子游戏，整个游戏即为原游戏和。用二进制数表示每一行20个格子的有无状态，递推出SG值，最后根据SG定理求Nim和判断即可。SG函数值可以暴力求出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题可以比较好地练习SG函数求法和SG定理应用，故加入博客。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int SG[1 &lt;&lt; 20];bool vis[20] = &#123;false&#125;;inline int solve(int x, int y) &#123; for (int i = y - 1; i &gt;= 0; i--)if ((x &amp; (1 &lt;&lt; i)) == 0)return i; return -1;&#125;int main() &#123; SG[0] = 0; for (int i = 1; i &lt; (1 &lt;&lt; 20); i++) &#123;//暴力求SG函数值 memset(vis, false, sizeof(vis)); for (int j = 0; (1 &lt;&lt; j) &lt;= i; j++) &#123; if ((i &amp; (1 &lt;&lt; j)) &gt; 0) &#123; int p = solve(i, j); if (p != -1) &#123; vis[SG[((~(1 &lt;&lt; j)) &amp; i) | (1 &lt;&lt; p)]] = true;//这是一个玄学的式子，用于mex运算 &#125; &#125; &#125; for (int j = 0; j &lt; 20; j++) if (!vis[j]) &#123; SG[i] = j; break; &#125; &#125; int T; cin &gt;&gt; T; for (int ti = 0; ti &lt; T; ti++) &#123; int n, ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int k, p = 0; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; int x; cin &gt;&gt; x; p |= (1 &lt;&lt; (20 - x)); &#125; ans ^= SG[p];//求Nim和 &#125; if (ans == 0)cout &lt;&lt; "NO" &lt;&lt; endl;//根据SG函数值判断结果 else cout &lt;&lt; "YES" &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这个方法很粗暴，并不优，但可以在SG函数求取时优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍一种洛谷大佬想出的方法：用阶梯Nim方法解决本问题。要理解该做法，需要先了解什么是阶梯Nim，可以参考这篇博客。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将两个空位之间的部分看做阶梯，其中的棋子数目就是阶梯上的石子数目，那么本问题就相当于做阶梯Nim游戏。比如若仅有18、19处有棋子，那么阶梯就是：第一阶梯2个棋子，之后的阶梯没有棋子，共17个阶梯；又比如仅有18、19、20处有棋子，则阶梯相当于所有阶梯都没有石子，共16个阶梯。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么可以将这个跳棋问题看作阶梯Nim游戏呢？这是由游戏的操作性质决定的。考虑仅有16、17、18处有棋子，那么该局面的二进制表示为011100（只写后几位），对应阶梯为0、3、0（按阶梯编号升序，只写前几位）。这个局面可以转移到001110、010110、011010三个状态，对应的阶梯分别为：（3，0，0）、（2，1，0）、（1，2，0），正好对应了初始阶梯Nim局面的三种移动石子的方式，可见本游戏的棋子移动规则就是阶梯Nim游戏的变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可以用阶梯Nim的方法去求SG值，该方法效率很高，时间复杂度O(20Tn)。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;bool vis[21];int temp[20] = &#123;0&#125;;int main() &#123; int T; cin &gt;&gt; T; for (int ti = 0; ti &lt; T; ti++) &#123; int n, ans = 0, ans0 = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int k, last = -1; ans0 = 0; cin &gt;&gt; k; memset(vis, false, sizeof(vis)); temp[0] = 0; for (int j = 0; j &lt; k; j++) &#123; int x; cin &gt;&gt; x; vis[x] = true; &#125; for (int j = 20; j &gt; 0; j--) &#123; if (!vis[j]) &#123; if (last != -1)temp[++temp[0]] = last - j - 1; last = j; &#125; &#125; if (last != 1)temp[++temp[0]] = last - 1; for (int j = 1; j &lt;= temp[0]; j += 2)ans0 ^= temp[j]; ans ^= ans0; &#125; if (ans == 0)cout &lt;&lt; "NO" &lt;&lt; endl; else cout &lt;&lt; "YES" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单博弈论和SG定理]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%92%8CSG%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博弈论是OI和数学竞赛中的重要一项，它考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看这样一个经典问题（Nim游戏）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定若干堆石子，你和队手轮流选取任意一堆石子，拿走其中的若干颗（没有上界，不能不拿）。首先拿走所有石子的人获胜（也就是面临所有石子都被拿走局面的人判负）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种游戏规则下，给定每一堆石子的数量，如何判断先手有没有必胜的可能？这里直接给出定理： 【Bouton定理】Nim游戏中，先手必败等价于$A_1\ xor\ A_2\ xor\ …\ xor\ A_n=0$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$A_i$为第i堆石子的数量，xor表示按位求和并模2取余，也就是异或，对应C语言中的^。这种操作也称Nim和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nim游戏拥有很简洁的结论，下面的SG函数以及SG定理则将其推广到更一般化的问题上。要了解SG函数，需要理解以下两个概念。 $P-position(P点)：$ 必败点。在P点时，无论如何操作，只要队手不失误，必败。 $N-position(N点)：$ 必胜点。在N点时，无论对手如何操作，只要自己不失误，必胜。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P/N点有以下性质： 当游戏到达没有任何合法操作的局面时（比如Nim游戏中的石子全部被取走时），面临该局面的一方判负，也就是P点。 P点的后继一定是N点。 N点的后继中至少有一个P点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是公平组合游戏(ICG)的概念，它是满足以下几点条件的游戏： 有且仅有两人参与。 游戏局面的状态集合有限。 对于同一个局面，两个游戏者的可操作集合完全相同。 游戏者轮流进行游戏。 当无任何合法操作时游戏结束，面临者判负。 无论游戏如何进行，总可以在有限步数之内结束。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此来看Nim游戏是ICG，象棋不是ICG（因为双方只能操作自己的棋子，不满足第3条）。这里只探讨ICG。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个ICG，可以将其抽象为一个有向无环图，图的节点是游戏的一个局面，有向边表示局面通过合法操作进行的转化。显然没有出度的节点必然代表着游戏的结束。ICG的进行可以看作是在图上移动棋子的过程：起初棋子在最初局面上，然后双方轮流将棋子沿有向边移动到下一个节点，直到有一方无法移动时判负。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一个节点，都可以判定它是P点还是N点，如果可以找到处态的P/N性质，那么判定先手能否获胜的问题就得到解读。终点显然是P点，下面来探讨其余点的P/N性质。根据P点和N点的定义有以下结论： 如果一个节点的后继均为N点，则该点为P点。 如果一个节点的后继存在P点，则该点为N点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种递推关系，可以得到初态的P/N性质。在博弈论中，SG函数用来描述一个局面的P/N性质，要理解SG函数需要先引入mex(minimal excludant)运算。设$N$为自然数集合，对于任何$S\subseteq N$，定义： mexS=\min\{x|x\in N,x\notin S\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，mexS表示不在S中的最小自然数。我们用mex运算来定义SG函数，定义如下： SG(x)=mex\{SG(p_1),SG(p_2),...,SG(p_m)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$p_i$是x的m个后继。特别地，当x没有后继时（也就是终点），其SG值为$mex\varnothing$，即为0。这样易知一个局面为P点等价于其SG值非0。简单归纳证明如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先所有终点都为P点，SG值为0，成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如若后继中存在P点，则取mex后值一定大于0，该点即为N点；若后继中不存在P点，则取mex后值一定为0，该点即为P点。这与P点N点定义及性质一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SG函数是解决ICG问题的利器。但是既然可以直接递推求出P/N性质，为何还要引入SG函数呢？这是因为SG函数有一个强大的定理——SG（Sprague-Grundy）定理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入SG定理前，先来认识游戏和的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个游戏可能是由多个子游戏组成的（将其记作$G_1,G_2…G_n$），如果整个游戏进行时，玩家可以任意选取一个子游戏进行上面的合法操作，所有子游戏均无法进行合法操作时判负。这时的整个游戏称为子游戏的游戏和，记作$G=G_1+G_2+…+G_n$。于是有SG定理： 【SG定理】游戏和的SG值为所有子游戏SG值的Nim和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样可以将一个游戏分成若干子游戏，从而分而治之，求出SG值。从这里可以发现Bouton定理与SG定理的内在联系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nim游戏其实就是由若干子游戏组成的，每个子游戏都是如下的形式：给一堆石子，从中拿走至少一个石子，先全部拿走者胜。这个子问题很无聊，因为只要一开始石子数非零，则先手必胜（直接全部拿走即可）。但是可以从另一个角度去理解这个问题。注意到当前石子数是局面的唯一描述变量，设其为x。我们证明SG(x)=x，证明如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用归纳证明。显然SG(0)=0；假设x≤k时均成立，由于可以从k+1个石子中任意拿石子，故0~k都是k+1这个局面的后继，所以： SG(k+1)=mex\{SG(k),SG(k-1),...,SG(0)\}=mex\{k,k-1,...,0\}=k+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即对x=k+1也成立，故SG(x)=x是正确的。这样根据SG定理，游戏和（即Nim游戏）的SG值为： SG=SG(A_1)\ xor\ SG(A_2)\ xor\ ...\ xor\ SG(A_n)=A_1\ xor\ A_2\ xor\ ...\ xor\ A_n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个值为0时，说明游戏初态局面为P点，先手必败，于是证明了Bouton定理。可以发现Bouton定理是SG定理在Nim问题上的直接应用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SG函数以及SG定理是解决组合游戏问题的利器，下面举几个例子。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mr.Jia和Boy next door在玩一个游戏。一开始有一个正整数x，可以进行对其进行两种操作：x/2(向下取整)和x-1。现在Mr.Jia和Boy next door轮流进行任意一种操作，先得到0的一方胜利。现在若Mr.Jia先进行操作，给定初始的数x，判断Mr.Jia能否获胜。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要吐槽Boy next door。这是TJU某次编程竞赛的第四题，用SG函数可以轻松做出。注意到SG值非零的时候表示必胜，它的具体值并没有意义，不妨将其统一为1，这样可以简化算法。123456int SG(int x) &#123; if (x == 0)return 0; int a = SG(x / 2), b = SG(x - 1); if (a != 0 &amp;&amp; b != 0)return 0;//后继无0说明x为P点 return 1;//后继有0说明x为N点&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用上面代码求出SG值即可，需要用递推或记忆化优化，这里只点明思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实在做这题时，发现如果把x写成k2s（k为奇数），则s为偶数则Mr.Jia赢，否则Boy next door赢。这是一个靠眼力得出的结论，实际上也是正确的，现在来用SG函数来证明这个结论。这里的SG函数可以看成是一个bool类型的函数，有递推式： SG(x)=\begin{cases}false\ & x=0\\ !SG(x/2)||!SG(x-1)\ & x>0 \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现x=1时SG(1)为true，表示Mr.Jia赢，1对应的s为0，0是偶数，这是正确的。假设x≤p时都正确，下证x=p+1也正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若x为偶数且x=k2s（k为奇数且s&gt;0）。注意到x-1一定是奇数，根据归纳假设SG(x-1)=true。x/2必然为k2s-1，若s为偶数，则s-1为奇数，由归纳假设SG(x/2)=false，则SG(x)=true，成立；若s为奇数，则s-1为偶数，由归纳假设SG(x/2)=true，则SG(x)=false，同样成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若x为奇数（只考虑大于1的情况），设x=k2s+1，这里k为奇数。若s为偶数，则由归纳假设SG(x-1)=true，SG(x/2)=SG(k2s-1)=false，那么SG(x)=true，成立；若s为奇数，则由归纳假设SG(x-1)=false，SG(x)必然为true，也成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，结论是正确的，也就是说可以用给定数中2因子的个数来判定答案，这样对于一个数n，就可以在O(logn)复杂度下判断。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一题（洛谷P1290）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欧几里德的两个后代Stan和Ollie正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数M和N，从Stan开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于&gt;0。然后是Ollie，对刚才得到的数，和M，N中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25，7)两个数游戏的过程：Start：25 7Stan：11 7Ollie：4 7Stan：4 3Ollie：1 3Stan：1 0Stan赢得了游戏的胜利。现在，假设他们完美地操作，谁会取得胜利呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这仍然是一个ICG，可以考虑SG函数，发现有如下的递推式（假设n≥m）： SG(n,m)=mex\{SG(n-m,m),SG(n-2m,m),...,SG(n\%m,m)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递推式通俗易懂，但它并不利于实际操作，这时适当的观察是有益的。发现： SG(n-m,m)=mex\{SG(n-2m,m),...,SG(n\%m,m)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子说明只要知道SG(n%m，m)，就可以递推求出上面式子中的所有值。若SG(n%m，m)=0，则SG(n%m+m，m)=1，SG(n%m+2m，m)=2…之后的值均非零。若SG(n%m，m)=1，则SG(n%m+m，m)=0，之后的值均非零，于是得出一个重要结论：当SG(n%m，m)=0时，SG(n，m)必非零；当SG(n%m，m)=1时，若n/m&gt;1则SG(n，m)非零，若n/m=1则SG(n，m)=0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与上一题思想相似，非零全部按1处理，于是有：123456int getSG(int x, int y) &#123; if (x &lt; y)swap(x, y); if (y == 0)return 0; if (x / y == 1 &amp;&amp; getSG(y, x % y) == 1)return 0; return 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求出SG值判断即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三题，洛谷P2148，山东2009年省选题： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小E 与小W 进行一项名为“E&amp;D”游戏。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏的规则如下： 桌子上有2n 堆石子，编号为1..2n。其中，为了方便起见，将第2k-1 堆与第2k 堆 （1 ≤ k ≤ n）视为同一组。第i堆的石子个数用一个正整数Si表示。 一次分割操作指的是，从桌子上任取一堆石子，将其移走。然后分割它同一组的另一堆 石子，从中取出若干个石子放在被移走的位置，组成新的一堆。操作完成后，所有堆的石子 数必须保证大于0。显然，被分割的一堆的石子数至少要为2。 两个人轮流进行分割操作。如果轮到某人进行操作时，所有堆的石子数均为1，则此时 没有石子可以操作，判此人输掉比赛。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小E 进行第一次分割。他想知道，是否存在某种策 略使得他一定能战胜小W。因此，他求助于小F，也就是你，请你告诉他是否存在必胜策略。 例如，假设初始时桌子上有4 堆石子，数量分别为1,2,3,1。小E可以选择移走第1堆， 然后将第2堆分割（只能分出1 个石子）。接下来，小W 只能选择移走第4 堆，然后将第3 堆分割为1 和2。最后轮到小E，他只能移走后两堆中数量为1 的一堆，将另一堆分割为1 和1。这样，轮到小W 时，所有堆的数量均为1，则他输掉了比赛。故小E 存在必胜策略。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个游戏和，子游戏是从两堆石子中任取一堆分割。对于石子堆数为x，y的一个组合，可以用SG(x，y)表示这个子游戏的SG值。x与y均为1时SG值为0，当两者均非1时，显然有两种总的策略：分x和分y。发现分割操作只与一个数有关而与另一个数无关，不妨只探讨一个数p的分割情况，并观察其SG值的规律。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出1~10的SG值（实质上是SG(1，1)~SG(1，10)，自行理解）并写出mex后继集合：用二进制数表示，0表示不存在，1表示存在，那么有： 1：00000002：00000013：00000104：00000115：00001006：00001017：00001108：00001119：000100010：0001001 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惊奇地发现，x对应的mex后继集合居然就是x-1的二进制表示！那么SG(n，m)就是(n-1)|(m-1)的二进制表示中第一个0出现的位置！那么getSG函数可以轻松写出：12345int getSG(int a, int b) &#123; int ans = (a - 1) | (b - 1), r = 0; while ((ans &amp; 1) == 1)ans &gt;&gt;= 1, r++; return r;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那游戏和的SG值如何求呢？整个游戏有2n堆石子，是由n个子游戏组成的。根据SG定理，将这n组的SG值一一求出，取Nim和就可以得到游戏和的SG值，于是问题迎刃而解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这里可以看出，找SG函数的规律是一个很实用的技巧，可以先找到SG函数的规律再用这个规律快速求SG值，从而解出原题。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展欧几里得算法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文探讨扩展欧几里得算法，这是一个基础而常用的数论算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，欧几里得算法（辗转相除法）是求解两数最大公约数的算法，前文又认识到stein算法用于在高精度下代替欧几里得算法。扩展欧几里得算法又是做什么的呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩展欧几里得算法不仅可以求出两数（假如为a，b）的最大公因数，还可以求出方程$ax+by=gcd(a,b)$的一个特解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在过河的题后注解中，已经认识到了模线性方程解的性质，这里不再重复。下面探讨算法思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑数15和36，它们的欧几里得算法过程如下： 36\div 15=2\cdots \cdots 6\\ 15\div6=2\cdots \cdots 3\\ 6\div 3=2\cdots \cdots 0\\ 3\div 0 =X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以最大公约数为3。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现整个过程中出现了4个算式，对于每一个式子中的被除数和除数，将其设为a、b（比如第一个式子中a=36，第二个中a=15），并设gcd(36，15)=g，考虑a和b的一组特解x1、y1，那么有： ax_1+by_1=g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将这个式子扩展下去。根据带余除法原理，可以把a写成如下形式： a=kb+r,0\leq r]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数论</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂与矩阵方法]]></title>
    <url>%2F2019%2F01%2F20%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E7%9F%A9%E9%98%B5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍矩阵快速幂以及矩阵在OI中的简单应用。本文需要一些线性代数知识作铺垫，这里不再重复。关于快速幂的思想，建议先阅读快速幂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先看这么一道题（洛谷P1307）： 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于Fibonacci数列：1,1,2,3,5,8,13……大家应该很熟悉吧~~~但是现在有一个很“简单”问题：第n项和第m项的最大公约数是多少？ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个正整数n和m。（n,m≤109）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：数据很大 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fn和Fm的最大公约数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于看了大数字就头晕，所以只要输出最后的8位数字就可以了。 输入输出样例Sample input 4 7 Sample output 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决本题需要先认识到一个事实（证明略）： gcd(Fib(n),Fib(m))=Fib(gcd(n,m))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是只需要求出n与m的最大公因数，再找它所对应的一位即可。注意在整个过程中对1e8取模，时间复杂度O(gcd(n,m))。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，对于很大的数（比如本题达到1e9的数量级），循环1e9次显然会超时。于是需要借助矩阵这个工具来简化运算过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵是解决线性问题的利器。所谓运用矩阵工具，就是要善于发现题目中的线性关系。注意到斐波那契数列的递推式为： Fib(n+1)=Fib(n)+Fib(n-1),n\geq 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个典型的线性关系，立即可以得到（用f(x)表示Fib(x)）： \begin{bmatrix} f(n+1)\\ \end{bmatrix}= \begin{bmatrix} 1&1 \end{bmatrix} \begin{bmatrix} f(n)\\ f(n-1) \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现两侧的非常数矩阵形式不同，不利于递推，于是把它扩展为： \begin{bmatrix} f(n+1)\\ f(n) \end{bmatrix}= \begin{bmatrix} 1&1\\ 1&0 \end{bmatrix} \begin{bmatrix} f(n)\\ f(n-1) \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行如下定义： X(n)=\begin{bmatrix}f(n+1)\\f(n)\end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么有递推关系： X(n)=\begin{bmatrix}1&1\\1&0\end{bmatrix}X(n-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是斐波那契数列的矩阵递推式，反复利用递推公式可以得到： X(n)=\begin{bmatrix}1&1\\1&0\end{bmatrix}^{n-1}\begin{bmatrix}1\\1\end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是斐波那契数列的矩阵通项公式，问题转化为如何快速求矩阵的幂。结合整数快速幂的思想，仍然可以用倍增方法求解矩阵的幂，将求矩阵乘积次数降至对数级别。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵快速幂与整数快速幂有以下几点区别： 矩阵的平方和乘积更复杂，可以采用朴素的行乘列法则暴力求出。 初始化的值由1改为单位矩阵，即：E_n=\begin{bmatrix}1&0\\0&1\end{bmatrix} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用矩阵快速幂优化，本题迎刃而解。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#define MOD 100000000using namespace std;struct Matrix &#123;//2*2矩阵 long long Main[2][2]&#123;&#125;; Matrix(int a, int b, int c, int d) &#123; Main[0][0] = a, Main[0][1] = b, Main[1][0] = c, Main[1][1] = d; &#125; void operator*=(Matrix x) &#123;//重载乘法运算 long long temp[2][2]; temp[0][0] = (Main[0][0] * x.Main[0][0] + Main[0][1] * x.Main[1][0]) % MOD; temp[0][1] = (Main[0][0] * x.Main[0][1] + Main[0][1] * x.Main[1][1]) % MOD; temp[1][0] = (Main[1][0] * x.Main[0][0] + Main[1][1] * x.Main[1][0]) % MOD; temp[1][1] = (Main[1][0] * x.Main[0][1] + Main[1][1] * x.Main[1][1]) % MOD; Main[0][0] = temp[0][0], Main[0][1] = temp[0][1]; Main[1][0] = temp[1][0], Main[1][1] = temp[1][1]; &#125;&#125;;int gcd(int a, int b) &#123; if (a &lt; b)swap(a, b); if (b == 0)return a; return gcd(b, a % b);&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Matrix sta(1, 1, 1, 0), ans(1, 0, 0, 1);//ans为单位阵 int p = gcd(n, m) - 1;//下计算sta的p次方，矩阵快速幂 while (p &gt; 0) &#123; if ((p &amp; 1) == 1)ans *= sta; sta *= sta; p &gt;&gt;= 1; &#125; cout &lt;&lt; (ans.Main[1][0] + ans.Main[1][1]) % MOD; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stein算法]]></title>
    <url>%2F2019%2F01%2F19%2FStein%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次介绍一种在高精度下求最大公约数的算法——stein算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较常规的gcd算法有辗转相除法和更相减损术，但是后者过慢，前者不利于高精度（因为有大量的除法取余运算，对高精度十分不友好），于是需要一种更高效又易于操作的算法。这便是stein算法，它是更相减损术的改进。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法思想如下（比如求x和y的最大公因数）： 如果两个数均为偶数，则两数均取半，答案为2*gcd(x/2，y/2)。 如果两数中有一方为偶数，一方为奇数（假如x为偶数），则偶数取半，答案为gcd(x/2，y)。 如果两数均为奇数，若x=y则答案即为x；否则若x&gt;y，则答案为gcd(x-y，y)，x&lt;y为gcd(x，y-x)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法正确性很容易证明，这里略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复以上过程即可得到答案。容易发现整个过程中只有除以2，乘法和减法运算，在高精度下容易操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面用洛谷P2152 SuperGCD来应用这个算法。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sheng bill有着惊人的心算能力，甚至能用大脑计算出两个巨大的数的GCD（最大公约 数）！因此他经常和别人比赛计算GCD。有一天Sheng bill很嚣张地找到了你，并要求和你比赛，但是输给Sheng bill岂不是很丢脸！所以你决定写一个程序来教训他。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共两行： 第一行：一个数A。 第二行：一个数B。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行，表示A和B的最大公约数。 输入输出样例Sample input 1254 Sample output 6 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于20%的数据，0 &lt; A , B ≤ 1018。 对于100%的数据，0 &lt; A , B ≤ 1010000。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道很裸的高精度gcd，注意压位（这里压8位），用stein算法就可以快速求出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓压位，就是将10进制数按10k进制数储存在数组中（这里选k=8），从而减小时空消耗的方法。压位后的输出是一大坑点，要格外注意前导0数量的准确判定。压位后的运算过程与朴素10进位方法没有大的差别，要注意提前设置好进位base。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题不要用递归，否则MLE，用数组循环即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;string&gt;#define P 8#define Base 100000000using namespace std;long long s1[10000] = &#123;0&#125;, s2[10000] = &#123;0&#125;, ans[10000] = &#123;0&#125;, temp[10000] = &#123;0&#125;;inline int change(string x) &#123;//化字符串为数字 int s = 0; for (int i = 0; i &lt; x.length(); i++)s = s * 10 + x[i] - '0'; return s;&#125;inline bool isEven(const long long *x) &#123;//判断偶数 return x[1] % 2 == 0;&#125;inline void div(long long *x) &#123;//除以2 int r = 0; for (int i = x[0]; i &gt;= 1; i--) &#123; if (x[i] % 2 == 0) &#123; x[i] = (x[i] + r * Base) / 2; r = 0; &#125; else x[i] = (x[i] + r * Base) / 2, r = 1; &#125; if (x[x[0]] == 0)x[0]--;&#125;inline void times(long long *x) &#123;//x=x*2 int r = 0; for (int i = 1; i &lt;= x[0]; i++)x[i] *= 2, x[i] += r, r = x[i] / Base, x[i] %= Base; if (r != 0)x[++x[0]] = r;&#125;inline int cmp(long long *x, long long *y) &#123;//x&lt;y? if (x[0] &lt; y[0])return 1; if (x[0] &gt; y[0])return -1; for (int i = x[0]; i &gt;= 1; i--) if (x[i] &lt; y[i])return 1; else if (x[i] &gt; y[i])return -1; return 0;//=&#125;inline void times2(long long *x, const long long *y) &#123;//x=x*y for (int i = 1; i &lt;= x[0]; i++) &#123; for (int j = 1; j &lt;= y[0]; j++) &#123; temp[j + i - 1] += x[i] * y[j]; &#125; &#125; long long r = 0; x[0] = y[0] + x[0] - 1; for (int i = 1; i &lt;= x[0]; i++) &#123; long long t = temp[i] + r; x[i] = t % Base; r = t / Base; &#125; while (r != 0)x[++x[0]] = r % Base, r /= Base;&#125;inline void sub(long long *x, long long *y) &#123;//x=x-y for (int i = 1; i &lt;= x[0]; i++) &#123; if (x[i] &gt;= y[i])x[i] -= y[i]; else &#123; x[i] = x[i] + Base - y[i];//不够借位 x[i + 1]--; &#125; &#125; for (int i = x[0]; i &gt;= 1; i--)//重新找右值 if (x[i] != 0) &#123; x[0] = i; return; &#125;&#125;inline void print(long long *x) &#123;//输出x int te; for (int i = x[0]; i &gt;= 1; i--) &#123; if (i == x[0]) cout &lt;&lt; x[i]; else &#123; te = Base / 10; while (te &gt; 0)cout &lt;&lt; x[i] / te, x[i] %= te, te /= 10; &#125; &#125; cout &lt;&lt; endl;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = a.length() - 1; i &gt;= 0; i -= P) &#123;//压位 if (i - P + 1 &gt;= 0)s1[++s1[0]] = change(a.substr(i - P + 1, P)); else s1[++s1[0]] = change(a.substr(0, i + 1)); &#125; for (int i = b.length() - 1; i &gt;= 0; i -= P) &#123;//压位 if (i - P + 1 &gt;= 0)s2[++s2[0]] = change(b.substr(i - P + 1, P)); else s2[++s2[0]] = change(b.substr(0, i + 1)); &#125; ans[1] = ans[0] = 1; while (true) &#123;//stein算法执行 if (isEven(s1) &amp;&amp; isEven(s2))div(s1), div(s2), times(ans); else if (isEven(s1))div(s1); else if (isEven(s2))div(s2); else &#123; int status = cmp(s1, s2); if (status == 0) &#123; times2(ans, s1); print(ans); return 0; &#125; else if (status == 1)sub(s2, s1); else sub(s1, s2); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P.S.据说Python代码就两行…Orz]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3084]Photo]]></title>
    <url>%2F2019%2F01%2F19%2F%E6%B4%9B%E8%B0%B7P3084-Photo%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;农夫约翰决定给站在一条线上的N(1 ≤ N ≤ 200,000)头奶牛制作一张全家福照片，N头奶牛编号1到N。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是约翰拍摄了M(1 ≤ M ≤ 100,000)张照片，每张照片都覆盖了连续一段奶牛：第i张照片中包含了编号ai 到 bi的奶牛。但是这些照片不一定把每一只奶牛都拍了进去。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在拍完照片后，约翰发现了一个有趣的事情：每张照片中都有且仅有一只身上带有斑点的奶牛。约翰意识到他的牛群中有一些斑点奶牛，但他从来没有统计过它们的数量。 根据照片，请你帮约翰估算在他的牛群中最多可能有多少只斑点奶牛。如果无解，输出“-1”。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个整数：N和M。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2到M+1行，两个整数，ai和bi。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，牛群中斑点奶牛的最大数目。如果无解输出-1。 输入输出样例Sample input 5 31 42 53 4 Sample output 1 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这其实是差分约束的题目，也可以用DP做。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定r(i)为包含i这个点的所有区间的左端点最小值-1，l(i)表示在i左侧的所有区间左端点的最大值。这两个量是后面DP的基础，可以用两遍for循环解决。初始化l(i)=0，r(i)=i-1，并在读入数据时预处理。有方程： l(i)=\max\{l(i),l(i-1)\};r(i)=\min\{r(i),r(i+1)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个思路很重要，可以用于一些区间DP的预处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(i)为1~i的奶牛最大数量并且i处必须有奶牛，仅有i=n+1时为i处没有奶牛的值。有状态转移方程： dp(i)=\begin{cases}\max\{dp(k)\}+1,l(i)\leq k \leq r(i)\ \ \ & i\leq n\\ \max\{dp(k)\},l(i)\leq k \leq r(i)\ \ \ & i=n+1 \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果l(i)&gt;r(i)则dp(i)=-inf。最终答案即为dp(n+1)，如果为负输出-1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到l和r都是单调递增的，可以用单调队列优化。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#define N 200000+1#define inf 0x7ffffffusing namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;int deq[N + 100], fr = 0, ba = -1;int n, m, l[N] = &#123;0&#125;, r[N], dp[N];int x, y;inline void Push(int x) &#123;//单调队列 while (ba &gt;= fr &amp;&amp; dp[deq[ba]] &lt; dp[x])ba--; deq[++ba] = x;&#125;inline int Front(int x) &#123; while (deq[fr] &lt; x)fr++; return deq[fr];&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n + 1; i++)r[i] = i - 1; for (int i = 1; i &lt;= m; i++) &#123; x = read(), y = read(); l[y + 1] = max(l[y + 1], x), r[y] = min(r[y], x - 1); &#125; for (int i = 2; i &lt;= n + 1; i++)l[i] = max(l[i], l[i - 1]); for (int i = n; i &gt;= 1; i--)r[i] = min(r[i], r[i + 1]); dp[0] = 0; int key = 0; for (int i = 1; i &lt;= n + 1; i++) &#123; for (int k = key; k &lt;= r[i]; k++)Push(k); key = r[i] + 1; if (l[i] &gt; r[i])dp[i] = -inf; else if (i &lt;= n)dp[i] = dp[Front(l[i])] + 1; else dp[i] = dp[Front(l[i])]; &#125; if (dp[n + 1] &lt; 0)cout &lt;&lt; -1; else cout &lt;&lt; dp[n + 1]; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LYH注：这法真是妙，深深感受到自己的渺小]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列优化DP]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的日志中提到了单调队列的一个用途——求固定长区间最值。这里介绍单调队列的另一种用途——优化DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在状态转移方程中，有一种方程十分常见，它的形式如下所示： dp(i)=\min/\max\{s(k)\}+c(i),l(i)\leq k \leq r(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里dp由s转移而来（s可以就是dp本身），s的取值范围由l(i)和r(i)确定，c(i)为转移代价，与k的选取无关。在求解这个方程时，需要for一遍i，还要for一遍k才可以得到dp值。如果l和r的距离很大，时间复杂度将达到O(n2)，转移时间消耗不可忽视。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当从小到大递推dp值时，如果发现l和r均单调递增，这时可以用单调队列优化DP过程，降低时间复杂度。这里的单调队列仍然存下标，具体算法如下： 定义开始点key，key初始化为最小的l值，如果从0开始计数则key=l(0)。 对于枚举到的每一个i，将[key，r(i)]的下标加入单调队列，并更新key=r(i)+1。 取队首元素。如果队首元素不在[l(i)，r(i)]中，忽略该元素继续取队首。最终得到的队首元素所指的元素即为最值。 算法正确性证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下证i=k+1时可以求出最值：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若l(k+1)&gt;r(k)，那么由于key更新为r(k)+1≤l(k+1)，易知[l(k+1)，r(k+1)]中的所有元素都在i=k+1时入队，显然可以得到最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若l(k)≤l(k+1)≤r(k)，如果i=k+1的最优解出现在[r(k)+1,r(k+1)]中，那么这一个区间的值一定在i=k+1时入队，一样可以求出最优解。如果i=k+1的最优解出现在[l(k+1)，r(k)]中（假设为p），现证明p这个元素不可能被“剔除”。倘若存在q由于比p更优将p剔除出队列，那么一定有q&gt;p，容易知q也在[l(k+1)，r(k)]中，那么q应该是i=k+1时比p更优的解，这与p最优矛盾。因此p最优时不可能被剔除，最终仍可以得到最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，算法正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单调队列求固定长区间最值其实是这种方法的特殊情况。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四边形不等式]]></title>
    <url>%2F2019%2F01%2F18%2F%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍DP的优化方法之一————四边形不等式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在列状态转移方程时，常常会遇到如下形式的方程： dp(i,j)=\min\{dp(i,k)+dp(k+1,j)\}+m(i,j),i\leq k < j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方程很常见，比如题目合并石子的方程就满足这种形式。m为转移的代价。dp时间复杂度为O(n2)，转移枚举为O(n)，故总体时间复杂度为O(n3)。可以用四边形不等式将其减至O(n2)复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于a≤i&lt;j≤b，总有： m(a,j)+m(i,b)\leq m(i,j)+m(a,b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则称m满足四边形不等式，一句话概括为：交叉小于包含。下面介绍三个重要定理。 【定理一】m满足四边形不等式的充要条件是 $m(i,j)+m(i+1,j+1)≤m(i+1,j)+m(i,j+1),i&lt;j$。 证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然这个不等式是m满足四边形不等式的特殊情形，于是必要性成立，下证充分性。只需证明$m(i,j)+m(i+a,j+b)≤m(i+a,j)+m(i,j+b),i\leq i+a &lt; j \leq j+b$，这里只对i的情况进行讨论，采用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由已知可知，$m(i,j)+m(i+1,j+1)\leq m(i+1,j)+m(i,j+1)$是成立的。假设$m(i,j)+m(i+k,j+1)\leq m(i+k,j)+m(i,j+1)$成立，那么由已知，应有： m(i+k,j)+m(i+k+1,j+1)\leq m(i+k+1,j)+m(i+k,j+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与假设的式子联立，立即得到： m(i,j)+m(i+k,j+1)+m(i+k,j)+m(i+k+1,j+1)\leq m(i+k,j)+m(i,j+1)+m(i+k+1,j)+m(i+k,j+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是： m(i,j)+m(i+k+1,j+1)\leq m(i,j+1)+m(i+k+1,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由归纳法便知$m(i,j)+m(i+a,j+1)≤m(i+a,j)+m(i,j+1)$是成立的，j类似证明即可。两个结合便可证明四边形不等式，于是定理一得证。这个定义可以帮助判断m是否满足四边形不等式。 【定理二】若m满足四边形不等式，则dp也满足四边形不等式。 证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需证明$dp(a,j)+dp(i,b)\leq dp(i,j)+dp(a,b),a\leq i &lt; j\leq b$。采用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=i&lt;i+1=j=b时显然成立。对于固定的a、i，假设在a≤i&lt;j≤b≤P时成立，那么在b=P+1时：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设dp(i,j)在k=x处取得最优解，dp(a,P+1)在k=y处取到最优解，假设x≤y(x &gt;y时类似可证)，那么上式等价于： dp(a,j)+dp(i,P+1)\leq dp(i,x)+dp(x+1,j)+dp(a,y)+dp(y+1,P+1)+m(i,j)+m(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到： dp(a,j)+dp(i,P+1)\leq dp(a,x)+dp(x+1,j)+dp(i,y)+dp(y+1,P+1)+m(a,j)+m(i,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而m满足四边形不等式，也就是有： m(a,j)+m(i,P+1)\leq m(i,j)+m(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于a≤i&lt;x≤y&lt;P+1由归纳假设，有(i=x时也成立)： dp(a,x)+dp(i,y)\leq dp(i,x)+dp(a,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是有： dp(a,x)+dp(x+1,j)+dp(i,y)+dp(y+1,P+1)+m(a,j)+m(i,P+1)\leq dp(i,x)+dp(x+1,j)+dp(a,y)+dp(y+1,P+1)+m(i,j)+m(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么： dp(a,j)+dp(i,P+1)\leq dp(i,j)+dp(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是对P+1也成立，由归纳法可知dp也满足四边形不等式。这个定理是定理三的基础。 【定理三】若dp满足四边形不等式，设S(i,j)为dp(i,j)取最优解的k值，那么有$S(i,j-1)\leq S(i,j)\leq S(i+1,j)$ 证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$dp_k(i,j)=dp(i,k)+dp(k+1,j)+m(i,j)，S(i,j)=d$那么：$(dp_k(i+1,j)-dp_d(i+1,j))-(dp_k(i,j)-dp_d(i,j))$$=(dp_k(i+1,j)+dp_d(i,j))-(dp_d(i+1,j)+dp_k(i,j))$$=(dp(i+1,k)+dp(k,j)+dp(i,d)+dp(d,j)+m(i+1,j)+m(i,j))-\\(dp(i+1,d)+dp(d,j)+dp(i,k)+dp(k,j)+m(i+1,j)+m(i,j))$$=(dp(i+1,k)+dp(i,d))-(dp(i+1,d)+dp(i,k))$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若k&lt;d，那么有i&lt;i+1&lt;k&lt;d。由dp的四边形不等式，有： dp(i,k)+dp(i+1,d)\leq dp(i+1,k)+dp(1,d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是$(dp_k(i+1,j)-dp_d(i+1,j))-(dp_k(i,j)-dp_d(i,j))\geq 0$，即： dp_k(i+1,j)-dp_d(i+1,j)\geq dp_k(i,j)-dp_d(i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于S(i,j)=d，故$dp_k(i,j)\geq dp_d(i,j)$，所以： dp_k(i+1,j)\geq dp_d(i+1,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子说明，k&lt;d时不能取到比k=d更优的解，所以S(i+1,j)≥d。S(i,j-1)≤d同理可证，定理三成立。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定理三表明，k的取值可以优化到一个很小的范围内，即[S(i,j-1),S(i+1,j)]，开一个数组S储存这个结果，时间复杂度便压缩到O(n2)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是对于最大值又如何做呢？最大值不能用四边形不等式，但是它有另一个性质：最大值的k值一定在端点处取到。这个性质仍然可以帮助优化算法。容易验证石子合并的m是满足四边形不等式的，于是可以用四边形不等式优化DP过程，下面给出优化版代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#define N 100*2+1using namespace std;int n, op[N], sum[N] = &#123;0&#125;;int dp1[N][N], dp2[N][N], S[N][N];int ans1 = 0x7fffffff, ans2 = -1;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; op[i + n] = op[i]; &#125; for (int i = 1; i &lt;= 2 * n; i++)sum[i] = op[i] + sum[i - 1];//前缀和 for (int j = 2 * n; j &gt;= 1; j--) &#123;//最大值 for (int z = j; z &lt;= 2 * n; z++) &#123; if (j == z)dp2[j][z] = 0; else dp2[j][z] = max(dp2[j + 1][z], dp2[j][z - 1]) + sum[z] - sum[j - 1]; &#125; &#125; for (int j = 2 * n; j &gt;= 1; j--) &#123;//最小值 for (int z = j; z &lt;= 2 * n; z++) &#123; if (j == z)S[j][z] = j, dp1[j][z] = 0; else &#123; dp1[j][z] = 0x7fffffff; for (int k = S[j][z - 1]; k &lt;= S[j + 1][z] &amp;&amp; k &lt; z; k++) &#123; if (dp1[j][k] + dp1[k + 1][z] + sum[z] - sum[j - 1] &lt; dp1[j][z]) dp1[j][z] = dp1[j][k] + dp1[k + 1][z] + sum[z] - sum[j - 1], S[j][z] = k; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++)ans1 = min(ans1, dp1[i][i + n - 1]), ans2 = max(ans2, dp2[i][i + n - 1]); cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于环的处理，仍然是剪环为链，但是这里的做法比原先的做法高明的多（直接将n个石子扩展为2n个，再寻找答案），于是时间复杂度降了一维。再用四边形不等式降一维，总体时间复杂度便为O(n2)。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3652]时间复杂度]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%B4%9B%E8%B0%B7P3652-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOIP2017 D1 T2原题，难度较大的模拟 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。A++语言的循环结构如下： F i x y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环体E &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中F i x y表示新建变量 i（变量 i 不可与未被销毁的变量重名）并初始化为 x， 然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 i 都会被修改成 i +1，一旦 i 大于 y 终止循环。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x 和 y 可以是正整数（x 和 y 的大小关系不定）或变量 n。n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件第一行一个正整数 t，表示有 t（t≤10）个程序需要计算时间复杂度。 每个程序只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构 允许嵌套。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来每个程序的第一行包含一个正整数 L 和一个字符串，L 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为n^w，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 L 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 i 是一个小写字母（保证不为n），表示新建的变量名，x 和 y 可能是正整数或 n ，已知若为正整数则一定小于 100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序行若以E开头，则表示循环体结束。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件共 t 行，对应输入的 t 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入输出样例Sample input 82 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE Sample output YesYesERRYesNoYesYesERR 说明【输入输出样例解释1】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个程序 i 从 1 到 1 是常数复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个程序 x 从 1 到 n 是 n 的一次方的复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个程序有一个 F 开启循环却没有 E 结束，语法错误。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四个程序二重循环，n 的平方的复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五个程序两个一重循环，n 的一次方的复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第六个程序第一重循环正常，但第二重循环开始即终止（因为n远大于100，100大于4）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第七个程序第一重循环无法进入，故为常数复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第八个程序第二重循环中的变量 x 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 【数据规模与约定】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 L/2 行一定为以 F 开头的语句，第 L/2+1行至第 L 行一定为以 E 开头的语句，L≤10，若 x、y 均为整数，x 一定小于 y，且只有 y 有可能为 n。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据：不存在语法错误，L≤100，且若 x、y 均为整数，x 一定小于 y， 且只有 y 有可能为 n。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于70%的数据：不存在语法错误，L≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据：L≤100。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路还是比较清晰的，用栈模拟循环嵌套过程，并不断记录已经存在的变量。详细过程见代码注释。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;bool vis[26];stack&lt;int&gt; sta;inline int find(string x) &#123;//字符串解析 if (x[2] == '1')return 0; int s = 0; for (int i = 4; x[i] != ')'; i++)s = s * 10 + x[i] - '0'; return s;&#125;inline int solve(string x, string y) &#123;//循环开始结束时间解析，0表示可执行的常数次数，1表示可执行的线性次数，-1表示不可执行 if (x[0] == 'n' &amp;&amp; y[0] == 'n')return 0; if (y[0] == 'n')return 1;//一定可以执行，与n成正比 if (x[0] == 'n')return -1;//一定不能被执行 if (x.length() &gt; y.length())return -1; if (x.length() &lt; y.length())return 0;//可以被执行，常数复杂度 for (int i = 0; i &lt; x.length(); i++)if (x[i] &lt; y[i])return 0; else if (x[i] &gt; y[i])return -1; return 0;//x=y，常数复杂度&#125;int main() &#123; int T, L, ans0, ans, depth; //T 样例数、L 行数、ans0 给定的时间复杂度答案(只存指数，O(1)存0)、ans 实际的答案(语法错误即为-1)，depth为有效深度 //有效深度指可以被执行的并且与n有线性时间关系的循环嵌套层数，ans就是depth的最大值 bool key;//是否会执行 string op, n1, n2; char e; cin &gt;&gt; T; for (int ti = 0; ti &lt; T; ti++) &#123; cin &gt;&gt; L &gt;&gt; op; ans0 = find(op), memset(vis, 0, sizeof(vis)), ans = 0, key = true, depth = 0;//初始化 while (!sta.empty())sta.pop();//清空栈 for (int i = 0; i &lt; L; i++) &#123;//逐行读取 cin &gt;&gt; e;// if (e == 'E') &#123;//循环结束标志 if (sta.empty())ans = -1;//栈已空，ERR else &#123; if (sta.top() / 100 == 1)key = true, vis[sta.top() - 100] = false;//找到不可执行开始符，标记又可以执行 else if (sta.top() / 100 == 2) &#123;//找到有效深度标识符 if (key)depth--;//可以被执行的情况下深度减一 vis[sta.top() - 200] = false; &#125; else vis[sta.top()] = false;//直接去除重名标记 sta.pop();//出栈 &#125; if (ans == -1)continue;//语法错误跳过 &#125; else &#123;//循环开始标志 cin &gt;&gt; e &gt;&gt; n1 &gt;&gt; n2; if (vis[e - 'a'])ans = -1;//重名，ERR else vis[e - 'a'] = true;//加上重名限制 if (ans == -1)continue;//已经有语法错误，后面跳过即可 int temp = solve(n1, n2);//储存循环结果 if (temp == 1) &#123;//随n线性时间复杂度情况 if (key)depth++;//如果可以执行，更新有效深度 sta.push(200 + e - 'a');//入栈，打上有效深度标记 &#125; else if (temp == -1) &#123;//不能执行 if (key)sta.push(100 + e - 'a'), key = false;//标记不可执行开始符，标记key，之后不可执行 else sta.push(e - 'a'); &#125; else sta.push(e - 'a');//常数复杂度不影响结果，不更新有效深度，直接入栈即可 &#125; ans = max(ans, depth);//ans在不为-1时记录最大有效深度 &#125; if (!sta.empty())ans = -1;//栈没空，说明少E，ERR if (ans == -1)cout &lt;&lt; "ERR" &lt;&lt; endl; else if (ans0 != ans)cout &lt;&lt; "No" &lt;&lt; endl; else cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2467]地精部落]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%B4%9B%E8%B0%B7P2467-%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录一道简单的省选题 难度：省选/NOI-（个人感觉难度虚高） 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传说很久以前，大地上居住着一种神秘的生物：地精。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为N的山脉H可分为从左到右的N段，每段有一个独一无二的高度Hi，其中Hi是1到N之间的正整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精们希望这N段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你希望知道，长度为N的可能有地精居住的山脉有多少种。两座山脉A和B不同当且仅当存在一个i，使得Ai≠Bi。由于这个数目可能很大，你只对它除以P的余数感兴趣。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件goblin.in仅含一行，两个正整数N, P。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件goblin.out仅含一行，一个非负整数，表示你所求的答案对P取余之后的结果。 输入输出样例Samplle input 4 7 Sample output 3 说明【样例说明】共有十种可能的情况，分别为：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1324&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1423&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2143&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2314&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2413&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3241&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3412&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4132&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4231&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加下划线的数位表示可以设立瞭望台的山峰，其它表示可以设立酒馆的山谷。【数据规模和约定】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于20%的数据，满足N≤10；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于40%的数据，满足N≤18；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于70%的数据，满足N≤550；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，满足3≤N≤4200，P≤1e9。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以说是一道很水的省选题了。考察动态规划，题目本质上是对于一个数N，求1~N能够组成的大小相间的排列方案数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(x，p，y)表示长度为x，末尾数字作p(0为山谷、1为山峰)，末尾数不超过y时的方案数，则有状态转移方程： dp(x,0,i)=dp(x,0,i-1)+dp(x-1,1,x-1)-dp(x-1,1,i-1),1\leq i \leq x\\ dp(x,1,i)=dp(x,1,i-1)+dp(x-1,0,i-1),1\leq i \leq x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对状态转移方程的理解是本题唯一难点。之后将数组第一维滚动掉，最终空间复杂度O(N)，时间复杂度O(N2)。123456789101112131415161718192021#include&lt;iostream&gt;#define N 4200+1using namespace std;int n, mod, dp[2][2][N] = &#123;0&#125;;bool k = false;//0山谷，1山峰int main() &#123; cin &gt;&gt; n &gt;&gt; mod; dp[0][0][2] = dp[0][0][1] = dp[0][1][2] = 1; for (int i = 3; i &lt;= n; i++) &#123; k = !k; for (int j = 1; j &lt;= i; j++) &#123; dp[k][0][j] = (dp[k][0][j - 1] + (dp[!k][1][i - 1] - dp[!k][1][j - 1] + mod) % mod) % mod; dp[k][1][j] = (dp[k][1][j - 1] + dp[!k][0][j - 1]) % mod; &#125; &#125; cout &lt;&lt; (dp[k][0][n] + dp[k][1][n]) % mod; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2331]最大子矩阵]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%B4%9B%E8%B0%B7P2331-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。注意：选出的k个子矩阵不能相互重叠。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为n,m,k（1≤n≤100,1≤m≤2,1≤k≤10），接下来n行描述矩阵每行中的每个元素的分值(每个元素的分值的绝对值不超过32767)。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一行为k个子矩阵分值之和最大为多少。 输入输出样例Sample input 3 2 21 -32 3-2 3 Sample output 9 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先好好读题，m只能取1或2（坑了很多人了！）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于构造数据的缘故，本题考虑和不考虑空矩阵（分值为0）都是可以的。如果考虑空矩阵，题意即为选取不超过k个不重叠的子矩阵使得分值之和最大。介绍两种解法，其中第一种解法不考虑空矩阵，第二种考虑。 辣鸡解法（也就是我第一次的解法） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我第一次AC本题时用的方法，时间空间复杂度都很高。但是因为数据量太小，轻松水过~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路是矩阵先划分再分配。如果规定dp(x1,y1,x2,y2,p)表示从坐标(x1，y1)到(x2，y2)的矩阵区域中选取p个子矩阵时的分值最大值，那么在p&gt;1时，一定可以将这p个子矩阵划分到两个区域中。既可以横向划分（有x2-x1种情况）也可以纵向划分（y1≠y2时才可以划分，显然这时仅有1种情况），之后再对这两个划分区域进行子矩阵数量的分配，注意分配时不要超出区域最大承受的范围（因为没有考虑空矩阵）。本方法难点在于如何求解p=1时的情况，思路是先用dp手段求连续区间的最大值（要限制左端点），需要求三次（第一列，第二列以及两列对应元素和），再在这些dp数据中找到最大值即可。注意到这里找最大值是一个区间最值问题，用ST表维护。总体时间复杂度O(kn3m2)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int dp[100][2][100][2][11] = &#123;0&#125;, dp2[2][100][100], op[100][2], op2[100] = &#123;0&#125;, dp3[100][100], n, m, k;int ST[2][100][100][10], ST2[100][100][10];int Log[101], bin[10];int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; op[i][j]; dp2[j][i][i] = op[i][j]; op2[i] += op[i][j]; &#125; for (int i = 0; i &lt; n; i++) &#123;//求区间连续最大值 for (int j = i; j &lt; n; j++) &#123; if (j == i)dp2[0][i][i] = op[i][0], dp2[1][i][i] = op[i][1], dp3[i][j] = op2[i]; else &#123; if (dp2[0][i][j - 1] &lt; 0)dp2[0][i][j] = op[j][0]; else dp2[0][i][j] = op[j][0] + dp2[0][i][j - 1]; if (dp2[1][i][j - 1] &lt; 0)dp2[1][i][j] = op[j][1]; else dp2[1][i][j] = op[j][1] + dp2[1][i][j - 1]; if (dp3[i][j - 1] &lt; 0)dp3[i][j] = op2[j]; else dp3[i][j] = op2[j] + dp3[i][j - 1]; &#125; ST[0][i][j][0] = dp2[0][i][j], ST[1][i][j][0] = dp2[1][i][j], ST2[i][j][0] = dp3[i][j]; &#125; &#125; Log[0] = -1, bin[0] = 1; for (int i = 1; i &lt;= 100; i++)Log[i] = Log[i / 2] + 1; for (int i = 1; i &lt; 10; i++)bin[i] = bin[i - 1] * 2;//ST表初始化 for (int i = 0; i &lt; n; i++) for (int j = 1; j &lt;= Log[n]; j++) for (int p = i; p &lt; n; p++) if (p + bin[j] &lt;= n) &#123; ST[0][i][p][j] = max(ST[0][i][p][j - 1], ST[0][i][p + bin[j - 1]][j - 1]); ST[1][i][p][j] = max(ST[1][i][p][j - 1], ST[1][i][p + bin[j - 1]][j - 1]); ST2[i][p][j] = max(ST2[i][p][j - 1], ST2[i][p + bin[j - 1]][j - 1]); &#125; for (int l = 1; l &lt;= k; l++) &#123;//数量枚举 for (int x1 = 0; x1 &lt; n; x1++) &#123; for (int y1 = 0; y1 &lt; m; y1++) &#123; for (int x2 = x1; x2 &lt; n; x2++) &#123; for (int y2 = y1; y2 &lt; m; y2++) &#123; dp[x1][y1][x2][y2][l] = -0x7fffffff; if (l == 1) &#123; int len = x2 - x1 + 1; if (y1 == 0) dp[x1][y1][x2][y2][l] = max(ST[0][x1][x1][Log[len]], ST[0][x1][x2 - bin[Log[len]] + 1][Log[len]]); if (y2 == 1) dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], max(ST[1][x1][x1][Log[len]], ST[1][x1][x2 - bin[Log[len]] + 1][Log[len]])); if (y1 != y2) dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], max(ST2[x1][x1][Log[len]], ST2[x1][x2 - bin[Log[len]] + 1][Log[len]])); &#125; else &#123; for (int i = x1; i &lt; x2; i++) &#123; int last = min(l, (i - x1 + 1) * (y2 - y1 + 1)); for (int j = max(0, l - (x2 - i) * (y2 - y1 + 1)); j &lt;= last; j++)//分配 dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], dp[x1][y1][i][y2][j] + dp[i + 1][y1][x2][y2][l - j]); &#125; if (y1 != y2) &#123; int last = min(l, x2 - x1 + 1); for (int i = max(0, l + x1 - x2 - 1); i &lt;= last; i++) dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], dp[x1][0][x2][0][i] + dp[x1][1][x2][1][l - i]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[0][0][n - 1][m - 1][k]; return 0;&#125; 更好的解法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;划分为m=1和m=2两种情况。m=1时就是一个改编的连续区间和最值问题，直接上DP求出即可。方法是令dp(x，p)表示在序号为1~x（从1开始计数）的区间中找到不超过p个连续子区间分值之和的最大值，那么有状态转移方程： dp(x，p)=\max\{\max\{dp(i,p),dp(i,p-1)+S(i+1,x)\}\},0\leq i < x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S(a，b)为[a，b]的分值之和，用前缀和维护。初始化dp(1，i)=max(0,value(1,1))(1≤i≤k)，其余为0，递推即可。答案即为dp(n，k)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m=2时令dp(i，j，p)表示从第一列前i行，第二列前j行组成的区域中选取不超过p个子矩阵的分值之和最大值。在末行元素不选时有： dp(i,j,p)=\max\{dp(i-1,j,p),dp(i,j-1,p)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里类似最长公共子序列的解法。而选取第一列末行元素时有： dp(i,j,p)=\max\{dp(l,j,p-1)+S1(l+1,i)\},0\leq l < i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S1(a，b)表示第一列区间[a，b]的分值之和，同样用前缀和维护。同理可得选取第二列末行元素时有： dp(i,j,p)=\max\{dp(i,l,p-1)+S2(l+1,j)\},0\leq l < j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S2维护第二列区间分值之和。特殊地，在i=j时，可以将它们同时选取，分到同一个子矩阵中： dp(i,j,p)=\max\{dp(l,l,p-1)+S1(l+1,i)+S2(l+1,j)\},0\leq l < i=j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从它们当中找到最大值即可，初始化方法类似m=1时的情形。答案即为dp(n，n，k)，时间复杂度为O(knm+1)。这种方法代码量较小，效率较高。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;int op[101][3], dp1[101][11] = &#123;0&#125;, dp2[101][101][11] = &#123;0&#125;, sum[3][101] = &#123;0&#125;;int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; op[i][j]; if (i == 1)sum[j][i] = op[i][j];//前缀和 else sum[j][i] = sum[j][i - 1] + op[i][j]; &#125; &#125; if (m == 1) &#123; for (int i = 1; i &lt;= k; i++)dp1[1][i] = max(0, op[1][1]); for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; for (int p = i - 1; p &gt;= 0; p--) &#123; dp1[i][j] = max(dp1[i][j], dp1[p][j - 1] + sum[1][i] - sum[1][p]); dp1[i][j] = max(dp1[i][j], dp1[p][j]); &#125; &#125; &#125; cout &lt;&lt; dp1[n][k]; &#125; else &#123; for (int i = 1; i &lt;= k; i++)dp2[0][1][i] = max(0, op[1][2]), dp2[1][0][i] = max(0, op[1][1]); for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (!i &amp;&amp; !j)continue; for (int p = 1; p &lt;= k; p++) &#123; if (i &gt; 0)dp2[i][j][p] = max(dp2[i][j][p], dp2[i - 1][j][p]);//不选的情况 if (j &gt; 0)dp2[i][j][p] = max(dp2[i][j][p], dp2[i][j - 1][p]); for (int z = i - 1; z &gt;= 0; z--)//第一列枚举 dp2[i][j][p] = max(dp2[i][j][p], dp2[z][j][p - 1] + sum[1][i] - sum[1][z]); for (int z = j - 1; z &gt;= 0; z--)//第二列枚举 dp2[i][j][p] = max(dp2[i][j][p], dp2[i][z][p - 1] + sum[2][j] - sum[2][z]); if (i == j) &#123; for (int z = i - 1; z &gt;= 0; z--)//全枚举 dp2[i][j][p] = max(dp2[i][j][p], dp2[z][z][p - 1] + sum[1][i] - sum[1][z] + sum[2][i] - sum[2][z]); &#125; &#125; &#125; &#125; cout &lt;&lt; dp2[n][n][k]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>矩阵</tag>
        <tag>动态规划</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2157]学校食堂]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%B4%9B%E8%B0%B7P2157-%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题难度不算小，2007山东省选题。 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是a，这一道为b，则做这道菜所需的时间为（a or b）-（a and b），而做第一道菜是不需要计算时间的。其中，or 和and 表示整数逐位或运算及逐位与运算，C语言中对应的运算符为“|”和“&amp;”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第i 个同学，最多允许紧跟他身后的Bi 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 现在，小F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数C，表示测试点的数据组数。 每组数据的第一行包含一个正整数N，表示同学数。 每组数据的第二行起共N行，每行包含两个用空格分隔的非负整数Ti和Bi，表示按队伍顺序从前往后的每个同学所需的菜的口味和这个同学的忍受度。 每组数据之间没有多余空行。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含C行，每行一个整数，表示对应数据中食堂完成所有菜所需的最少时间。 输入输出样例Sample input 255 24 112 03 32 225 04 0 Sample output 161 说明对于第一组数据：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同学1允许同学2或同学3在他之前拿到菜；同学2允许同学3在他之前拿到菜；同学3比较小气，他必须比他后面的同学先拿菜……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种最优的方案是按同学3、同学2、同学1、同学4、同学5做菜，每道菜所需的时间分别是0、8、1、6及1。【数据规模和约定】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，满足1 ≤ N ≤ 20。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，满足1 ≤ N ≤ 1,000，0 ≤ Ti ≤ 1,000，0 ≤ Bi ≤ 7，1 ≤ C ≤ 5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在30%的数据，满足0 ≤ Bi ≤ 1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在65%的数据，满足0 ≤ Bi ≤ 5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在45%的数据，满足0 ≤ Ti ≤ 130。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察状态压缩DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(r,k,p)表示从第r（从0开始）个人开始，上一个人打饭的人距离r位置为k，且r后面七个人（含自己）的打饭状态为p（状态压缩，0表示未打饭、1表示已经打饭），那么可知状态转移方程： dp(r,k,p)=\begin{cases} dp(r+1,k-1,p>>1)\ \ \ & p\&1=1\\ \min\{dp(r,l,p|(1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列与固定长区间最值]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%B8%8E%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里探讨一种求固定长度区间最值的高效方法—用单调队列求最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先认识什么是单调队列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列是一种先进先出(FIFO)的线性表，而单调队列则是指队列中元素符合单调性的特殊队列，可以分为单调增和单调减队列。前者队首元素总是最大的，后者总是最小的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当有元素需要加入队列时（这里以单调增队列为例），我们需要考察这个元素与队尾元素的大小关系。如果它比队尾元素小，则元素入队后仍符合单调性，直接入队即可；若否，则队尾元素出队，然后继续比较，直到队空或队尾元素大于或等于待入队元素，之后该元素入队。也就是说，单调队列中有元素入队时，会把比它小的所有元素“挤出”。这里还可以发现入队操作需要访问队尾元素，这是STL中的queue做不到的。通常单调队列用STL中的deque(双向队列)实现，当然也可以手写。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如何用单调队列维护固定长度的区间最值？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓固定长度区间最值，即是给定一段区间(长度为n)，维护区间内所有长度为m的区间最值。通常用一个一维数组（比如ans[]）来记录结果。这时ans[i]表示[i,i+n-1]的最值。这里值得注意的是，用单调队列维护固定长区间最值时，队列中存放的不是元素本身，而是元素在区间中的编号，检验大小关系时，利用编号到元素的映射里比较。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体算法如下： 区间前n个元素入单调队列，这时队首所指元素即为前n个元素最值，将其记录在ans[0]中（下标从0开始）。 对于第n+1以及以后的元素（假设编号是k），该元素先入队，再取队首元素，如果队首元素（是一个编号）不在区间[k-n+1,k]中，那么忽略该元素，直到队首元素在区间中，这个编号所指元素即为最值。 附算法正确性证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,n-1]的最值显然可以得到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设单调队列中成功地维护了[a,a+n-1]的最值p，在第a+n个元素入队后，下证明队列可以维护[a+1,a+n]的最值q。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果p就是编号为a的元素。q编号在[a+1,a+n]中，假如有q≤p。编号在[a+1,a+n]中的所有元素x都应满足x≤q。根据单调队列的构造方法，可知q一定不会被“挤出”，并且一定在p的紧跟着的后面。根据算法，q因为编号不在[a+1,a+n]中，会被忽略，然后立刻得到q，即为最值，成立。若q&gt;p，则q会将p“挤出”并且其编号成为队首，并且之后一定不会再被“挤出”，取出即为最值，成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果p编号在[a+1,a+n-1]中，只需比较编号为a+n的元素x和p即可。如果x≤p，则p仍然在队首，取出即为最值。若x&gt;p，则x会将p“挤出”，于是x成为队首，取出即为最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此算法正确。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>区间最值</tag>
        <tag>区间</tag>
        <tag>单调队列</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2216]理想的正方形]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%B4%9B%E8%B0%B7P2216-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题目为矩阵最值问题的模板题 难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个a*b的整数组成的矩阵，现请你从中找出一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为3个整数，分别表示a,b,n的值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅一个整数，为a*b矩阵中所有“n*n正方形区域中的最大整数和最小整数的差值”的最小值。 输入输出样例Sample input 5 4 21 2 5 60 17 16 016 17 2 12 10 2 11 2 2 2 Sampe output 1 说明问题规模 矩阵中的所有数都不超过1,000,000,000 20%的数据2≤a,b≤100,n≤a,n≤b,n≤10 100%的数据2≤a,b≤1000,n≤a,n≤b,n≤100 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一道很好的矩阵最值问题。下面介绍3种方法。 暴力DP法（不能AC）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果用dp(x，y，k)表示以坐标(x，y)为左上方点，边长为k的方阵最大值，显然有状态转移方程（最小值类比）： dp(x,y,k)=\max\{dp(x+1,y,k-1),dp(x,y+1,k-1),dp(x+1,y+1,k-1)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种思想即是将大方阵分成了三个小方阵，并且这三个小方阵可以覆盖原来的大方阵。按照该方程递推，即可以得出答案。时间复杂度O(abn)，预计得分60，开O2优化可以AC。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三维数组过大会爆空间，需要滚动数组优化。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAX 1000using namespace std;unsigned int op[MAX][MAX], a, b, n, dpMax[MAX][MAX][2], dpMin[MAX][MAX][2];bool key = false;int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; s = s * 10 + e - '0'; e = getchar(); &#125; return s;&#125;int main() &#123; a = read(), b = read(), n = read(); memset(dpMax, 0, sizeof(dpMax)), memset(dpMin, -1, sizeof(dpMin)); for (int i = 0; i &lt; a; i++) &#123; for (int j = 0; j &lt; b; j++)op[i][j] = read(); &#125; unsigned int ans = dpMin[0][0][0]; for (int k = 1; k &lt;= n; k++) &#123; for (int i = a - k; i &gt;= 0; i--) &#123; for (int j = b - k; j &gt;= 0; j--) &#123; if (k == 1)dpMax[i][j][key] = dpMin[i][j][key] = op[i][j]; else &#123; dpMax[i][j][key] = max(op[i][j], max(dpMax[i + 1][j][!key],max(dpMax[i][j + 1][!key], dpMax[i + 1][j + 1][!key]))); dpMin[i][j][key] = min(op[i][j], min(dpMin[i + 1][j][!key],min(dpMin[i][j + 1][!key], dpMin[i + 1][j + 1][!key]))); &#125; if (k == n)ans = min(ans, dpMax[i][j][key] - dpMin[i][j][key]); &#125; &#125; key = !key; &#125; cout &lt;&lt; ans; return 0;&#125; 倍增DP法（二维ST表）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前的日志记录了一维ST表。建立ST表是一种基于倍增思想的求区间最值方法，本质上是DP。这里将一维ST表推广到二维。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令ST(x，y，k)表示以坐标(x，y)为左上方点，边长为2k的方阵的最大值。那么有状态转移方程： ST(x,y,k)=\max\{ST(x,y,k),ST(x+bin(k-1),y,k-1),ST(x,y+bin(k-1),k-1),ST(x+bin(k-1),y+bin(k-1),k-1)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方程容易理解，这里是将大方阵分成四个等大的小方阵，它们彼此没有交集但覆盖了整个大方阵。根据方程递推即可，重点在于如何用ST表求边长为n的方阵最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一维ST表，应将方阵化为四个小方阵。容易得出边长为n的方阵最值即为： \max\{ST(x,y,log(n)),ST(x+n-bin(log(n)),y,log(n)),ST(x,y+n-bin(log(n)),log(n)),ST(x+n-bin(log(n)),y+n-bin(log(n)),log(n))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log以及bin与一维ST表相同，详见一维ST表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最小值类比。时间复杂度O(ablog(n))。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX 1000using namespace std;int a, b, n, op[MAX][MAX], ST1[MAX][MAX][10], ST2[MAX][MAX][10];int bin[10], log[101];inline int read() &#123;//读入优化 char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; s = s * 10 + e - '0'; e = getchar(); &#125; return s;&#125;int main() &#123; a = read(), b = read(), n = read(); for (int i = 0; i &lt; a; i++) for (int j = 0; j &lt; b; j++) &#123; op[i][j] = read(); ST1[i][j][0] = ST2[i][j][0] = op[i][j]; &#125; log[0] = -1, bin[0] = 1; for (int i = 1; i &lt;= 100; i++)log[i] = log[i / 2] + 1;//log for (int i = 1; i &lt; 10; i++)bin[i] = bin[i - 1] * 2;//bin for (int k = 1; k &lt;= log[n]; k++) &#123; for (int i = 0; i &lt; a; i++) &#123; for (int j = 0; j &lt; b; j++) &#123; if (i + bin[k] &gt; a || j + bin[k] &gt; b)continue; ST1[i][j][k] = max(ST1[i][j][k - 1],max(ST1[i + bin[k - 1]][j][k - 1],max(ST1[i][j + bin[k - 1]][k - 1], ST1[i + bin[k - 1]][j + bin[k - 1]][k - 1]))); ST2[i][j][k] = min(ST2[i][j][k - 1],min(ST2[i + bin[k - 1]][j][k - 1],min(ST2[i][j + bin[k - 1]][k - 1], ST2[i + bin[k - 1]][j + bin[k - 1]][k - 1]))); &#125; &#125; &#125; int ans = 0x7fffffff; for (int i = 0; i &lt;= a - n; i++) &#123; for (int j = 0; j &lt;= b - n; j++) &#123; int maxn = max(ST1[i][j][log[n]],max(ST1[i + n - bin[log[n]]][j][log[n]],max(ST1[i][j + n - bin[log[n]]][log[n]],ST1[i + n - bin[log[n]]][j + n - bin[log[n]]][log[n]]))); int minn = min(ST2[i][j][log[n]],min(ST2[i + n - bin[log[n]]][j][log[n]],min(ST2[i][j + n - bin[log[n]]][log[n]],ST2[i + n - bin[log[n]]][j + n - bin[log[n]]][log[n]]))); ans = min(ans, maxn - minn); &#125; &#125; cout &lt;&lt; ans; return 0;&#125; 单调队列法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单调队列可以维护固定长度的区间最值，可以用单调队列维护每一行长度为n的所有区间最值，由此可以得到一个二维表(行数为a，列数为b-n+1)。在这个二维表上再用单调队列维护每一列长度为n的所有区间最值，又可以得到一个二维表(行数为a-n+1，列数为b-n+1)，它记录的即是所有边长为n的方阵的最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单调队列维护固定区间最值详见这篇日志。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;cstdio&gt;#define MAX 1000using namespace std;deque&lt;int&gt; q1, q2;int a, b, n, op[MAX][MAX], X[MAX][MAX], x[MAX][MAX], Y[MAX][MAX], y[MAX][MAX];inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; s = s * 10 + e - '0'; e = getchar(); &#125; return s;&#125;inline void push1(int x, int y) &#123;//单调增队列 while (!q1.empty() &amp;&amp; op[x][q1.back()] &lt; op[x][y])q1.pop_back(); q1.push_back(y);&#125;inline void push2(int x, int y) &#123;//单调减队列 while (!q2.empty() &amp;&amp; op[x][q2.back()] &gt; op[x][y])q2.pop_back(); q2.push_back(y);&#125;inline void push3(int x, int y) &#123; while (!q1.empty() &amp;&amp; X[q1.back()][y] &lt; X[x][y])q1.pop_back(); q1.push_back(x);&#125;inline void push4(int x0, int y0) &#123; while (!q2.empty() &amp;&amp; x[q2.back()][y0] &gt; x[x0][y0])q2.pop_back(); q2.push_back(x0);&#125;inline int front1(int x) &#123; while (q1.front() &lt;= x)q1.pop_front(); return q1.front();&#125;inline int front2(int x) &#123; while (q2.front() &lt;= x)q2.pop_front(); return q2.front();&#125;int main() &#123; a = read(), b = read(), n = read(); for (int i = 0; i &lt; a; i++) for (int j = 0; j &lt; b; j++)op[i][j] = read(); for (int i = 0; i &lt; a; i++) &#123; q1.clear(), q2.clear(); for (int j = 0; j &lt; n; j++)push1(i, j), push2(i, j); X[i][0] = op[i][front1(-1)], x[i][0] = op[i][front2(-1)]; for (int poi = 1, j = n; j &lt; b; j++, poi++) push1(i, j), push2(i, j), X[i][poi] = op[i][front1(j - n)], x[i][poi] = op[i][front2(j - n)]; &#125; for (int i = 0; i &lt;= b - n; i++) &#123; q1.clear(), q2.clear(); for (int j = 0; j &lt; n; j++)push3(j, i), push4(j, i); Y[i][0] = X[front1(-1)][i], y[i][0] = x[front2(-1)][i]; for (int poi = 1, j = n; j &lt; a; j++, poi++) push3(j, i), push4(j, i), Y[i][poi] = X[front1(j - n)][i], y[i][poi] = x[front2(j - n)][i]; &#125; int ans = 0x7fffffff; for (int i = 0; i &lt;= b - n; i++) &#123; for (int j = 0; j &lt;= a - n; j++)ans = min(ans, Y[i][j] - y[i][j]); &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>矩阵</tag>
        <tag>动态规划</tag>
        <tag>区间最值</tag>
        <tag>ST表</tag>
        <tag>区间</tag>
        <tag>单调队列</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1415]拆分数列]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%B4%9B%E8%B0%B7P1415-%E6%8B%86%E5%88%86%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[作者Lyh注：本题解法并不优&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录一道费一天时间才A的一道省选难度题 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出一列数字，需要你添加任意多个逗号将其拆成若干个严格递增的数。如果有多组解，则输出使得最后一个数最小的同时，字典序最大的解（即先要满足最后一个数最小；如果有多组解，则使得第一个数尽量大；如果仍有多组解，则使得第二个数尽量大，依次类推……）。【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于10%的数据，输入长度≤5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，输入长度≤15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，输入长度≤50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，输入长度≤500 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，为初始的数字。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，为拆分之后的数列。每个数之间用逗号分隔。行尾无逗号。 输入输出样例Sample input [1]3456[2]3546[3]3526[4]0001[5]100000101 Sample output [1]3,4,5,6[2]35,46[3]3,5,26[4]0001[5]100,000101 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题还是有难度的，考察动态规划上的字符串问题。答案字典序最大和末尾数最小限制是坑点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，找到末尾最小的那个数。若记dp1(i，r)表示第i个元素前已经加了逗号，是否在区间[0,i-1]存在一种加逗号方案使得它们严格递增且小于[i,r]表示的数。若有值为1，否则为0。这样便有状态转移方程：(区间表示的数的关系暂且记作区间的关系) dp1(i,r)=dp1(k_1,i-1)||dp1(k_2,i-1)||...||dp1(k_m,i-1)||false,[k,i-1]]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2051]中国象棋]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%B4%9B%E8%B0%B7P2051-%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次不看任何解析A出的省选难度题，留作纪念。 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。你也来和小可可一起锻炼一下思维吧！ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行包含两个整数N，M，之间由一个空格隔开。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。 输入输出样例Sample input 1 3 Sample output 7 说明【样例说明】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有2*2*2-1=7种方案。【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据中N和M均不超过100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50%的数据中N和M至少有一个数不超过8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30%的数据中N和M均不超过6 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划，还是有一定难度的，但在省选题中算简单的了。这里的状态转移是性质转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记dp(x，y，t)表示x行y列的棋盘在满足P(t)性质的条件下所有的方案数，P性质定义如下： P(0)：第一行不能有棋子 P(1)：第一行仅有一个棋子 P(2)：第一行有两个棋子 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有这三种情况，因为每一行一列不可能有三个及以上数目的棋子。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于t=0的情况很容易进行状态转移，这是因为首行没有棋子，不会对下面的棋子选取产生任何影响。 dp(x，y，0)=dp(x-1，y，0)+dp(x-1，y，1)+dp(x-1，y，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t=1的情况就复杂很多。注意到第一行仅有且必须有一个棋子，它所在的一列的后x-1行可能有0个或1个棋子。可以最这两个子情况分别讨论，方案总数即是它们的和。当后x-1行没有棋子时，删去这一列和首行，得到一个x-1行y-1列的棋盘。这时发现首行的棋子对这个x-1行y-1列的棋盘棋子选取没有任何影响，方案总数即为dp(x-1，y-1，0)+dp(x-1，y-1，1)+dp(x-1，y-1，2)，再乘上y（被删去的一列有y种选法）就是第一个子情况的方案数。当后x-1行有一个棋子时，删去首行并将这一列拿到最左端，将这个棋盘（看作矩阵）转置，这是一个y行x-1列的棋盘且首行仅有一个棋子，故方案数即为dp(y，x-1，1)，再乘上y（理解同上）就是第二个子情况的方案数。于是有： dp(x，y，1)=(dp(x-1，y-1，0)+dp(x-1，y-1，1)+dp(x-1，y-1，2)+dp(y，x-1，1))*y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后再来看t=2的情况。仍然可以这种情况归结为三种子情况：两个棋子下面均没有其他棋子、一个棋子下面有一个棋子但另一个没有、两个棋子下面均有一个棋子。将它们三个的值加起来即可。第一种子情况理解与t=1相同，删去这两列，得到一个x-1行y-2列的棋盘，方案数为dp(x-1，y-2，0)+dp(x-1，y-2，1)+dp(x-1，y-2，2)，还需要乘上y*(y-1)/2（两个空列的组合数）。第二个子情况理解仍然同t=1时，删去没有棋子的那一列，将有一个棋子的一列拿到最左端，转置后得到一个y-1行x-1列的棋盘且满足P(1)性质，方案数即为dp(y-1，x-1，1)，需要再乘上y*(y-1)（乘一个排列数，将这两列作排列）。最后一种子情况很复杂，仍然需要划分为两种情况：下面的两个棋子不在同一行、下面的两个棋子在同一行。前者可以删去首行，再将两列合并，移到最左边，转置后得到一个y-1行x-1列并且满足性质P(2)的棋盘，方案数即为dp(y-1，x-1，2)，再乘上y*(y-1)即可。后者从棋盘中合并首行和两个棋子所在的一行，移到最顶端，这时下面的x-2行y列的棋盘在首行两个棋子所在的列不应有棋子，也就是两个空列。删去这两个空列，得到一个x-2行y-2列的棋盘，它的棋子选取没有受到影响，方案数为dp(x-2，y-2，0)+dp(x-2，y-2，1)+dp(x-2，y-2，2)，再乘上y*(y-1)/2（这里是一个组合数，是两个空列的选取情况），再乘上x-1（下面棋子所在行的情况）就是后一种情况的答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此t=2时的状态转移方程为： dp(x，y，2)=(dp(x-1，y-2，0)+dp(x-1，y-2，1)+dp(x-1，y-2，2))*y*(y-1)/2+dp(y-1，x-1，1)*y*(y-1)+(dp(x-2，y-2，0)+dp(x-2，y-2，1)+dp(x-2，y-2，2))*y*(y-1)/2*(x-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意边界处理和取模，递推即可。答案即为dp(n，m，0)+dp(n，m，1)+dp(n，m，2)对9999973的模。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAX 101#define MOD 9999973using namespace std;long long dp[MAX][MAX][3] = &#123;0&#125;;int n, m;long long DP(int x, int y, int t) &#123; if (x == 0 || y == 0)return 0; if (x == 1) &#123; if (t == 0)return 1; if (t == 1)return y; if (t == 2)return y * (y - 1) / 2; &#125; if (y == 1) &#123; if (t == 0)return (DP(x - 1, 1, 0) + DP(x - 1, 1, 1) + DP(x - 1, 1, 2)) % MOD; if (t == 1)return x; if (t == 2)return 0; &#125; if (t == 2) &#123; if (x == 2)return y * (y - 1) / 2 * (y * y + y + 2) / 2; if (y == 2)return x * x; &#125; //上面是边界处理 if (dp[x][y][t] &gt;= 0)return dp[x][y][t];//记忆化 //下面是状态转移，t=2时方程太长，分开计算 if (t == 0)return dp[x][y][t] = (DP(x - 1, y, 0) + DP(x - 1, y, 1) + DP(x - 1, y, 2)) % MOD; if (t == 1)return dp[x][y][t] = ((DP(x - 1, y - 1, 0) + DP(x - 1, y - 1, 1) + DP(x - 1, y - 1, 2)) % MOD + DP(y, x - 1, 1)) * y % MOD; int ans = 0; ans += (DP(x - 1, y - 2, 0) + DP(x - 1, y - 2, 1) + DP(x - 1, y - 2, 2)) * y * (y - 1) / 2 % MOD; ans += DP(y - 1, x - 1, 1) * y * (y - 1) % MOD; ans %= MOD; ans += DP(y - 1, x - 1, 2) * y * (y - 1) % MOD + (DP(x - 2, y - 2, 0) + DP(x - 2, y - 2, 1) + DP(x - 2, y - 2, 2)) % MOD * y * (y - 1) / 2 * (x - 1) % MOD; return dp[x][y][t] = ans % MOD;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(dp, -1, sizeof(dp)); cout &lt;&lt; (DP(n, m, 0) + DP(n, m, 1) + DP(n, m, 2)) % MOD &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然花了我3个小时去想它的解法（太弱），但评测用时36ms，内存占0.93mb AC这题还是值得的。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1070]道路游戏]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%B4%9B%E8%B0%B7P1070-%E9%81%93%E8%B7%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小新正在玩一个简单的电脑游戏。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏中有一条环形马路，马路上有n个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这n个机器人工厂编号为1~n，因为马路是环形的，所以第 n个机器人工厂和第1个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这n段马路也编号为1~n，并规定第i段马路连接第i个机器人工厂和第i+1个机器人工厂（1≤i≤n-1），第n段马路连接第n个机器人工厂和第1个机器人工厂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在i（1≤i≤n）号机器人工厂购买了一个机器人，这个机器人会从i号机器人工厂开始，顺时针在马路上行走，第一次行走会经过i号马路，到达i+1号机器人工厂（如果 i=n，机器人会到达第1个机器人工厂），并将i号马路上的所有金币收集给小新。 游戏中，环形马路上不能同时存在2个或者2个以上的机器人，并且每个机器人最多能够在环形马路上行走p次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为1~p之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。 以下是游戏的一些补充说明： 游戏从小新第一次购买机器人开始计时。 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过m个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行3个正整数n,m,p意义如题目所述。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的n行，每行有m个正整数，每两个整数之间用一个空格隔开，其中第i行描&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;述了i号马路上每个单位时间内出现的金币数量（1≤金币数量≤100），即第i行的第j（1≤j≤m）个数表示第j个单位时间内i号马路上出现的金币数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行，有n个整数，每两个整数之间用一个空格隔开，其中第i个数表示在i号机器人工厂购买机器人需要花费的金币数量（1≤金币数量≤100）。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，包含1个整数，表示在m个单位时间内，扣除购买机器人&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花费的金币之后，小新最多能收集到多少金币。 输入输出样例Sample input 2 3 21 2 32 3 41 2 Sample output 5 说明【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 40%的数据，2≤n≤40,1≤m≤40。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 90%的数据，2≤n≤200,1≤m≤200。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 100%的数据，2≤n≤1000,1≤m≤1000,1≤p≤m。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道很有趣的题目，考察动态规划。这里介绍一种O(n3)的做法，本以为会TLE，但是由于某些原因（数据太水），导致这种方法也是可以AC的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路就是规定dp(x)为x时刻开始购置一个机器人，到游戏结束可以得到的最多金币数。这样写的状态转移方程十分复杂。转移时遍历所有可能的购置和选择步数的方案，结合机器人的价格，进行之后时间状态的转移，取最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历是一件特别低效的做法。但是可以注意到dp(x)只能转移到dp(x+k)（1≤k≤p），每一个转移都固定了步数，只是选择哪一个机器人不定。可以开一个数组记录这个量，从而加快速度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以开一个T数组记录第t时刻，设置步数为x时可以得到的最大金币收益（实质上就是机器人的选择）。求这个金币收益可以用矩阵的对角前缀和加速。再来点inline和读入优化黑魔法这题就A了。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#define N 1000#define inf 1e8using namespace std;int op[N][N], dp[N], T[N][N], n, m, p, sum[N][N] = &#123;0&#125;, value[N];inline int solve(int t, int a, int b) &#123; int s = 0; if (t &amp;&amp; a)s = sum[a - 1][t - 1]; if (a + b - 1 &lt; n) return sum[a + b - 1][t + b - 1] - s; return sum[n - 1][t + n - 1 - a] - s + sum[(a + b - 1) % n][t + b - 1];&#125;inline int f(int t, int x) &#123; if (T[t][x] &gt; -1e7)return T[t][x]; for (int i = 0; i &lt; n; i++)T[t][x] = max(T[t][x], solve(t, i, x) - value[i]); return T[t][x];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; op[i][j]; if (!i || !j)sum[i][j] = op[i][j]; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 1; j &lt;= p; j++)T[i][j] = (int) (-inf); &#125; for (int i = 0; i &lt; n; i++)cin &gt;&gt; value[i]; for (int i = 1; i &lt; m; i++) &#123;//求对角前缀和 for (int j = i; j &lt; m; j++)sum[i][j] = sum[i - 1][j - 1] + op[i][j]; for (int j = i + 1; j &lt; n; j++)sum[j][i] = sum[j - 1][i - 1] + op[j][i]; &#125; dp[m] = 0; for (int i = m - 1; i &gt;= 0; i--) &#123;//时刻 dp[i] = (int) (-inf); for (int j = 1; j &lt;= m - i &amp;&amp; j &lt;= p; j++)dp[i] = max(dp[i], f(i, j) + dp[i + j]); &#125; cout &lt;&lt; dp[0]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2577]午餐]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2577-%E5%8D%88%E9%A4%90%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数N，代表总共有N个人。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数T，代表所有人吃完饭的最早时刻。 输入输出样例Sample input 52 27 71 36 48 5 Sample output 17 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有输入数据均为不超过200的正整数。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划和贪心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先应明确：在所有人都在一个队列中时，按照每个人吃饭时间降序排列才可以获得最优解。这是一种贪心思想，是比较容易发现的，下面给出它的数学证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑两个相邻的人，假设他们前面的人总共打饭时间为p，那么如果第一个人在前，他们两人的吃完饭最晚时刻为 \max\{p+a1+b1，p+a1+a2+b2\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反之为 \max\{p+a2+b2，p+a1+a2+b1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设第一个在前更优，则有 \max\{p+a1+b1，p+a1+a2+b2\} \leq \max\{p+a2+b2，p+a1+a2+b1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到$p+a1+b1&lt;p+a1+a2+b1$并且$p+a2+b2&lt;p+a1+a2+b2$，因此上式等价于 p+a1+a2+b1\geq p+a1+a2+b2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是$b1≥b2$，即吃饭时间长的在前更优。根据相邻全局最优化原理（还记得皇后游戏吗？）可知按照吃饭时间降序排列的贪心策略是正确的。证毕。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是先对这些数据按照第二元素（也就是吃饭用时）降序排列，那么问题的重点就是如何对他们进行分队安排，这是一个动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于每一个人都有进入两个队列任意一个的决策，于是考虑决策转移。记dp(i，j，k)表示到第i个人，在第一个队列已用时j单位时间，第二个队列已用时k个单位时间的情况下，能得到的最早的吃饭完成时刻。这里的j、k已经包含了i这个人本身的打饭时间。那么有状态转移方程： dp(i，j，k)=\min\{\max\{dp(i-1，j-i.a，k)，j+i.b\}，\max\{dp(i-1，j，k-i.a)，k+i.b\}\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方程比较容易理解，两个状态分别表示将第i个人分配到第一个队列和第两个队列。如果无法分配，则直接分配到另一个合法的队列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是注意到这样开三维数组很容易MLE，又发现j+k=sum(i)恒成立，这也就是说j和k本身就有关系，在这个情况下j和k这两个状态参量可以去除一个，另一个只需求出即可。所以排序后应该求一个前缀和。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200#define inf (int)1e8using namespace std;int n, dp[N][N * N + 1];int sum[N] = &#123;0&#125;;struct node &#123; int a, b; bool operator&lt;(node x) &#123; return b &gt; x.b; &#125;&#125; op[N];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; op[i].a &gt;&gt; op[i].b; sort(op, op + n); sum[0] = op[0].a; for (int i = 1; i &lt; n; i++)sum[i] = sum[i - 1] + op[i].a; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= sum[n - 1]; j++)dp[i][j] = inf; &#125; dp[0][0] = dp[0][op[0].a] = op[0].a + op[0].b; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt;= sum[i]; j++) &#123; if (j &gt;= op[i].a)dp[i][j] = min(dp[i][j], max(dp[i - 1][j - op[i].a], j + op[i].b)); if (sum[i] - j &gt;= op[i].a)dp[i][j] = min(dp[i][j], max(dp[i - 1][j], sum[i] - j + op[i].b)); &#125; &#125; int ans = inf; for (int i = 0; i &lt;= sum[n - 1]; i++)ans = min(ans, dp[n - 1][i]); cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步观察可发现，状态转移方程的量仅限于相邻两行之间，于是可以把数组压缩至一维，这也是本题目前最好的解法。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200#define inf (int)1e8using namespace std;int n, dp[N * N];int sum[N] = &#123;0&#125;;struct node &#123; int a, b; bool operator&lt;(node x) &#123; return b &gt; x.b; &#125;&#125; op[N];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; op[i].a &gt;&gt; op[i].b; sort(op, op + n); sum[0] = op[0].a; for (int i = 1; i &lt; n; i++)sum[i] = sum[i - 1] + op[i].a; for (int j = 0; j &lt;= sum[n - 1]; j++)dp[j] = inf; dp[0] = dp[op[0].a] = op[0].a + op[0].b; for (int i = 1; i &lt; n; i++) &#123; for (int j = sum[i]; j &gt;= 0; j--) &#123; int p = inf; if (j &gt;= op[i].a)p = min(p, max(dp[j - op[i].a], j + op[i].b)); if (sum[i] - j &gt;= op[i].a)p = min(p, max(dp[j], sum[i] - j + op[i].b)); dp[j] = p; &#125; &#125; int ans = inf; for (int i = 0; i &lt;= sum[n - 1]; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1273]有线电视网]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很不容易独立A出的一道题，做做纪念。 难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行包含两个用空格隔开的整数N和M，其中2≤N≤3000，1≤M≤N-1，N为整个有线电视网的结点总数，M为用户终端的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个转播站即树的根结点编号为1，其他的转播站编号为2到N-M，用户终端编号为N-M+1到N。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的N-M行每行表示—个转播站的数据，第i+1行表示第i个转播站的数据，其格式如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K A1 C1 A2 C2 … Ak Ck&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K表示该转播站下接K个结点(转播站或用户)，每个结点对应一对整数A与C，A表示结点编号，C表示从当前转播站传输信号到结点A的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。 输入输出样例Sample input 5 32 2 2 5 32 3 2 4 33 4 2 Sample output 2 说明[样例解释]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，共有五个结点。结点①为根结点，即现场直播站，②为一个中转站，③④⑤为用户端，共M个，编号从N-M+1到N，他们为观看比赛分别准备的钱数为3，4，2，从结点①可以传送信号到结点②，费用为2，也可以传送信号到结点⑤，费用为3(第二行数据所示)，从结点②可以传输信号到结点③，费用为2。也可传输信号到结点④，费用为3(第三行数据所示)，如果要让所有用户(③④⑤)都能看上比赛，则信号传输的总费用为:2+3+2+3=10，大于用户愿意支付的总费用3+4+2=9，有线电视网就亏本了，而只让③④两个用户看比赛就不亏本了。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题实际上在考察树上的分组背包DP问题，属于树型DP。这里先介绍一种转二叉树的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先注意到题目没有给定价格和边权的数据范围，若以此为依据DP，连数组范围都难以确定。于是不妨令dp(r，k)表示以r为根的子树中满足k个用户时可以得到的最大收益，这样状态就可以得到确定，答案即为使dp(1，k)为非负时的最大k(假设1是整棵树的根)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样状态转移会很难写，因为需要把这k个用户分配给其子树，这显然有很多情况，是难以分配的。但是注意到二叉树很容易分配，于是考虑转多叉树为二叉树的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认清一个事实，以下两棵树是等价的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里新建了一个节点和一条边，并令这条边的边权为0，这样就把三叉树转成了一棵等价的二叉树。其余如四叉树等的转法与之同理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预处理出每一个节点所含的叶子节点数child(i)，DP时严格保证dp(r，k)中k≤child(r)，这样状态转移方程就可以列出:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任何节点i，dp(i，0)=0。 若i为叶子节点，则dp(i，1)=money(i)，即这个用户支付的费用。 若i有一个儿子，则dp(i，k)=dp(c1，k)-v1。c1为儿子节点，v1为到儿子的边的边权。 若i有两个儿子，则需要进行分配。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果k=child(c1)+child(c2)，则不需进行分配，直接结果就是 dp(r，k)=dp(c1，child(c1))+dp(c2，child(c2))-v1-v2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果k&lt;child(c1)+child(c2): dp(r，k)=\min\{dp(c1，k1)+dp(c2，k2)-v1-v2\}，1\leq k1\leq child(c1)，1\leq k2\leq child(c2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对只分配给一棵子树的情况需要之后另行特判。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若k≤child(c1)，则: dp(r，k)=\min\{dp(r，k)，dp(c1，k)-v1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若k≤child(c2)。则: dp(r，k)=\min\{dp(r，k)，dp(c2，k)-v2\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据状态转移方程推出结果即可，这种方法其实很快。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include &lt;cstring&gt;#include&lt;cstdio&gt;#define NUM 3000*2using namespace std;int head[NUM], to[NUM], nxt[NUM], value[NUM], child[NUM] = &#123;0&#125;;int money[3000];int dp[NUM][3000] = &#123;0&#125;;int cnt = 1, ncnt = 0;int N, M;inline void add(int x, int y, int z) &#123; nxt[cnt] = head[x], to[cnt] = y, value[cnt] = z, head[x] = cnt++;&#125;int DFS(int x) &#123; for (int i = head[x]; i != -1; i = nxt[i])child[x] += DFS(to[i]); if (child[x] == 0)return child[x] = 1; return child[x];&#125;int DP(int root, int n) &#123; if (n == 0)return 0; if (dp[root][n] &gt; -1e7)return dp[root][n]; int l1, l2; if (head[root] == -1)return dp[root][n] = money[root]; l1 = to[head[root]];//左儿子 if (nxt[head[root]] == -1)return dp[root][n] = DP(l1, n) - value[head[root]]; l2 = to[nxt[head[root]]];//右儿子 if (n == child[root])return dp[root][n] = DP(l1, child[l1]) + DP(l2, child[l2]) - value[head[root]] - value[nxt[head[root]]]; if (child[l1] &gt;= n)dp[root][n] = max(dp[root][n], DP(l1, n) - value[head[root]]); if (child[l2] &gt;= n)dp[root][n] = max(dp[root][n], DP(l2, n) - value[nxt[head[root]]]); for (int i = max(1, n - child[l2]); i &lt;= child[l1] &amp;&amp; i &lt; n; i++)dp[root][n] = max(dp[root][n], DP(l1, i) + DP(l2, n - i) - value[head[root]] - value[nxt[head[root]]]); return dp[root][n];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M; ncnt = N + 1; memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= N - M; i++) &#123; int x; cin &gt;&gt; x; if (x &lt;= 2) &#123; for (int j = 1; j &lt;= x; j++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(i, a, b); &#125; &#125; else &#123; int from = i; for (int j = 1; j &lt;= x; j++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(from, a, b); if (j &lt;= x - 2)add(from, ncnt, 0), from = ncnt++;//转二叉树 &#125; &#125; &#125; for (int i = N - M + 1; i &lt;= N; i++)cin &gt;&gt; money[i]; DFS(1); for (int i = 1; i &lt; ncnt; i++) &#123; for (int j = 0; j &lt;= child[i]; j++)dp[i][j] = static_cast&lt;int&gt;(-1e8); &#125; for (int i = M; i &gt;= 0; i--) &#123; if (DP(1, i) &gt;= 0) &#123; cout &lt;&lt; i; return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的k级覆盖问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%A0%91%E7%9A%84k%E7%BA%A7%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一棵树，约定选定一个点，被选点可以覆盖与其距离不大于k的所有节点，问覆盖整棵树的最小选点数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇《动态规划与状态设计》中提及了k=2的DP做法，但是随着k的增大，状态数也会随之增多，这里介绍一种贪心方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心思路：选择树中最深的没有被覆盖的节点，标记其k级祖先，直到整棵树都被覆盖。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体实现时，要先确定树根，计算出每一个节点的深度，每次选最深的节点，判断其是否被覆盖。若无则标记k级祖先，否则继续选点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何判断是否被标记。只需要开一个数组来记录每一个节点到与它最近的被标记点的距离即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出上一篇文章中的第一道题目(洛谷P2279，k=2)的示例代码。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 1001#define inf 10000using namespace std;int n;int father[MAX] = &#123;0&#125;, depth[MAX];//标记节点的父节点编号和深度,认为根节点为1号节点int rk[MAX];//序号,用于深度排序int dict[MAX];//离被标记点最近的距离bool cmp(int a, int b) &#123; return depth[b] &lt; depth[a]; &#125;//比较函数,用于深度排序int main() &#123; cin &gt;&gt; n; depth[1] = 1, rk[1] = 1, dict[0] = dict[1] = inf;//初始化,0是虚拟父节点 for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; father[i]; depth[i] = depth[father[i]] + 1, rk[i] = i, dict[i] = inf;//利用题目输入规则,直接确定深度和父节点 &#125; sort(rk + 1, rk + n + 1, cmp);//排序 int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int f = father[rk[i]], gf = father[f];//获取父节点和祖父 dict[rk[i]] = min(dict[rk[i]], min(dict[f] + 1, dict[gf] + 2));//更新距离 if (dict[rk[i]] &gt; 2) &#123;//没被覆盖 dict[gf] = 0, ans++;//标记父节点,计数器加一 dict[father[gf]] = min(dict[father[gf]], 1), dict[father[father[gf]]] = min(dict[father[father[gf]]], 2); //更新祖父的父节点和祖父的距离 &#125; &#125; cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记祖父时，其所有子节点孙子节点都会在它们的距离更新中被发现已被覆盖，同时祖父的父节点和祖父节点也会更新距离，从而使兄弟节点也会得到覆盖。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，如果一个节点没有父节点或者祖父节点，那么就用到了虚拟父节点的概念。当任何时候一个节点没有父节点或祖父节点时，都认为它是节点0。0就是虚拟父节点。这种方法是正确的，这是因为当一个节点未被覆盖但又没有父节点或祖父节点时，由于它是目前深度最深的未被标记的节点，只需标记根节点即可完成整棵树的全覆盖。标记0节点和标记根节点显然是等价的，它们都能覆盖整棵树，结果都是计数器加一。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，标记虚拟父节点就是标记根节点，答案不变。所以不需要对没有父节点或祖父节点时特判。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法很普适，可以推广到k级半径的问题，不用存图。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划与状态设计]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一篇文章谈谈动态规划(Dynamic Programming， DP)。本材料中大量地出现动态规划类题目，这里做一个总结。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态规划是一种解决多阶段决策问题的高效算法设计思路，它的本质是分治思想。对于一个问题，它通常由若干子问题组成，解决了这些子问题，原问题也迎刃而解。例如树这种数据结构，它的分枝仍是一棵树，又如将区间分割，得到的仍是一个区间…很多事物都满足这种性质，可以考虑用DP思路解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍一些DP术语。 状态。当前阶段所面临的客观条件称为一种状态。状态需要一定的量去描述，称为状态变(参)量。同时状态也拥有一定的值，称为状态量。 状态转移。状态可以视为一个问题，它由若干子问题构成，这些子问题也是一个个状态。由当前状态到它的子状态的过程称为状态转移。转移的数学表达式称为状态转移方程。 无后效性。每一个状态都是客观的。一个状态所对应的问题可能是多个不同问题的子问题，但是无论它从哪一个状态转移过来，这个状态都应该是客观独立的，它的任何属性都不会随受前一个状态的影响。这种性质称为无后效性，能用DP解决的问题必须满足无后效性。 最优化原理。一个问题是最优的，它的子问题必然也是最优的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用DP解决问题实际上就是设计合适的状态，列出对应的状态转移方程。DP的重点在于看清问题和子问题以确定状态，状态的设计是很重要的，它必须满足以下几点要求: 状态参量到状态量是一个多数值到单数值的映射，也就是说，每一个状态必须是确定的，唯一的，并且满足无后效性。 状态必须是可转移的，也就是能够列出明确的状态转移方程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面思考这样一个题目，来认识状态设计: 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，称基地A到基地B的距离为d。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行为n （n&lt;=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]&lt;i。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目实质上是给定一棵树，其中一个选定的点可以覆盖两层的其余顶点，求覆盖整棵树的选点最小值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个显然的状态设计思路是令f(x)表示以x为根的子树的选点最小值。这样做状态的确是唯一的并且有明确的值，但是它无法列出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，f(x)=$\sum f(k)$(k表示x的子节点)是否成立呢?显然不可，这是因为即使每一个子树都被覆盖掉了，根节点x也可能没被覆盖到;同时，每一个子树的选点覆盖范围可能有所包含，使得全局仍可以删掉几个点，结果不最优。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的状态设计显然是失败的，问题便出在状态描述不清上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时状态虽唯一，但是无法转移，就需要增加状态描述量来细化状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识到一个事实，原问题满足某种性质时，往往意味这它的子问题也要满足某种性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果定义f(x，y)表示根节点为x的子树，在满足性质P(y)的前提下最小选点数。P定义如下: P(0):子树完全被覆盖，且根节点被选。 P(1):子树完全被覆盖，子节点被选。 P(2):子树完全被覆盖，孙子节点被选。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子树被完全覆盖仅有这三种状态 P(3):所有子节点及其子树都被覆盖，但根节点未知。 P(4):所有孙子节点及其子树都被覆盖，但根节点和子节点未知。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实还可以有P(5):所有孙子节点的子节点及其子树都被覆盖，但根节点子节点，孙子节点未知。但之后可以看到这种状态不参与转移，是无用的。仅这样就是可以转移的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若原树满足P(0)，则根节点向下两层(儿子和孙子)都一定被覆盖，但是倘若全树都被覆盖，所有子树都必须满足其孙子节点及其子树都被覆盖的性质。发现P(0~4)都符合条件，可以证明其余的任何状态都不符合，又发现全树的选点数是所有子树上选点数加一，于是有: f(x，0)=\sum(min\{f(k，0...4)\})+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一个子树，取其五个性质中选点最少的一个，这样既满足性质又能使解最优。这样直接作和是不会出现漏选多选的情况的。这是因为，子树都满足了需要的性质，全树一定可以完全被覆盖，不会缺选;同时，由于每一个子树都是满足性质的，并且选的是最小值，其余状态又不能使性质成立，删掉一个点必然使性质不再成立，所以不会多点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若原树满足P(1)，则根节点下一层全被覆盖，此时因为全树都被覆盖，所有子树都必须满足其子节点和子树都被覆盖的性质(即P(0~3))，被选的点满足P(0)性质。所以有: f(x，1)=\min\{f(k，0)+\sum (\min\{f(k’，0...3)\})\}，k是任意子节点，k’是剩余的子节点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解同上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理可得: f(x，2)=\min\{f(k，1)+\sum (\min\{f(k’，0...2)\})\}，k是任意子节点，k’是剩余的子节点\\ f(x，3)=\sum (\min\{f(k，0...2)\})\\ f(x，4)=\sum (\min\{f(k，0...3)\})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种转移方法称为性质转移，它的原理是当原问题满足状态指定的某种性质时，其子问题也要满足特定的性质，这时原问题状态可以转移到所有满足特定性质的子问题状态。这里给出的五个状态就是所有满足的状态，少一个都会难以转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种转移方式即为决策转移，它的原理通常是不同的决策，例如背包问题。本题用决策转移很难列方程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地理解状态设计，来重新认识一下01背包问题这种经典DP问题。本材料第2题就是这类问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01背包属于决策转移型，决策是选不选当前的这个物品。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当从所有物品中随机拿出一个时，如果背包可以装下的话，便会面临选还是不选的问题，这便是一个决策。规定物品全集为S，拿出的物品为x，物品i价值为wi，则两种决策得到的价值分别为: 选该物品:wx+?不选该物品:0+? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的?表示后面加上的价值暂时无法确定。但是注意到，如果选了该物品，对于剩下的物品集合S-{x}与原问题集合S，它们的问题本质上是同一类问题，都是从一个集合中取一些物品使价值总和最大，不选与之同理。这样就把问题拆成了两个本质相同的子问题。同时子问题最优时，原问题才最优，这是显然的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是定义dp(Q)表示对于集合Q，从中拿走若干个物品得到的价值最大值。但是很快便发现，这其中忽略了物品体积的问题，物品体积显然会影响决策(太大时一定不能选)，并且这样描述状态并不能唯一地确定状态。于是应定义dp(Q，p)表示背包容量为p时，从集合Q中拿走若干物品得到的价值最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么就有关系(vi表示物品i的体积): 若p\geq v_x时:dp(Q，p)=\max\{dp(Q-\{x\}，p)，dp(Q-\{x\}，p-v_x)+w_x\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里从不选和选中取一个较大值。 p]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1373]小a和uim之大逃离]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1373-%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小a和uim来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个披头散发，青面獠牙的怪物，低沉着声音说：“呵呵，既然你们来到这，只能活下来一个！”。小a和他的小伙伴都惊呆了！ 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;瞬间，地面上出现了一个n*m的巨幅矩阵，矩阵的每个格子上有一坨0~k不等量的魔液。怪物各给了小a和uim一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小a用魔瓶吸收地面上的魔液，下一步由uim吸收，如此交替下去，并且要求最后一步必须由uim吸收。魔瓶只有k的容量，也就是说，如果装了k+1那么魔瓶会被清空成零，如果装了k+2就只剩下1，依次类推。怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小a和uim感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小a灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小a和他的小伙伴都笑呆了！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在他想知道他们都能活下来有多少种方法。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行，三个空格隔开的整数n，m，k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n行，m列，表示矩阵每一个的魔液量。同一行的数字用空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示方法数。由于可能很大，输出对1 000 000 007取余后的结果。 输入输出格式Sample input 2 2 31 11 1 Sample output 4 说明[样例解释]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四种方案是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)-&gt;(1，2)，(1，1)-&gt;(2，1)，(1，2)-&gt;(2，2)，(2，1)-&gt;(2，2)。[数据范围]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于20%的数据，n，m≤10，k≤2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，n，m≤100，k≤5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，n，m≤800，1≤k≤15 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划。本题对时间空间复杂度都有考验。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定f(a，b，x，y，t)表示在坐标(x，y)，两人魔液值为a，b(已吸收(x，y)处的)，在t状态(0表示小a吸收，1表示uim吸收)的方案数，则有递推关系: f(a，b，x，y，0)=f(a，(b+value(x+1，y))\%(1+k)，x+1，y，1)+f(a，(b+value(x，y+1)\%(1+k))，x，y+1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时有: f(a，b，x，y，1)=f((a+value(x+1，y))\%(1+k)，b，x+1，y，0)+f((a+value(x，y+1))\%(1+k)，b，x，y+1，0)+∂(a，b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∂(a，b)在a=b时为1，否则为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$\sum f(value(x，y)，0，x，y，0)$，1≤x≤n且1≤y≤m。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个5维的递推式，需要用一个5维数组储存数据，极易MLE。注意到递推式只与两个相邻行有关，可以考虑压缩数组(这个思想已经用过很多次了)。但是不能直接将其压缩至4维，这是因为其余维度的数据很难保证不被异常覆盖。这时采用滚动数组的方法，这是压缩数组维数不可行时的另一种解决方案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动数组很容易理解。将控制行的一维压缩至2个元素，分别储存待计算的一行和提供递推数据的一行(即相邻的两行)。两行交替进行递推，便可递推出所有的数值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出原版代码和滚动数组优化的代码，请读者观察其区别。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)#define S2(x) (x&lt;MOD?x:x-MOD)using namespace std;int dp[16][16][805][805][2] = &#123;0&#125;;int op[805][805];int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; k++;//k自加,后边不用再+1 for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)cin &gt;&gt; op[i][j]; &#125; for (int i = 0; i &lt; k; i++)dp[i][i][n][m][1] = 1;//递推奠基 for (int i = n; i ≥ 1; i--) &#123; for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int a = 0; a &lt; k; a++) &#123; for (int b = 0; b &lt; k; b++) &#123; dp[a][b][i][j][0] = dp[a][S1(b + op[i + 1][j])][i + 1][j][1] + dp[a][S1(b + op[i][j + 1])][i][j + 1][1]; dp[a][b][i][j][1] = dp[S1(a + op[i + 1][j])][b][i + 1][j][0] + dp[S1(a + op[i][j + 1])][b][i][j + 1][0]; if (a == b)dp[a][b][i][j][1]++; dp[a][b][i][j][0] = S2(dp[a][b][i][j][0]); dp[a][b][i][j][1] = S2(dp[a][b][i][j][1]); &#125; &#125; &#125; &#125; int ans = 0; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)ans += dp[op[i][j]][0][i][j][0], ans = S2(ans);//求和 &#125; cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动数组优化版本(65分)(外加读入优化)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)int dp[16][16][2][805][2] = &#123;0&#125;;//第三维压至2个元素short int op[805][805];int n, m, k;inline int ID(int x) &#123; if (x == 1)return 0; return 1;&#125;short int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); short int sum = 0; while (e ≥ '0' &amp;&amp; e ≤ '9') &#123; sum = sum * 10 + e - '0'; e = getchar(); &#125; return sum;&#125;int main() &#123; n = read(), m = read(), k = read(); k++; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)op[i][j] = read(); &#125; for (int i = 0; i &lt; k; i++)dp[i][i][0][m][1] = 1; bool key = true; int ans = 0; for (int i = n; i ≥ 1; i--) &#123; key = !key;//控制交替 for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int a = 0; a &lt; k; a++) &#123; for (int b = 0; b &lt; k; b++) &#123; dp[a][b][key][j][0] = dp[a][S1(b + op[i + 1][j])][!key][j][1] + dp[a][S1(b + op[i][j + 1])][key][j + 1][1]; dp[a][b][key][j][1] = dp[S1(a + op[i + 1][j])][b][!key][j][0] + dp[S1(a + op[i][j + 1])][b][key][j + 1][0]; if (a == b)dp[a][b][key][j][1]++; if (dp[a][b][key][j][0] ≥ MOD) dp[a][b][key][j][0] -= MOD; if (dp[a][b][key][j][1] ≥ MOD)dp[a][b][key][j][1] -= MOD; &#125; &#125; ans += dp[op[i][j]][0][key][j][0];//答案必须即时更新,因为数组经压缩,数据得不到保存 if (ans ≥ MOD)ans -= MOD; &#125; &#125; printf("%d", ans); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这样并不是最优解，这里需要注意到两人的魔液值其实没有实质意义，它们的差才是最重要的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义f(h，x，y，t)表示两人魔液值差为h(若为负则转化为k最小剩余系中与h对1+k同余的数)，其余意义不变。差值为h表示小a要么比uim多h，要么比他少1+k-h，当其中任一人的值确定时，另一人的值通过h必然唯一确定。由此可知，这样定义的差值是合理的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知h=(V(0)-V(1))%(1+k)，V(0)，V(1)分别为小a，uim的魔液值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小a吸收p个单位的魔液时: h=((p+V(0))\%(1+k)-V(1))\%(1+k)=(p+V(0)-V(1))\%(1+k)=(p+h)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当uim吸收p个单位的魔液时: h=(V(0)-(V(1)+p)\%(1+k))\%(1+k)=(V(0)-V(1)-p)\%(1+k)=(h-p)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际计算中，由于计算机计算余数并不一定得到正数，故后一个式子要写成: h=(h-p+k+1)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可知无论两人实际的魔液值为多少，只要确定了差值，经过一定的吸收变化，其差值总是唯一确定的。所以可以将前两维压缩至1维，仅表示差值的大小。0即表示两人魔液值相同。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)int dp[16][2][805][2] = &#123;0&#125;;short int op[805][805];int n, m, k;inline short int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); short int sum = 0; while (e ≥ '0' &amp;&amp; e ≤ '9') &#123; sum = sum * 10 + e - '0'; e = getchar(); &#125; return sum;&#125;int main() &#123; n = read(), m = read(), k = read(); k++; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)op[i][j] = read(); &#125; dp[0][0][m][1] = 1; bool key = true; int ans = 0; for (int i = n; i ≥ 1; i--) &#123; key = !key; for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int b = 0; b &lt; k; b++) &#123; dp[b][key][j][0] = dp[S1(b - op[i + 1][j] + k)][!key][j][1] + dp[S1(b - op[i][j + 1] + k)][key][j + 1][1]; dp[b][key][j][1] = dp[S1(b + op[i + 1][j])][!key][j][0] + dp[S1(b + op[i][j + 1])][key][j + 1][0]; if (b == 0)dp[0][key][j][1]++; if (dp[b][key][j][0] ≥ MOD) dp[b][key][j][0] -= MOD; if (dp[b][key][j][1] ≥ MOD)dp[b][key][j][1] -= MOD; &#125; ans += dp[op[i][j]][key][j][0]; if (ans ≥ MOD)ans -= MOD; &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1850]换教室]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1850-%E6%8D%A2%E6%95%99%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在可以选择的课程中，有2n节课程安排在n个时间段上。在第i(1≤i≤n)个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室ci上课，而另一节课程在教室di进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第i个时间段去教室di上课，否则仍然在教室ci上课。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第i节课程的教室时，申请被通过的概率是一个已知的实数ki，并且对于不同课程的申请，被通过的概率是互相独立的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多m节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请;牛牛可以申请自己最希望更换教室的m门课程，也可以不用完这m个申请的机会，甚至可以一门课程都不申请。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;牛牛所在的大学有v个教室，有e条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第i(1≤i≤n−1)节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行四个整数 n，m，v，e。n表示这个学期内的时间段的数量;m表示牛牛最多可以申请更换多少节课程的教室;v表示牛牛学校里教室的数量;e表示牛牛的学校里道路的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行n个正整数，第i(1≤i≤n)个正整数表示ci，即第i个时间段牛牛被安排上课的教室;保证1≤ci≤v。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行n个正整数，第i(1≤i≤n)个正整数表示di，即第i个时间段另一间上同样课程的教室;保证1≤di≤v。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四行n个实数，第i(1≤i≤n)个实数表示ki，即牛牛申请在第i个时间段更换教室获得通过的概率。保证0≤ki≤1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来e行，每行三个正整数aj，bj，wj，表示有一条双向道路连接教室aj，bj，通过这条道路需要耗费的体力值是wj;保证1≤aj，bj≤v，1≤wj≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证1≤n≤2000，0≤m≤2000，1≤v≤300，0≤e≤90000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证输入的实数最多包含3位小数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出一行，包含一个实数，四舍五入精确到小数点后恰好2位，表示答案。你的输出必须和标准输出完全一样才算正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于4×10−3。(如果你不知道什么是浮点误差，这段话可以理解为:对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理) 输入输出样例Sample input 3 2 3 32 1 21 2 10.8 0.2 0.51 2 51 3 32 3 1 Sample output 2.80 说明[样例1说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有可行的申请方案和期望收益如下表:[提示]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道路中可能会有多条双向道路连接相同的两间教室。也有可能有道路两端连接的是同一间教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意区分n，m，v，e的意义，n不是教室的数量， m不是道路的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊性质1:图上任意两点ai，bi，ai≠bi间，存在一条耗费体力最少的路径只包含一条道路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊性质2:对于所有的1≤i≤n，ki=1。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察图的最短路和期望DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道路和教室视为图，用Floyd算法求出各个节点对的最短路。注意考虑自环和重边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题重点在于期望DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期望DP的原则是:只能作各阶段期望的和，不允许用子阶段期望乘概率。我就曾因试图用子阶段期望乘概率而出问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若令dp(i，j，t)表示经过1~i节课，用了j次申请机会，第i节课申请状态为t(只能是0或1)所得的期望最小值。容易发现，这样设计状态可以完整地描述状态并且能够进行状态转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且有状态转移方程: dp(i，j，0)=\min\{dp(i-1，j，0)+dict(c_{i-1}，c_i)，dp(i-1，j，1)+dict(c_{i-1}，c_i)*k_{i-1}+dict(d_{i-1}，c_i)*(1-k_{i-1})\}，j\leq i-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出，这是阶段期望的相加运算。 dp(i，j，1)=\min\{dp(i-1，j-1，0)+dict(c_{i-1}，d_i)*k_i+dict(c_{i-1}，c_i)*(1-k_i)，dp(i-1，j-1，1)+dict(c_{i-1}，c_i)*(1-k_{i-1})*(1-k_i)+dict(c_{i-1}，d_i)*(1-k_{i-1})*k_i+dict(d_{i-1}，c_i)*k_{i-1}*(1-k_i)+dict(d_{i-1}，d_i)*k_{i-1}*k_i\}，j≠0且j\leq i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;史上最长状转方程没有之一&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化dp(1，0，0)=dp(1，1，1)=0.0，其余inf。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即是min{dp(n，q，0)，dp(n，q，1)}，0≤q≤m。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;iomanip&gt;#define inf (int)1e8using namespace std;int dict[301][301];int c[2001], d[2001];double k[2001];int n, m, v, e;double dp[2001][2001][2];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; v &gt;&gt; e; for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++)if (i == j)dict[i][i] = 0; else dict[i][j] = inf; &#125; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; c[i];//原有 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; d[i];//欲更换 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; k[i];//概率 for (int i = 1; i &lt;= e; i++) &#123;//读图 int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; dict[x][y] = dict[y][x] = min(dict[x][y], z); &#125; for (int k = 1; k &lt;= v; k++) &#123;//Floyed算法 for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i != j &amp;&amp; j != k &amp;&amp; k != i)dict[i][j] = min(dict[i][j], dict[i][k] + dict[k][j]); &#125; for (int i = 1; i &lt;= n; i++)//预处理 for (int j = 0; j &lt;= m; j++)dp[i][j][0] = dp[i][j][1] = inf; dp[1][0][0] = 0.0, dp[1][1][1] = 0.0; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i; j++) &#123; if (j &lt; i) dp[i][j][0] = min(dp[i - 1][j][0] + dict[c[i - 1]][c[i]], dp[i - 1][j][1] + dict[d[i - 1]][c[i]] * k[i - 1] +dict[c[i - 1]][c[i]] * (1 - k[i - 1])); if (j != 0) dp[i][j][1] = min(dp[i - 1][j - 1][0] + dict[c[i - 1]][d[i]] * k[i] +dict[c[i - 1]][c[i]] * (1 - k[i]), dp[i - 1][j - 1][1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]) + dict[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i] +dict[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]) +dict[d[i - 1]][d[i]] * k[i - 1] * k[i]); &#125; &#125; double ans = inf; for (int i = 0; i &lt;= m; i++)ans = min(ans, min(dp[n][i][0], dp[n][i][1])); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，状态转移方程前两维只与上边一行的元素有关，且有关的列不大于当前列。于是可以压缩数组至2维，此时枚举j时要倒序枚举。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;iomanip&gt;#define inf (int)1e8using namespace std;int dict[301][301];int c[2001], d[2001];int n, m, v, e;double k[2001];double dp[2001][2];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; v &gt;&gt; e; for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++)if (i == j)dict[i][i] = 0; else dict[i][j] = inf; &#125; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; c[i];//原有 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; d[i];//欲更换 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; k[i];//概率 for (int i = 1; i &lt;= e; i++) &#123;//读图 int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; dict[x][y] = dict[y][x] = min(dict[x][y], z); &#125; for (int k = 1; k &lt;= v; k++) &#123;//Floyed算法 for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i != j &amp;&amp; j != k &amp;&amp; k != i)dict[i][j] = min(dict[i][j], dict[i][k] + dict[k][j]); &#125; for (int j = 0; j &lt;= m; j++)dp[j][0] = dp[j][1] = inf; dp[0][0] = dp[1][1] = 0.0; for (int i = 2; i &lt;= n; i++) &#123; for (int j = min(m, i); j &gt;= 0; j--) &#123; if (j &lt; i) dp[j][0] = min(dp[j][0] + dict[c[i - 1]][c[i]], dp[j][1] + dict[d[i - 1]][c[i]] * k[i - 1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1])); if (j != 0) dp[j][1] = min(dp[j - 1][0] + dict[c[i - 1]][d[i]] * k[i] + dict[c[i - 1]][c[i]] * (1 - k[i]), dp[j - 1][1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]) + dict[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i] + dict[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]) + dict[d[i - 1]][d[i]] * k[i - 1] * k[i]); &#125; &#125; double ans = inf; for (int i = 0; i &lt;= m; i++)ans = min(ans, min(dp[i][0], dp[i][1])); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>图论</tag>
        <tag>图的最短路</tag>
        <tag>动态规划</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1242]新汉诺塔]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1242-%E6%96%B0%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 本文题解改编自洛谷题解第二篇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在洛谷上看到了一种新奇的解法，记录一下。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设有n个大小不等的中空圆盘，按从小到大的顺序从1到n编号。将这n个圆盘任意的迭套在三根立柱上，立柱的编号分别为A，B，C，这个状态称为初始状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移动时有如下要求: 一次只能移一个盘; 不允许把大盘移到小盘上面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件第一行是状态中圆盘总数;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二到第四行分别是初始状态中A，B，C柱上圆盘的个数和从上到下每个圆盘的编号;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五到第七行分别是目标状态中A，B，C柱上圆盘的个数和从上到下每个圆盘的编号。输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行一步移动方案，格式为：move I from P to Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行输出最少的步数。 输入输出样例Sample input 53 3 2 12 5 401 23 5 4 31 1 Sample output move 1 from A to Bmove 2 from A to Cmove 1 from B to Cmove 3 from A to Bmove 1 from C to Bmove 2 from C to Amove 1 from B to C7 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;圆盘总数≤45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行的圆盘描述是从下到上的圆盘编号。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题解用了随机数…竟然A了，这应该是和模拟退火算法类似的一种算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知大盘要在小盘之前就位，否则小盘最终仍要移动。为了得到最简洁的步骤，应从大到小使各个盘子依次就位。但每一个盘子有两种移动方式:直接就位和先移到辅助位再移到目标位。通常前者更优但后者在某些情况下优于前者。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个盘子移动时，比其小的盘子不能出现在原位和要移动的位置上，必须全部放到辅助位上。于是事先要先移动较小盘，这是一个递归过程，模拟这个过程即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个通俗的做法是每一次都同时考虑这两种情况并进行状态转移。这里采用另一种方法—随机数转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次使用后一种(见上文)转移方法时都有一定的概率，这个概率随着时间的推移不断减小(这是模拟退火算法的思想)。也就是说用随机数来判别下一次的状态转移方式。这样做显然偶然性太大，可以使这个过程进行更多次(比如500次)，来获得很高概率的正确性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随机数转移法将总路径压缩到一定的值，比起朴素盲目搜索算法大大简化了总状态数。但缺点是具有一定偶然性，可以通过参数调整的方法来尽可能地提高正确率。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;using namespace std;int first[46], last[46];int first2[46], last2[46];int n, ans = static_cast&lt;int&gt;(1e8);int ANS[233333], size = 0;int an[233333];void mv(int p, int from, int to) &#123; if (from == to)return;//就在目标位上,不用动 for (int i = p - 1; i &gt;= 1; i--)mv(i, first2[i], 6 - from - to);//小盘全移到辅助位上 ANS[size++] = p * 100 + from * 10 + to;//记录移动步骤 first2[p] = to;//修改&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= 3; i++) &#123; int x, y; cin &gt;&gt; x; for (int j = 1; j &lt;= x; j++) &#123; cin &gt;&gt; y; first[y] = i; &#125; &#125; for (int i = 1; i &lt;= 3; i++) &#123; int x, y; cin &gt;&gt; x; for (int j = 1; j &lt;= x; j++) &#123; cin &gt;&gt; y; last[y] = i; &#125; &#125; srand(23333);//随机种子 for (int g = 1; g &lt;= 500; g++) &#123; size = 0; for (int i = 1; i &lt;= n; i++)first2[i] = first[i], last2[i] = last[i];//先复制一遍数据 for (int i = n; i &gt;= 1; i--) &#123; if (rand() % (n - i + 2) == 0)mv(i, first2[i], 6 - first2[i] - last2[i]), mv(i, first2[i], last2[i]);//第二种转移 else mv(i, first2[i], last2[i]);//第一种转移 &#125; if (ans &gt; size) &#123;//获得更优解,记录 ans = size; for (int i = 0; i &lt; size; i++)an[i] = ANS[i]; &#125; &#125; for (int i = 0; i &lt; ans; i++) cout &lt;&lt; "move " &lt;&lt; an[i] / 100 &lt;&lt; " from " &lt;&lt; char(an[i] % 100 / 10 + 'A' - 1) &lt;&lt; " to " &lt;&lt; char(an[i] % 10 + 'A' - 1) &lt;&lt; endl; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>随机数</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2827]蚯蚓]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2827-%E8%9A%AF%E8%9A%93%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题中，我们将用符号⌊c⌋表示对c向下取整，例如:⌊3.0⌋ = ⌊3.1⌋ = ⌊3.9⌋ = 3。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国里现在共有n只蚯蚓(n为正整数)。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为ai(i=1，2，… ，n)，并保证所有的长度都是非负整数(即:可能存在长度为0的蚯蚓)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只(如有多个则任选一个)将其切成两半。神刀手切开蚯蚓的位置由常数p(是满足0 &lt; p &lt; 1的有理数)决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为⌊px⌋和x - ⌊px⌋的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q(是一个非负整常数)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来……(m为非负整数)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m秒内，每一秒被切断的蚯蚓被切断前的长度(有m个数);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m秒后，所有蚯蚓的长度(有n+m个数)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王当然知道怎么做啦！但是他想考考你…… 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含六个整数 n，m，q，u，v，t其中:n，m，q的意义见[问题描述];u，v，t均为正整数;你需要自己计算 p=u/v(保证0]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2831]愤怒的小鸟]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我第一年竞赛(NOIP2016)的最后一题，考状压DP，当时拿了5分，印象十分深刻，现在特此记录一下AC过程。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kiana 最近沉迷于一款神奇的游戏无法自拔。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说，这款游戏是在一个平面上进行的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一架弹弓位于 (0，0)处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx的曲线，其中a，b是Kiana 指定的参数，且必须满足a &lt; 0，a，b 都是实数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小鸟落回地面(即x轴)时，它就会瞬间消失。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在游戏的某个关卡里，平面的第一象限中有n只绿色的小猪，其中第i只小猪所在的坐标为(xi，yi)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某只小鸟的飞行轨迹经过了(xi，yi)，那么第i只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一只小鸟的飞行轨迹没有经过(xi，yi)，那么这只小鸟飞行的全过程就不会对第i只小猪产生任何影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，若两只小猪分别位于(1，3)和(3，3)，Kiana可以选择发射一只飞行轨迹为y=-x2+4x的小鸟，这样两只小猪就会被这只小鸟一起消灭。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这款神奇游戏的每个关卡对 Kiana来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在[输入格式]中详述。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设这款游戏一共有T个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数T，表示游戏的关卡总数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面依次输入这T个关卡的信息。每个关卡第一行包含两个非负整数n，m分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的n行中，第i行包含两个正实数xi，yi，表示第i只小猪坐标为(xi，yi)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=0，表示Kiana输入了一个没有任何作用的指令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=1，则这个关卡将会满足:至多用⌈n/3+1⌉只小鸟即可消灭所有小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=2，则这个关卡将会满足:一定存在一种最优解，其中有一只小鸟消灭了至少⌊n/3⌋只小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证1≤n≤18，0≤m≤2，0 &lt; xi，yi &lt; 10，输入中的实数均保留到小数点后两位。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文中，符号⌈c⌉和⌊c⌋分别表示对c向上取整和向下取整，例如:⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个关卡依次输出一行答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。 输入输出样例Sample input#1 22 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.00 Sample output#1 11 Sample input#2 32 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.00 Sample output#2223 Sample input#3 110 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99 Sample output#3 6 说明[样例解释1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这组数据中一共有两个关卡。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个关卡与[问题描述]中的情形相同，2只小猪分别位于(1.00，3.00)和(3.00，3.00)，只需发射一只飞行轨迹为y = -x2 + 4x的小鸟即可消灭它们。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个关卡中有5只小猪，但经过观察我们可以发现它们的坐标都在抛物线 y = -x2 + 6x上，故Kiana只需要发射一只小鸟即可消灭所有小猪。[数据范围] 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察状态压缩DP，与上一个题目思想类似，但实现更复杂。另外其实我没看出来指令的作用…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据状压DP的思路，仍用一个二进制数来表示状态。对于一个二进制数x，当第i位为0时表示第i只小猪未被消灭，为1表示已被消灭，令f(x)表示在x的状态下需要发射的最少的小鸟数量，则有状态转移方程: f(x)=1+\min(f(x|1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJUOJ]难以置信的竞赛]]></title>
    <url>%2F2019%2F01%2F10%2FTJUOJ-%E9%9A%BE%E4%BB%A5%E7%BD%AE%E4%BF%A1%E7%9A%84%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[难度：估计在普及+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;天津大学OJ上的一道题，最早来自The 7th UESTC Programming Contest Preliminary。看rank list发现这道题都做的特别惨烈…一看这题感觉是状压DP，一写果然A了，在这里做一个总结。之后应该还会有类似的情景。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题在http://acm.tju.edu.cn/toj/vcontest/showp10518_B.html ，下面是翻译。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上周，应用数学学院举办了放风筝比赛，参赛者分成两组，一对选手与另一名参赛者竞争。众所周知，划分对的不同方式可能带来不同的精彩等级值，精彩等级值是一个数。现在，叶小姐想知道如何划分竞争对手，以达到最高的精彩等级。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行包含一个整数T，表示测试样例的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每个测试样例，在第一行中有一个整数N(N≤16，N总是偶数)，表示有N名参赛者参加比赛。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下一个N行中，每行包含N个数。当第i个选手和第j个常数在一对中进行时，第i行中的第j个数是对应的精彩等级值。数据保证第i行中的第j个数等于第j行中的第i个数，即输入的矩阵是对称的。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每种情况，输出最大的精彩等级值，保留两位小数。 输入输出样例Sample input 120.0 1.01.0 0.0 Sample output 1.00 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察状态压缩DP(状压DP)，这是继离散化，压缩数组等DP技巧后的又一个重要方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态压缩DP是指用二进制编码的方法记录状态。这类的问题通常状态很多，但个体总数是不大的，比如本题小于16。这时可以用一个16位二进制数的01序列顺序来记录这些状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于一个二进制数x，用第i位为0表示第i+1个人未被安排，为1表示已被安排。f(x)表示在此情况下所得的最大精彩等级值，那么有状态转移方程： f(x)=\max\{f(x|(1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1514]引水入城]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1514-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N行×M列的矩形，如下图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，只有与湖泊毗邻的第1行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第N行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢?如果能，请计算最少建造几个蓄水厂;如果不能，求干旱区中不可能建有水利设施的城市数目。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行两个数，之间用一个空格隔开。输入的第一行是两个正整数N，M表示矩形的规模。接下来N行，每行M个正整数，依次代表每座城市的海拔高度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两行。如果能满足要求，输出的第一行是整数1，第二行是一个整数，代表最少建造几个蓄水厂;如果不能满足要求，输出的第一行是整数0，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。 输入输出样例Sample input#1 2 59 1 5 4 38 7 6 1 2 Sample output#1 11 Sample input#2 3 68 4 5 6 4 47 3 4 3 3 33 2 2 1 1 2 Sample output#2 13 说明[样例1 说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需要在海拔为9的那座城市中建造蓄水厂，即可满足要求。[样例2 说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图中，在3个粗线框出的城市中建造蓄水厂，可以满足要求。以这3个蓄水厂为源头在干旱区中建造的输水站分别用3 种颜色标出。当然，建造方法可能不唯一。[数据范围] 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察搜索算法和区间覆盖问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将水的流向关系抽象成有向无环图。实际操作中没有必要存图，只需在搜索中现找到邻边即可，这样时间差距不大但空间消耗大大减小，只有在无法现搜边的情况下才存图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样经过DFS或BFS即可找到第一行每一个城市能够联通的节点。本题中推荐BFS，因为图的规模过大很容易使DFS递归深度过高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过m次BFS，可以确定末行那些节点是与第一行联通的，若有k个无法联通，说明该处不可能建有水利工程，输出0即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题关键在于求最少数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先要知道如果每一个末行节点都与第一行某节点联通，则任何一个首行节点在末行与之联通的节点必定是连续的(可以画图验证)。这样可以得到每一个首行节点在末行的覆盖区间。问题便转化为区间完全覆盖问题，用贪心算法求解即得。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意本题中的一处剪枝:若首行中某一个节点值小于其左边或右边的节点值，则该节点不用考虑。这是因为其周围的节点覆盖区间一定包含该节点的覆盖区间，去除这一个子区间对于解区间完全覆盖问题是没有任何影响的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;struct Temp &#123; int l, r, rank; Temp() : l(static_cast&lt;int&gt;(1e8)), r(static_cast&lt;int&gt;(-1e8)) &#123;&#125; bool operator&lt;(Temp t) &#123; return this-&gt;l &lt; t.l; &#125;&#125; can[550];int op[250500];bool vis[250500] = &#123;false&#125;;bool mainVis[550] = &#123;false&#125;;int n, m;inline void BFS(int x) &#123; queue&lt;int&gt; que; que.push(x); while (!que.empty()) &#123; int a = que.front(); if (a &gt;= n * m - m)can[x].l = min(can[x].l, a % m), can[x].r = max(can[x].r, a % m), mainVis[a % m] = true; que.pop(); if (a &gt;= m &amp;&amp; op[a - m] &lt; op[a] &amp;&amp; !vis[a - m])que.push(a - m),vis[a - m] = true; if (a &lt; n * m - m &amp;&amp; op[a + m] &lt; op[a] &amp;&amp; !vis[a + m])que.push(a + m), vis[a + m] = true; if (a % m != 0 &amp;&amp; op[a - 1] &lt; op[a] &amp;&amp; !vis[a - 1])que.push(a - 1), vis[a - 1] = true; if (a % m != m - 1 &amp;&amp; op[a + 1] &lt; op[a] &amp;&amp; !vis[a + 1])que.push(a + 1), vis[a + 1] = true; &#125;&#125;inline int read() &#123; char e = static_cast&lt;char&gt;(getchar()); while (e &lt; '0' || e &gt; '9')e = static_cast&lt;char&gt;(getchar()); int sum = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10, sum += e - '0'; e = static_cast&lt;char&gt;(getchar()); &#125; return sum;&#125;int main() &#123; n = read(), m = read(); int c = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; op[c++] = read(); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; memset(vis, 0, sizeof(vis)); if (m != 1) &#123; if (i == 0 &amp;&amp; op[0] &lt; op[1])continue; if (i == m - 1 &amp;&amp; op[m - 1] &lt; op[m - 2])continue; if (i != 0 &amp;&amp; i != m - 1 &amp;&amp; (op[i] &lt; op[i - 1] || op[i] &lt; op[i + 1]))continue; &#125; BFS(i); &#125; bool key = true; int ans1 = 0; for (int i = 0; i &lt; m; i++) &#123; if (!mainVis[i])key = false, ans1++; &#125; if (key) &#123; cout &lt;&lt; 1 &lt;&lt; endl; sort(can, can + m); int r = 0, ans2 = 0, i = 0; while (r &lt; m) &#123; int p = 0; while (i &lt; m &amp;&amp; can[i].l &lt;= r)p = max(p, can[i++].r); r = p + 1; ans2++; &#125; cout &lt;&lt; ans2; &#125; else cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>区间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1312]Mayan游戏]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1312-Mayan%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个7行5列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下: 每步移动可以且仅可以沿横向(即向左或向右)拖动某一方块一格:当拖动这一方块时，如果拖动后到达的位置(以下称目标位置)也有方块，那么这两个方块将交换位置(参见输入输出样例说明中的图6到图7 );如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落(直到不悬空，参见下面图1 和图2); 任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除(参见图1 到图3)。 注意: 如果同时有多组方块满足消除条件，几组方块会同时被消除(例如下面图4 ，三个颜色为1的方块和三个颜色为2的方块会同时被消除，最后剩下一个颜色为2的方块)。 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除(例如下面图5 所示的情形，5 个方块会同时被消除)。 方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意:掉落的过程中将不会有方块的消除。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面图1到图3给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为(0，0)，将位于(3，3)的方块向左移动之后，游戏界面从图1变成图2所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图3所示的局面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共 6 行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为一个正整数n，表示要求游戏通关的步数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的5行，描述7×5的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个0结束，自下向上表示每竖列方块的颜色编号(颜色不多于10种，从1开始顺序编号，相同数字表示相同颜色)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据保证初始棋盘中没有可以消除的方块。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有解决方案，输出n行，每行包含 3 个整数x，y，g表示一次移动，每两个整数之间用一个空格隔开，其中(x，y)(x，y)表示要移动的方块的坐标，g表示移动的方向，1表示向右移动，-1表示向左移动。注意:多组解时，按照x为第一关健字，y为第二关健字，1优先于-1，给出一组字典序最小的解。游戏界面左下角的坐标为(0，0)(0，0)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有解决方案，输出一行，包含一个整数-1。 输入输出样例Sample input 31 02 1 02 3 4 03 1 02 4 3 4 0 Sample output 2 1 13 1 13 0 1 说明[输入输出样例说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按箭头方向的顺序分别为图6到图11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;样例输入的游戏局面如上面第一个图片所示，依次移动的三步是:(2，1)处的方格向右移动，(3，1)处的方格向右移动，(3，0)处的方格向右移动，最后可以将棋盘上所有方块消除。[数据范围]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，初始棋盘上的方块都在棋盘的最下面一行;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，0&lt;n≤5。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察DFS。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到题目规则很复杂，动态规划状态太多压不下，并且数据量固定为5×7，可以考虑时间复杂度很高的暴力DFS法。本题很考验码力。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本做法正如题目中所言，按部就班模拟即可，还要注意一处剪枝:若一个方块左侧有方块时没有必要进行向左交换，因为之前必定有与之等价的右交换发生了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其余见示例代码注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;struct node &#123; int x, y, status;//相当于队列节点&#125; ans[5];//存答案int op[5][7] = &#123;0&#125;, n;//存当前的图案信息和移动次数int sum = 0;//记录还没有解决的色块数目inline void copy(int a[5][7], int b[5][7]) &#123;//复制数组函数 for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++)a[i][j] = b[i][j]; &#125;&#125;inline void findR(int x, int y, int &amp;last, int &amp;end) &#123;//找行上相同色块范围 for (int i = x; op[i][y] == op[x][y] &amp;&amp; i &gt;= 0; i--)last = i; for (int i = x; op[i][y] == op[x][y] &amp;&amp; i &lt; 5; i++)end = i;&#125;inline void findC(int x, int y, int &amp;last, int &amp;end) &#123;//找列上相同色块范围 for (int i = y; op[x][i] == op[x][y] &amp;&amp; i &gt;= 0; i--)last = i; for (int i = y; op[x][i] == op[x][y] &amp;&amp; i &lt; 7; i++)end = i;&#125;int update() &#123;//更新当前的图案信息 bool key[10][20] = &#123;false&#125;;//标志那个色块需要被解决 int l1, e1, l2, e2, t = 0; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; if (op[i][j] == 0)continue;//没有色块不考虑 findR(i, j, l1, e1), findC(i, j, l2, e2);//找到它的相同色块范围 if (e1 - l1 &gt;= 2) &#123; for (int p = l1; p &lt;= e1; p++)key[p][j] = true;//标记为true &#125; if (e2 - l2 &gt;= 2) &#123; for (int p = l2; p &lt;= e2; p++)key[i][p] = true; &#125; &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123;//解决所有被标记的色块 for (int j = 0; j &lt; 7; j++) &#123; if (!key[i][j])continue; t++;//统计被解决色的数目 op[i][j] = 0;//置为0,表示没有色块 &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123;//处理落下的色块 int begin = 0; while (op[i][begin] != 0 &amp;&amp; begin &lt; 7)begin++; for (int j = begin + 1; j &lt; 7; j++)if (op[i][j] != 0)op[i][begin++] = op[i][j]; for (int j = begin; j &lt; 7; j++)op[i][j] = 0; &#125; if (t != 0) &#123; return t + update();//如果本次处理了色块就可能有其余色块需要被解决,继续递归 &#125; return 0;//没有被解决的就返回0&#125;void DFS(int rank, int tot) &#123; if (rank == n) &#123; if (tot == 0) &#123;//全部的色块被解决,输出答案 for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ans[i].x &lt;&lt; " " &lt;&lt; ans[i].y &lt;&lt; " " &lt;&lt; ans[i].status &lt;&lt; endl; &#125; exit(0);//然后立即结束程序 &#125; else return;//否则返回 &#125; int temp[5][7];//储存没被处理的图案信息 copy(temp, op);//复制数组 for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; if (temp[i][j] == 0)continue; copy(op, temp);//每一次都要还原图案信息,相当于朴素DFS中的visit标记清零 if (i &lt; 4) &#123; ans[rank].x = i, ans[rank].y = j, ans[rank].status = 1; if (temp[i + 1][j] == 0) &#123;//右移落下的情况 int begin = 0; while (temp[i + 1][begin] != 0)begin++; op[i + 1][begin] = temp[i][j]; for (int z = j + 1; z &lt; 7; z++)op[i][z - 1] = op[i][z]; op[i][6] = 0; DFS(rank + 1, tot - update()); &#125; else &#123;//右移交换的情况 if (op[i + 1][j] == op[i][j])continue; swap(op[i + 1][j], op[i][j]); DFS(rank + 1, tot - update()); &#125; &#125; copy(op, temp); if (i &gt;= 1) &#123;//左移落下的情况 ans[rank].x = i, ans[rank].y = j, ans[rank].status = -1; if (temp[i - 1][j] == 0) &#123; int begin = 0; while (temp[i - 1][begin] != 0)begin++; op[i - 1][begin] = temp[i][j]; for (int z = j + 1; z &lt; 7; z++)op[i][z - 1] = op[i][z]; op[i][6] = 0; DFS(rank + 1, tot - update()); &#125; else continue;//左移交换,由于之前必有等价的右移在先,可知其不可行,直接剪枝,不考虑这一步 &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; 5; i++) &#123; int x, j = 0; while (cin &gt;&gt; x) &#123; if (x == 0)break; op[i][j++] = x; sum++; &#125; &#125; DFS(0, sum);//sum表示有多少色块 cout &lt;&lt; -1;//DFS过程中没有结束程序,说明无解,输出-1 return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合方案数问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E7%BB%84%E5%90%88%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里介绍组合方案数的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定N个正整数和M，用这N个数中的一些数进行求和，使得和为M，问方案数。该问题可以采用动态规划的方法快速求得。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设dp(x，y)表示从序号为1~x的数中选使得和为y的方案数，则有状态转移方程: dp(x,y)=\begin{cases}dp(x-1，y)+1 & y=value(x)\\ dp(x-1，y)+dp(x-1，y-value(x)) & y>value(x)\\ dp(x-1，y) & y]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间问题专题]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次探讨区间问题，这大多是基于贪心算法的，在很多题目中都能用到。下面讨论仅限于闭区间，开区间只需稍作调整即可。 区间完全覆盖问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间和这个区间上的m个子区间，求其中尽量少的区间，使得它们的并集覆盖整个区间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法:将各个区间的左端点升序排序;确定左值p，初始化p=0。从所有左端点小于等于左值的区间中选出右端点最大的一个，并加入集合，更新左值为右端点值+1。贪心正确性证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设总区间[1，n]，分区间[a1，b1]，[a2，b2]，… ，[am，bm]。规定f(x)表示覆盖[x，n]的最小区间数，则有状态转移方程: f(x)=\min\{1+f(b_k+1)\}，a_k\leq x\leq b_k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然f(x)是单调减的，所以取bk的最大值，即有f(x)=1+f(bt+1)，bt是最大的一个。这样就把动态规划问题转化为贪心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在题目保证有解的前提下，bt一定是不小于x的，可知算法的正确性。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int l, r; bool operator&lt;(node x) &#123; return this-&gt;l &lt; x.l; &#125;&#125; op[50];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++)cin &gt;&gt; op[i].l &gt;&gt; op[i].r; sort(op, op + m); int p = 0, i = 0, ans = 0; while (p &lt; m) &#123; int maxn = 0; while (op[i].l &lt;= p)maxn = max(maxn, op[i].r), i++;//根据序列的有序性,i不必初始化为0,直接按上一次的继续即可 p = maxn + 1; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 最大不相交区间问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间和它的m个子区间，求尽量多的区间使得它们两两不相交。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法:将区间按右端点升序排序，对于一簇右端点相同的区间，取左端点最大一个加入集合(如果可以加入的话)，然后继续找后面右端点相同的区间簇。贪心正确性证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设总区间[1，n]，分区间[a1，b1]，[a2，b2]，… ，[am，bm]。规定f(x)表示[1，x]中的最大不相交区间数目，则有状态转移方程:当x是某个区间右端点时: f(x)=\max\{1+f(a_k-1)\}，b_k=x否则: f(x)=f(p)，p=\max\{b_k\}，b_k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>区间</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串哈希]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[本文改编自https://blog.csdn.net/pengwill97/article/details/80879387&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多题目涉及字符串问题，但是字符串不如整数那样容易处理，尤其是涉及图时。这时需要构造映射string-&gt;int来将字符串转化为int，这就是字符串哈希算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希方案有很多种，这里选择很常用的一个—BKDR Hash。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希思路是将字符串看成是一个base位进制数(base为一个大质数)，具体思路如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于字符串的第i位，有: hash(0)=str(i)-’a’+1\\ hash(i)=(hash(i-1)*base+str(i)-’a’+1)%P，i\geq 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一个算出的hash值作为整个字符串的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P是一个大于base的质数。hash为一个unsigned long long的数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出这是计算这个base进制数的公式并且每个值都对P取了模，这个方法可以将字符串映射到[0，P)的正整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是可能有两个字符串不同但哈希值相同的情况，称为哈希冲突。在base，P足够大时这种冲突概率很低。这里列举几个质数，读者可以参考使用。 素数 冲突率% 53 10.416667 97 1.0416670 193 0.520833 389 1.302083 769 0.130208 1543 0.455729 3079 0.227865 6151 0.113932 12289 0.008138 24593 0.069173 49157 0.010173 98317 0.013224 196613 0.002543 393241 0.006358 786433 0.000128 1572869 0.000318 3145739 0.000350 6291469 0.000207 12582917 0.000040 25165843 0.000075 50331653 0.000010 100663319 0.000023 201326611 0.000009 402653189 0.000001 805306457 0.000011 1610612741 0.000000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;洛谷P3370用字符串哈希求互异字符串个数，下面给出代码:12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int P1 = 19260817, P2 = 100663319;int vis[P2] = &#123;0&#125;;unsigned long long h[1050] = &#123;0&#125;;inline int Hash(string s) &#123; h[0] = s[0] - 'a' + 1; for (int i = 1; i &lt; s.length(); i++) &#123; h[i] = (h[i - 1] * P1 + s[i] - 'a' + 1) % P2; &#125; return h[s.length() - 1];&#125;int main() &#123; ios::sync_with_stdio(false); int n, ans = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string str; cin &gt;&gt; str; int h = Hash(str); if (vis[h] == 0)vis[h] = 1, ans++; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>基础算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增法求LCA]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%80%8D%E5%A2%9E%E6%B3%95%E6%B1%82LCA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次讨论树这种数据结构上的一种算法—用倍增算法求最近公共祖先(LCA)。首先介绍倍增算法的原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若给定一个正整数x且有x &lt; 2k，若从2k开始，令x从大到小依次减去2的方幂p(2k，2k-1…，1)，第一个能够使x-p≥0的数p必定在数x的二进制拆分表达式中。这个很容易用二进制解释证明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用depth[]储存每一个节点的深度(认为根节点深度为1)，用grand[][]储存每个节点的祖先并定义grand[x][y]表示x节点向上2y处的祖先。若越界则置为0。显然grand[x][0]是每个节点的父节点编号。这两个数组均可由DFS求出，详见示例代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定两个待求LCA的节点标号，首先要做的是将两个节点排到同一深度。操作方法是令深度较大的节点向上”跳跃”，直至深度与较小节点相同。一种朴素的方法是一层一层地向上跳，但时间消耗明显。这里可以用与快速幂类似的倍增思想加快跳跃速度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先确定k的大小，容易知道k=ceil{log_2(DEPTH)}，这里DEPTH为树的最大深度。通常取20即可。从大到小枚举2的方幂p，最终能使较大深度节点达到与较小深度节点相同的深度。这时如果两个节点重合，则它即为LCA。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若两个节点不相同，就需要让这两个节点同时向上跳，加快跳跃速度的方式与之前类似，也是通过倍增实现，跳跃后会到达LCA的正下方，直接返回父节点即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int MAX = 500001;struct edge &#123;//链式前向星存边 int to, next;&#125; op[MAX * 2];int head[MAX];//链式前向星节点首边int cnt = 0;//边编号int root = 1;//根节点编号int depth[MAX] = &#123;0&#125;;//存各个节点深度int grand[MAX][21] = &#123;0&#125;;//倍增使用int N, M;//存节点数和询问数int read() &#123;//读入优化 char e = static_cast&lt;char&gt;(getchar()); while (e &lt; '0' || e &gt; '9')e = static_cast&lt;char&gt;(getchar()); int sum = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10, sum += e - '0'; e = static_cast&lt;char&gt;(getchar()); &#125; return sum;&#125;void add(int x, int y) &#123;//构建链式前向星,从x到y有一条边 op[cnt].to = y; op[cnt].next = head[x]; head[x] = cnt++;&#125;void DFS(int x) &#123; for (int i = head[x]; i != -1; i = op[i].next) &#123;//遍历各个子节点 if (depth[op[i].to] != 0)continue;//不能向父节点回溯 depth[op[i].to] = depth[x] + 1;//深度加一 grand[op[i].to][0] = x;//初始化递推 for (int j = 1; j &lt; 21; j++)grand[op[i].to][j] = grand[grand[op[i].to][j - 1]][j - 1];//递推 DFS(op[i].to);//下一个子节点 &#125;&#125;int LCA(int x, int y) &#123;//求LCA的函数 if (depth[x] &gt; depth[y])swap(x, y);//认为y的深度较大 for (int i = 20; i &gt;= 0; i--) &#123; if (depth[grand[y][i]] &gt;= depth[x])y = grand[y][i];//y倍增至与x同深度 &#125; if (x == y)return x;//节点相同就是LCA 直接返回 for (int i = 20; i &gt;= 0; i--) &#123;//两个节点倍增至LCA的正下方 if (grand[x][i] != grand[y][i])x = grand[x][i], y = grand[y][i]; &#125; return grand[x][0];//父节点即为LCA&#125;int main() &#123; N = read(), M = read(), root = read(); memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= N - 1; i++) &#123; int x, y; x = read(), y = read(); add(x, y), add(y, x); &#125;//读入树的信息 depth[root] = 1;//初始化 DFS(root);//深搜求depth和grand for (int i = 0; i &lt; M; i++) &#123; int x, y; x = read(), y = read(); printf("%d\n", LCA(x, y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST表]]></title>
    <url>%2F2019%2F01%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST表是一种求区间最值的高效数据结构，不支持动态维护，建表时间复杂度O(nlogn)，查询复杂度O(1)。在不需要修改原数据的情况下ST表要比线段树更简洁，但在需要修改原数据时只能用线段树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST表可以定义为二维数组ST[][]，其中ST[i][j]表示从第j的元素开始的长度为2i的区间中的最值，也就是区间[j，j+2i-1]中的最值。这个表可以用DP思想建立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建表前，需要两个辅助数组log[]与bin[]。其中log[i]储存使2k&lt;=i的整数k的最大值;bin[i]储存2i。这两个数组都可以通过递推实现: log[0]=-1，log[x]=log[x/2]+1\\ bin[0]=1，bin[x]=bin[x/2]*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log数组大小达到数据量n，bin达到logn。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辅助数组构建完毕后开始建ST表。首先对ST表首行初始化，即ST[0][x]。它们都表示从x号元素开始长度为1的区间的最值，显然就是该元素本身。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外ST表中有递推公式: ST[i][x]=\max/\min\{ST[i-1][x]，ST[i-1][x+bin[i-1]]\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即将区间分成两半，求取其中的最值，这里注意x+bin[i]-1≤n。递推后即可完成建表。 下面探讨查询操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也可以用将区间平均拆分的分治思想来求给定区间的最值，但是给定区间长度不一定就是2的方幂，于是需要其它分治方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到有不等式2log[l]*2&gt;l。这是显然的。这个不等式启示我们可以将长度为l的区间拆分成两个长度为2log[l]的区间，这两个区间已然覆盖了区间所有的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此区间[a，b]的最值即为$\max/\min\{ST[log[l]][a]，ST[log[l]][b-bin[log[l]]+1]\}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里l=b-a+1，为区间长度。123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int ST[20][10000];//储存ST表数据int op[10000], n;//储存区间数据int log[10000], bin[20];//储存log值以及指数值int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; ST[0][i] = op[i]; &#125;//第一行初始化 log[0] = -1; for (int i = 1; i &lt;= n; i++)log[i] = log[i / 2] + 1;//log初始化 bin[0] = 1; for (int i = 1; i &lt; 20; i++)bin[i] = bin[i - 1] * 2;//bin初始化 for (int i = 1; i &lt; 20; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (j + bin[i] - 1 &lt;= n) &#123; ST[i][j] = min(ST[i - 1][j], ST[i - 1][j + bin[i - 1]]);//递推建表,DP思想 &#125; &#125; &#125; int k; cin &gt;&gt; k;//查询k次 while (k-- &gt; 0) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; int t = log[r - l + 1]; cout &lt;&lt; min(ST[t][l], ST[t][r - bin[t] + 1]) &lt;&lt; endl;//输出查询结果 &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>区间最值</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在来认识一种新的求幂算法—快速幂算法。这个算法可以在O(logn)的时间复杂度下计算nm的值(要求m为自然数)。相比朴素O(n)累乘算法，效率大大提升。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速幂算法基于倍增思想，是倍增算法的一个应用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个自然数都可以写出它唯一的二进制数，即有: m=2^{k_1}+2^{k_2}+...+2^{k_m}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里$0\leq k_1 &lt; k_2&lt; …&lt; k_m$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么$n^m$可以表示为$n^{2^{k_1}+2^{k_2}+…+2^{k_m}}$，即$n^{2^{k_1}} × n^{2^{k_2}} × … × n^{2^{k_m}}$，从而化为几个数的乘积，并且这几个数有这平方级的关系。这样就可以把求幂运算压至O(logn)复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码(答案对P取模):12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; const int P = 10000007; long long int n, m; cin &gt;&gt; n &gt;&gt; m; long long int t = n; long long int ans = 1; while (m &gt; 0) &#123; if (m % 2 == 1)ans *= t, ans %= P; t *= t; t %= P; m /= 2; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法]]></title>
    <url>%2F2019%2F01%2F09%2FFloyd%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了Dijkstra算法和SPFA算法，另一种求最短路方法是Floyd算法。这个算法可以求出任意两点之间的最短路径长度，支持负边权，需要用邻接矩阵存图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法缺点是耗时过大，时间复杂度O(n3)。算法步骤:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 初始化dist数组，邻接节点dist值即为相邻边权值，否则为inf(无穷大)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 枚举每一个节点，用这个节点作中介，更新所有节点对的最短路径值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后dist即为最短路径数组，如果为inf则两点不连通。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下:12345678for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i != j &amp;&amp; i != k &amp;&amp; j != k) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); &#125; &#125;&#125; 算法正确性证明:首先要清楚，最短路只有三种情况:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 两点直接相连且路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 两点经一个中介点路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 两点经多个中介点路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况1已经求出，且算法全程对这个值没有影响。情况2在枚举到中介点k时就已经求出了所有以k为单个中介的两点最短路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于情况3，假设中介点为a1 &lt; a2 &lt; … &lt; am。两点靠m个中介点获得最短路。令集合S={x，y，a1，a2…am}(x，y分别是源点和终点)。当k枚举到a1时，必然会更新这样一对属于情况2的节点对(ai，aj)，其中ai，aj∈S。这时可以看作是ai，aj直接相连而不经过a1，然后从S中清除a1，这样m个中介就减少至m-1个。后面的过程每次都使中介点减一，在枚举完成之前必可以将其转化为情况2并求出最短路径值。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
        <tag>图的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法与SPFA]]></title>
    <url>%2F2019%2F01%2F09%2FDijkstra%E7%AE%97%E6%B3%95%E4%B8%8ESPFA%2F</url>
    <content type="text"><![CDATA[Dijkstra算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dijkstra算法是一种基于贪心思想的求单源最短路算法，时间复杂度为$O(n^2)$。Dijkstra算法要求边权为正。步骤:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 一个数组dis[]保存最短路径长的结果，源点值置为0，其余为inf。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 一个集合S保存所有已求出最短路径长的节点，初始化S为空。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 从不在S中的节点集合中找到dis最小的节点，用这个节点更新与之相邻的的节点dis值(这个过程叫松弛)，并将这个节点加入S。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复③，直到所有节点都加入S中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们证明，不在S中的节点集合里面dis最小的节点，设为min，它的dis最小值必为当前值。这是因为若存在另外一条路径使得点dis值更小，必定会经过其余的某一个点，假设该点dis值为k，则应该有k+p &lt; min，然而p ≥ 0且k ≥ min，可知这是不可能的。从这个原理上就可以明白Dijkstra要求边权非负的原因。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际操作中可以用小根堆来维护最小值，这样时间复杂度降至稳定的$O((m+n)logn)$。这里值得注意的是，由于堆中经常进行调整，对于一个dis值已经被修改然而已在堆中的节点，我们应该对其进行调整。所以构造一个从节点序号到堆中具体位置的映射，来更新节点在堆中的位置。具体细节见示例代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本示例代码采用链式前向星+小根堆优化的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n, m, from;const int MAX = 100000;struct edge &#123; int to, value, next;&#125; op[2 * MAX + 1];//链式前向星存图int head[MAX + 1], dis[MAX + 1];int heap[MAX + 1], size = 0;//小根堆使用int ID[MAX + 1] = &#123;0&#125;;//构造映射inline void solve(int x) &#123; int x1 = x &lt;&lt; 1, x2 = x &lt;&lt; 1 | 1, minn = x; if (x1 &lt;= size &amp;&amp; dis[heap[x1]] &lt; dis[heap[minn]])minn = x1; if (x2 &lt;= size &amp;&amp; dis[heap[x2]] &lt; dis[heap[minn]])minn = x2; if (minn != x) &#123; swap(ID[heap[minn]], ID[heap[x]]); swap(heap[minn], heap[x]); solve(minn); &#125;&#125;inline int top() &#123; int r = heap[1]; heap[1] = heap[size--]; ID[heap[1]] = 1; solve(1); return r;&#125;inline void up(int x) &#123; if (x == 1)return; if (dis[heap[x / 2]] &gt; dis[heap[x]]) ID[heap[x / 2]] = x, ID[heap[x]] = x / 2, swap(heap[x / 2], heap[x]), up(x / 2);&#125;inline void add(int x) &#123; heap[++size] = x; ID[x] = size; up(size);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; from; memset(head, -1, sizeof(head)); for (register int i = 1; i &lt;= n; i++)dis[i] = 2147483647; dis[from] = 0; for (register int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; op[i].next = head[x], op[i].to = y, op[i].value = z; head[x] = i; &#125; add(from);//将源点加入堆 while (size &gt; 0) &#123; int t = top();//取堆中dis值最小节点,并将其移出堆,此后这个节点不可能再被加入堆中 for (register int i = head[t]; i != -1; i = op[i].next) &#123;//找到该节点邻接节点 if (dis[t] + op[i].value &lt; dis[op[i].to]) &#123; dis[op[i].to] = dis[t] + op[i].value;//修改该邻接点dis值 if (ID[op[i].to] != 0) &#123;//已在堆中,更新其在堆中的位置 up(ID[op[i].to]); &#125; else &#123; add(op[i].to);//不在堆中,将其加入堆 &#125; &#125; &#125; &#125; for (register int i = 1; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; " "; return 0;&#125; SPFA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来介绍SPFA，SPFA本质上是基于队列的Bellman-Ford算法，支持负边权并且可以判断负环。该算法时间复杂度达$O(km)$。该算法不稳定，在某些情况下时间复杂度会达到朴素Bellman-Ford级别。算法思想:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 将源点加入队列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 弹出队首元素，用该元素松弛其邻接点，若松弛后的节点不在队列中，让该节点入队。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复②，直到队列为空为止。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当图存在负环时，最短路径是不存在的。可以证明存在负环的充要条件是某一个节点入队次数大于n次。利用这个结论可以方便地判定负环，这是BFS版的SPFA判负环方法。SPFA还有DFS版本，即用栈代替队列，只要需要松弛的点在栈中就可以判断有负环。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int n, m, from;const int MAX = 100000;struct edge &#123; int to, value, next;&#125; op[2 * MAX + 1];//链式前向星存图int head[MAX + 1];int dis[MAX + 1];bool vis[MAX + 1] = &#123;false&#125;;int num[MAX + 1] = &#123;0&#125;;int main() &#123; ios::sync_with_stdio(false); queue&lt;int&gt; que; cin &gt;&gt; n &gt;&gt; m &gt;&gt; from; memset(head, -1, sizeof(head)); for (register int i = 1; i &lt;= n; i++)dis[i] = 2147483647; dis[from] = 0; for (register int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; op[i].next = head[x], op[i].to = y, op[i].value = z; head[x] = i; &#125; que.push(from), vis[from] = true, num[from]++; while (!que.empty()) &#123; int r = que.front(); que.pop(); vis[r] = false; for (int i = head[r]; i != -1; i = op[i].next) &#123; if (dis[r] + op[i].value &lt; dis[op[i].to]) &#123; dis[op[i].to] = dis[r] + op[i].value; if (!vis[op[i].to])que.push(op[i].to), vis[op[i].to] = true, num[op[i].to]++; if (num[op[i].to] &gt; n) &#123; cout &lt;&lt; "ERR" &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; for (register int i = 1; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; " "; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过洛谷上的测试，Dijkstra+heap优化可以通过P3371和强化版的P4779。SPFA可以通过前者，但由于在后者被卡，无法通过。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，Dijkstra+heap与SPFA的速度比较存在争议，对上面算法的正确性和算法选择请读者自行理解。推荐在没有负边时使用堆优化Dijkstra算法，仅在含负边或者需要判负环时使用SPFA。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于SPFA的两个优化： SLF（Small Label First）优化：设当前队首元素为f（要取出队首），待入队元素为x，若dict[x]&lt;dict[f]，则将x插入队首，否则插入队尾。 LLL（Large Label First）优化：若队首为f，如果dict[f]大于当前队列中dict的平均值，则取出f放到队尾，跳过该元素判断下一个，直到队首元素的dict不大于平均值，将其拿出进行松弛。实际操作中我们需要不停记录队列中的元素个数和dict和来维护平均值。 对最短路算法的进一步理解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dijkstra算法中，每一个结点仅入堆一次，这样可以保证时间复杂度在较低的水平，并且能够保证算法的稳定性。但是如果我们每次取的点并不一定是最小dist的点又会如何？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若我们不加堆，每次取一个随机的结点，这样最终也是可以完成松弛操作，同样可以求出最短路。但是那样结点会多次入堆，造成效率的大大降低。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在来看SPFA的算法过程，可以发现SPFA就如同随机从点中取一个进行松弛，只不过加了一个队列而已。这样SPFA的效率应该比Dijkstra堆优化版本更低。但是在某些随机的情况下，SPFA可以做到每一个结点仅入队一次或很少次，这样做到了和Dijkstra相似的算法过程，还省略了堆优化的log级别的复杂度，总体效率会优于Dijkstra。但是在某些构造数据下，SPFA算法过程中结点会多次入队，直接被卡到甚至$O(nm)$级别。但相同情况下，Dijkstra通过加堆优化，强行先松弛dist最小的结点的出点，保证结点入堆次数仅有一次，实现了算法稳定性的提升。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里就可以更深层次地理解Dijkstra要求边权非负的原因：利用边权非负来保证结点入堆次数仅有一次以提高效率。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有负权的图如何应用Dijkstra算法？一种方法是用Johnson重标记法来解决这个问题，以后再介绍。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于上面的问题和讨论，可以发现Dijkstra其实也可以处理不含负环的负边权问题，只需允许结点多次入堆即可，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//该代码未经测试!!!!!#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n, m, from;const int MAX = 100000;struct edge &#123; int to, value, next;&#125; op[2 * MAX + 1];int head[MAX + 1], dis[MAX + 1];int heap[MAX + 1], size = 0;int ID[MAX + 1] = &#123;0&#125;;inline void solve(int x) &#123; int x1 = x &lt;&lt; 1, x2 = x &lt;&lt; 1 | 1, minn = x; if (x1 &lt;= size &amp;&amp; dis[heap[x1]] &lt; dis[heap[minn]])minn = x1; if (x2 &lt;= size &amp;&amp; dis[heap[x2]] &lt; dis[heap[minn]])minn = x2; if (minn != x) &#123; swap(ID[heap[minn]], ID[heap[x]]); swap(heap[minn], heap[x]); solve(minn); &#125;&#125;inline int top() &#123; int r = heap[1]; ID[r] = 0;//映射置为0表示可以重新加入 if (size &gt; 1)heap[1] = heap[size--], ID[heap[1]] = 1, solve(1);//size&gt;1更新信息 else size = 0;//否则size=0 return r;&#125;inline void up(int x) &#123; if (x == 1)return; if (dis[heap[x / 2]] &gt; dis[heap[x]]) ID[heap[x / 2]] = x, ID[heap[x]] = x / 2, swap(heap[x / 2], heap[x]), up(x / 2);&#125;inline void add(int x) &#123; heap[++size] = x; ID[x] = size; up(size);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; from; memset(head, -1, sizeof(head)); for (register int i = 1; i &lt;= n; i++)dis[i] = 2147483647; dis[from] = 0; for (register int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; op[i].next = head[x], op[i].to = y, op[i].value = z; head[x] = i; &#125; add(from); while (size &gt; 0) &#123; int t = top(); for (register int i = head[t]; i != -1; i = op[i].next) &#123; if (dis[t] + op[i].value &lt; dis[op[i].to]) &#123; dis[op[i].to] = dis[t] + op[i].value; if (ID[op[i].to] != 0) &#123; up(ID[op[i].to]); &#125; else &#123; add(op[i].to); &#125; &#125; &#125; &#125; for (register int i = 1; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; " "; return 0;&#125; 分层图最短路&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑一个问题，现在给定一个图，允许将其中不超过k条边改为0边权，问某点的单源最短路最小为多少？这就是分层图最短路问题，洛谷有模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法是改进后的Dijkstra算法。规定dict[i][j]为源点到i且将j条边权值置为0时的最短路，根据此进行松弛。这个算法在Dijkstra算法基础上给dict添加了第二个指标元素来描述以更改边权边的条数。类似的方法也可以处理将边权改成其它值的情况。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define inf 1l&lt;&lt;50using namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;struct Edge &#123; int next, to, v;&#125; edge[50005 &lt;&lt; 1];struct Node &#123; int r, k; Node(int x = 0, int y = 0) : r(x), k(y) &#123;&#125;&#125; heap[10005 * 24];int n, m, head[10005], cnt = 1, k, size = 0, rk[10005][24];long long dp[10005][24];inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;void solve(int x) &#123; int x1 = x &lt;&lt; 1, x2 = x &lt;&lt; 1 | 1, minn = x; if (x1 &lt;= size &amp;&amp; dp[heap[x1].r][heap[x1].k] &lt; dp[heap[minn].r][heap[minn].k])minn = x1; if (x2 &lt;= size &amp;&amp; dp[heap[x2].r][heap[x2].k] &lt; dp[heap[minn].r][heap[minn].k])minn = x2; if (x != minn) swap(heap[minn], heap[x]), swap(rk[heap[minn].r][heap[minn].k], rk[heap[x].r][heap[x].k]), solve(minn);&#125;void up(int x) &#123; if (x == 1)return; if (dp[heap[x &gt;&gt; 1].r][heap[x &gt;&gt; 1].k] &gt; dp[heap[x].r][heap[x].k]) &#123; swap(heap[x &gt;&gt; 1], heap[x]), swap(rk[heap[x &gt;&gt; 1].r][heap[x &gt;&gt; 1].k], rk[heap[x].r][heap[x].k]), up(x &gt;&gt; 1); &#125;&#125;Node top() &#123; Node t = heap[1]; rk[t.r][t.k] = 0, rk[heap[size].r][heap[size].k] = 1, heap[1] = heap[size--], solve(1); return t;&#125;void add(Node z) &#123; rk[z.r][z.k] = ++size, heap[size] = z, up(size);&#125;int main() &#123; n = read(), m = read(), k = read(); for (int i = 1; i &lt;= m; i++) &#123; int x = read(), y = read(), z = read(); add(x, y, z), add(y, x, z); &#125; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= k; j++)dp[i][j] = inf; for (int i = 0; i &lt;= k; i++)dp[1][i] = 0, add(Node(1, i)); while (size &gt; 0) &#123; Node t = top(); for (int i = head[t.r]; i; i = edge[i].next) &#123; if (dp[edge[i].to][t.k] &gt; dp[t.r][t.k] + edge[i].v) &#123;//第一种松弛 dp[edge[i].to][t.k] = dp[t.r][t.k] + edge[i].v; if (rk[edge[i].to][t.k])up(rk[edge[i].to][t.k]); else add(Node(edge[i].to, t.k)); &#125; if (t.k &lt; k &amp;&amp; dp[edge[i].to][t.k + 1] &gt; dp[t.r][t.k]) &#123;//第二种松弛 dp[edge[i].to][t.k + 1] = dp[t.r][t.k]; if (rk[edge[i].to][t.k + 1])up(rk[edge[i].to][t.k + 1]); else add(Node(edge[i].to, t.k + 1)); &#125; &#125; &#125; long long ans = inf; for (int i = 0; i &lt;= k; i++)ans = min(ans, dp[n][i]); cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于分层图的理解：将原图赋值若干份，平行排布，下一层与上一层的点之间有边（与原图边对应）相连，边权为0。这样分层图就有了所有的决策情况，求一个最短路即可。分层图模型在很多问题上都有应用。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
        <tag>图的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分解质因数]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分解质因数算法是一种很重要的数论算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; for (int i = 2; i &lt;= n / 2; i++) &#123; if (n % i == 0) &#123; cout &lt;&lt; i &lt;&lt; " "; n /= i--; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法通俗易懂。易知第一个可以整除n的i必然是n最小的质因数，这时我们将其输出，并令n除掉i，再令i自减1以在后来的循环中消除n的所有i因子。最后的n将成为一个质数，循环将退出，再将剩下的n输出即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间与n的大小呈对数关系。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2123]皇后游戏]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2123-%E7%9A%87%E5%90%8E%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游戏的另一个问题。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;皇后有 n 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 n 位大臣颁发奖金，其中第 i 位大臣所获得的奖金数目为第i－1 位大臣所获得奖金数目与前 i 位大臣左手上的数的和的较大值再加上第 i 位大臣右手上的数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;形式化地讲:我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则第 i 位大臣获得的奖金数目为 ci可以表达为: c_i=\begin{cases} a_1+b_1 & i=1\\ \max\{c_{i-1},\displaystyle\sum_{j=1}^ia_j\} & 2\leq i\leq n \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。注意:重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 T，表示测试数据的组数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 T 个部分，每个部分的第一行包含一个正整数 n，表示大臣的数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个部分接下来 n 行中，每行两个正整数，分别为 ai和 bi，含义如上文所述。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共 T 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 输入输出样例Sample input#1 134 12 21 2 Sample output#1 8 Sample input#2 2585 10095 9976 8760 9779 85129 6818 4552 6139 8363 6745 9952 5482 10023 5499 9463 10052 68 Sample output#2 528902 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 1，2，3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 1，3，2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 2，1，3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 2，3，1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 3，1，2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 3，2，1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当按照 3，2，1 这样排列队伍时，三位大臣左右手的数分别为:(1， 2)，(2， 2)，(4， 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 1 位大臣获得的奖金为 1 + 2 = 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 2 位大臣获得的奖金为 max{3， 3} + 2 = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 3 为大臣获得的奖金为 max{5， 7} + 1 = 8。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于全部测试数据满足:T≤10，1≤n≤20000，1≤ai，bi≤109。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察数学推导，排序和贪心，难度很高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个相邻的大臣i，j，假定i前方的a之和为p，i前的大臣c值为q，那么可以求出j的c值: c_j=\max\{c_i，p+a_i+a_j\}+b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里ci也可以求出: c_i= \max\{q，p+a_i\}+b_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以有 c_j=\max\{\max\{q，p+a_i\}+b_i，p+a_i+a_j\}+b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即 c_j=\max\{q+b_i+b_j，p+a_i+b_i+b_j，p+a_i+a_j+b_j\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理交换后有 c_j=\max\{q+b_j+b_i，p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定不交换更优，那么有 \max\{q+b_i+b_j，p+a_i+b_i+b_j，p+a_i+a_j+b_j\}\leq \max\{q+b_j+b_i，p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把这个式子记作①。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现其中都有q+bi+bj这一项，把它们归结为max{a，b}≤max{a，c}。容易发现当b≤时max{a，b}≤max{a，c}必成立。在b&gt;c时可能max{a，b}≤max{a，c}，也可能max{a，b}&gt;max{a，c}。这时我们会交换两个元素使b≤c，从而使max{a，b}≤max{a，c}一定成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此我们可以不考虑q+bi+bj，只考虑后边式子的大小关系: \max\{p+a_i+b_i+b_j，p+a_i+a_j+b_j\}\leq \max\{p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记作②。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当②成立时，①必然也是成立的;而②不成立时交换后即可使①成立。所以可以通过②来判别是否要交换。另外可以发现②取等时，①也取等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将②变形 \max\{b_i，a_j\}+a_i+b_j\leq \max\{b_j，a_i\}+b_i+a_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移项得 \max\{b_i，a_j\}-b_i-a_j\leq \max\{b_j，a_i\}-a_i-b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等价于 -\min\{b_i，a_j\}\leq -\min\{b_j，a_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即为 \min\{a_i，b_j\}\leq \min\{a_j，b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记为③。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地理解本题，下面给出几个概念和定理。 [判别元素]参与相邻元素判别的因子。比如这里的min{ai，bj}和min{aj，bi}。 [相邻子条件]可以使相邻元素在某种次序下更优的判别元素所满足的条件。如果记A=min{ai，bj}，B=min{aj，bi}，则相邻子条件为A≤B，此时i在j前更优。记相邻子条件为P(X，Y)，在判别元素X，Y满足相邻子条件(X≤Y)时为真。 [逆序]对于一个序列A1，A2，A3，…An，若存在i，j$(1 \leq i &lt; j \leq n)$使得P(Ai，Aj)为假，则称Ai，Aj组成一个逆序。逆序会破坏序列的最优性。 [相邻全局最优化原理]一个序列，其判别元素序列为A1，A2，A3，…An。当序列不存在逆序时，序列最优。 [等价序列转化原理]交换相邻相等元素的位置，答案不变，这时两个序列等价。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个两两相邻元素都满足子条件的序列不一定是最优的，因为它可能存在逆序。比如序列ABC满足A≤B，B≤C，但是A&gt;C(一个逆序)，此时若B=C，可以进行等价变形得到ACB，此时AC违背了子条件，交换AC得到序列CAB，显然CAB是比ABC更优的序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是存在逆序并不一定使序列不最优，也就是说存在逆序的序列得到的答案可能与最优序列答案是相同的。但是没有逆序的序列一定是最优的，化为没有逆序的序列是最保险，最稳妥的做法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于国王游戏，可以采用按照左右手数值乘积升序排列的做法。这是因为排序后得到的序列没有逆序。这种两两相邻元素满足子条件就可以保证全局没有逆序的性质称为传递性。国王游戏中小于号是可传递的，但本题不可以。在本题中如果A≤B，B≤C，可能有A&gt;C的情况发生。如果只像国王游戏那样按照相邻子条件排序，得到的序列可能有逆序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该设法创造一个具有传递性的排序思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察③式，发现a与b的情况可以归结为以下几种: 第一种:ai &lt; bi且aj &gt; bj，此时必有ai≤aj，也就是说a是升序的。 第二种:ai = bi且aj = bj。a与b都是不变的，③式显然成立。 第三种:ai &gt; bi且aj &gt; bj，此时必有bj≤bi，也就是说b是降序的。 第四种:ai &lt; bi且aj &gt; bj，③式显然成立。 当然还有第五种:ai &gt; bi且aj &lt; bj，此时③式显然不成立 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先将I组(ab)的元素。在I组中按照a升序排列，在III组中按b降序排列。可以证明这是一种可行且可传递的排序方法。可以证明它没有逆序，任取两个元素X，Y(Y在X后)，可以归结为以下六种情况来判别P(X，Y)的成立与否: X，Y都来自I:符合第一种情况，成立。 X来自I，Y来自II:显然成立 X来自I，Y来自III:符合第四种，成立。 X来自II，Y来自II:这时两者是相等的，成立。 X来自II，Y来自III:显然成立。 X来自III，Y来自III:符合第三种，成立。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就找到了一种排序策略得到一个满足全局最优化原理的序列，从中找到的答案必然为最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这个题，可以发现相邻交换法并不只是按照相邻子条件排序就可以的，排序后的序列不能只让两两相邻元素符合子条件，还要没有逆序。这是相邻交换法的重要理论依据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，虽然a=b时可以任意排序(依据等价序列转化原理)，但是不能在重载时直接返回一个true或者false，这样会出现矛盾(a &lt; b且b &lt; a)造成RE。示例代码中把它归到了I组中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; long long a, b; int d; void make(long long x, long long y) &#123; a = x, b = y; if (a == b)d = 0; else if (a &lt; b)d = -1; else d = 1; &#125; bool operator&lt;(node p) &#123; if (this-&gt;d != p.d)return this-&gt;d &lt; p.d; if (this-&gt;d &lt;= 0)return this-&gt;a &lt; p.a; else return this-&gt;b &gt; p.b; &#125;&#125; op[20001];long long c[20001];int n;int main() &#123; int T; cin &gt;&gt; T; for (int t = 1; t &lt;= T; t++) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; long long x, y; cin &gt;&gt; x &gt;&gt; y; op[i].make(x, y); &#125; sort(op + 1, op + n + 1); long long ans = c[1] = op[1].a + op[1].b, temp = op[1].a; for (int i = 2; i &lt;= n; i++) &#123; temp += op[i].a; c[i] = max(c[i - 1], temp) + op[i].b; ans = max(ans, c[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2258]子矩阵]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2258-%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出如下定义:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子矩阵:从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵(保持行与列的相对顺序)被称为原矩阵的一个子矩阵。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，下面左图中选取第2，4行和第2，4，5列交叉位置的元素得到一个2×3的子矩阵如图所示。9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1的其中一个2×3的子矩阵是4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相邻的元素:矩阵中的某个元素与其上下左右四个元素(如果存在的话)是相邻的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵的分值:矩阵中每一对相邻元素之差的绝对值之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题任务:给定一个n行m列的正整数矩阵，请你从这个矩阵中选出一个r行c列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含用空格隔开的四个整数n，m，r，c意义如问题描述中所述，每两个整数之间用一个空格隔开。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的n行，每行包含m个用空格隔开的整数，用来表示问题描述中那个n行m列的矩阵。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示满足题目描述的子矩阵的最小分值。 输入输出样例Sample input#1 5 5 2 39 3 3 3 99 4 8 7 41 7 4 6 66 8 5 6 97 4 5 6 1 Sample output#1 6 Sample input#2 7 7 3 37 7 7 6 2 10 55 8 8 2 1 6 22 9 5 5 6 1 77 9 3 6 1 7 81 9 1 4 7 8 810 5 9 1 1 8 101 3 1 5 4 8 6 Sample output#2 16 说明[输入输出样例1说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该矩阵中分值最小的2行3列的子矩阵由原矩阵的第4行，第5行与第1列，第3列，第4列交叉位置的元素组成为6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6其分值为:|6−5| + |5−6| + |7−5| + |5−6| + |6−7| + |5−5| + |6−6| =6[输入输出样例2说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该矩阵中分值最小的3行3列的子矩阵由原矩阵的第4行，第5行，第6行与第2列，第6列，第7列交叉位置的元素组成，选取的分值最小的子矩阵为9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10[数据说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，1 ≤ n ≤ 12，1 ≤ m ≤ 12矩阵中的每个元素1≤aij≤20;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，1 ≤ n ≤ 16，1 ≤ m ≤ 16，矩阵中的每个元素1≤aij≤1000，1≤r≤n，1≤c≤m。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察动态规划和DFS，实际上本题考察这两种方法的结合。由于涉及到行和列的全排，直接进行DP无法写出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现给定矩阵的型很小(不大于16)，在这种情况下用指数级时间复杂度的DFS枚举出所有的行排列，在这个基础上对列进行DP。这时DFS时间复杂度为$O(C_n^r)$，DP时间复杂度为$O(n^3)$。总时间复杂度即为$O(C_n^r*n^3)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一种行的枚举情况，令f(x，y)表示从前x列中取y列可以获得的最小绝对值之和(第x列必须在其中且x≥y)，那么有状态转移方程: f(x，y)=\min\{f(k，y-1)+S1(k，x)\}+S2(x)，1\leq k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>矩阵</tag>
        <tag>动态规划</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1108]低价购买]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1108-%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买;再低价购买”。每次你购买一支股票，你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价(216范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买;再低价购买”的原则。写一个程序计算最大购买次数。这里是某支股票的价格清单:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日期 1 ， 2 ， 3 ， 4 ， 5 ， 6 ， 7 ， 8， 9 ，10 ，11， 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;价格68 ，69 ，54， 64，68 ，64 ，70 ，67 ，78 ，62， 98， 87最优秀的投资者可以购买最多4次股票，可行方案中的一种是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日期 2 ， 5 ， 6 ，10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;价格 69， 68 ，64 ，62 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行: N(1≤N≤5000)，股票发行天数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行: N个数，是每天的股票价格。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个数:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大购买次数和拥有最大购买次数的方案数(≤231)当二种方案“看起来一样”时(就是说它们构成的价格队列一样的时候)，这2种方案被认为是相同的。 输入输出样例Sample input 1268 69 54 64 68 64 70 67 78 62 98 87 Sample output 4 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划/递推，与本材料第四题导弹拦截非常类似(只是多了一个求方案数的步骤)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问很容易求得，既可以使用O(n2)的经典动态规划思路也可以使用O(nlogn)的二分和贪心思路(详见第四题的加强版本解析)。示例代码给出的是前者。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨方案数的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令f(x)为以下标为x的元素为末尾的最长序列方案数。则dp(x)不为1时有如下的递推关系(不正确的版本): f(x)=\sum f(k)，1\leq kvalue(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化f(x)为0，dp(x)为1时直接令f(x)=1。这样答案即为所有dp(x)取到最大值的f(x)之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里注意到f(x)是很多函数值的和，它们其中重复的组合一定会被重复计算。容易发现，对于一个给定的x，value(x)即是确定的。倘若对于两个k1，k2满足递推式中的条件但是value(k1)≠value(k2)，可以肯定k1和k2这两个序列必不存在相同的序列组合。倘若value(k1)=value(k2)且有k1&lt;k2，可以肯定以k1所指元素为末尾的所有序列都在k2对应的序列集合中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上可知若令S(x)表示以下标为x的元素为末尾的序列组成的集合，那么有: value(a)≠value(b)时: S(a)\cap S(b)=\varnothing \\ value(a)=value(b)(a]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1736]创意吃鱼法]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1736-%E5%88%9B%E6%84%8F%E5%90%83%E9%B1%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考:到底要以何种方法吃鱼呢(猫猫就是这么可爱，吃鱼也要想好吃法 ^_*)。她发现，把大池子视为01矩阵(0表示对应位置无鱼，1表示对应位置有鱼)有助于决定吃鱼策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有多组输入数据，每组数据:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有两个整数n和m(n，m≥1)，描述池塘规模。接下来的n行，每行有m个数字(非“0”即“1”)。每两个数字之间用空格隔开。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，有n，m≤100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于60%的数据，有n，m≤1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，有n，m≤2500 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一个整数——猫猫一口下去可以吃掉的鱼的数量，占一行，行末有回车。 输入输出样例Sample input 4 60 1 0 1 0 00 0 1 0 1 01 1 0 0 0 10 1 1 0 1 0 Sample output 3 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察二维DP。该题目与本材料第一题最大正方形有类似之处。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，从左下角开始向右上方吸和从右上角开始向左下方吸本质是一样的。不妨强制要求只能向上吸，这样吸的方向就只有两种:向左上方和向右上方。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定dp(x，y，z)为从坐标(x，y)开始向z方向吸到的鱼的最大数目。这里z的定义是:向左上方为0，向右上方为1。dp全初始化为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样很难进行状态转移，这是因为在方阵中只有对角线有鱼时才可以吸。如果没有这个限制，状态转移方程很容易列出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于加上了限制，需要三个辅助数组来帮助完成状态转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取R1(x，y)表示坐标(x，y)的左方离它最近的鱼与其的距离;R2(x，y)表示坐标(x，y)的右方离它最近的鱼与其的距离;C(x，y)表示坐标(x，y)的上方离它最近的鱼与其的距离。不需要与下方鱼的距离，这是因为已经强制规定只能向上吸，下方的鱼对求解没有意义。这里的三个数组都在坐标(x，y)有鱼时才有定义。在某个方向上没有鱼时，直接赋上与边界的距离即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的话，状态转移方程就可以列出了，在坐标(x，y)有鱼时，有如下递推式: dp(x，y，0)=\min\{R1(x，y)，C(x，y)，dp(x-1，y-1，0)+1\}\\ dp(x，y，1)=\min\{R2(x，y)，C(x，y)，dp(x-1，y+1，1)+1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;坐标(x，y)没有鱼时，直接赋值为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从所有dp值中找到最大值即为答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码的数组记录的是鱼的坐标值，在递推时现算出距离。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;int dp[2505][2505][2] = &#123;0&#125;;int n, m;short int op[2501][2501] = &#123;0&#125;;short int sumR_1[2505][2505] = &#123;0&#125;;short int sumR_2[2505][2505] = &#123;0&#125;;short int sumC[2505][2505] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) &#123; int temp = 0; for (register int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; op[i][j]; if (op[i][j])sumR_2[i][temp] = j, sumR_1[i][j] = temp, temp = j; &#125; sumR_2[i][temp] = 2501; &#125; for (register int i = 1; i &lt;= m; i++) &#123; int temp = 0; for (register int j = 1; j &lt;= n; j++) if (op[j][i])sumC[i][j] = temp, temp = j; &#125; int ans = 0; for (register int i = 1; i &lt;= n; i++) &#123; for (register int j = 1; j &lt;= m; j++) &#123; if (!op[i][j])continue; dp[i][j][0] = min(min(j - sumR_1[i][j], i - sumC[j][i]), dp[i - 1][j - 1][0] + 1); dp[i][j][1] = min(min(sumR_2[i][j] - j, i - sumC[j][i]), dp[i - 1][j + 1][1] + 1); ans = max(ans, max(dp[i][j][0], dp[i][j][1])); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2158]仪仗队]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2158-%E4%BB%AA%E4%BB%97%E9%98%9F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。 现在，C君希望你告诉他队伍整齐时能看到的学生人数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一个数N(1≤N≤40000)。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一个数，即C君应看到的学生人数。 输入输出样例Sample input 4 Sample output 9 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以左下方的观察点为原点建系，发现可以观察到的人总在正上方和正右方以及右上方一个n-1阶的方阵中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以图中n=6为例，考察右上方5阶方阵中的观察情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中红色标出的是观察不到的人的坐标。发现可以被观察到等价于其横纵坐标互素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么若令f(x)表示n阶方阵中横纵坐标互素的点的个数，则答案即为f(N)+2。注意N=1时特判为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨f(x)的求法，很自然想到递推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图，在n=4(绿色部分)的基础上递推到n=5的情况，容易发现(5，5)一定会被剔除，然后(5，5)的正左方和正下方一定是成对剔除的。显然，如果令φ(x)表示小于x且与x互素的正整数的个数，则有以下递推式: f(x)=f(x-1)+2*φ(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在问题的关键在于求解φ(x)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;φ(x)在数论上是有定义的，称为欧拉函数(Euler’s totient function)。现在介绍欧拉函数的线性筛法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了理解这个筛法，要了解以下三个基本原理: 若p为素数，则φ(p)=p-1 若p为素数且p†k，则φ(kp)=(p-1)φ(k) 若p为素数且p|k，则φ(kp)=pφ(k) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明见题后注解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用这三个原理结合欧拉筛素数法，可得到下面筛法: 123456789101112131415161718int euler[40001] = &#123;0&#125;;//记录欧拉函数值int mark[40001] = &#123;0&#125;;//记录是不是素数int prim[40001], tot = 0;//储存当前已知的素数,tot 记录个数for (int i = 2; i &lt;= 40000; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; euler[i] = i - 1;//判断为素数,直接给欧拉函数赋值 &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (i * prim[j] &gt; 40000)break; mark[i * prim[j]] = 1;//标记这个数一定不是素数 if (i % prim[j] == 0) &#123; euler[i * prim[j]] = euler[i] * prim[j]; break; &#125; else euler[i * prim[j]] = euler[i] * (prim[j] - 1); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个筛法的可行性除了与欧拉筛法有关外，还利用了一个事实:每一个合数都可以写成k*p的形式并且p&lt;=k。prim数组中存放了所有不大于i的质数，由上面的原理可知在计算φ(i*prim[j])时φ(i)一定已经被求出了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个筛法很重要，它是很多数论方面题目的重要算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这个算法再结合递推式，本题目迎刃而解。12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int euler[40001] = &#123;0&#125;;int mark[40001] = &#123;0&#125;;int prim[40001], tot = 0;int A[40001] = &#123;0&#125;;int main() &#123; for (int i = 2; i &lt;= 40000; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; euler[i] = i - 1; &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (i * prim[j] &gt; 40000)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0) &#123; euler[i * prim[j]] = euler[i] * prim[j]; break; &#125; else euler[i * prim[j]] = euler[i] * (prim[j] - 1); &#125; &#125; A[1] = 1; for (int i = 2; i &lt;= 40000; i++)A[i] = A[i - 1] + 2 * euler[i]; int n; cin &gt;&gt; n; if (n == 1)cout &lt;&lt; 0; else cout &lt;&lt; A[n - 1] + 2; return 0;&#125; 注解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出欧拉函数性质后两个的证明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先欧拉函数是积性函数，即在(a，b)=1时有φ(ab)=φ(a)φ(b)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么在p†k时，由于p是素数，必有(p，k)=1，故φ(pk)=φ(p)φ(k)=(p-1)φ(k)。在p|k时，不妨设k=qps(p†q)，那么φ(pk)=φ(ps+1q)=φ(ps+1)φ(q)。这里φ(ps+1)为ps+1-ps，即ps(p-1)，因此φ(pk)=(p-1)psφ(q)。并且φ(k)=φ(q)φ(ps)=φ(q)ps-1(p-1)。代入即得φ(pk)=pφ(k)。 【扩展】欧拉定理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提到欧拉函数不得不提欧拉定理，它的内容如下： 【欧拉定理】若a与m互质，则有$a^{\phi(m)}\equiv 1(mod\ m)$。【推论】若a与m互质，则有$a^b\equiv a^{b\%\phi(m)}(mod\ m)$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个定理可以用来实现超级快速幂（指数极大，需要高精度）,在a与m不互质的情况下，有欧拉函数扩展形式： 【扩展欧拉定理】对于a、b与m，在$b\geq \phi(m)$时，有$a^b\equiv a^{b\% \phi(m)+\phi(m)}(mod\ m)$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样在b巨大，但m很小时，可以将b减小到m的欧拉函数级别。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个扩展：直接求欧拉函数。由上文可知，欧拉函数可以通过线性筛筛出来，但是对于很大的数去求欧拉函数，并且只求一个的情况，线性筛比较低效。这里可以直接用欧拉函数公式在$O(\sqrt n)$下计算出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m的所有互异质因子为$p_1,p_2,\cdots,p_s$，则有： \phi(m)=m\prod_{i=1}^s\frac {p_i-1} {p_i}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过下面的代码计算：123456789101112inline int getEuler(int x) &#123; euler = 1; for (int i = 2; 1ll * i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; x /= i; euler *= (i - 1); while (x % i == 0)x /= i, euler *= i; &#125; &#125; if (x &gt; 1)euler *= x - 1; return euler;&#125;; 【扩展】线性筛&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线性筛可以在线性时间内求解积性函数，这里的欧拉函数就是积性函数。利用线性筛，我们不仅可以筛出欧拉函数还可以筛出其它积性函数。 约数个数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定$d(x)$表示x的约数个数，比如$d(6)=4$，是因为6含有1、2、3、6四个因子，$d(x)$是积性函数。1~n的约数个数可以在线性时间内筛出。为了保证能够筛出，这里需要引入一个辅助数组$num[x]$，其表示x除去所有最小质因子后的数，这样可以得到下面筛法代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define N 1000000using namespace std;int d[N + 1], prim[N + 1], tot, num[N + 1];bool vis[N + 1];int main() &#123; d[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!vis[i])prim[++tot] = i, d[i] = 2, num[i] = 1; for (int j = 1; j &lt;= tot; j++) &#123; if (1ll * i * prim[j] &gt; N)break; vis[i * prim[j]] = true; if (i % prim[j])d[i * prim[j]] = d[i] * d[prim[j]], num[i * prim[j]] = i;//积性函数 else &#123; d[i * prim[j]] = d[num[i * prim[j]] = num[i]] + d[i];//这一步是关键 break; &#125; &#125; &#125; for (int i = 1; i &lt;= 100; i++)cout &lt;&lt; d[i] &lt;&lt; endl;//只输出前100验证 return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然在$i\%prim[j]\not =0$时，两者互质，直接利用积性函数性质即可。在两者不互质时，利用$num$数组求解。期间需要更新$num$数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里不易理解的是$d[i * prim[j]] = d[num[i * prim[j]] = num[i]] + d[i]$这一句。这里$i * prim[j]$的最小质因子显然为$prim[j]$，故其因子组成应该来自两部分，一部分是$i$本身就有的，另一部分是$i$除去最小质因子后的数（即$num[i]$）的所有因子与$i * prim[j]$全部最小质因子的乘积。从这个角度不难理解算法正确性。 约数和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定$d(x)$为x的所有因子之和，比如$d(6)=12$。可以证明$d(x)$也为积性函数，可以线性筛出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由约数个数中$num$数组的启发，我们应该保留$num$数组，但这样仍然求不出来，故需要引入另一个数组$minn[x]$，表示x全部最小质因子的乘积。和约数个数类似，代码改一下就好：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define N 10000using namespace std;int d[N + 1], prim[N + 1], tot, num[N + 1], minn[N + 1];bool vis[N + 1];int main() &#123; d[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!vis[i])prim[++tot] = i, d[i] = i + 1, num[i] = 1, minn[i] = i; for (int j = 1; j &lt;= tot; j++) &#123; if (1ll * i * prim[j] &gt; N)break; vis[i * prim[j]] = true; if (i % prim[j])d[i * prim[j]] = d[i] * d[prim[j]], num[i * prim[j]] = i, minn[i * prim[j]] = prim[j]; else &#123; d[i * prim[j]] = d[i] + d[num[i * prim[j]] = num[i]] * (minn[i * prim[j]] = minn[i] * prim[j]); break; &#125; &#125; &#125; for (int i = 1; i &lt;= 100; i++)cout &lt;&lt; d[i] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1052]过河]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1052-%E8%BF%87%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点:0，1，… ，L(其中L是桥的长度)。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数(包括S，T)。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目给出独木桥的长度L，青蛙跳跃的距离范围S，T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有1个正整数L(1≤L≤109)，表示独木桥的长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行有3个正整数S，T，M分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中1≤S≤T≤10，1≤M≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行有M个不同的正整数分别表示这M个石子在数轴上的位置(数据保证桥的起点和终点处没有石子)。所有相邻的整数之间用一个空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示青蛙过河最少需要踩到的石子数。 输入输出样例Sample input 102 3 52 3 5 6 7 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察线性动态规划，难点在于离散化数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(x)表示到达x这个点时踩到的最少的石子数，则状态转移方程为: dp(x)=\min\{dp(x-k)+status(x)\}，S \leq k \leq T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里status(x)在x处没有石子时为0，否则为1。起初dp均置为inf，dp(0)置为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$\max\{dp(L+k)，0 \leq k&lt;T\}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是注意到L非常大，一维数组会直接爆掉，必须采取离散化的方法降低数组大小。这里利用石子数很少的特点压缩。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了讲清楚压缩的方法，下面先介绍几个概念和原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引理：若dp(x)已知，青蛙经过合理的跳跃次序从x跳到y，[x，y]中没有任何石子，则dp(y)=dp(x)。引理显然。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源区间：对于一个石子，假定其坐标是x，那么称区间[x-T，x)为源区间。很容易证明，如果青蛙想要跳过这个石子，一定会经过源区间。这也就是说，倘若源区间中的所有DP值全部求得，那么这个石子所在位置及其后面的所有点的DP值都可以由状态转移方程推出。由此我们得到了一个重要结论。某一石子及其后的所有DP值只与这个石子源区间的值有关。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，源区间的长度是T。如若两个石子距离本身就不大于T，则我们称这个石子对应的源区间是不完整的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上面的结论可以发现，对于拥有完整源区间的一个石子，倘若在其前方的区间段中有一段与源区间同样长的区间且它们的值完全相等，则这两个区间是等价的，此时把石子移动到新的区间的右端点上，不影响结果。由引理可知，只需找到一段区间可以使其中任一点都可以经合理的次序跳到源区间的对应位置上即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨缩点方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2520缩：取1，2，… ，10的最小公倍数2520。容易发现，无论S，T为何值，青蛙总可以从x点跳跃至x+2520处的点。也就是说，将石子向前挪动2520个单位(如果可以移动的话)，不影响结果，类似地，将石子后移2520个单位同样不影响结果。这样的操作我们称之为同解变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72缩：经过数论上的证明(见题后注解)，可以发现方程:Sx1+(S+1)x2+…+TxT-S+1=72在1 ≤ S &lt; T ≤ 10时一定是有自然数解的。同样可以知道对于任意的S，T(S &lt; T)，青蛙总可以从x跳跃至x+72处。将石子向前向后移动72个单位仍然是同解变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然还有其它缩点方案，但原理都是一致的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，无论怎么变形，都必须保证两个源区间中没有石子，否则引理条件不满足，无法证明两个区间等价。比如两个石子距离2521而T为5时，不能将后一个石子向前挪2520个单位，这是因为新的源区间包含了前一个石子。72缩同理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，72缩必须对S=T的情况进行特判。2520缩不需要是因为即使S=T，2520仍然可以整除S，青蛙跳跃2520/S次仍然可以跳跃2520个单位。但72缩时由数论内容，只有S &lt; T时方程有自然数解，当S=T时，也仅有S=1，2，3，4，6，8，9时有解。倘若数据给定S=T=7，那么青蛙不可能跳跃若干步达到72个单位距离。因此S=T时需要特判(实际上只需特判S=T且为5，7，10即可)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要跳过最后一个石子迟早能到达桥的末端，直接置L为最后一个石子的位置即可，这样可以从最后一个石子的”后源区间”取答案。12345678910111213141516171819202122232425262728293031323334352520缩：#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e8using namespace std;int L, S, T, M;int op[101] = &#123;0&#125;, op2[101] = &#123;0&#125;;int status[258000] = &#123;0&#125;;int dp[258000];int main() &#123; cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; op[i]; sort(op + 1, op + M + 1); for (int i = 1; i &lt;= M; i++) &#123; if (op[i] - op[i - 1] &gt; 2520) &#123; op2[i] = (op[i] - op[i - 1]) % 2520 + op2[i - 1]; if (op2[i] - op2[i - 1] &lt;= T)op2[i] += 2520; &#125; else op2[i] = op2[i - 1] + op[i] - op[i - 1]; status[op2[i]] = 1; &#125; L = op2[M]; for (int i = 1; i &lt; L + T; i++)dp[i] = inf; dp[0] = 0; for (int i = 0; i &lt; L; i++) &#123; for (int j = S; j &lt;= T; j++) dp[i + j] = min(dp[i + j], dp[i] + status[i + j] ); &#125; int ans = inf; for (int i = L; i &lt; L + T; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404172缩：#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e8using namespace std;int L, S, T, M;int op[101] = &#123;0&#125;, op2[101] = &#123;0&#125;;int status[8000] = &#123;0&#125;;int dp[8000];int main() &#123; cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M; int ans = inf; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; op[i]; sort(op + 1, op + M + 1); if (S == T &amp;&amp; (S == 5 || S == 7 || S == 10)) &#123; //写成 if(S==T)同样正确 ans = 0; for (int i = 1; i &lt;= M; i++)if (op[i] % S == 0)ans++; cout &lt;&lt; ans; return 0; &#125; for (int i = 1; i &lt;= M; i++) &#123; if (op[i] - op[i - 1] &gt; 72) &#123; op2[i] = (op[i] - op[i - 1]) % 72 + op2[i - 1]; if (op2[i] - op2[i - 1] &lt;= T)op2[i] += 72; &#125; else op2[i] = op2[i - 1] + op[i] - op[i - 1]; status[op2[i]] = 1; &#125; L = op2[M]; for (int i = 1; i &lt; L + T; i++)dp[i] = inf; dp[0] = 0; for (int i = 0; i &lt; L; i++) &#123; for (int j = S; j &lt;= T; j++) dp[i + j] = min(dp[i + j], dp[i] + status[i + j] ); &#125; for (int i = L; i &lt; L + T; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125; 注解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出72缩的数学证明，以下内容涉及初等数论的相关内容，建议读者在熟悉初等数论的基础上阅读。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先介绍一个定理。 [赛瓦维斯特定理]给定两个互素的正整数a，b。若$ax+by=z$没有非负的整数解，则z具有最大值，该值为$ab-a-b$。 证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由$(a，b)=1$可知任意整数z，不定线性方程$ax+by=z$都是有解的。容易知道，对于不定方程的一个特解$x_0，y_0$，知$x_0+bt，y_0-at$也是方程的解，也就是说这些解x，y满足：$x \equiv x_0(mod\ b)，y \equiv y_0(mod\ a)$，它们本质上是同一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们证明$ax+by=z$在a，b互素时，仅有这样的一组解。假设x，y满足$ax+by=z$，而$ax_0+by_0=z$，作差得$a(x-x_0)+b(y-y_0)=0$，故有$ax \equiv ax_0(mod\ b)$。由于$(a，b)=1$，所以$ax \equiv ax_0(mod\ b)$就是$x \equiv x_0(mod\ b)$。故仅有一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(扩展:$ax\equiv b(mod\ m)$在$(a，m)|b$时有解，且有$(a，m)$组解)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这样的一系列解，必存在这样的一个解$x_1$，$y_1$满足$-b\leq x_10$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候若$x_1$加上$b$，就一定可以使x对应的解非负，但同时$y_1$要减去$a$。倘若$y_1 \geq a$，则对应的$ax+by=z$必然是有非负整数解的。倘若$y_1 &lt; a$，容易知道此时无论$x_1$加上多少倍的$b$，都不能使x和y同时非负，这时方程是无解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此，我们得到方程无解等价于$-b\leq x_1&lt;0$时有$y_1&lt;a$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个基础上令x1，y1分别取它们的最大值-1，a-1，代入原方程得到: z=-a+b(a-1)=ab-a-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是无解的z的最大值。证毕。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由这个定理，我们就可以更好地理解72缩的原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知道相邻的两个自然数是互素的，那么这两个自然数a，a+1不能线性表示的最大数是a*(a+1)-a-a-1=a2-a-1。给定S和T(S]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
        <tag>动态规划</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1156]垃圾陷阱]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1156-%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卡门――农夫约翰极其珍视的一条Holsteins奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为D(2≤D≤100)英尺。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设卡门预先知道了每个垃圾扔下的时间t(0 &lt; t ≤ 1000)，以及每个垃圾堆放的高度h(1 ≤ h ≤ 25)和吃进该垃圾能维持生命的时间f(1 ≤ f ≤ 30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续10小时的能量，如果卡门10小时内没有进食，卡门就将饿死。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为2个整数，D和G(1≤G≤100)，G为被投入井的垃圾的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二到第G+1行每行包括3个整数:T(0&lt;T&lt;=1000)，表示垃圾被投进井中的时间;F(1≤F≤30)，表示该垃圾能维持卡门生命的时间;和H(1≤H≤25)，该垃圾能垫高的高度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果卡门可以爬出陷阱，输出一个整数表示最早什么时候可以爬出;否则输出卡门最长可以存活多长时间。 输入输出样例Sample input 20 45 4 99 3 212 6 1013 1 1 Sample output 13 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察动态规划。这里提供三种解决思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要先对垃圾投入时间升序排列，确定序号。 三维DP法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析题目，状态量有垃圾序号，生命值，高度和绝对时间四种。一种解决思路是将垃圾序号，生命值和高度作为状态描述参量，对绝对时间求DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若令dp(r，l，h)表示在处理到第r个垃圾，生命值为l，高度为h时的最优逃出时间，则状态转移方程为:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time(r+1)&gt;l时: dp(r，l，h)=inf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h+height(r)&lt;d时: dp(r，l，h)=\min\{dp(r+1，l+life(r)，h)，dp(r+1，l，h+height(r))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;否则: dp(r，l，h)=time(r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起初，dp所有元素均置为0。inf表示无穷大。考虑到数据量大小，可以递归而非递推求解，但缺点是空间消耗过大，状态参量过多。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为dp(1，10，0)，若其为inf，说明无法逃出。在递归过程中用一个变量记录最长生存期，最后输出这个值即可。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e9using namespace std;int dp[3200][101][101] = &#123;0&#125;;int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxh = 0;int DP(int l, int r, int h) &#123; if (dp[l][r][h] != 0)return dp[l][r][h]; if (op[r].t &gt; l || r == g + 1) &#123; maxh = max(maxh, l); return dp[l][r][h] = inf; &#125; if (h + op[r].h &gt;= d)return dp[l][r][h] = op[r].t; return dp[l][r][h] = min(DP(l + op[r].v, r + 1, h), DP(l, r + 1, h + op[r].h));&#125;int main() &#123; cin &gt;&gt; d &gt;&gt; g; for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); if (DP(10, 1, 0) &lt; inf)cout &lt;&lt; DP(10, 1, 0); else cout &lt;&lt; maxh; return 0;&#125; 二维DP法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只考虑垃圾序号和高度两个参量，对生命值求dp。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(r，h)表示处理了前r个垃圾，高度达到h时的最大生存期。状态转移方程为:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time(r+1)≤dp(r，h)时: dp(r+1，h)=\max\{dp(r，h)+life(r+1)，dp(r，h-height(r+1))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起初所有dp元素全置为-1并初始化dp[0][0]=10，按照上述方程递推。结合方程特点，递推应按照从左到右，从上到下的顺序。行坐标范围为[0，G)，列坐标范围[0，D)。当其中出现dp(i，j)不为-1且j&gt;=d的情况时，记录逃出时间为time(i)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后遍历一遍二维表获得最大的dp(i，j)，此为最大生存期，注意行坐标范围为[0，G]。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度O(D×G)。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define inf (int)1e9using namespace std;int dp[3200][150];int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxt = 0;int mint = inf;int main() &#123; cin &gt;&gt; d &gt;&gt; g; memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); dp[0][0] = 10; for (int i = 0; i &lt; g; i++) &#123; for (int j = 0; j &lt;= d; j++) &#123; if (op[i + 1].t &lt;= dp[i][j]) &#123; dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + op[i + 1].v); if (j + op[i + 1].h &gt;= d)mint = min(mint, op[i + 1].t); dp[i + 1][j + op[i + 1].h] = max(dp[i + 1][j + op[i + 1].h], dp[i][j]); &#125; &#125; &#125; for (int i = 0; i &lt;= g; i++) for (int j = 0; j &lt; d; j++)maxt = max(maxt, dp[i][j]); if (mint != inf)cout &lt;&lt; mint; else cout &lt;&lt; maxt; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;善于发现的读者可能会注意到，这个二维DP只与两个相邻的行有关，容易发现dp数组可以压缩至一维。考虑到每一个元素只可能影响它正下方和正下方右边的某一值，我们应采取从上到下，从右到左的顺序进行DP。除此之外还要注意值修改顺序的不同。这便是解决本题的第三个方法，也是最优的方法。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define inf (int)1e9using namespace std;int dp[200];int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxt = 0;int mint = inf;int main() &#123; cin &gt;&gt; d &gt;&gt; g; memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); dp[0] = 10; for (int i = 0; i &lt; g; i++) &#123; for (int j = d - 1; j &gt;= 0; j--) &#123; if (op[i + 1].t &lt;= dp[j]) &#123; if (j + op[i + 1].h &gt;= d)mint = min(mint, op[i + 1].t); dp[j + op[i + 1].h] = max(dp[j + op[i + 1].h], dp[j]); maxt = max(maxt, dp[j]); dp[j] = max(dp[j], dp[j] + op[i + 1].v); maxt = max(maxt, dp[j]); &#125; &#125; &#125; if (mint != inf)cout &lt;&lt; mint; else cout &lt;&lt; maxt; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里总结一下动态规划问题的求解模型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 确定状态和状态之间的关系，理清那些是状态的描述量，那些是所求量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 列出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 观察状态转移方程，确定递推顺序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4#. 必要时应采取状态压缩DP，离散化(后文详述)和数组维数压缩的方法降低空间复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DP降维的方法有以下几种:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 状态之间可以互相表示，这时可以去除一些状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 该状态没有必要或者不影响递推过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上文的讲述，可以发现选取正确的状态参量来描述状态是一件很有意义的事情。选取状态时不仅要紧抓题目要点，还要尽可能精简。状态参量过少会难以描述状态甚至无法转移，过多很容易造成时间和空间的浪费。这一种能力既需要深厚的经验积累，有时又需要一点点灵感和大胆的猜想。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1120]小木棍[数据加强版]]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1120-%E5%B0%8F%E6%9C%A8%E6%A3%8D-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共二行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为一个单独的整数N表示砍过以后的小木棍的总数，其中N≤65。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行为N个用空个隔开的正整数，表示N根小木棍的长度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个数，表示要求的原始木棍的最小可能长度。 输入输出样例Sample input 95 2 1 5 2 1 5 2 1 Sample output 6 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察DFS及剪枝，对搜索和剪枝能力要求很高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入时过滤掉大于50的数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知最小的木棍长度可能值一定不小于当前木棍长度的最大值，不大于所有木棍长度的和。从可能的最小值开始只到最大值依次检验，但凡找到一个值可行，该值显然最小，输出该值并结束程序。另外答案只可能是长度和的因子，非因子直接continue即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检验方式为DFS，从搭建第一个木棍开始，遍历所有尚未访问的木棍数值，将其加入到新的木棍中。若所有木棍都可以加入到新木棍中以拼成若干根等长的木棍，则该值可行。这样的做法时间复杂度相当高，极易超时。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于值只有在DFS完成后才可以知道其可行性，并且得到最值后立即结束程序，我们不可在DFS过程中通过值的最优性剪枝。下面探讨其它剪枝方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自排序原则：每一根新的长木棍是由许多小木棍组成的，本质上是若干个数相加，这些数之间一定有次序关系。由于我们只考虑它们的和而并不关心它们的次序，所以可以规定每一个长木棍由若干长度递减的木棍组成，从而避免很多次序不同但本质相同的组合。这里不推荐升序排列，这是因为较小的木棍有更高的机动性，升序后每一个新的长木棍末端都由较长的木棍组成，由于较长的木棍机动性差，会导致频频回溯，最终使程序性能下降。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一剪枝法则：一个待完成的长木棍在加入一根木棍后刚好完成，若在此基础上拼凑剩余长木棍不可行，则用其他木棍拼凑该待完成长木棍一定也是不可行的。结论证明:已知剩余长度为a1，a2，…，an的木棍，在加入ai后刚好拼凑了一根长木棍，之后用剩余的n-1根木棍拼凑剩下的长木棍不可行。假设加入ap1，ap2，…，aps这s根木棍(满足ap1+ap2+…+aps=ai)后拼凑好了最初的长木棍，剩下的n-s根木棍同样可以拼凑剩下的长木棍。这n-s根木棍中必有ai，此时交换ai和ap1，ap2，…，aps的位置，这显然是一种可行的方案，与已知条件矛盾，从而得证其余拼凑方案必不可行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二剪枝法则：对于一根完全没有完成的长木棍(长度为0)，向其中加入一根木棍，若在此基础上不可行，则向其中加入剩余木棍中的任何一个都不可行。该结论证明与第一剪枝法则类似，从略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合上述三点策略，容易写出完整DFS代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结:递归时尽量小起点，避免频繁回溯。另外注意自排序原则，这是很重要的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(int x, int y) &#123; return x &gt; y;&#125;int op[100], n, sum[100] = &#123;0&#125;, vis[100], length, number;void DFS(int rank, int start, int temp) &#123; if (rank == number + 1) &#123; cout &lt;&lt; length; exit(0); &#125; if (sum[start] &lt; length - temp)return; int t = 100; for (register int i = start; i &lt;= n; i++) &#123; if (vis[i])continue; if (op[i] + temp &gt; length)continue; if (t == op[i])continue; vis[i] = 1; t = op[i]; if (op[i] + temp == length) &#123; DFS(rank + 1, 1, 0); vis[i] = 0; return; &#125; else DFS(rank, i + 1, temp + op[i]); vis[i] = 0; if (!temp)return; &#125;&#125;int main() &#123; cin &gt;&gt; n; int j = 1; for (register int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[j]; if (op[j] &lt;= 50)j++; &#125; n = j - 1; sort(op + 1, op + n + 1, cmp); for (register int i = n; i &gt;= 1; i--)sum[i] = op[i] + sum[i + 1]; for (register int i = n; i &gt;= 1; i--) &#123; if (sum[1] % i != 0)continue; memset(vis, 0, sizeof(vis)); length = sum[1] / i, number = i; DFS(1, 1, 0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1080]国王游戏]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1080-%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恰逢H国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左，右手上面分别写下一个整数，国王自己也在左，右手上各写一个整数。然后，让这n位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是:排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数n，表示大臣的人数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含两个整数 a和b，之间用一个空格隔开，分别表示国王左手和右手上的整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 n行，每行包含两个整数a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 输入输出样例Sample input 31 12 37 44 6 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察高精度算法和数学推导，难度较大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个大臣x，y。假定x前面的大臣左手上数字之积为p(p&gt;0)，那么两者金币数分别为: p*x.r， p*x.l/y.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调换位置后，金币数分别为: p/y.r， p*y.l/x.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然有$p*x.l/y.r&gt;p/y.r$且有$p*y.l/x.r&gt;p/x.r$，倘若大臣x在前时金币最大值更小，那么必有$p*x.l/y.r \leq p*y.l/x.r$，即: x.l*x.r \leq y.l*y.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个不等式是解决本题的关键，它给出了排序的策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知当大臣站序按照l*r升序时最大值最小，否则必有一组违反上述的不等式，这个时候两人金币最大值会变大，不利于整体最大值尽量小的条件。也就是说，按照该标准排序后，可以保证任何相邻两人的金币最大值尽可能的小，从而整体最大值尽可能小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照该不等式排序，再用高精度算法计算结果并输出即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意不要重载&lt;=，仅重载&lt;即可获得不降序的结果。重载&lt;=很容易导致RE。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int king_l, king_r;struct node &#123; int l, r; bool operator&lt;(node y) &#123; if (y.r * y.l &gt; this-&gt;l * this-&gt;r)return true; return false; &#125;&#125; op[1005];int read() &#123; int sum = 0; char e; e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10; sum += e - '0'; e = getchar(); &#125; return sum;&#125;bool check(int *p, int *q) &#123; if (p[0] &lt; q[0])return true; if (p[0] &gt; q[0])return false; for (register int i = 1; i &lt;= p[0]; i++) &#123; if (p[i] &lt; q[i])return true; if (p[i] &gt; q[i])return false; &#125; return false;&#125;void copy(int *p, int *q) &#123; p[0] = q[0]; for (register int i = 1; i &lt;= q[0]; i++)p[i] = q[i];&#125;void mutiple(int *p, int q) &#123; int r = 0, tp = 0, i; for (i = 10000; i &gt; p[0]; i--)tp = p[i], p[i] = (p[i] * q + r) % 10, r = (tp * q + r) / 10; while (r &gt; 0)p[i--] = r % 10, r /= 10; p[0] = i;&#125;void divide(int *x, int y, int *z) &#123; int tp = 0, i = x[0] + 1, j = 1; while (tp &lt; y)tp *= 10, tp += x[i++]; while (i &lt;= 10001) &#123; z[j++] = tp / y, tp %= y; tp *= 10, tp += x[i++]; &#125; z[0] = j - 1;&#125;void print(int *x) &#123; for (register int i = 1; i &lt;= x[0]; i++)cout &lt;&lt; x[i]; cout &lt;&lt; endl;&#125;int main() &#123; int num[10001] = &#123;0&#125;, temp[10000], ans[10000] = &#123;0&#125;; num[0] = 9999; num[10000] = 1; n = read(); king_l = read(), king_r = read(); for (register int i = 1; i &lt;= n; i++)op[i].l = read(), op[i].r = read(); sort(op + 1, op + n + 1); mutiple(num, king_l); for (register int i = 1; i &lt;= n; i++) &#123; divide(num, op[i].r, temp); if (check(ans, temp))copy(ans, temp); mutiple(num, op[i].l); &#125; print(ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>贪心</tag>
        <tag>高精度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1074]靶型数独]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1074-%E9%9D%B6%E5%9E%8B%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;靶形数独的方格同普通数独一样，在9格宽×9格高的大九宫格中有9个3格宽×3格高的小九宫格(用粗黑色线隔开的)。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 1 到 9的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行，每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图具体的分值分布是:最里面一格(黄色区域)为 10 分，黄色区域外面的一圈(红色区域)每个格子为9分，再外面一圈(蓝色区域)每个格子为8 分，蓝色区域外面一圈(棕色区域)每个格子为7分，最外面一圈(白色区域)每个格子为6分，如上图所示。比赛的要求是:每个人必须完成一个给定的数独(每个给定数独可能有不同的填法)，而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一共 9 行。每行9个整数(每个数都在0-9的范围内)，表示一个尚未填满的数独方格，未填的空格用“0”表示。每两个数字之间用一个空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共 1 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1。 输入输出样例Sample input#1 7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2 Sample output#1 2829 Sample input#2 0 0 0 7 0 2 4 5 39 0 0 0 0 8 0 0 07 4 0 0 0 5 0 1 01 9 5 0 8 0 0 0 00 7 0 0 0 0 0 2 50 3 0 5 7 9 1 0 80 0 0 6 0 1 0 0 00 6 0 9 0 0 0 0 10 0 0 0 0 0 0 0 6 Sample output#2 2852 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察深度优先搜索(DFS)，有一定难度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个基本思路是，从首行首列开始进行DFS，将未填数的格子填上数。在填数过程中要注意符合数独的规则，也就是说要开数组记录当前行当前列和当前九宫格已有数字的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照这种方法，在填完末行末列的格子时，整个数独已经填好且符合规则。此时计算数独的分数，记录分数最大值。这里可以开一个常量数组记录每个格子的分数以简化运算。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，倘若首行待填格很多，则可能会导致DFS频繁向底层回溯，加大函数调用次数，很容易导致TLE。一种解决方法是从待填格最少的行开始DFS，将待填格最多的行后置，这样DFS向底层回溯的次数会减小，高层回溯次数增加，能够提高效率。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#define ID(x, y) x/3*3+y/3+1using namespace std;const int Point[9][9] = &#123;&#123;6, 6, 6, 6, 6, 6, 6, 6, 6&#125;, &#123;6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 10, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;6, 6, 6, 6, 6, 6, 6, 6, 6&#125;&#125;;int row[9][10] = &#123;0&#125;, colum[9][10] = &#123;0&#125;, form[10][10] = &#123;0&#125;;int op[9][9], rank2[10];int temp[9];int ans = -1;void calculate() &#123; int sum = 0; for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++)sum += op[i][j] * Point[i][j]; ans = max(ans, sum);&#125;void DFS(int x, int y, int r) &#123; if (y == 9) &#123; if (r &lt; 8) DFS(rank2[r + 1], 0, r + 1); else calculate(); return; &#125; if (op[x][y]) &#123; DFS(x, y + 1, r); return; &#125; for (int i = 1; i &lt;= 9; i++) &#123; if (row[x][i] || colum[y][i] || form[ID(x, y)][i])continue; row[x][i] = colum[y][i] = form[ID(x, y)][i] = 1; op[x][y] = i; DFS(x, y + 1, r); op[x][y] = 0; row[x][i] = colum[y][i] = form[ID(x, y)][i] = 0; &#125;&#125;int main() &#123; for (int i = 0; i &lt; 9; i++) &#123; temp[i] = i * 10 + 9; for (int j = 0; j &lt; 9; j++) &#123; cin &gt;&gt; op[i][j]; if (op[i][j]) row[i][op[i][j]] = colum[j][op[i][j]] = form[ID(i, j)][op[i][j]] = 1, temp[i]--; &#125; &#125; for (int i = 8; i &gt;= 0; i--) for (int j = 0; j &lt; i; j++) if (temp[j] % 10 &gt; temp[j + 1] % 10)swap(temp[j], temp[j + 1]); for (int i = 0; i &lt; 9; i++)rank2[i] = temp[i] / 10; DFS(rank2[0], 0, 0); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次介绍线段树，线段树是一种可以维护区间和，区间最值的高效数据结构。线段树本质上是一棵平衡二叉树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先探讨线段树的构造。由于线段树基于平衡二叉树，且仅有叶子节点储存实际的序列信息，故线段树的空间消耗是比较大的，实际空间消耗大约为给定序列的四倍。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以维护区间和的线段树为例。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造线段树时，假定f(l，r)为将[l，r]的序列构造为线段树，f(l，r)可以拆分成f(l，mid)和f(mid+1，r)，其中mid=(l+r)/2。按照二叉树的节点规律向下构造，并给相应的节点赋值即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:123456789void make(int x, int y, int k) &#123; if (x == y) &#123; tree[k] = op[x]; return; &#125; int mid = (x + y) / 2; make(x, mid, 2 * k), make(mid + 1, y, 2 * k + 1); tree[k] = tree[2 * k] + tree[2 * k + 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求特定区间[l，r]的区间和则通过拆分区间，从线段树中读出分区和，再相加即可。通过这种操作可以将线段树的时间复杂度降至O(logn)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何进行区间拆分。实际上区间拆分可分为四种情况:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 给定区间和线段树划分区间恰好相同。直接返回该区间的值即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 给定区间在划分区间的右半部分。将右半部分作为新的划分区间再进行拆分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 给定区间在划分区间的左半部分。将左半部分作为新的划分区间再进行拆分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 给定区间部分在左区间，部分在右区间。分别将左半部分和右半部分作为新的划分区间，再分别在两个划分区间中拆分各自的给定区间部分，返回两者结果的和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:1234567int find(int x, int y, int l, int r, int k) &#123; if (l &lt;= x &amp;&amp; y &lt;= r)return tree[k]; int mid = (x + y) / 2; if (l &gt;= mid + 1)return find(mid + 1, y, l, r, 2 * k + 1); if (r &lt;= mid)return find(x, mid, l, r, 2 * k); return find(x, mid, l, mid, 2 * k) + find(mid + 1, y, mid + 1, r, 2 * k + 1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，通过这两个函数已经可以处理一个不再修改的线段树。但是在实际操作中，有时不仅需要频繁求出区间和，还要不断地修改数据。下面介绍线段树的值修改方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种显而易见的思路是直接修改数据再重新构造线段树，或者直接在线段树中查找到相关的节点，修改这些节点的值。显然后者要优于前者，但是倘若修改的区间之后不再参与查找区间和的操作，那么时间就会白白浪费。所以，需要一种方法，在求区间和时才对相关节点进行实际的值修改操作，否则只作个标记即可。这种方法可以大大提升效率。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现值修改的标记，需要引入懒标记(Lazy)的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给每一个节点添加变量Lazy并初始化为0，它的意义是标明这个节点的所有子节点都要在原有的基础上加上Lazy。值得注意的是，该节点本身不在标记的范围内，并且Lazy标记仅是一个标记，子节点的值实际上并没有改变。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要将区间[l，r]全体加上x时，需要进行如下操作:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 将每一个拆分区间(假定为[a，b])的值加上(b-a+1)*x。((b-a+1)是该拆分区间的数据量)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 用与查找区间和相同的方法拆分区间[l，r]，给每一个拆分的区间的Lazy加上x。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 更新拆分区间节点的祖先节点和父节点的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:123456789101112void add(int x, int y, int l, int r, int c, int k) &#123; if (l &lt;= x &amp;&amp; y &lt;= r) &#123; tree[k] += (r - l + 1) * c; lazy[k] += c; return; &#125; int mid = (x + y) / 2; if (l &gt;= mid + 1)add(mid + 1, y, l, r, c, 2 * k + 1); else if (r &lt;= mid)add(x, mid, l, r, c, 2 * k); else add(x, mid, l, mid, c, 2 * k), add(mid + 1, y, mid + 1, r, c, 2 * k + 1); tree[k] = tree[2 * k] + tree[2 * k + 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何使用这个标记?这里需要用到down()函数来完成Lazy下压实现操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了构造线段树，当任何时候需要使用一个节点时，需要先检查该节点的Lazy是否为0。若为0，不必调用down();否则应调用down()来下压标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;down()的具体实现如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 两个子节点的值自加上它们数据量与该节点Lazy的乘积，更新自身数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 两个子节点的Lazy自加该节点的Lazy，来继承父节点的标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 该节点Lazy清空为0，表示下压完成。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，叶子节点由于没有子节点，它的Lazy是没有意义的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:1234567void down(int l, int r, int k) &#123; if (l == r)return; int mid = (l + r) / 2; tree[2 * k] += (mid - l + 1) * lazy[k], tree[2 * k + 1] += (r - mid) * lazy[k]; lazy[2 * k] += lazy[k], lazy[2 * k + 1] += lazy[k]; lazy[k] = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护区间最值类比即可。 线段树进阶&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新加一种操作：给区间[l,r]上的所有数乘上某个数，如何用线段树维护区间和？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新引入一个懒标记表示乘法是显然的，但是问题并没有想像中那样简单。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果下压标记时发现该结点同时有加法标记和乘法标记，究竟是先加再乘还是先乘再加？顺序的不同显然会影响结果。如果原有的数为a，考虑先加上b再乘上c的结果$(a+b)c=ac+bc$和顺序反过来的结果$ac+b$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，无论是先乘再加还是先加再乘，原数一定会被乘，区别只是加数要不要乘的问题。显然先加再乘可以转化为先乘然后再加上一个“处理后”的加数，这就是我们之后操作的原理。我们所有的步骤都基于先乘再加的思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给每一个结点开两个标记：add、muti，（下面代码中用的lazy1和lazy2）分别表示加法标记和乘法标记。初始化add=0，muti=1（注意是1）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;懒标记的意义是：这个结点的所有子结点需要先乘上muti，再加上add。（先乘再加思想）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有关加法的任何操作都与普通的线段数相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乘法的步骤便有所不同： 将该结点值乘上p（假设需要乘的是p） 乘法标记乘上p（表示下面的子树也要乘p） 加法标记乘上p（这是很重要的一步!!） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么还要处理加法标记呢？前文已经说明我们要先乘再加，先加则用处理加数的方法实现。如果发现当前结点已经有了加法标记，说明“先加”，那么必须给这个加数也乘上p，这就相当于处理了加数，从而把先加再乘转化为等价的先乘再加问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;懒标记下压也有所不同，根据先乘再加的思想，有以下步骤： 该两个子结点值乘上muti（先乘） 两个子结点乘法标记乘上muti（乘法标记继承） 两个子结点加法标记乘上muti（处理加数!!） 恢复muti=1（清空乘法标记） 两个子结点加上区间长度乘以add（再加） 两个子结点加法标记加上add（加法标记继承） 恢复add=0（清空加法标记） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是线段树模板2的示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX (100000+5)using namespace std;long long tree[MAX * 4], op[MAX], lazy1[MAX * 4], lazy2[MAX * 4], n, m, mod;inline long long read() &#123; char e = getchar(); while ((e &lt; '0' || e &gt; '9') &amp;&amp; (e != '-'))e = getchar(); bool k = false; long long s = 0; if (e == '-')k = true, e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return k ? -s : s;&#125;void build(int l, int r, int k) &#123; lazy1[k] = 0, lazy2[k] = 1; if (l == r) &#123; tree[k] = op[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, 2 * k), build(mid + 1, r, 2 * k + 1), tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;void down(int x, int l, int r) &#123; int ls = 2 * x, rs = 2 * x + 1, mid = (l + r) / 2; lazy2[ls] = (lazy2[ls] * lazy2[x]) % mod, lazy2[rs] = (lazy2[rs] * lazy2[x]) % mod; lazy1[ls] = (lazy1[ls] * lazy2[x]) % mod, lazy1[rs] = (lazy1[rs] * lazy2[x]) % mod; tree[ls] = (tree[ls] * lazy2[x]) % mod, tree[rs] = (tree[rs] * lazy2[x]) % mod; lazy2[x] = 1; lazy1[ls] = (lazy1[ls] + lazy1[x]) % mod, lazy1[rs] = (lazy1[rs] + lazy1[x]) % mod; tree[ls] = (tree[ls] + (mid - l + 1) * lazy1[x]) % mod; tree[rs] = (tree[rs] + (r - mid) * lazy1[x]) % mod; lazy1[x] = 0;&#125;long long find(int a, int b, int l, int r, int k) &#123; if (l &gt;= a &amp;&amp; r &lt;= b)return tree[k]; if (l &lt; r &amp;&amp; (lazy1[k] != 0 || lazy2[k] != 1))down(k, l, r); int mid = (l + r) &gt;&gt; 1; if (a &gt;= mid + 1)return find(a, b, mid + 1, r, 2 * k + 1); if (b &lt;= mid)return find(a, b, l, mid, 2 * k); return (find(a, mid, l, mid, 2 * k) + find(mid + 1, b, mid + 1, r, 2 * k + 1)) % mod;&#125;void add(int a, int b, int l, int r, long long s, int k) &#123; if (l &gt;= a &amp;&amp; r &lt;= b) &#123; tree[k] = ((r - l + 1) * s + tree[k]) % mod; lazy1[k] += s, lazy1[k] %= mod; return; &#125; if (l &lt; r &amp;&amp; (lazy1[k] != 0 || lazy2[k] != 1))down(k, l, r); int mid = (l + r) &gt;&gt; 1; if (mid + 1 &lt;= a)add(a, b, mid + 1, r, s, 2 * k + 1); else if (b &lt;= mid)add(a, b, l, mid, s, 2 * k); else add(a, mid, l, mid, s, 2 * k), add(mid + 1, b, mid + 1, r, s, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;void times(int a, int b, int l, int r, long long s, int k) &#123; if (l &gt;= a &amp;&amp; r &lt;= b) &#123; tree[k] = tree[k] * s % mod, lazy2[k] *= s, lazy2[k] %= mod, lazy1[k] *= s, lazy1[k] %= mod; return; &#125; if (l &lt; r &amp;&amp; (lazy1[k] != 0 || lazy2[k] != 1))down(k, l, r); int mid = (l + r) &gt;&gt; 1; if (mid + 1 &lt;= a)times(a, b, mid + 1, r, s, 2 * k + 1); else if (b &lt;= mid)times(a, b, l, mid, s, 2 * k); else times(a, mid, l, mid, s, 2 * k), times(mid + 1, b, mid + 1, r, s, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;int main() &#123; n = read(), m = read(), mod = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); build(1, n, 1); for (int i = 0; i &lt; m; i++) &#123; long long x, a, b, c; x = read(); if (x == 1)a = read(), b = read(), c = read(), times(a, b, 1, n, c, 1); else if (x == 2)a = read(), b = read(), c = read(), add(a, b, 1, n, c, 1); else a = read(), b = read(), cout &lt;&lt; find(a, b, 1, n, 1) &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个进阶（其实就是线段树另一个功能）：维护区间连续和最大（小）值，模板题：戳这里。下面以最大值为例。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法是维护用线段树维护四个值：anssum、lsum、rsum、totsum。分别表示这个区间最大连续和，从左端点开始的最大连续和、从右端点开始的最大连续和以及区间和。这四个值可以互相递推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#define N 50005using namespace std;struct NP &#123;//线段树数据结构体定义 long long lsum, rsum, totsum, anssum;&#125; tree[N &lt;&lt; 2];int n, m, op[N &lt;&lt; 2];inline int readInt() &#123; char e = getchar(); int s = 0; bool g = false; while (e &lt; '-')e = getchar(); if (e == '-')g = true, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return g ? -s : s;&#125;inline void update(int k) &#123;//递推出来 tree[k].lsum = max(tree[k &lt;&lt; 1].lsum, tree[k &lt;&lt; 1].totsum + tree[k &lt;&lt; 1 | 1].lsum); tree[k].rsum = max(tree[k &lt;&lt; 1 | 1].rsum, tree[k &lt;&lt; 1 | 1].totsum + tree[k &lt;&lt; 1].rsum); tree[k].totsum = tree[k &lt;&lt; 1].totsum + tree[k &lt;&lt; 1 | 1].totsum; tree[k].anssum = max(tree[k &lt;&lt; 1 | 1].lsum + tree[k &lt;&lt; 1].rsum, max(tree[k &lt;&lt; 1].anssum, tree[k &lt;&lt; 1 | 1].anssum));&#125;void build(int l, int r, int k = 1) &#123;//构建线段树 if (l == r) &#123; tree[k].anssum = tree[k].totsum = tree[k].lsum = tree[k].rsum = op[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, k &lt;&lt; 1), build(mid + 1, r, k &lt;&lt; 1 | 1); update(k);&#125;void modify(int pos, int what, int l, int r, int k = 1) &#123;//单点修改 if (l == r) &#123; tree[k].anssum = tree[k].totsum = tree[k].lsum = tree[k].rsum = what; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &gt; mid)modify(pos, what, mid + 1, r, k &lt;&lt; 1 | 1); else modify(pos, what, l, mid, k &lt;&lt; 1); update(k);&#125;NP query(int l, int r, int a, int b, int k = 1) &#123;//查询 if (a &gt;= l &amp;&amp; b &lt;= r)return tree[k]; int mid = (a + b) &gt;&gt; 1; if (l &gt; mid)return query(l, r, mid + 1, b, k &lt;&lt; 1 | 1); else if (r &lt;= mid)return query(l, r, a, mid, k &lt;&lt; 1); else &#123; NP t1 = query(l, mid, a, mid, k &lt;&lt; 1), t2 = query(mid + 1, r, mid + 1, b, k &lt;&lt; 1 | 1), tmp; tmp.totsum = t1.totsum + t2.totsum;//下面是合并答案的过程 tmp.lsum = max(t1.lsum, t1.totsum + t2.lsum); tmp.rsum = max(t2.rsum, t2.totsum + t1.rsum); tmp.anssum = max(t1.rsum + t2.lsum, max(t1.anssum, t2.anssum)); return tmp; &#125;&#125;int main() &#123; n = readInt(); for (int i = 1; i &lt;= n; i++)op[i] = readInt(); build(1, n); m = readInt(); for (int i = 1; i &lt;= m; i++) &#123; int a = readInt(), b = readInt(), c = readInt(); if (a == 0)modify(b, c, 1, n); else printf("%lld\n", query(b, c, 1, n).anssum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1282]多米诺骨牌]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1282-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多米诺骨牌有上下2个方块组成，每个方块中有1~6个点。现有排成行的若干多米诺骨牌。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上方块中点数之和记为S1，下方块中点数之和记为S2，它们的差为|S1-S2|。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如在图中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转180°，使得上下两个方块互换位置。 编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行是一个正整数n(1≤n≤1000)，表示多米诺骨牌数。接下来的n行表示n个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数a和b，且1≤a，b≤6。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅一行，包含一个整数。表示求得的最小旋转次数。 输入输出样例Sample input 46 11 51 31 2 Sample output 1 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察线型动态规划，难度较大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定value[i]表示第i个骨牌上下两行的差值，f(x，y)表示第1~x骨牌上下差值为y时的最小交换次数，则有状态转移方程: f(x，y)=\min\{f(x-1，y-value[x])，f(x-1，y+value[x])+1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可用数组来保存结果，由于y可能为负，要构造一个映射将其与一个正整数相联系并作为数组下标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期初将数组初始化为INF(无穷大)，表示不能翻转到此值。再将f(1，value[1])置为0，f(1，-value[1])置为1即可。最后在f(n，y)中寻找y绝对值最小又使f(n，y) &lt; INF的f(n，y)作为结果。1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#define ID(x) 6000+xusing namespace std;int n;int value[1001];int res[1001][12000];const int INF = 1e9;int main() &#123; cin &gt;&gt; n; int x, y; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; value[i] = x - y; &#125; for (register int i = 1; i &lt;= 1000; i++) for (register int j = 0; j &lt; 12000; j++)res[i][j] = INF; res[1][ID(value[1])] = 0, res[1][ID(-value[1])] = 1; for (register int i = 2; i &lt;= n; i++) &#123; for (register int j = 0; j &lt;= 5 * i; j++) &#123; res[i][ID(j)] = min(res[i - 1][ID(j - value[i])], res[i - 1][ID(j + value[i])] + 1); res[i][ID(-j)] = min(res[i - 1][ID(-j - value[i])], res[i - 1][ID(value[i] - j)] + 1); &#125; &#125; for (register int i = 0; i &lt;= 5 * n; i++) &#123; if (res[n][ID(i)] &lt; INF || res[n][ID(-i)] &lt; INF) &#123; cout &lt;&lt; min(res[n][ID(i)], res[n][ID(-i)]); return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1417]烹调方案]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1417-%E7%83%B9%E8%B0%83%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于你的帮助，火星只遭受了最小的损失。但gw懒得重建家园了，就造了一艘飞船飞向遥远的earth星。不过飞船飞到一半，gw发现了一个很严重的问题:肚子饿了~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw希望能在T时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的gw只好求助于你了。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一共有n件食材，每件食材有三个属性，ai，bi和ci，如果在t时刻完成第i样食材则得到ai-t*bi的美味指数，用第i件食材做饭要花去ci的时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，gw的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行是两个正整数T和n，表示到达地球所需时间和食材个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，ai&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，bi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，ci 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出最大美味指数 数据范围&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于40%的数据1≤n≤10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据1≤n≤50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有数字均小于100，000 输入输出样例Sample input 74 1502247 Sample output 408 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划，也属于基本的01背包问题，但本题相比背包问题更能体现出问题的本质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在经典的01背包问题即第二题采药中，物品的顺序是不影响最终结果的。这个结论显然，因为物品无论先加入还是后加入，它们占据背包的空间不变，价值也不变，对其它物品也不会造成实质上的影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但本题不同，本题中物品的价值随着时间的增长而减小，所以对于两个物品，将哪一个放到前面会直接影响结果。也就是说只有把B放于A前或反之时才有最优解。我们在DP时必须遵从这个会出现最优解的顺序来加入物品，即要先对物品进行排序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，排序的标准是什么?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑两个物品，假定在时刻p开始加入背包，则将第一个物品先放入随机放入第二个时的价值为: v_1=a_1-(p+c_1-1)b_1+a_2-(p+c_1+c_2-1)b_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反之时总价值为: v_2=a_2-(p+c_2-1)b_2+a_1-(p+c_2+c_1-1)b_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令$v_1&lt;v_2$，进行运算，得到: c_2b_1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1880]石子合并]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1880-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个圆形操场的四周摆放N堆石子，现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试设计出1个算法，计算出将N堆石子合并成1堆的最小得分和最大得分。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据的第1行为正整数N，1≤N≤100，表示有N堆石子。第2行有N个数，分别表示每堆石子的个数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共2行，第1行为最小得分，第2行为最大得分。 输入输出样例Sample input 44 5 9 4 Sample output 4354 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与贪心算法不同的是，本题要求只能合并相邻的两堆石子，环形排布又加大了题目难度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种思路是将已知的序列首尾相接，从中截取长度为n的子序列，来模拟环形。这是因为在环形结构中，若只合并相邻的两个数，最后必有两个数待合并，从这两个数中间剪环为链，容易知这两者是等价的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是期初并不知从何处剪环，故要将所有情况都考虑到，从每个剪环策略中选取最值即可。在这个思路中，从何处截取序列便是剪环的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定在一个剪环策略下，令左元素为l，右元素为r。设从x到y的序列合并得分最值为f(x，y)，那么可列出状态转移方程(设value(l，r)表示l到r的石子总和): f(x，y)=\min/\max\{f(l，k)+f(k+1，r)\}+value(l，r),l \leq k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次谈谈树状数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先考虑一个问题，对于一个给定的数组，如何快速地求出其前缀和?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最通俗的做法是循环求出前n项和，时间复杂度O(n)。如果数组相当大又多次修改其中数据，求和过程时间消耗巨大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了快速求和，可以用树状数组来完成这一操作。树状数组可以维护并快速求出数组前缀和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要理解树状数组原理，先介绍lowbit的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任何一个数，设lowbit(x)表示这个数能够整除的最大的2的方幂。容易知道，将x写成二进制后，lowbit(x)表示从右向左第一个1所对应的二进制数。例如，对于二进制数x: x=1101101100，lowbit(x)=100;x=1011000，lowbit(x)=1000;x=1010000，lowbit(x)=10000.…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowbit有一个重要性质:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定数x，则对于满足条件x-lowbit(x)&lt;y&lt;x的数均可以在有限次地进行运算y = y + lowbit(y)后，使得y=x。并且其余的y一定不能在有限次的上述运算后得到x。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如给定x=101100，则对于y=101001，进行一次运算，得到101010，再进行一次得到101100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明从略。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对于一个数组tree[i]，tree[i]储存所有满足i-lowbit(i)&lt;x&lt;=i的x的和。这个和是易求的。对于一个符合条件的x，由上面的定理，给x作若干次运算。对于每一次合法的运算结果y，都进行tree[y]+=value[x]，这些y中一定有i，从而将所有符合条件的x都计入了tree[i]。由定理又知，其余不符合条件的x一定不会计入tree[i]。记得将tree[i]+=value[i]，就得到完整的求和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对1~n的所有数，都进行上述操作，就可以得到tree数组，这就是树状数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面研究如何用tree数组求前缀和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如求前10110010前缀和([x，y]表示第x到第y元素的和): tree[10000000]储存[1，10000000]的数的和，tree[10100000]储存[10000001，10100000]的和，tree[10110000]储存[10100001，10110000]的和，tree[10110010]储存[10110001，10110010]的和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，10110010前缀和就是树状数组中这4项的和。并且这4项的下标都是重复进行运算y = y - lowbit(y)得到的，直到y=0。这样，计算10110010前缀和只需进行4次加法，比进行传统的10110010(=178)次运算相比，效率大大提升。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为何叫作树状数组?下图给出解释。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粗体表示树状数组中的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知lowbit(x)=x&amp;-x，这样就有了树状数组的完整编写思路：123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int NUM = 1000000;int op[NUM + 1], tree[NUM + 1] = &#123;0&#125;, n;void add(int x, int y) &#123; for (; x &lt;= n; x += (x &amp; -x))tree[x] += y;&#125;int sum(int x) &#123; int res = 0; for (; x &gt;= 1; x -= (x &amp; -x))res += tree[x]; return res;&#125;int main() &#123; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; add(i, op[i]); &#125; int x; cin &gt;&gt; x; cout &lt;&lt; sum(x) &lt;&lt; endl; return 0;&#125; 树状数组进阶&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树状数组能很好地实现单点查询和前缀和维护，但对于区间求改却无能为力，此时多用线段树来代替。其实树状数组也可以进行区间修改。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开数组c储存原数组差分，差分即： c[i]=\begin{cases} a[i] & i=1\\ a[i]-a[i-1] & i>1\\ \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用树状数组维护c数组，易知c数组前缀和就是原数组对应元素的值。在修改区间时，只需修改c数组两个点即可。比如需要将[l,r]上的数都加p，只需将c[l]加上p，c[r+1]减去p。结合树状数组即可快速原数组元素值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那区间和如何求呢？注意到： \sum_{i=1}^ka_i=\sum_{i=1}^k\sum_{j=1}^ic_j=k\sum_{i=1}^kc_i-\sum_{i=1}^k(i-1)c_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是开数组d记录(i-1)c[i]，并用树状数组维护。在修改c数组时同步修改d数组，结合上面公式即可求出区间和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种思路可以使树状数组代替线段树维护区间和，可以过线段树模板题：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX 100000+5using namespace std;long long op[MAX], tree1[MAX] = &#123;0&#125;, tree2[MAX] = &#123;0&#125;, n, m;inline long long read() &#123; char e = getchar(); while((e &lt; '0' || e &gt; '9') &amp;&amp; (e != '-'))e = getchar(); bool k = false; long long s = 0; if (e == '-')k = true, e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return k ? -s : s;&#125;void add(int x, long long z, long long tree[]) &#123; for (int i = x; i &lt;= n; i += (i &amp; -i))tree[i] += z;&#125;long long find(int x, const long long tree[]) &#123; long long s = 0; for (int i = x; i &gt;= 1; i -= (i &amp; -i))s += tree[i]; return s;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) &#123; op[i] = read(); if (i == 1)add(1, op[i], tree1), add(1, 0, tree2); else add(i, op[i] - op[i - 1], tree1), add(i, (i - 1) * (op[i] - op[i - 1]), tree2); &#125; for (int i = 0; i &lt; m; i++) &#123; int x, a, b, c; x = read(); if (x == 1) &#123;//区间修改 a = read(), b = read(), c = read(); add(a, c, tree1), add(a, (a - 1) * c, tree2); add(b + 1, -c, tree1), add(b + 1, -c * b, tree2); &#125; else &#123;//区间查询 a = read() - 1, b = read(); long long s1 = a * find(a, tree1) - find(a, tree2), s2 = b * find(b, tree1) - find(b, tree2); cout &lt;&lt; s2 - s1 &lt;&lt; endl; &#125; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树状数组另一个作用是统计当前大于或小于某个数的元素个数，比如下题： 给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B中所有整数的和小于K。1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举每一个子数组求和的$O(n^2)$做法一定会TLE，另一个思路是先预处理前缀和，然后从左到右顺次枚举，根据当前的前缀和推算出使子区间和小于k的前缀和范围，然后查找当前有多少前缀和满足这个条件，有几个合法前缀和便有几个合法的子数列。这个过程可以用树状数组维护。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了方便起见，先将问题等价转化：将所有数变为其相反数，问题转化为有多少自数列和大于-k。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求前缀和，然后从左到右枚举。如果当前的前缀和为s，那么合法的前缀和x应满足： s-x>-k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是x &lt; s-k，我们找出之前有多少小于s-k的前缀和就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开一个与数据范围一样大的树状数组，每找到一个前缀和q，我们令q处的元素加一，这样对于一个大于q的数p，它的前缀和就增大了一，从而达到计数目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，数据范围确实过大（达到10^10）。可以采用离散化的方法：前缀和最多有100000种可能，给它们按照小大顺序重新编号，编号的相对大小就是原数据的相对大小。开100000大小的数组完全是可以的，本题便得以解决。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;map&lt;long long, int&gt; m;long long sum[100000 + 5], sumCopy[100000 + 5], tree[100000 + 5] = &#123;0&#125;, ans = 0;int id = 1, n, k;int ID(long long x, int l, int r) &#123;//[,) if (r == l + 1) &#123; if (sumCopy[l] &lt;= x)return m[sumCopy[l]]; return -1; &#125; int mid = (l + r) &gt;&gt; 1; if (sumCopy[mid] &lt;= x)return ID(x, mid, r); return ID(x, l, mid);&#125;inline int query(int x) &#123; int s = 0; for (int i = x; i &gt;= 1; i -= (i &amp; -i))s += tree[i]; return s;&#125;inline void add(int x) &#123; for (int i = x; i &lt;= n; i += (i &amp; -i))tree[i]++;&#125;int main() &#123; ios::sync_with_stdio(false);//关掉同步，加速读入 cin &gt;&gt; n &gt;&gt; k; k = -k;//先对k取相反数 sumCopy[0] = sum[0] = 0;//copy一下前缀和 for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; sumCopy[i] = sum[i] = sum[i - 1] - x;//求前缀和 &#125; sort(sumCopy + 1, sumCopy + n + 1);//排序 for (int i = 1; i &lt;= n; i++) &#123; if (m.count(sumCopy[i]) == 0) &#123; m[sumCopy[i]] = id++;//用map判重并重新编号 &#125; &#125; for (int i = 1; i &lt;= n; i++)if (sum[i] &gt; k)ans++;//首先把前缀和本身对应的合法子数列加上 for (int i = 1; i &lt;= n; i++) &#123; int p = ID(sum[i] - k - 1, 1, n + 1);//找到第一个不大于sum[i]-k-1的前缀和编号，二分 if (p != -1)ans += query(p);//存在满足条件的前缀和编号，用树状数组找数量 add(m[sum[i]]);//把这个前缀和加入树状数组 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1090]合并果子]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1090-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 ， 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力=3+12=15。可以证明 15为最小的体力耗费值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共两行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行是一个整数 n(1≤n≤10000) ，表示果子的种类数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 n个整数，用空格分隔，第 i 个整数 ai(1≤ai≤20000) 是第 i 种果子的数目。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 231 。 输入输出样例Sample input 31 2 9 Sample output 15 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察贪心算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次只需选取序列中最小的两个数相加，将和计入答案中，再将和加入序列。当序列为空时结束算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于序列要频繁地选取最小数并有数据的写入，推荐使用数据结构小根堆积树来完成操作。使用STL中的优先队列(priority_queue)也是可以的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;class heap &#123;private: int tree[10005]; int size;public: heap(int *p, int n) &#123; for (register int i = 1; i &lt;= n; i++)tree[i] = p[i]; size = n; for (register int i = size / 2; i &gt;= 1; i--)solve(i); &#125; void solve(int x) &#123; int l1 = 2 * x, l2 = 2 * x + 1, l = x; if (l1 &lt;= size &amp;&amp; tree[l1] &lt; tree[l])l = l1; if (l2 &lt;= size &amp;&amp; tree[l2] &lt; tree[l])l = l2; if (l != x) &#123; swap(tree[x], tree[l]); solve(l); &#125; &#125; int top() &#123; int temp = tree[1]; tree[1] = tree[size--]; solve(1); return temp; &#125; void up(int x) &#123; if (x == 1)return; if (tree[x] &lt; tree[x / 2])swap(tree[x], tree[x / 2]), up(x / 2); &#125; void add(int x) &#123; tree[++size] = x; up(size); &#125; bool empty() &#123; if (size == 0)return true; return false; &#125;&#125;;int main() &#123; int ans = 0; int op[10005]; int n; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; heap h(op, n); while (1) &#123; int x = h.top(), y = h.top(); ans += x + y; if (h.empty())break; h.add(x + y); &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一串数，在有频繁的加入删除操作时，如何维护它们的最大值和最小值?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的O(n)做法即为遍历整个数组，找到最值。这种方法简单但效率低下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆积树是一种基于完全二叉树的数据结构，可以在O(logn)的时间复杂度下维护序列最值。堆积树的特点是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 是一棵完全二叉树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 每一个节点的值都大于(或小于)其儿子节点的值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点值大于儿子节点的为大根堆，小于即为小根堆。显然，在根节点处可以取到最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面谈论堆的构造与维护算法(以小根堆为例)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先讲堆的节点交换算法，它的作用是在两棵子树已经为堆的基础上将这棵树转化为堆积树。 节点的交换算法是堆的基本算法。算法的步骤是先找到根节点与两个儿子节点的最小值，将根节点与最小值所在节点交换。此时根节点所在的局部具有小根堆性质。倘若一开始根节点就最小，依照算法的前提(两棵子树已为堆)，此时堆积树构造完毕，算法结束。但是倘若根节点起初不是最小值，交换后参与交换的子树由于根节点值变大，小根堆性质可能局部被破坏，但是由于该子树的两棵子树仍为堆，符合算法前提，再对该子树进行同样的递归操作，直到树的叶子节点。此时整棵树已经成为小根堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法的示例代码如下:12345678910void solve(int x) &#123; if (x &gt; n)return; int l1 = 2 * x, l2 = 2 * x + 1, l = x; if (l1 &lt;= n &amp;&amp; heap[l1] &lt; heap[l])l = l1; if (l2 &lt;= n &amp;&amp; heap[l2] &lt; heap[l])l = l2; if (l != x) &#123; swap(heap[l], heap[x]); solve(l); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆的构造过程即为从堆的最后一个非叶子节点开始，直至根节点，顺次执行堆的节点交换算法。由完全二叉树的性质易得这个非叶子节点编号为n/2(n为节点数量)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码如下:123void build() &#123; for (register int i = n / 2; i &gt;= 1; i--)solve(i);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点交换算法定义上不难理解这个方法的可行性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何找到最小值并将其删除?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上文讨论，heap[1]即为最小值。删除该元素只需将堆中最后一个元素覆盖到根节点处并令节点数减一，再在根节点处调用节点交换函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下:123456int top() &#123; int t = heap[1]; heap[1] = heap[n--]; solve(1); return t;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向堆中添加一个元素只需在堆的末尾加上该元素，该重新构造一遍堆即可。这个方法可行，但不最优。这里介绍一种更高效的算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于此时除了该元素之外，其余均维持小根堆性质。所以只需将该元素“上浮”，即将该元素与其父节点比较，若其比父节点值小，交换两个节点，从父节点开始继续上浮，直到父节点不比其大或者到达根节点时为止。1234void up(int x) &#123; if (x == 1)return; if (tree[x] &lt; tree[x / 2])swap(tree[x], tree[x / 2]), up(x / 2);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大根堆类比即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于堆可以维护最值，可以将其与选择排序算法结合，形成一种时间复杂度为O(nlogn)的新算法，称为堆排序算法。堆排序是不稳定的排序算法。算法思想是先将数据构造成堆，从中不断选出最值，再将其从堆中删除，重复该过程直到堆为空，此时即可获得有序的序列。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1040]加分二叉树]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1040-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设一个n个节点的二叉树tree的中序遍历为(1，2，3，… ，n)，其中数字1，2，3，… ，n为节点编号。每个节点都有一个分数(均为正整数)，记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree(也包含tree本身)的加分计算方法如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree的左子树的加分 × subtree的右子树的加分＋subtree的根的分数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试求一棵符合中序遍历为(1，2，3，… ，n)且加分最高的二叉树tree。要求输出;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)tree的最高加分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)tree的前序遍历 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行:1个整数n(n&lt;30)，为节点个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行:n个用空格隔开的整数，为每个节点的分数(分数&lt;100)。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行:1个整数，为最高加分(Ans≤4，000，000，000)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行:n个用空格隔开的整数，为该树的前序遍历。 输入输出样例Sample input 55 7 1 2 10 Sample output 1453 1 2 4 5 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察树型动态规划和二叉树遍历。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x，y)表示中序遍历为x，x+1，…，y-1，y的子树的最高加分，则有: f(x，y)=\begin{cases}\max\{f(x，k-1)*f(k+1，y)+value[k]\}(x≤k≤y) & xy \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递推即得结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二问可以设置一个数组tree[x][y]表示x~y的子树的根节点，递归遍历可得前序遍历序列。123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int op[50], n;int rem[50][50] = &#123;0&#125;;int tree[50][50] = &#123;0&#125;;int DP(int x, int y) &#123; if (x &gt; y)return 1; if (x == y)return op[x]; if (rem[x][y] != 0)return rem[x][y]; int ans = 0; for (register int i = x; i &lt;= y; i++) if (DP(x, i - 1) * DP(i + 1, y) + op[i] &gt; ans) ans = DP(x, i - 1) * DP(i + 1, y) + op[i], tree[x][y] = i; return rem[x][y] = ans;&#125;void print(int x, int y) &#123; if (x &gt; y)return; if (x == y) &#123; cout &lt;&lt; x &lt;&lt; '\x20'; return; &#125; cout &lt;&lt; tree[x][y] &lt;&lt; '\x20'; print(x, tree[x][y] - 1); print(tree[x][y] + 1, y);&#125;int main() &#123; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; cout &lt;&lt; DP(1, n) &lt;&lt; endl; print(1, n); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1126]机器人搬重物]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1126-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AC%E9%87%8D%E7%89%A9%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器人移动学会(RMI)现在正尝试用机器人搬运物品。机器人的形状是一个直径$1。6米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个N×M的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有:向前移动1步(Creep);向前移动2步(Walk);向前移动3步(Run);向左转(Left);向右转(Right)。每个指令所需要的时间为1秒。请你计算一下机器人完成任务所需的最少时间。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为两个正整数N，M(N，M≤50)，下面N行是储藏室的构造，0表示无障碍，1表示有障碍，数字之间用一个空格隔开。接着一行有4个整数和1个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向(东E，南S，西W，北N)，数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出-1。 输入输出样例Sample input 9 100 0 0 0 0 0 1 0 0 00 0 0 0 0 0 0 0 1 00 0 0 1 0 0 0 0 0 00 0 1 0 0 0 0 0 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 0 00 0 0 1 1 0 0 0 0 00 0 0 0 0 0 0 0 0 01 0 0 0 0 0 0 0 1 07 2 2 7 S Sample output 12 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题考察广度优先搜索(BFS)，比较常规。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用二维数组储存输入的01序列，用一个结构体储存当前点信息，开队列储存节点，还要记得保存当前已入队的节点信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何判定机器人是否可以前移以及边界处理问题。还有一个值得注意的是输入数据不一定合法，比如机器人初始坐标四周已有障碍物，此时直接输出-1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题有一个小技巧是将方向代数表示，这时机器人的转向可以转化为代数运算。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct node &#123; int time; int x, y; int turn;&#125;;int n, m;int op[55][55];int vis[55][55][4] = &#123;0&#125;;int a_x, a_y, b_x, b_y;queue&lt;node&gt; que;int check(int &amp;x, int &amp;y, int z) &#123; switch (z) &#123; case 0: if (x &lt;= 1 || op[x - 1][y] || op[x - 1][y + 1])return 0; else &#123; x--; return 1; &#125; break; case 1: if (y &gt;= m - 1 || op[x][y + 2] || op[x + 1][y + 2])return 0; else &#123; y++; return 1; &#125; break; case 2: if (x &gt;= n - 1 || op[x + 2][y] || op[x + 2][y + 1])return 0; else &#123; x++; return 1; &#125; break; case 3: if (y &lt;= 1 || op[x][y - 1] || op[x + 1][y - 1])return 0; else &#123; y--; return 1; &#125; break; &#125;&#125;int BFS() &#123; while (!que.empty()) &#123; node p = que.front(); if (p.x == a_x &amp;&amp; p.y == a_y)return p.time; que.pop(); p.time++; int t = p.turn; if (!vis[p.x][p.y][(p.turn + 1) % 4]) &#123; vis[p.x][p.y][(p.turn + 1) % 4] = 1; p.turn = (p.turn + 1) % 4; que.push(p); &#125; p.turn = t; if (!vis[p.x][p.y][(p.turn + 3) % 4]) &#123; vis[p.x][p.y][(p.turn + 3) % 4] = 1; p.turn = (p.turn + 3) % 4; que.push(p); &#125; p.turn = t; for (register int i = 1; i &lt;= 3; i++) &#123; if (!check(p.x, p.y, p.turn))break; if (vis[p.x][p.y][p.turn])continue; vis[p.x][p.y][p.turn] = 1; que.push(p); &#125; &#125; return -1;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) for (register int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; cin &gt;&gt; b_x &gt;&gt; b_y &gt;&gt; a_x &gt;&gt; a_y; node temp; temp.time = 0, temp.x = b_x, temp.y = b_y; char e; cin &gt;&gt; e; switch (e) &#123; case 'S': temp.turn = 2; break; case 'N': temp.turn = 0; break; case 'E': temp.turn = 1; break; case 'W': temp.turn = 3; &#125; if (op[b_x][b_y] || op[b_x + 1][b_y + 1] || op[b_x + 1][b_y] || op[b_x][b_y + 1]) &#123; cout &lt;&lt; "-1"; return 0; &#125; vis[b_x][b_y][temp.turn] = 1; que.push(temp); cout &lt;&lt; BFS(); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1316]丢瓶盖]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1316-%E4%B8%A2%E7%93%B6%E7%9B%96%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;陶陶是个贪玩的孩子，他在地上丢了A个瓶盖，为了简化问题，我们可以当作这A个瓶盖丢在一条直线上，现在他想从这些瓶盖里找出B个，使得距离最近的2个距离最大，他想知道，最大可以到多少呢？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个整数，A，B。(B≤A≤100000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行，A个整数，分别为这A个瓶盖坐标。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅一个整数，为所求答案。 输入输出样例Sample input 5 31 2 3 4 5 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题是一道典型的二分答案题目。考察二分和贪心思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分答案是一种寻求答案的方法，其原理利用了答案的单调性。在给定的答案域中，判断中点答案的可行性，根据其可行性再在答案域的左半区间或右半区间寻求答案，直到找到最终答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解释地更加清晰，下面说明几个概念。 答案域：答案可能的取值区间。在本题中答案域的左值为当前最小距离，最大值为最末与最初瓶盖坐标的差值。 可行：当存在一种方案使得在取出不小于B个瓶盖时，可以使任意两个相邻瓶盖间距都大于或等于x，则称x是可行的。也就是说，存在一种符合题目要求的选取策略，使得瓶盖间距最小值大于或等于x。同样，当不存在任何一种方案使得上述条件成立，则称x不可行。 答案单调性：当一个x可行时，由于要求最大值，故正确答案一定大于或等于x;类似地，当x不可行时，易知所有大于x的值都不可行，正确答案一定小于x。这就是答案的单调性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据以上说明，用二分查找方法，判定中点值的可行性，从而缩小区间，确定答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定一个值可行性的方法可用贪心策略，详见代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，本题中并未说明输入数据有序，必须先对输入的数据进行排序，再二分答案。12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int op[100005], a, b;int check(int x) &#123; int p = op[1], q = a - b; for (register int i = 2; i &lt;= a; i++) &#123; if (op[i] - p &lt; x) &#123; if (!q)return 0; q--; &#125; else p = op[i]; &#125; return 1;&#125;int find(int l, int r)//[,)&#123; if (r == l + 1)return l; int mid = (l + r) / 2; if (check(mid))return find(mid, r); else return find(l, mid);&#125;int main() &#123; cin &gt;&gt; a &gt;&gt; b; int minn = 1e8; for (register int i = 1; i &lt;= a; i++)cin &gt;&gt; op[i]; sort(op + 1, op + a + 1); for (register int i = 2; i &lt;= a; i++)minn = min(minn, op[i] - op[i - 1]); cout &lt;&lt; find(minn, op[a] - op[1]); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>二分查找</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F01%2F09%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍二分查找的相关内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个已经排好序的数组，如何快速从中找出值为x的元素的位置?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个通俗的做法是从第一个数开始遍历数组，直到找到x。时间复杂度O(n)。这种方法在数据量很大又频繁查找时效率低下。为了充分利用数据的有序性，可以使用二分查找算法在O(logn)复杂度下快速找到特定值的元素位置。二分查找是用来在已排序序列中找到特定值元素位置的高效算法，它的原理是一个基本事实: 在升序序列中[l，r]中，若mid=(l+r)/2且value[mid]&lt;x，那么x对应的元素必位于(mid，r]中，否则必位于[l，mid]中。降序排列类似。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个升序排序，不难写出代码:123456int binary_find(int l, int r, int x) &#123; if (l == r)return l; int mid = (l + r) / 2; if (value[mid] &lt; x)return binary_find(mid + 1, r, x); else return binary_find(l, mid, x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，假定在[2，3]中寻找元素x，value[2] &lt; x，value[3]=x，运行这段代码，会发现函数无限递归导致段错误。这是因为(2+3)/2=2，函数不断地在[2，3]中查找，无法跳出这个循环。这也是这种二分查找算法的重要缺陷。那么如何优化?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当函数传入参数l，r时，规定函数只能在(l，r]中查找，那么代码就变成:1234567int binary_find(int l, int r, int x)//(,]&#123; if (r == l + 1)return r; int mid = (l + r) / 2; if (value[mid] &lt; x)return binary_find(mid, r, x); else return binary_find(l, mid, x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时调用函数binary_find(-1，n-1，x)即可(n为数据量)。这种半开半闭式二分查找思想可以完美解决上面的问题。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1020]导弹拦截]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入导弹依次飞来的高度(雷达给出的高度数据是≤50000的正整数)，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1行，若干个整数(个数≤100000) 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例Sample input 389 207 155 300 299 170 158 65 Sample output 62 题解未强化版本:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的求最长上升(下降…)子序列问题，属于线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问即求序列中最长不上升子序列的长度，第二问即求序列中最少的最长不上升子序列数量。由Dilworth定理，该问即为求序列的最长上升子序列长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x)为以第x个数为序列起点，可得到的最长序列长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则对于第一问，状态转移方程为: f(x)=\max\{f(i)\}+1，x]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1606]疯狂的采药]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1606-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说:“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你是LiYuxiang，你能完成这个任务吗？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此题和原题的不同点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1。每种草药可以无限制地疯狂采摘。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2。药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入第一行有两个整数T(1 ≤ T ≤ 100000)和M(1 ≤ M ≤ 10000)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间(包括1和10000)的整数，分别表示采摘某种草药的时间和这种草药的价值。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 输入输出样例Sample input 70 371 10069 11 2 Sample output 140 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无限背包问题，属于经典的线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与01背包不同的是，无限背包允许每个物品无穷次加入背包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x，y)表示在容量剩余y时，将x~m物品加入背包的最大价值。则可列出状态转移方程: f(x，y)=\begin{cases} \max\{f(x，y-time[x])+value[x]，f(x+1，y)\}\ \ & y \geq time[x]\\ f(x+1，y) & y]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1048]采药]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1048-%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[难度：普及- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说:“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”如果你是辰辰，你能完成这个任务吗？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有2个整数T(1≤T≤1000)M(1≤M≤100)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间(包括1和100)的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1个整数，表示在规定的时间内可以采到的草药的最大总价值。 输入输出样例Sample input 70 371 10069 11 2 Sample output 3 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典01背包问题，考察线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x,y)表示在x时间内对于物品y~m的最大价值。显然,物品顺序对结果无影响，容易列出状态转移方程: f(x,y)=\max\{f(x,y+1),f(x-time[x],y+1)+value[x]\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当xm时，f(x,y)均为0。12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int time2[1005], value[105];int dp[1005][105] = &#123;0&#125;;int main() &#123; int t, m; cin &gt;&gt; t &gt;&gt; m; for (register int i = 1; i &lt;= m; i++)cin &gt;&gt; time2[i] &gt;&gt; value[i]; for (register int i = m; i &gt;= 1; i--) &#123; for (register int j = 1; j &lt;= t; j++) &#123; if (j &lt; time2[i])dp[j][i] = dp[j][i + 1]; else dp[j][i] = max(dp[j][i + 1], dp[j - time2[i]][i + 1] + value[i]); &#125; &#125; cout &lt;&lt; dp[t][1]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1387]最大正方形]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1387-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个n*m的只包含0和1的矩阵里找出一个不包含0的最大正方形，输出边长。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件第一行为两个整数n，m(1≤n,m≤100)，接下来n行，每行m个数字，用空格隔开，0或1。 输出格式:一个整数,最大正方形的边长。 输入输出样例:Sample input 4 40 1 1 11 1 1 00 1 1 01 1 0 1 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察二维动态规划及递推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若设f(x,y)示以此点为左上点正方形的最大边长。则易得: f(x,y)=\min\{f(x+1,y),f(x,y+1), f(x+1,y+1)\}+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意若点(x,y)为0或者超出边界，则f(x,y)=0，从f(x,y)中找出最大值即可。1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int op[105][105], n, m;int ans[105][105] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) for (register int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; int res = 0; for (register int i = n; i &gt;= 1; i--) for (register int j = m; j &gt;= 1; j--) &#123; if (op[i][j] == 0)continue; ans[i][j] = min(ans[i + 1][j], min(ans[i][j + 1], ans[i + 1][j + 1])) + 1; res = max(res, ans[i][j]); &#125; cout &lt;&lt; res; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬线法]]></title>
    <url>%2F2019%2F01%2F08%2F%E6%82%AC%E7%BA%BF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个矩阵中找到满足某种性质的最大子矩阵问题是一个很常见的问题，悬线法是求解此类问题的高效算法。现在来看这样一题(洛谷 P1169)来认识悬线法。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 8×8 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小 Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小 W 决定将棋盘扩大以适应他们的新规则。小 Q 找到了一张由 N×M$(N,M \leq 2000)$个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小 Q 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。不过小 Q 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘(当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色)，所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。于是小 Q 找到了即将参加全国信息学竞赛的你，你能帮助他么? 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含两个整数 N 和 M ，分别表示矩形纸片的长和宽。接下来的 N 行包含一个 N × M 的 01 矩阵，表示这张矩形纸片的颜色( 0 表示白色， 1 表示黑色)。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积(注意正方形和矩形是可以相交或者包含的)。可以看出，本题实质上在求一个矩阵中满足 01 相间排列性质的最大方阵和最大矩阵的面积，可以用悬线法高效解决。 悬线法思想：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 up(x，y)表示点(x，y)所在的满足性质(本题就是点的值互异)的“最大”矩形的高度 ，left(x，y) 表 示 点 (x，y) 所 在 的 满 足 性 质 的 同 一 个 “ 最 大 ” 矩 形 向 左 延 伸 的 距离，right(x，y)是向右的距离。那么横向延伸距离为 a=right+left-1，纵向即为 b=up，方阵面积为 min(a，b)2 ，矩阵面积即为 ab。对“最大”矩形的理解其实是一个较困难的问题。它要求每一个点的“最大”矩形必须继承自其正上方点，所在的矩形并且高度必须加一，也就是说这个点的最大矩形必须是在其正上方点所在点的矩形的子集基础上只作左右延伸得到的。除非正上方的点无法延伸到这个点(本题中即是这两个点同为 1 或同为 0)，这个点所在的矩形才可以完全独立于正上方点所在的矩形而没有交集，否则它们一定有所交集。“最大”即是指在满足这个继承性质的前提下可以得到的最大矩阵，它显然是唯一的。由于这种方法就像一根悬线左右摆动，不断求左右延伸量，来求子矩阵，故名悬线法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化全部点的三个值均为 1，这是第一次初始化。首先认为每一个点所在的最大矩形均为 1，在其所在的一行中更新 left 和 right。这是第二次初始化，这也是完全没有继承上一行矩阵时的值。自上而下从左到右遍历整个矩阵，按照 up，left，right 的定义更新值，算出面积。如果可以更新的话，递推公式为(首行不必更新)： up(x，y)=up(x-1，y)+1\\ left(x，y)=\min\{left(x，y)，left(x-1，y)\}\\ right(x，y)=\min\{right(x，y)，right(x-1，y)\}\\ x \geq 1下面证明这个思想的正确性，考虑用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先首行是完全满足三个值的定义的。因为作为首行，up 值必须为 1，left 和 right 在第二次初始化中得到的结果本身就是满足定义的。之后的操作中，倘若第 k 行所有点的三个值都满足定义，那么对于一个点(k，i)，若其正下方的点满足性质，可以做延伸，那么点(k+1，i)的 up 值必须是 up(k，i)+1。并且 left 取自己第二次初始化的值和 left(k，i)的较小值是合理的，这是因为前者是点(k+1，i)所在行可以向左延伸的最大距离，而 left(k，i)是点(k，i)所在的矩形向左延伸的最大距离，取较小值才是这个点在继承自上一个矩阵的基础上向左延伸的最大距离。right 同理，均满足定义。如果不能正下方的点不满足性质，无法作延伸也就无法继承，那么这两个矩形独立，这个点的三个值保持初始化状态不变。显然这也是满足定义的。于是递推公式成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是为什么仅仅作矩阵的继承操作，在遍历整个矩阵后一定可以找到最优解呢?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设 P(x，y)是实际上的最大的矩形中的某一点：红色矩形为 P 实际所在的最大矩形，黑色矩形是 P 继承正上方的点所在矩形得到的最大矩形。这时黑色矩形的最优性很可能不如红色矩形。但是注意到红色矩形的首行一行中至少有一点 Q(x’，y’)无法继承自其正上方的点，其 up 值便仍为 1，红色矩形向左向右延伸的最大距离也便在 Q 的第二次初始化中确定。Q 正下方的点列要继承 Q 所在的矩形，会将这个矩形的高度层层扩大，于是在 Q 正下方且在红色矩形的末行上的某点 Q’处取到最优解。这便证明了算法的最优性，并且给出了最优解的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出本题的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include &lt;cstring&gt;#define MAX 2001using namespace std;int n, m;int op[MAX][MAX];int l[MAX][MAX], r[MAX][MAX], u[MAX][MAX];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++)cin &gt;&gt; op[i][j], l[i][j] = r[i][j] = 1, u[i][j] = 1;//初始化 for (int i = 0; i &lt; n; i++) for (int j = 1; j &lt; m; j++) if (op[i][j] != op[i][j - 1]) l[i][j] = l[i][j - 1] + 1;//一行中更新 left for (int i = 0; i &lt; n; i++) for (int j = m - 2; j &gt;= 0; j--) if (op[i][j] != op[i][j + 1]) r[i][j] = r[i][j + 1] + 1;//一行中更新 right int ans1 = 0, ans2 = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int a, b; if (i == 0) &#123; a = r[i][j] + l[i][j] - 1; b = min(a, u[i][j]); ans1 = max(ans1, b * b), ans2 = max(ans2, a * u[i][j]); &#125; else if (op[i][j] != op[i - 1][j]) &#123; u[i][j] = u[i - 1][j] + 1; l[i][j] = min(l[i][j], l[i - 1][j]); r[i][j] = min(r[i][j], r[i - 1][j]); a = r[i][j] + l[i][j] - 1; b = min(a, u[i][j]); ans1 = max(ans1, b * b), ans2 = max(ans2, a * u[i][j]); &#125; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
</search>
