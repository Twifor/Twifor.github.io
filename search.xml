<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[倍增算法]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍倍增算法+三道例题，题目来自洛谷，难度至少提高+/省选-。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倍增算法在之前的快速幂、求LCA算法、ST表中都有体现，它基于下面的基本原理： \forall x\in \mathbb {N},x=2^{p_1}+2^{p_2}+\cdots +2^{p_n},0\leq p_1 < p_2 < \cdots < p_n,p_i\in \mathbb {N}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，对于任意一个自然数，它都可以唯一地表示成若干个互异的2的方幂相加的形式。利用这个原理，我们可以将x的求得过程降至对数级别。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际操作中，通常采用“跳跃式行进”的方法去应用倍增，具体做法是：从2的高幂次方幂开始进行跳跃，如果越过目标，则将方幂减少一倍（即下一个方幂）；如果未越过，可以证明该方幂一定在上面给出的二进制拆分表达式中，进行跳跃操作，之后也需要将方幂减少一倍。重复这个过程直到取尽2的所有自然数方幂，此时就已经跳跃到目标位置。这样可以在$O(logn)$复杂度下完成跳跃操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面三道例题，点击题目标题可进行跳转。样例及说明略，见洛谷原题。 例题一 货车运输(P1967)难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有两个用一个空格隔开的整数 n,m，表示A国有n座城市和 m 条道路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来m行每行 3 个整数 x, y, z，每两个整数之间用一个空格隔开，表示从 x 号城市到y号城市有一条限重为z的道路。注意： x 不等于 y，两座城市之间可能有多条道路 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来一行有一个整数 q，表示有 q 辆货车需要运货。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题本质上是求图中任意两点可能路径中最小边权值的最大值。看到最小值的最大值首先想到二分答案，二分答案比暴力快，但是免不了每次都要遍历一遍图，效率低下一定TLE。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑其它方法。可以证明任意两点最大值出现的路径一定在该图的最大生成树上，于是用Kruskal算法配合并查集求出最大生成树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树构造完毕后，两点的路径显然就是经过两个点LCA的路径，这里改一下倍增法求LCA的步骤就可以轻易求出答案。查询时间复杂度$O(logn)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define N 10005#define inf 0x7ffffffusing namespace std;inline int read() &#123;//神奇的读入优化 char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return s;&#125;struct Edge &#123; int to, v, next;&#125; edge[N];struct Temp &#123; int from, to, v; bool operator&lt;(Temp t) &#123; return v &gt; t.v; &#125;&#125; temp[5 * N];int n, m, head[N], cnt = 1, father[N], grand[N][16], minn[N][16], depth[N];inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;int find(int x) &#123; return father[x] == x ? x : father[x] = find(father[x]);&#125;void DFS(int x) &#123; for (int i = head[x]; i; i = edge[i].next) if (!depth[edge[i].to]) &#123; grand[edge[i].to][0] = x, minn[edge[i].to][0] = edge[i].v, depth[edge[i].to] = depth[x] + 1; for (int j = 1; j &lt;= 15; j++) &#123; grand[edge[i].to][j] = grand[grand[edge[i].to][j - 1]][j - 1]; minn[edge[i].to][j] = min(minn[edge[i].to][j - 1], minn[grand[edge[i].to][j - 1]][j - 1]); &#125; DFS(edge[i].to); &#125;&#125;int findAns(int x, int y) &#123; if (x == y)return inf; if (find(x) != find(y))return -1; int ans = inf; if (depth[x] == depth[y]) &#123; for (int i = 15; i &gt;= 0; i--) &#123; if (grand[x][i] != grand[y][i]) ans = min(ans, min(minn[x][i], minn[y][i])), x = grand[x][i], y = grand[y][i]; &#125; return min(ans, min(minn[x][0], minn[y][0])); &#125; else &#123; if (depth[x] &lt; depth[y]) &#123; for (int i = 15; i &gt;= 0; i--) &#123; if (depth[grand[y][i]] &gt;= depth[x])ans = min(ans, minn[y][i]), y = grand[y][i]; &#125; return min(ans, findAns(x, y)); &#125; else &#123; for (int i = 15; i &gt;= 0; i--) &#123; if (depth[grand[x][i]] &gt;= depth[y])ans = min(ans, minn[x][i]), x = grand[x][i]; &#125; return min(ans, findAns(x, y)); &#125; &#125;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) &#123; father[i] = i; for (int j = 0; j &lt;= 15; j++)minn[i][j] = inf; &#125; for (int i = 1; i &lt;= m; i++)temp[i].from = read(), temp[i].to = read(), temp[i].v = read(); sort(temp + 1, temp + m + 1); for (int i = 1; i &lt;= m; i++) if (find(temp[i].from) != find(temp[i].to)) &#123; father[find(temp[i].from)] = find(temp[i].to); add(temp[i].from, temp[i].to, temp[i].v); add(temp[i].to, temp[i].from, temp[i].v); &#125; for (int i = 1; i &lt;= n; i++)if (!depth[i])depth[i] = 1, DFS(i); int q = read(); for (int i = 1; i &lt;= q; i++) &#123; int x = read(), y = read(); cout &lt;&lt; findAns(x, y) &lt;&lt; endl; &#125; return 0;&#125; 例题二 开车旅行(P1081)难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小A和小B决定利用假期外出旅行，他们将想去的城市从1到N编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市i的海拔高度为$H_i$ ，城市i和城市j之间的距离$d_{ij}$恰好是这两个城市海拔高度之差的绝对值，即$d_{ij}=|H_i-H_j|$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;旅行过程中，小 A和小B 轮流开车，第一天小 A 开车，之后每天轮换一次。他们计划选择一个城市 S 作为起点，一直向东行驶，并且最多行驶 X公里就结束旅行。小 A 和小 B的驾驶风格不同，小 B总是沿着前进方向选择一个最近的城市作为目的地，而小 A总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 X 公里，他们就会结束旅行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在启程之前，小 A想知道两个问题：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个给定的 $X=X_0$，从哪一个城市出发，小 A开车行驶的路程总数与小 B 行驶的路程总数的比值最小（如果小 B 的行驶路程为 0，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对任意给定的 $X=X_i$和出发城市 $S_i$，小 A开车行驶的路程总数以及小 B 行驶的路程总数。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数N，表示城市的数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行有 N个整数，每两个整数之间用一个空格隔开，依次表示城市 1 到城市 N的海拔高度，即$H_1,H_2,\cdots,H_n$，且每个$H_i$都是不同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行包含一个整数$X_0$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四行为一个整数M，表示给定M组$S_i$和$X_i$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的 M 行，每行包含 2 个整数$S_i$和$X_i$，表示从城市$S_i$出发，最多行驶$X_i$公里。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共 M+1行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数$S_0$ ，表示对于给定的$X_0$，从编号为$S_0$的城市出发，小A开车行驶的路程总数与小B行驶的路程总数的比值最小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的M行，每行包含 2个整数，之间用一个空格隔开，依次表示在给定的$S_i$和$X_i$下小 A 行驶的里程总数和小 B 行驶的里程总数。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题有一定难度。首先应该考虑预处理出每一个城市小A的目标和小B的目标。最直接的方法是暴力扫一遍找出最小和第二小，时间复杂度$O(n^2)$。在这样的数据量下，仅这个步骤就已经TLE了，显然不可取。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个较好的方法是从右向左进行预处理，每一次保证待求城市右侧的城市的高度升序（降序也可），然后二分求最小和次小。这样需要向有序序列中不断插入元素，还要保证能够二分，可以选择用平衡树这个数据结构完成这个操作，这里用fhq treap。平衡树操作求第二小可以先求最小再将其最小值删除，再求的最小值就是实际的第二小，紧接着把最小值重新插入即可。预处理时间复杂度$O(nlogn)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑后面的操作。对于小A的第一个问题，一种想法是遍历出发城市进行判断，这样做的时间复杂度仍然为$O(n^2)$，会TLE，于是采用倍增算法将其优化至$O(nlogn)$。预处理出从某个城市开始走$2^k$步的目标城市和小A、小B的驾驶距离，进行倍增即可。第二个问题也可以用倍增的方法解决。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;#define N 100005#define ABS(x) ((x)&gt;=0?(x):-(x))using namespace std;struct Node &#123; int v, ch[2], key, rk;&#125; node[N &lt;&lt; 1];int cnt = 1, root, to[N][2], op[N], n;int A[N][2][19], B[N][2][19], TO[N][2][19];inline int read() &#123; char e = getchar(); int s = 0, f = 0; while (e &lt; '-')e = getchar(); if (e == '-')f = 1, e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar(); return f ? -s : s;&#125;void split(int rt, int &amp;a, int &amp;b, int k) &#123; if (rt == 0)a = b = 0; else &#123; if (node[rt].v &lt;= k)a = rt, split(node[rt].ch[1], node[a].ch[1], b, k); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], k); &#125;&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0)rt = a + b; else if (node[a].key &lt; node[b].key)rt = b, merge(node[rt].ch[0], a, node[b].ch[0]); else rt = a, merge(node[rt].ch[1], node[a].ch[1], b);&#125;int newNode(int x, int rk) &#123; node[cnt].v = x, node[cnt].key = rand(), node[cnt].rk = rk; return cnt++;&#125;void insert(int x, int rk) &#123; int p = newNode(x, rk), a, b; split(root, a, b, x), merge(a, a, p), merge(root, a, b);&#125;void del(int x) &#123; int a, b, c; split(root, a, b, x), split(a, a, c, x - 1), merge(root, a, b);&#125;int findMin(int rt, int x) &#123; if (rt == 0)return 0; int ans; if (node[rt].v &lt; x)ans = findMin(node[rt].ch[1], x); else ans = findMin(node[rt].ch[0], x); if (ans == 0)return rt; if (ABS(node[ans].v - x) &lt; ABS(node[rt].v - x))return ans; else if (ABS(node[ans].v - x) &gt; ABS(node[rt].v - x))return rt; else return node[ans].v &lt; node[rt].v ? ans : rt;&#125;int findMin2(int x, int a) &#123; del(node[a].v); int ans = findMin(root, x); insert(node[a].v, node[a].rk); return ans;&#125;inline void solve() &#123; int x0 = read(), ans = 1, m; double minn = 1e9, tp; for (int i = 1; i &lt;= n; i++) &#123; int p = i, a = 0, b = 0; for (int j = 18; j &gt;= 0; j--) if (TO[p][0][j] != 0 &amp;&amp; a + b + A[p][0][j] + B[p][0][j] &lt;= x0) a += A[p][0][j], b += B[p][0][j], p = TO[p][0][j]; tp = (b == 0 ? 1e9 : (double) a / b); if (tp &lt; minn)ans = i, minn = tp; else if (tp == minn &amp;&amp; op[i] &gt; op[ans])ans = i; &#125; cout &lt;&lt; ans &lt;&lt; endl; m = read(); for (int i = 1; i &lt;= m; i++) &#123; int S = read(), X = read(), a = 0, b = 0; for (int j = 18; j &gt;= 0; j--) &#123; if (TO[S][0][j] != 0 &amp;&amp; a + b + A[S][0][j] + B[S][0][j] &lt;= X) &#123; a += A[S][0][j], b += B[S][0][j], S = TO[S][0][j]; &#125; &#125; cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; &#125;&#125;int main() &#123; srand(time(NULL)); n = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); insert(op[n], n); for (int i = n - 1; i &gt;= 1; i--) to[i][1] = findMin(root, op[i]), to[i][0] = findMin2(op[i], to[i][1]), insert(op[i], i); for (int i = 1; i &lt;= n; i++)to[i][0] = node[to[i][0]].rk, to[i][1] = node[to[i][1]].rk; for (int i = n - 1; i &gt;= 1; i--) &#123; A[i][0][0] = ABS(op[i] - op[to[i][0]]), B[i][1][0] = ABS(op[i] - op[to[i][1]]); TO[i][0][0] = to[i][0], TO[i][1][0] = to[i][1]; for (int j = 1; j &lt;= 18; j++) &#123; TO[i][0][j] = TO[TO[i][0][j - 1]][j == 1][j - 1]; TO[i][1][j] = TO[TO[i][0][j - 1]][j != 1][j - 1]; A[i][0][j] = A[i][0][j - 1] + (j == 1 ? 0 : A[TO[i][0][j - 1]][0][j - 1]); B[i][1][j] = B[i][1][j - 1] + (j == 1 ? 0 : B[TO[i][1][j - 1]][1][j - 1]); A[i][1][j] = A[i][1][j - 1] + (j == 1 ? A[TO[i][1][0]][0][0] : A[TO[i][1][j - 1]][1][j - 1]); B[i][0][j] = B[i][0][j - 1] + (j == 1 ? B[TO[i][0][0]][1][0] : B[TO[i][0][j - 1]][0][j - 1]); &#125; &#125; solve(); return 0;&#125; 例题三 跑路(P1613)难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小A的工作不仅繁琐，更有苛刻的规定，要求小A每天早上在6：00之前到达公司，否则这个月工资清零。可是小A偏偏又有赖床的坏毛病。于是为了保住自己的工资，小A买了一个十分牛B的空间跑路器，每秒钟可以跑2^k千米（k是任意自然数）。当然，这个机器是用longint存的，所以总跑路长度不能超过maxlongint千米。小A的家到公司的路可以看做一个有向图，小A家为点1，公司为点n，每条边长度均为一千米。小A想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证1到n至少有一条路径。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个整数n，m，表示点的个数和边的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来m行每行两个数字u，v，表示一条u到v的边。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行一个数字，表示到公司的最少秒数。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实是一道水题，能想出来方法则这题很简单，想不出来…就想不出来了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预处理任意两点间是否存在长度为$2^k$的路径，可以使用邻接矩阵快速幂。对于存在该路径的点对，显然可以用1s的时间在两点间“穿越”，相当于两点间有一条权为1的有向边。以此加边构图，最后结点1到结点n的最短路径就是答案，这里可以用Floyd算法求出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;int n, m;long long dict[51][51];struct Matrix &#123; int op[51][51]; void operator*=(Matrix p) &#123; int t[51][51] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int z = 1; z &lt;= n; z++)t[i][j] += this-&gt;op[i][z] * p.op[z][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++)this-&gt;op[i][j] = t[i][j] &gt;= 1; &#125;&#125;a;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++)dict[i][j] = i == j ? 0 : (1l &lt;&lt; 52); &#125; for (int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; a.op[x][y] = 1, dict[x][y] = 1; &#125; for (int i = 2; i &lt;= 63; i++) &#123; a *= a; for (int j = 1; j &lt;= n; j++) &#123; for (int z = 1; z &lt;= n; z++)if (a.op[j][z])dict[j][z] = 1; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (k != i &amp;&amp; i != j &amp;&amp; k != j) &#123; dict[i][j] = min(dict[i][k] + dict[k][j], dict[i][j]); &#125; &#125; &#125; &#125; cout &lt;&lt; dict[1][n]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>倍增算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2F2019%2F03%2F06%2F%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍简单的莫队算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫队算法是一种优雅的暴力方法，由前国家队队长莫涛提出，故称莫队算法。本文只探讨基本的莫队算法。值得注意的是，莫队算法必须离线，而且最好用来处理查询问题（尽可能不修改）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑一个问题：给定一个区间，求子区间中互异数的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最暴力的方法是每一次都遍历一遍子区间，求出互异数，时间复杂度为$O(nm)$，效率很低。莫队算法就是在暴力方法的基础上改进提出的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不变的序列和m个询问，考虑离线。置两个指针指向某个区间的首末位置，对于每一个询问区间，将两个指针移动到询问区间的两端，移动过程中修改答案数据。这样在指针移动到目标位置时就得到了答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显，这样并没有多少效率的提升。指针有可能从头指向尾，再从尾指向头，时间复杂度还是$O(nm)$，效率可能比暴力还低。这时，莫队算法的一个重要思想就体现出来了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对区间分块，分成t块。通常置每一块的长度为$\sqrt n$，这样t就大致为$\sqrt n$。当最后的序列长度不足组成一个块时，将它们视为一个。比如对于长度为10的序列，可将其分成3+3+3+1四个块。12int base = static_cast&lt;int&gt;(sqrt(n));for (int i = 1; i &lt;= n; i++)belong[i] = (i - 1) / base + 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码可以来完成分块操作。belong存每一个点所处块的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，对所有询问进行排序。当询问区间的左端点在同一块中时，按右端点升序排列，否则按左端点升序排列。1234bool operator&lt;(Node x) &#123; if (belong[l] == belong[x.l])return r &lt; x.r; return l &lt; x.l;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面是结点重载&lt;的形式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样排序有什么好处？下面分析排序后指针移动次数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在同一块中时，左指针最大移动$\sqrt n$，右指针只能升序移动，最大移动$n$；当跨块时，左指针最大移动$2\sqrt n$，右指针仍然为$n$。这样来看，对于每一次询问，左指针平均移动$\sqrt n$次；对于每一个块，右指针移动n次，于是时间复杂度为$O((n+m)\sqrt n)$，相比$O(nm)效率得到很大提升$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题：洛谷P1972。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题目就是本文一开始提出的问题，值得注意的是，莫队算法在本题中可得80分左右，思想很重要的，文末介绍本题正解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;int belong[500005], n, vis[1000000], op[500005], ans, m;struct Node &#123; int l, r, rk, ans; bool operator&lt;(Node x) &#123; if (belong[l] == belong[x.l])return r &lt; x.r; return l &lt; x.l; &#125;&#125; node[500005];inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (e &amp; 15), e = getchar();//神奇的读入优化 return s;&#125;bool cmp(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;inline void moveL(int &amp;p, int to) &#123;//移动左指针 if (p &lt; to) &#123; do &#123; vis[op[p]]--; if (vis[op[p]] == 0)ans--; p++; &#125; while (p &lt; to); &#125; else if (p &gt; to) &#123; do &#123; p--; vis[op[p]]++; if (vis[op[p]] == 1)ans++; &#125; while (p &gt; to); &#125;&#125;inline void moveR(int &amp;p, int to) &#123;//移动右指针 if (p &lt; to) &#123; do &#123; p++; vis[op[p]]++; if (vis[op[p]] == 1)ans++; &#125; while (p &lt; to); &#125; else if (p &gt; to) &#123; do &#123; vis[op[p]]--; if (vis[op[p]] == 0)ans--; p--; &#125; while (p &gt; to); &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); int base = static_cast&lt;int&gt;(sqrt(n)), l = 1, r = 1; for (int i = 1; i &lt;= n; i++)belong[i] = (i - 1) / base + 1; m = read(); for (int i = 1; i &lt;= m; i++)node[i].l = read(), node[i].r = read(), node[i].rk = i; sort(node + 1, node + m + 1); vis[op[1]] = 1, ans = 1; for (int i = 1; i &lt;= m; i++)moveL(l, node[i].l), moveR(r, node[i].r), node[i].ans = ans; sort(node + 1, node + m + 1, cmp); for (int i = 1; i &lt;= m; i++)cout &lt;&lt; node[i].ans &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二道例题：TJU某ACM冬季训练竞赛最后一题。 【排队接水】有n个小朋友需要接水，其中第i个小朋友接水需要ai分钟。由于水龙头有限，小Hi需要知道如果为第l个到第r个小朋友分配一个水龙头，如何安排他们的接水顺序才能使得他们等待加接水的时间总和最小。小Hi总共会有m次询问，你能帮助他解决这个问题吗？假设3个小朋友接水的时间分别是2，3，4。如果他们依次接水，第一位小朋友等待加接水的时间是2，第二位小朋友是5，第三位小朋友是9。时间总和是16。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心策略很容易知道将这些结点排序，求前缀和相加就是答案，本质上是构造哈夫曼树。本题用莫队算法可以比较容易地解决。一个难点是如何在指针移动时更新答案，这个过程需要维护两个树状数组。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '-')e = getchar(); while (e &gt; '-')s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (e &amp; 15), e = getchar(); return s;&#125;int n, m, op[20005], belong[20005], l, r;long long tree[20005], tree2[20005], ans;struct Node &#123; int l, r, rk; long long ans; bool operator&lt;(Node x) &#123; if (belong[l] == belong[x.l])return r &lt; x.r; return l &lt; x.l; &#125;&#125; node[20005];inline void add(int x, int y, long long *tr) &#123; for (; x &lt;= n; x += (x &amp; -x))tr[x] += y;&#125;inline long long sum(int x, const long long *tr) &#123; long long s = 0; for (; x &gt;= 1; x -= (x &amp; -x))s += tr[x]; return s;&#125;inline void moveL(int &amp;at, int to) &#123; long long p, s = r - l + 1; if (at &lt; to) &#123; do &#123; p = sum(op[at], tree), ans -= sum(op[at], tree2) + (s - p) * op[at]; add(op[at], -1, tree), add(op[at], -op[at], tree2), at++, s--; &#125; while (at &lt; to); &#125; else if (at &gt; to) &#123; do &#123; at--, p = sum(op[at], tree), ans += (s - p) * op[at] + sum(op[at], tree2) + op[at]; add(op[at], 1, tree), add(op[at], op[at], tree2), s++; &#125; while (at &gt; to); &#125;&#125;inline void moveR(int &amp;at, int to) &#123; long long p, s = r - l + 1; if (at &lt; to) &#123; do &#123; at++, p = sum(op[at], tree), ans += (s - p) * op[at] + sum(op[at], tree2) + op[at]; add(op[at], 1, tree), add(op[at], op[at], tree2), s++; &#125; while (at &lt; to); &#125; else if (at &gt; to) &#123; do &#123; p = sum(op[at], tree), ans -= sum(op[at], tree2) + (s - p) * op[at]; add(op[at], -1, tree), add(op[at], -op[at], tree2), at--, s--; &#125; while (at &gt; to); &#125;&#125;bool cmp(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;int main() &#123; int t = read(); while (t--) &#123; n = read(), m = read(); int base = static_cast&lt;int&gt;(sqrt(n)); for (int i = 1; i &lt;= n; i++)op[i] = read(), tree2[i] = tree[i] = 0, belong[i] = (i - 1) / base + 1; for (int i = 1; i &lt;= m; i++)node[i].l = read(), node[i].r = read(), node[i].rk = i; sort(node + 1, node + m + 1); l = r = 1, ans = op[1], add(op[1], 1, tree), add(op[1], op[1], tree2); for (int i = 1; i &lt;= m; i++)moveL(l, node[i].l), moveR(r, node[i].r), node[i].ans = ans; sort(node + 1, node + m + 1, cmp); for (int i = 1; i &lt;= m; i++)cout &lt;&lt; node[i].ans &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文末补充洛谷P1972正解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法仍然是离线。将所有询问按右结点升序排列，用树状数组维护最右侧某个数出现的第一个位置，使该位置+1，答案就是树状数组的区间和。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define N 500005using namespace std;int last[1000005];int tree[N], n, m, op[N];struct Node &#123; int l, r, rk, ans; bool operator&lt;(Node x) &#123; return r &lt; x.r; &#125;&#125; node[N];bool cmp(Node x, Node y) &#123; return x.rk &lt; y.rk;&#125;inline void add(int x, int y) &#123; for (int i = x; i &lt;= n; i += (i &amp; -i))tree[i] += y;&#125;inline int sum(int x) &#123; int s = 0; for (int i = x; i &gt;= 1; i -= (i &amp; -i))s += tree[i]; return s;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; last[op[i]] = -1; &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; i++)cin &gt;&gt; node[i].l &gt;&gt; node[i].r, node[i].rk = i; sort(node + 1, node + m + 1); for (int i = node[1].r; i &gt;= 1; i--)if (last[op[i]] == -1)last[op[i]] = i, add(i, 1); node[1].ans = sum(node[1].r) - sum(node[1].l - 1); for (int i = 2; i &lt;= m; i++) &#123; for (int j = node[i].r; j &gt; node[i - 1].r; j--) &#123; if (last[op[j]] == -1)last[op[j]] = j, add(j, 1); else if (last[op[j]] &lt;= node[i - 1].r)add(last[op[j]], -1), last[op[j]] = j, add(j, 1); &#125; node[i].ans = sum(node[i].r) - sum(node[i].l - 1); &#125; sort(node + 1, node + m + 1, cmp); for (int i = 1; i &lt;= m; i++)cout &lt;&lt; node[i].ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[替罪羊树]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;替罪羊树是博客里提到的第三种平衡树，前两种分别是Splay和Treap（含fhq Treap）。它更易写，也容易理解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;替罪羊树的目的同样是使树尽可能平衡，它的思路很简单粗暴：当某棵树不平衡时，拍掉重建。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国际惯例，先看结点结构体定义：1234struct Node &#123; int size, ch[2], v, s, num;&#125; node[500005]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有很多已经熟悉的变量，只是多了一个size。size记录子树中的有效结点数目，下文会提到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么会有有效结点这种说法呢？替罪羊树中删除某个结点，并不是直接删除，而是打上标记（即允许s=0的结点存在）。此时这个结点就是无效结点，不能计入size。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;何为拍掉重建？首先需要知道如何判定一棵树已经不平衡，这就需要引入平衡因子的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当左子树的size或着右子树的size大于整棵树的size乘以平衡因子时，我们认为这棵树不平衡。很明显左子树size和右子树size中一定有一个不小于整棵树size的一半，即平衡因子至少为0.5，而最大显然为1。平均来看，我们取平衡因子为0.75，记alpha=0.75。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update定义：1234void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s; node[x].size = node[node[x].ch[0]].size + node[node[x].ch[1]].size + (node[x].s &gt; 0);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检验函数：123bool check(int x) &#123; return node[node[x].ch[0]].size &gt; node[x].size * alpha || node[node[x].ch[1]].size &gt; node[x].size * alpha;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何重建？首先对树进行一次中序遍历，记得要剔除所有无效结点，将遍历编号序列存在数组中。然后新树的树根就是这个序列的中点，两棵子树递归进行，易知这样建树符合BST定义。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中序遍历代码：123456void serach(int x) &#123; if (x == 0)return; serach(node[x].ch[0]); if (node[x].s &gt; 0)temp[++ct] = x; serach(node[x].ch[1]);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重建函数：1234void rebuild(int &amp;x) &#123;//引用！！因为要修改值 ct = 0, serach(x); solve(x, 1, ct);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve就是负责建树的递归函数，这里记得传进来的x是引用。1234567891011void solve(int &amp;x, int l, int r) &#123;//引用！！ if (r &lt; l) &#123; x = 0; return; &#125; int mid = (l + r) / 2; x = temp[mid]; solve(node[x].ch[0], l, mid - 1); solve(node[x].ch[1], mid + 1, r); update(x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入元素与BST基本相同：123456789101112void insert(int &amp;x, int y) &#123;//仍然是引用，与treap的思想类似 if (x == 0) &#123; x = ++cnt;//新建一个点 node[x].v = y, node[x].s = node[x].size = node[x].num = 1, node[x].ch[0] = node[x].ch[1] = 0; return; &#125; if (node[x].v == y)node[x].s++;//直接更新 else if (node[x].v &lt; y)insert(node[x].ch[1], y); else insert(node[x].ch[0], y); update(x);//更新信息 if (check(x))rebuild(x);//重建&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除函数：12345678void del(int &amp;x, int y) &#123;//也是引用 if (x == 0)return; if (node[x].v &lt; y) del(node[x].ch[1], y); else if (node[x].v &gt; y)del(node[x].ch[0], y); else node[x].s--;//不需要检验s&gt;1，s=0就意味着这个点无效 update(x);//更新 if (check(x))rebuild(x);//重建&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找排名和根据排名找元素与Splay和Treap都相同，但是求前驱后继的方法有所不同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于无效结点的存在，无法判定前驱后继究竟在左子树上还是右子树上（以往是确定的，但替罪羊树上可能某一侧全部是无效结点），这就造成了麻烦。在替罪羊树中，可以用下面的思路求前驱和后继： 求x的前驱：插入x，找到x的排名p，删掉x，找到排名p-1的值即为前驱。 求x的后继：插入x+1，找到x+1的排名p，删掉x+1，找到排名p的值即为后继。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个算法很容易理解，代码如下：12345678910111213int preNum(int x) &#123; insert(root, x); int p = findRank(x); del(root, x); return findNum(p - 1);&#125;int nextNum(int x) &#123; insert(root, x + 1); int p = findRank(x + 1); del(root, x + 1); return findNum(p);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下附模板题AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;const double alpha = 0.75;struct Node &#123; int size, ch[2], v, s, num;&#125; node[500005];int root = 0, cnt = 0, ct = 0, temp[100005];void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s; node[x].size = node[node[x].ch[0]].size + node[node[x].ch[1]].size + (node[x].s &gt; 0);&#125;bool check(int x) &#123; return node[node[x].ch[0]].size &gt; node[x].size * alpha || node[node[x].ch[1]].size &gt; node[x].size * alpha;&#125;void serach(int x) &#123; if (x == 0)return; serach(node[x].ch[0]); if (node[x].s &gt; 0)temp[++ct] = x; serach(node[x].ch[1]);&#125;void solve(int &amp;x, int l, int r) &#123; if (r &lt; l) &#123; x = 0; return; &#125; int mid = (l + r) / 2; x = temp[mid]; solve(node[x].ch[0], l, mid - 1); solve(node[x].ch[1], mid + 1, r); update(x);&#125;void rebuild(int &amp;x) &#123; ct = 0, serach(x); solve(x, 1, ct);&#125;void insert(int &amp;x, int y) &#123; if (x == 0) &#123; x = ++cnt; node[x].v = y, node[x].s = node[x].size = node[x].num = 1, node[x].ch[0] = node[x].ch[1] = 0; return; &#125; if (node[x].v == y)node[x].s++; else if (node[x].v &lt; y)insert(node[x].ch[1], y); else insert(node[x].ch[0], y); update(x); if (check(x))rebuild(x);&#125;void del(int &amp;x, int y) &#123; if (x == 0)return; if (node[x].v &lt; y) del(node[x].ch[1], y); else if (node[x].v &gt; y)del(node[x].ch[0], y); else node[x].s--; update(x); if (check(x))rebuild(x);&#125;inline int findNum(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[node[cur].ch[0]].num &gt;= x)nxt = node[cur].ch[0]; else if (x &gt; node[node[cur].ch[0]].num &amp;&amp; x &lt;= node[node[cur].ch[0]].num + node[cur].s) &#123; return cur; &#125; else nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + node[cur].s; if (nxt != 0)cur = nxt; else break; &#125; return -1;&#125;inline int findRank(int x) &#123; int cur = root, nxt = 0, ans = 0; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1], ans += node[cur].num - node[nxt].num; else if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; return ans + 1;&#125;inline int preNum(int x) &#123; insert(root, x); int p = findRank(x); del(root, x); return findNum(p - 1);&#125;inline int nextNum(int x) &#123; insert(root, x + 1); int p = findRank(x + 1); del(root, x + 1); return findNum(p);&#125;int main() &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int opt, x; cin &gt;&gt; opt &gt;&gt; x; if (opt == 1)insert(root, x); else if (opt == 2)del(root, x); else if (opt == 3)cout &lt;&lt; findRank(x) &lt;&lt; endl; else if (opt == 4)cout &lt;&lt; node[findNum(x)].v &lt;&lt; endl; else if (opt == 5)cout &lt;&lt; node[preNum(x)].v &lt;&lt; endl; else cout &lt;&lt; node[nextNum(x)].v &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FHQ Treap]]></title>
    <url>%2F2019%2F03%2F03%2FFHQTreap%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍fhq Treap的相关内容，是Treap（树堆）的延伸。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外本文仅涉及普通平衡树和文艺平衡树的内容，暂不涉及可持久化平衡树，关于可持久化会有单独的文章（以后更新）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fhq Treap是非旋的树堆，具有易实现，功能强大的优点，支持可持久化和文艺平衡树操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fhq Treap中允许有相同权值的两个结点，因此每个结点不再有标记数量的s，也可以理解成每个结点的s一定为1。此时BST可以定义为左子树结点的值都不大于该结点，右子树都不小于该结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇文章中提到了Treap（树堆）的原理：利用优先级的随机性来保持树结构的随机性。fhq Treap是非旋的树堆，它自然没有旋转操作，而有另外的两个核心操作：分离（split）和合并（merge）。 分离操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分离是指将一个treap分成两个treap，常用的分离标准有两种：按值分离和按数量分离。 按值分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按值分离常常用于普通平衡树（普通平衡树就是上一篇文章提到的那些操作）。给定一个值val，需要将treap分离成两个，其中一个树中所有点权值都不大于val（称树a），另一个全都大于val（称树b）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如现在需要分离以rt结点为根的treap，分离后的treap的根是a和b（a和b一开始是未赋值的）。如果rt的权值不大于val，说明rt结点应该在树a中，容易知道rt结点的左子树也应该在树a中，那么不妨将rt作为树a的根结点。此时rt结点及其左子树已经得到了“归属”，下面的问题就是求树b的根，求树a的右子树，于是继续分离rt结点的右子树，这是一个递归过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是就可以得到下面的分离代码：123456789void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123;//不需分离时，a和b都是空树 a = b = 0; return; &#125; if (node[rt].v &lt;= v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是分离的函数实现，注意最后需要更新rt的num。split函数巧妙地利用了引用使得代码十分优雅。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出分离过程不会破坏BST的性质和堆的性质。 按数量分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定数量v，将treap中前v小的数分离到树a中，其余分离到树b中，这就是按数量分离。为什么还要学按数量分离呢？因为这是文艺平衡树的关键实现原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和按值分离原理类似。假设现在需要分离以rt为根的treap，如果rt左子树的结点数量（由于s为1，故结点数量就是数的数量）小于v，那么易知rt结点及其左子树都应该分到树a中，然后进行递归分离。如果左子树结点数量不小于v，那么rt结点及其右子树应该分到树b中。123456789void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; if (node[node[rt].ch[0]].num &lt; v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v - node[node[rt].ch[0]].num - 1); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一处需要注意：在分离右子树时，v需要进行更新。 合并操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;合并操作就是将树a和树b合并为一个treap，合并操作有一个前提：树a中的所有值不能大于树b中的值。无论采用按值分离方法还是按数量分离方法都是满足这个条件的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于树b上的数一定不小于树a，那么也不小于树a的根结点，那么合并a和b的问题就是把b合并到a的右子树上。当然也可以选择把a合并到b的左子树上，这于是就是一个递归问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择任何一个都可以吗？显然不是，因为还要满足堆的性质。两棵树都是满足堆的性质的，此时如果树a的根节点优先级更高，则应合并a的右子树和b，否则合并b的左子树和a。123456789void merge(int &amp;rt, int a, int b) &#123;//rt是合并后的树根 if (a == 0 || b == 0) &#123;//其中任何一个为0直接赋值即可 rt = a + b;//赋值不为0的那一个，这是一处巧妙的写法 return; &#125; if (node[a].key &gt; node[b].key)rt = a, merge(node[rt].ch[1], node[a].ch[1], b); else rt = b, merge(node[rt].ch[0], a, node[b].ch[0]); update(rt);&#125; 插入元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了split和merge就可以很容易地实现插入、删除操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要插入值为val的点，需要先新建一个值为val的点，假设新结点编号为p。在原treap上按val的值进行分离，分离成不大于val的treap和大于val的treap，然后合并树a和p，再合并树a和树b即可。1234567891011int addNode(int x) &#123;//分配新结点编号 node[++cnt].v = x, node[cnt].ch[0] = node[cnt].ch[1] = 0; node[cnt].num = 1, node[cnt].key = rand(); return cnt;&#125;void insert(int x) &#123;//插入元素 int p = addNode(x), a, b; split(root, a, b, x); merge(a, a, p); merge(root, a, b);&#125; 删除元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将原treap按val值分离成树a和树b，再将树a按值val-1分离成树c和树d。这样树d就是由全体val值结点组成的，合并树d的左子树和右子树（相当于删除根结点），再与树c和树b合并即可。12345678void delNum(int x) &#123; int a, b, c;//这里没有建变量d，为了重用变量 split(root, a, b, x);//分离root产生树a和树b split(a, a, c, x - 1);//分离a产生a和c（重用变量a） merge(c, node[c].ch[0], node[c].ch[1]);//合并c的左右子树到c中 merge(a, a, c);//将c合并到a中 merge(root, a, b);//将a、b合并到root中&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后的操作（如查找前驱后继等等）与普通treap相比没有变化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍fhq Treap的另一个功能：文艺平衡树。有洛谷模板题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓文艺平衡树就是实现这样一个功能：给定一个区间，不断翻转其中的某一段子区间，求最后的区间序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们需要翻转[l,r]区间时，首先按数量分离原有treap，分离成[1,l-1]、[l,r]、[r+1,n]三段区间，然后给[l,r]打上翻转标记，再将它们合并。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;翻转标记如同线段树中的lazy标记，表示以这个点为根的树需要翻转，该标记仅有0和1两种取值。它同时也有down函数来完成下压标记操作：123456inline void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]);//交换左右子树 node[node[x].ch[0]].lazy ^= 1;//打上标记 node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;//清空标记&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样我们的split和merge函数也应该带上下压操作：12345678910111213141516171819202122232425void split(int rt, int &amp;a, int &amp;b, int v) &#123; if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].lazy)down(rt);//下压标记 if (node[node[rt].ch[0]].num &lt; v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v - node[node[rt].ch[0]].num - 1); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (node[a].key &gt; node[b].key) &#123; if (node[a].lazy)down(a);//下压标记 rt = a, merge(node[a].ch[1], node[a].ch[1], b); &#125; else &#123; if (node[b].lazy)down(b);//下压标记 rt = b, merge(node[b].ch[0], a, node[b].ch[0]); &#125; update(rt);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了：交换左右子树难道不会违反BST性质？答案是肯定会违反的，但我们应该从一个更高的高度去理解BST。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BST左子树权值不大于该结点实质上是左子树结点的权重不大于该结点，权值不一定代表权重。因此翻转左右子树实质上就是认为左右结点的权重发生了调换。我们的merge函数和按数量分离的split函数不会改变原有的权重关系，而不是权值关系，因此翻转后再进行split或者merge等操作并不会影响翻转的结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但容易看出，按值分离函数是按照权值关系进行的，所以在文艺平衡树进行中不能有按值分离操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出最后的结果相当容易，只需一次中序遍历即可，记得下压标记：1234567void print(int x) &#123; if (!x)return; if (node[x].lazy)down(x); print(node[x].ch[0]); cout &lt;&lt; node[x].v &lt;&lt; " "; print(node[x].ch[1]);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩展：洛谷模板题中原有的序列是1~n，这个序列很特殊以至于我们可以先插入这几个元素再按文艺平衡树进行操作。但是如果原有序列是随机的呢？由于插入操作需要按值分离split函数，这个函数基于权值关系，插入后原有序列关系就被打乱了。洛谷模板题之所以可以直接插入是因为权值正好就是权重。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种方法是构造1~n到原有序列的映射，再将1~n插入treap中，进行区间操作，输出时映射回来即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下附洛谷模板题AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; int ch[2], v, num, key, lazy; Node() : num(0) &#123; lazy = ch[0] = ch[1] = 0; &#125;&#125; node[100005];int root = 0, cnt = 0;inline void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + 1;&#125;inline int addNode(int x) &#123; node[++cnt].v = x, node[cnt].ch[0] = node[cnt].ch[1] = 0; node[cnt].num = 1, node[cnt].key = rand(); return cnt;&#125;inline void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].lazy ^= 1; node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;&#125;void split(int rt, int &amp;a, int &amp;b, int v) &#123;//按数量分离 if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].lazy)down(rt); if (node[node[rt].ch[0]].num &lt; v)a = rt, split(node[rt].ch[1], node[a].ch[1], b, v - node[node[rt].ch[0]].num - 1); else b = rt, split(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125;void merge(int &amp;rt, int a, int b) &#123; if (a == 0 || b == 0) &#123; rt = a + b; return; &#125; if (node[a].key &gt; node[b].key) &#123; if (node[a].lazy)down(a); rt = a, merge(node[a].ch[1], node[a].ch[1], b); &#125; else &#123; if (node[b].lazy)down(b); rt = b, merge(node[b].ch[0], a, node[b].ch[0]); &#125; update(rt);&#125;void solve(int l, int r) &#123;//翻转函数 int a, b, c; split(root, a, b, l - 1); split(b, b, c, r - l + 1); node[b].lazy ^= 1; merge(a, a, b), merge(root, a, c);&#125;void split2(int rt, int &amp;a, int &amp;b, int v) &#123;//按值分离 if (rt == 0) &#123; a = b = 0; return; &#125; if (node[rt].v &lt;= v)a = rt, split2(node[rt].ch[1], node[a].ch[1], b, v); else b = rt, split2(node[rt].ch[0], a, node[b].ch[0], v); update(rt);&#125;inline void insert(int x) &#123;//插入 int p = addNode(x), a, b; split2(root, a, b, x); merge(a, a, p); merge(root, a, b);&#125;void print(int x) &#123;//输出 if (!x)return; if (node[x].lazy)down(x); print(node[x].ch[0]); cout &lt;&lt; node[x].v &lt;&lt; " "; print(node[x].ch[1]);&#125;int main() &#123; ios::sync_with_stdio(false); srand(static_cast&lt;unsigned int&gt;(time(nullptr))); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)insert(i);//把1~n插入到treap中 for (int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; solve(x, y); &#125; print(root); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>文艺平衡树</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Treap（树堆）]]></title>
    <url>%2F2019%2F03%2F03%2FTreap%EF%BC%88%E6%A0%91%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文是Splay（伸展树）的后续。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍Splay时，已经提及了BST的概念。BST在最坏情况下会达到$O(n)$复杂度，于是有各种使其平衡的方法，Treap就是一种，它也属于平衡树，比Splay要更易实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splay是通过伸展操作来使树的结构随机化，以达到均摊$O(logn)$的复杂度。Treap是通过在维护BST时同时维护堆来实现结构的随机化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓Treap就是Tree+Heap，故称树堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看看Treap的结点结构体定义，和Splay类似：1234567struct Node &#123; int v&#123;&#125;, key&#123;&#125;, ch[2]&#123;&#125;, s, num; Node() : num(0), s(0) &#123; ch[0] = ch[1] = 0; &#125;&#125; node[100005]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没记录父结点？是的，在Treap中不需要记录父结点信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外还可以发现多了一个key，key记录这个结点的优先级。刚才已经提到，Treap是树与堆的结合（这里的堆不再是完全二叉树，只要有堆的性质即可），所谓堆的性质就是：所有结点的优先级不得小于其子结点优先级。这当然是大根堆，用小根堆也是可以的，本文中使用大根堆。我们在维护BST的同时还要满足堆的要求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key应该如何赋值？在插入一个新结点时，会给它分配一个随机的优先值，这个可以通过rand()函数来实现。从这里就可以看出Treap的原理：通过优先级的随机性来保持树结构的随机性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的函数，若无特殊说明，函数都采用与Splay中相同的命名。 旋转操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap中同样有旋转操作。当某结点不满足堆的性质时（比如它的优先级大于父结点），就需要进行一次旋转，将其旋转到父结点的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap中只有左旋和右旋，没有Splay中双旋的概念。1234void rotate(int &amp;x, int w) &#123; int c1 = node[x].ch[w], c2 = node[c1].ch[w ^ 1]; node[x].ch[w] = c2, node[c1].ch[w ^ 1] = x, node[c1].num = node[x].num, update(x), x = c1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面就是旋转函数的定义，它的作用是将编号为x的结点旋转下去，方向为w（1为左旋），这和splay中的旋转上去有所不同。但事实上将子结点旋转上去就是把父结点旋转下来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一些值得注意的细节。一处是node[c1].num = node[x].num，这其实就是update(c1)的简略写法。另外还有x=c1，这里巧妙地使用引用来实现我们在Splay中旋转的第三步。 插入操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap中的插入是基于递归的，代码如下：1234567891011121314151617void insert(int &amp;x, int v) &#123; if (!x) &#123;//空结点，新建结点 x = cnt++; node[x].v = v, node[x].s = 1, node[x].num = 1, node[x].key = rand(); node[x].ch[0] = node[x].ch[1] = 0; return; &#125; node[x].num++;//路过的结点都要更新num if (node[x].v == v)node[x].s++;//找到直接更新s else if (node[x].v &lt; v) &#123;//找右树 insert(node[x].ch[1], v); if (node[node[x].ch[1]].key &gt; node[x].key)rotate(x, 1);//旋转，维护堆的性质 &#125; else &#123;//找左树 insert(node[x].ch[0], v); if (node[node[x].ch[0]].key &gt; node[x].key)rotate(x, 0); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的作用是在以结点x为根的子树上插入值为v的结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当x为0时，说明这里是一个空结点，此时新建结点，更新信息，分配优先级。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，所有经过的结点都需要更新num。其次在递归回溯后需要检查堆的性质是否满足，如果不满足就需要旋转来调整。从这里可以看出引用的技巧性。 删除操作1234567891011121314void del(int &amp;x, int v) &#123; if (!x)return;//空结点无需继续 if (node[x].v == v) &#123;//找到该结点 if (node[x].s &gt; 1) node[x].num--, node[x].s--;//直接更新值 else &#123;//需要删除结点 if (!node[x].ch[0] &amp;&amp; !node[x].ch[1])x = 0;//没有儿子，直接赋值0 else if (!node[x].ch[0])x = node[x].ch[1];//有右儿子，将右儿子移过来 else if (!node[x].ch[1])x = node[x].ch[0];//有左儿子，将左儿子移过来 else if (node[node[x].ch[0]].key &lt; node[node[x].ch[1]].key)rotate(x, 1), del(x, v);//将优先级大的旋转上去，递归 else rotate(x, 0), del(x, v); &#125; &#125; else if (node[x].v &gt; v)node[x].num--, del(node[x].ch[0], v);//找左树 else node[x].num--, del(node[x].ch[1], v);//找右树&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treap的删除操作基于分类讨论，有这几种情况（只考虑完全删除的情况，s自减一不考虑）： 若该结点没有儿子，直接删除 若结点仅有右儿子，则左儿子代替其位置。仅有左儿子同理。 若结点有两个儿子，则将优先级大的一个旋转到该结点位置，再递归进行删除。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的一个易错点是每一个经过的结点需要更新num，但是上面的分类讨论中不需要更新，因为上面的分类讨论过程只是更改了一下树的结构。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其余的操作与Splay完全相同。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay（伸展树）]]></title>
    <url>%2F2019%2F03%2F02%2FSplay%EF%BC%88%E4%BC%B8%E5%B1%95%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍Splay树的用法与实现。 二叉排序树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splay本质上是平衡二叉排序树（Binary Sort Tree，BST），是平衡树的一种。因此在了解Splay前必须先了解二叉排序树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉排序树是指满足以下性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于根结点。 若右子树不空，则右子树上所有结点的值均大于根结点。 左右子树也是BST。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出了一个BST的例子：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BST中不允许有相同的数，因此每一个结点都有自己的计数变量（在本文中用s表示）来记录这个数的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，BST的左右子树性质不同，因此不能向往常一样把树当图来存，必须基于一定储存结构。这里用结构体来定义树的每一个结点：1234567struct Node &#123; int v, ch[2], s, num, f; Node() : s(0), num(0) &#123; ch[0] = ch[1] = 0; &#125;&#125; node[500005]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v表示该结点表示的数，ch[0]和ch[1]是左右子树根结点编号，s是数的重数，num是该树所有数的总数量（计入重数），f是其父结点编号。然后开一个数组储存这些结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了，BST有什么用呢？如果我们需要不断加入删除数据，不断地询问某个数的排序序号，查找某个数的前驱或者后继等操作，普通的顺序表效率过低，而链表查找效率硬伤，此时我们就需要BST来完成这些工作。平衡的BST可以在$O(logn)$复杂度下完成这些操作，这是容易理解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但如果不平衡呢？当二叉排序树退化成一条链时，各种操作都会退化成$O(n)$复杂度，这是我们不希望看到的，于是就有了各种使BST平衡的方法，Splay就是其中之一。 旋转操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;旋转操作是Splay中很重要的操作。旋转的意思就是：将某个结点移动到其父结点的位置，保持BST性质不变。旋转只是树的结构变形，没有实质性改变。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当目标结点是其父结点的左儿子时，需要右旋（称为Zig操作），若为右儿子，需要左旋（称为Zag操作）。下面以右旋为例探讨旋转规律。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们想把值为2的结点移动到其父结点位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现4比5小，5应该接管以值为4的结点为根的子树，于是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5比3大，将值为5的结点移动下来作值为3的结点的左儿子（父结点变儿子结点）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后以3为值的结点替代原父结点位置：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;旋转完成，这就是一次zig操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论左旋还是右旋，都可以发现旋转分为三步。 父结点接管目标结点反边上的子树。（接管反边是指：若目标结点为左儿子，则接管右子树，右儿子反之）。 父结点作目标结点反边上的子树。 目标结点代替父结点位置（父结点是爷爷结点的什么儿子，目标结点就作什么儿子）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在就来编写实现旋转操作的函数，在这之前先写一个重建父子关系的函数：123void change(int father, int son, int w) &#123; node[father].ch[w] = son, node[son].f = father;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change函数的作用就是让son编号去作father编号结点的w儿子（0为左，1为右）。然后还需要一个判别父子关系的函数：1234int identify(int x) &#123; int f = node[x].f; return node[f].ch[0] == x ? 0 : 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数用来判断编号为x的结点是其父结点的什么儿子。最后需要一个update函数：123void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是更新一下编号为x的结点的num值。由于旋转后结点间关系发生改变，因此需要更新num。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以写出旋转函数：123456void rotate(int x) &#123; if (x == root)return; int f = node[x].f, g = node[f].f, i = identify(x), j = identify(f); change(f, node[x].ch[i ^ 1], i), change(x, f, i ^ 1), change(g, x, j); update(f), update(x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根结点不能旋转。根据三个步骤重建父子关系，然后更新目标结点和父结点的num。这里用i^1来取反边，这是一个技巧，在网络流中也用到了这个技巧。 伸展操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伸展树之所以叫伸展树就是因为伸展。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓伸展，就是将某个结点（本文中称为at）通过一系列旋转移动到另一个结点（称为to）下方（也就是儿子）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果to本身就在at的下方怎么办？在常规的splay操作中不会碰到这种情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要认识到一个问题：如果需要移动到根结点位置怎么办？根结点不是任何结点的儿子，其实从上面的叙述中的确无法做到，因此有个东西叫虚拟根结点，它是根结点的父结点。在本文中，虚拟根结点编号为0，根结点作其右儿子。这样就可以通过移动到虚拟根结点下面来移动到根结点位置了。在后文中可以看到引入虚拟根结点的很多好处。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当at的父结点正好就是to时无需伸展。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若at的爷爷结点正好是to时，一步旋转（zig或zag）就可以做到伸展效果。问题就是其余情况怎么处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当at的子结点性质和其父结点不同时（不同是指at是左儿子而父结点是右儿子或者反之）可以通过两次旋转（zig-zag或者zag-zig）at结点来将其旋转到爷爷结点的位置。这称为之字形旋转。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当at的子结点性质与其父结点相同时，同样两次旋转（zig-zig或者zag-zag）at结点来将其旋转到爷爷结点的位置。这称为一字形旋转。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但实际情况中可以发现，对于一字形旋转，树的结构并没有得到很好的改善。通常我们这样处理一子形旋转的情况：先旋转父结点再旋转at结点。这种用先旋转父结点再旋转子结点来代替旋转两次子结点的操作称为双旋，普通的一子形方法就称为单旋。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以写出伸展操作的函数了：1234567891011void splay(int at, int to = 0) &#123;//to默认为0表示默认移动到根结点 while (node[at].f != to) &#123; int f = node[at].f, g = node[f].f; if (g != to) &#123; if (identify(at) == identify(f))rotate(f);//双旋操作 else rotate(at); &#125; rotate(at); &#125; if (to == 0)root = at;//不要忘记修改根结点&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伸展有什么用呢？可以理解成保持树结构的随机性，也就是在一种平均意义上保持树的平衡。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伸展的另一个作用是更新经过结点的num值，这是旋转时所做的。 插入元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个不用多说，直接看代码就可以：12345678910111213141516void insert(int x) &#123; if (root == 0)change(0, cnt, 1), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, root = cnt++;//无根要建根 else &#123; int cur = root, nxt = 0; while (true) &#123; if (x &gt; node[cur].v)nxt = node[cur].ch[1]; else if (x &lt; node[cur].v)nxt = node[cur].ch[0]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x)node[cur].s++, splay(cur);//已经有了，s直接加一 else if (node[cur].v &gt; x)change(cur, cnt, 0), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); else change(cur, cnt, 1), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt是当出现新结点时的编号计数器，这样每有一个新的点加入都会分配一个新编号。这样导致的一个问题是不能重用空间，但是对于大多数情况空间都是够用的。如果希望重用空间可以选择每次重建根（为什么会多次重建根？因为可能会删元素啊）时重新从1编号，但是这样做一定要记得将已经被删除的结点完全清空（比如子结点编号设成0等等）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次插入元素后都要把已经插入的元素对应结点伸展到根结点以保持结构随机性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么没有看到更新num？伸展的时候顺便更新了，上文已经提到。 查找某数的编号123456789101112131415int find(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x) &#123; splay(cur); return cur; &#125; return -1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易理解，没有返回-1，最后将该结点伸展到根结点。 查找排名为k的数（第k小）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第k小就是指计入重数后的排序为k的数，直接看代码吧：12345678910111213int findNum(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[node[cur].ch[0]].num &gt;= x)nxt = node[cur].ch[0];//找左树 else if (x &gt; node[node[cur].ch[0]].num &amp;&amp; x &lt;= node[node[cur].ch[0]].num + node[cur].s) &#123; splay(cur); return cur; &#125; else nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + node[cur].s;//找右树 if (nxt != 0)cur = nxt; else break; &#125; return -1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数返回的是结点编号，如果没有返回-1。要把最后的结点伸展到根结点。 查询某元素排名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于相同的元素，这里的排名是指最小的排名。123456789101112131415int findRank(int x) &#123; int cur = root, nxt = 0, ans = 0; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1], ans += node[cur].num - node[nxt].num; else if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; splay(cur); return ans + 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码是容易理解的，最后仍然需要伸展。 查找前驱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前驱是指小于某个数中的最大的那一个。值得注意的是该数不一定是已经插入的元素，即使之前没有插入也是可以查找前驱的。12345678910111213int preNum(int x) &#123; int cur = root, nxt = 0, maxn = -0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x) &#123; nxt = node[cur].ch[1]; if (node[cur].v &gt; maxn)maxn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[0];//相等向小了找 if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样只返回编号，没有返回-1。 查找后继12345678910111213int nextNum(int x) &#123; int cur = root, nxt = 0, minn = 0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else if (node[cur].v &gt; x) &#123; nxt = node[cur].ch[0]; if (node[cur].v &lt; minn)minn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[1]; if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和前驱基本相同。 删除操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除是比较麻烦的一个，这里介绍两种实现方式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种：通过前驱和后继删除。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将前驱伸展到根结点然后将后继伸展到根结点（就是前驱）下方（作右儿子），那么待删除结点一定是后继的右儿子并且它没有任何子树。从这个结点上删除即可。如果其s&gt;1那么直接s减去一，否则删除该结点，最后进行一步伸展，还可以顺便更新一下num。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有前驱或后继怎么办？需要手动加入无穷小和无穷大两个数，这样所有数就都有前驱和后继了。12345678int delNum(int x) &#123; if (find(x) == -1)return 0;//没有该数就不能删除，如果保证存在该数，则该句可以忽略以提高效率 int pre = preNum(x), nxt = nextNum(x); splay(pre), splay(nxt, pre);//作伸展 if (node[node[nxt].ch[0]].s &gt; 1)node[node[nxt].ch[0]].s--, splay(node[nxt].ch[0]); else node[nxt].ch[0] = 0, splay(nxt); return 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种方法就是分类讨论。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将待删除结点伸展到根结点，然后分类讨论（只探讨完全删除结点的情况，s自减一的情况不探讨）： 根结点没有子树，直接删除，重置root=0。 根结点有右子树无左子树，将右子树根作为根。仅有左子树相似操作。 既有左子树又有右子树，按照方法一进行（因为这时候该数一定有前驱和后继）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上没有前驱和后继的情况仅有删除最小值最大值的时候才会出现，所以第二种方法常常会比第一种方法多一次splay，效率低一些。12345678910111213141516171819int delNum(int x) &#123; splay(find(x));//默认有该数 if (!node[root].ch[0] &amp;&amp; !node[root].ch[1]) &#123; if (node[root].s &gt; 1)node[root].s--; else root = 0, node[0].ch[1] = 0; &#125; else if (!node[root].ch[0]) &#123; if (node[root].s &gt; 1)node[root].s--; else change(0, node[root].ch[1], 1), root = node[root].ch[1]; &#125; else if (!node[root].ch[1]) &#123; if (node[root].s &gt; 1)node[root].s--; else change(0, node[root].ch[0], 1), root = node[root].ch[0]; &#125; else &#123; int pre = preNum(x), nxt = nextNum(x); splay(pre), splay(nxt, pre); if (node[node[nxt].ch[0]].s &gt; 1)node[node[nxt].ch[0]].s--, splay(node[nxt].ch[0]); else node[nxt].ch[0] = 0, splay(nxt); &#125; return 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推荐洛谷P3369模板题。AC代码就是上面的组合。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splay的操作函数尽量不要用递归写，因为splay操作的存在，递归时树的结构可能发生变化，极易出错。下面给出洛谷AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;iostream&gt;using namespace std;struct Node &#123; int v, ch[2], s, num, f; Node() : s(0), num(0) &#123; ch[0] = ch[1] = 0; &#125;&#125; node[100005];int root = 0, n, cnt;inline int identify(int x) &#123; int f = node[x].f; return node[f].ch[0] == x ? 0 : 1;&#125;inline void change(int t, int s, int w) &#123; node[t].ch[w] = s, node[s].f = t;&#125;inline void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + node[x].s;&#125;inline void rotate(int x) &#123; if (x == root)return; int f = node[x].f, g = node[f].f, i = identify(x), j = identify(f); change(f, node[x].ch[i ^ 1], i), change(x, f, i ^ 1), change(g, x, j); update(f), update(x);&#125;inline void splay(int at, int to = 0) &#123; while (node[at].f != to) &#123; int f = node[at].f, g = node[f].f; if (g != to) &#123; if (identify(at) == identify(f))rotate(f); else rotate(at); &#125; rotate(at); &#125; if (to == 0)root = at;&#125;inline int find(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x) &#123; splay(cur); return cur; &#125; return -1;&#125;inline int findRank(int x) &#123; int cur = root, nxt = 0, ans = 0; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1], ans += node[cur].num - node[nxt].num; else if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].num; break; &#125; if (nxt != 0)cur = nxt; else break; &#125; splay(cur); return ans + 1;&#125;inline int findNum(int x) &#123; int cur = root, nxt = 0; while (true) &#123; if (node[node[cur].ch[0]].num &gt;= x)nxt = node[cur].ch[0]; else if (x &gt; node[node[cur].ch[0]].num &amp;&amp; x &lt;= node[node[cur].ch[0]].num + node[cur].s) &#123; splay(cur); return cur; &#125; else nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + node[cur].s; if (nxt != 0)cur = nxt; else break; &#125; return -1;&#125;inline int preNum(int x) &#123; int cur = root, nxt = 0, maxn = -0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &gt; x)nxt = node[cur].ch[0]; else if (node[cur].v &lt; x) &#123; nxt = node[cur].ch[1]; if (node[cur].v &gt; maxn)maxn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[0]; if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125;inline int nextNum(int x) &#123; int cur = root, nxt = 0, minn = 0x7fffffff, ans = -1; while (true) &#123; if (node[cur].v &lt; x)nxt = node[cur].ch[1]; else if (node[cur].v &gt; x) &#123; nxt = node[cur].ch[0]; if (node[cur].v &lt; minn)minn = node[cur].v, ans = cur; &#125; else nxt = node[cur].ch[1]; if (nxt != 0)cur = nxt; else break; &#125; return ans;&#125;inline void insert(int x) &#123; if (root == 0)change(0, 1, 1), node[1].v = x, node[1].s = 1, node[1].num = 1, root = 1, cnt = 2; else &#123; int cur = root, nxt = 0; while (true) &#123; if (x &gt; node[cur].v)nxt = node[cur].ch[1]; else if (x &lt; node[cur].v)nxt = node[cur].ch[0]; else break; if (nxt != 0)cur = nxt; else break; &#125; if (node[cur].v == x)node[cur].s++, splay(cur); else if (node[cur].v &gt; x)change(cur, cnt, 0), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); else change(cur, cnt, 1), node[cnt].v = x, node[cnt].s = 1, node[cnt].num = 1, splay(cnt++); &#125;&#125;inline int delNum(int x) &#123; int pre = preNum(x), nxt = nextNum(x); splay(pre), splay(nxt, pre); if (node[node[nxt].ch[0]].s &gt; 1)node[node[nxt].ch[0]].s--, splay(node[nxt].ch[0]); else node[nxt].ch[0] = 0, splay(nxt); return 1;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; insert(-(1 &lt;&lt; 30)), insert(1 &lt;&lt; 30); for (int i = 1; i &lt;= n; i++) &#123; int opt, x; cin &gt;&gt; opt &gt;&gt; x; if (opt == 1)insert(x); else if (opt == 2)delNum(x); else if (opt == 3)cout &lt;&lt; findRank(x) - 1 &lt;&lt; endl; else if (opt == 4)cout &lt;&lt; node[findNum(x + 1)].v &lt;&lt; endl; else if (opt == 5)cout &lt;&lt; node[preNum(x)].v &lt;&lt; endl; else cout &lt;&lt; node[nextNum(x)].v &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新文艺平衡树的splay版本，建议先阅读这篇文章的后半部分，这里其实是它的扩展。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间，需要不断翻转其中某一段子区间，如何用Splay完成这项操作？以洛谷模板题为例。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以先将1~n加入splay，这样splay的中序遍历序列就是原序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加入无穷小点和无穷大点，保证所有值都有前驱和后继。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要翻转[l,r]时，找到排名为l和r+2的两个结点(为什么是l和r+2？不要忘记之前加入了无穷小点！)，这是区间的前驱和后继。将前驱splay到根结点，后继splay到根结点下方，然后后继的左子树就是目标区间，在其根结点上打上翻转标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;翻转标记表明这个树需要翻转，它自然有自己的下压函数：123456void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].lazy ^= 1; node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每当rotate或者通过排名找数时都需要下压标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个疑问：翻转子树难道不会破坏BST性质？从权值的角度讲当然会破坏，但是可以从更高的角度去理解。BST维护的是权重的大小关系，左树权重比右树小。在这里权重就意味着在区间中的位置，从这个角度看，BST的性质没有被破坏。寻找排名为k的数是一个基于权重的算法而非权值，因此这里需要通过排名来寻找结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果洛谷模板题的原始序列是随机的，问题就会更复杂一些。这是因为1~n序列很特殊，它的权值就是权重。我们可以通过一些基于权值的算法（比如insert）来构树，但是对于随机的序列，再用这种方法就不能保证原有的顺序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下附模板题AC代码，注意这里没有s变量，这是因为1~n一定不会重。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; int v, ch[2], f, lazy, num;&#125; node[100005];int cnt, n, m, root, p = 0;void update(int x) &#123; node[x].num = node[node[x].ch[0]].num + node[node[x].ch[1]].num + 1;&#125;void change(int x, int y, int w) &#123; node[x].ch[w] = y, node[y].f = x;&#125;inline int identify(int x) &#123; return node[node[x].f].ch[0] != x;&#125;inline void down(int x) &#123; swap(node[x].ch[0], node[x].ch[1]); node[node[x].ch[0]].lazy ^= 1; node[node[x].ch[1]].lazy ^= 1; node[x].lazy = 0;&#125;void rotate(int x) &#123; if (x == root)return; if (node[x].lazy)down(x); int f = node[x].f, g = node[f].f, w = identify(x), w1 = identify(f); change(f, node[x].ch[w ^ 1], w); change(x, f, w ^ 1); change(g, x, w1); update(x), update(f);&#125;void splay(int at, int to = 0) &#123; while (node[at].f != to) &#123; int f = node[at].f, g = node[f].f; if (g != to) &#123; if (identify(f) == identify(at))rotate(f); else rotate(at); &#125; rotate(at); &#125; if (to == 0)root = at;&#125;void insert(int x) &#123; cnt++, node[cnt].v = x, node[cnt].ch[0] = node[cnt].ch[1] = 0, node[cnt].lazy = 0, node[cnt].num = 1; if (root == 0) &#123; change(0, cnt, 1), root = cnt; return; &#125; int cur = root, nxt; while (true) &#123; if (node[cur].v &lt;= x)nxt = node[cur].ch[1]; else nxt = node[cur].ch[0]; if (nxt == 0)break; else cur = nxt; &#125; if (node[cur].v &lt;= x)change(cur, cnt, 1); else change(cur, cnt, 0); splay(cur);&#125;int findNum(int x) &#123; int cur = root, nxt; while (true) &#123; if (node[cur].lazy)down(cur); if (node[node[cur].ch[0]].num + 1 == x) &#123; splay(cur); return cur; &#125; else if (node[node[cur].ch[0]].num &lt; x)nxt = node[cur].ch[1], x -= node[node[cur].ch[0]].num + 1; else nxt = node[cur].ch[0]; if (nxt == 0)break; else cur = nxt; &#125; return -1;&#125;void print(int x) &#123; if (x == 0)return; if (node[x].lazy)down(x); print(node[x].ch[0]); if (p &gt;= 1 &amp;&amp; p &lt;= n)cout &lt;&lt; node[x].v &lt;&lt; " "; p++; print(node[x].ch[1]);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; insert(-0x7ffffff), insert(0x7ffffff); for (int i = 1; i &lt;= n; i++)insert(i); for (int i = 1; i &lt;= m; i++) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; l = findNum(l), r = findNum(r + 2); splay(l), splay(r, l); node[node[node[root].ch[1]].ch[0]].lazy ^= 1; &#125; print(root); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>平衡树</tag>
        <tag>文艺平衡树</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2634]聪聪可可]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%B4%9B%E8%B0%B7P2634-%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以即约分数形式输出这个概率（即“a/b”的形式，其中a和b必须互质。如果概率为1，输出“1/1”）。 输入输出样例Sample input 51 2 11 3 21 4 12 5 3 Sample output 13/25 说明【样例说明】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13组点对分别是(1,1) (2,2) (2,3) (2,5) (3,2) (3,3) (3,4) (3,5) (4,3) (4,4) (5,2) (5,3) (5,5)。【数据规模】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，n≤20000。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难度较低的省选题，考察点分治。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目实质上是求所有距离为3的倍数的点对数目，用点分治求即可，时间复杂度$O(nlog^2n)$。注意点分治时的距离都需要对3取模，这样直接根据距离为0即可判断合法的点对。另外每个点与自身形成的点对也是合法点对。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在操作中需要实现点分治的work函数，这里的work函数可以在线性时间内解决：统计距离为0、1、2的点的数目，再用排列组合来求点对数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出数量来，用欧几里得算法去一下最大公因数输出即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define N 20005using namespace std;struct Edge &#123; int to, next, v;&#125; edge[N * 2];int n, head[N], cnt = 1, vis[N] = &#123;0&#125;, size[N], f[N], minn, root, ans = 0, num[3];inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS(int x, int fa, int p) &#123; size[x] = 1, f[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS(edge[i].to, x, p), size[x] += size[edge[i].to], f[x] = max(f[x], size[edge[i].to]); &#125; f[x] = max(f[x], p - size[x]); if (f[x] &lt; minn)minn = f[x], root = x;&#125;void findRoot(int x, int s) &#123; minn = 0x7fffffff, DFS(x, 0, s);&#125;void DFS2(int x, int fa, int v) &#123; num[(v % 3 + 3) % 3]++; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS2(edge[i].to, x, v + edge[i].v); &#125;&#125;void work(int x, int f, int w) &#123; num[0] = num[1] = num[2] = 0, DFS2(x, 0, 0); if (f == 0)ans += num[0] * (num[0] - 1) / 2 * w + num[1] * num[2] * w; else if (f == 1)ans += num[0] * num[1] * w + num[2] * (num[2] - 1) / 2 * w; else ans += num[0] * num[2] * w + num[1] * (num[1] - 1) / 2 * w;&#125;void divide(int x) &#123; vis[x] = 1, work(x, 0, 1); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (!vis[edge[i].to]) &#123; work(edge[i].to, (6 - 2 * edge[i].v) % 3, -1); findRoot(edge[i].to, size[edge[i].to]); divide(root); &#125; &#125;&#125;int gcd(int x, int y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, (z % 3 + 3) % 3), add(y, x, (z % 3 + 3) % 3); &#125; findRoot(1, n), divide(root); int g = gcd(2 * ans + n, n * n); cout &lt;&lt; (2 * ans + n) / g &lt;&lt; "/" &lt;&lt; n * n / g; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题还有一个更优雅的做法，那就是用树型DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(x,y)表示在以x为根的子树上，经过x并且距离总和对3的模为y的点对路径总数（每一个点对都要求两点互异），那么有状态转移方程： dp(x,y)=\sum^s_{i=1} \{dp[c_i,(y-v(x,c_i))mod\ 3]+\delta_{y,v(x,c_i)}\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$c_1,\cdots ,c_s$是x结点的s个子结点，$v(x,c_i)$是两点连边的边权。$\delta_{i,j}$是克罗内克符号，它在i=j时为1，否则为0。克罗内克符号的作用就是计入父结点与子结点连边本身就成立的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树型DP也需要去重，去重方法与点分治类似。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define N 20005using namespace std;struct Edge &#123; int to, next, v;&#125; edge[N * 2];int n, head[N], cnt = 1, dp[N][3], ans = 0;inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;int gcd(int x, int y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;int DP(int x, int p, int fa) &#123; if (dp[x][p] != -1)return dp[x][p]; dp[x][p] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa)dp[x][p] += DP(edge[i].to, (p - edge[i].v + 3) % 3, x) + (edge[i].v == p ? 1 : 0); &#125; return dp[x][p];&#125;inline void solve(int x, int p, int fa) &#123;//用来去重的函数 if (p == 0)ans -= DP(x, 0, fa) * (DP(x, 0, fa) - 1) / 2 + DP(x, 1, fa) * DP(x, 2, fa) + DP(x, 0, fa); else if (p == 1)ans -= DP(x, 2, fa) * (DP(x, 2, fa) - 1) / 2 + DP(x, 0, fa) * DP(x, 1, fa) + DP(x, 1, fa); else ans -= DP(x, 1, fa) * (DP(x, 1, fa) - 1) / 2 + DP(x, 0, fa) * DP(x, 2, fa) + DP(x, 2, fa);&#125;void DFS(int x, int fa) &#123; ans += DP(x, 0, fa) * (DP(x, 0, fa) + 1) / 2 + DP(x, 1, fa) * DP(x, 2, fa); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa)solve(edge[i].to, (6 - 2 * edge[i].v) % 3, x), DFS(edge[i].to, x); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1, dp[i][0] = dp[i][1] = dp[i][2] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, (z % 3 + 3) % 3), add(y, x, (z % 3 + 3) % 3); &#125; DFS(1, 0); int g = gcd(2 * ans + n, n * n); cout &lt;&lt; (2 * ans + n) / g &lt;&lt; "/" &lt;&lt; n * n / g; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>动态规划</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治]]></title>
    <url>%2F2019%2F02%2F28%2F%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点分治是一类解决树上路径问题的算法，下面以判断树中是否存在长度为k的路径这一问题来介绍点分治算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是一棵树（边权未标出）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个路径，我们可以把它归结为两类：经过根节点和不经过根节点。对于不经过根节点的路径，总可以找到一个新的根节点使之经过根节点。比如图中EBF这一路径没有经过根节点A，但是它经过了子树的根节点B。因此所有路径都可以归结到第一种（也就是经过根节点），于是可以通过不同根结点来判别各种路径。这里体现了分治的思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面来看看点分治的操作： 确定树根&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们一开始得到的树通常是无根树，即使是有根树也可以发现答案与树根的选取无关。不妨选取一个点为根使得树尽量平衡，递归次数尽量少。这个点显然是树的重心。重心可以通过一遍DFS求出。关于树的重心见这篇文章。 从树根开始进行分治&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里就是点分治的核心了，先来看看代码模板：12345678910void divide(int x) &#123; work();//第一个work vis[x] = 1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to])continue; work();//第二个work findRoot(edge[i].to); divide(root); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该函数中x为现在树的树根编号。vis[x]=1标记该点已经被使用，下面遍历出边。当前函数处理的是经过点x的路径，所以对于出点（也就是子树的树根），我们需要对其进行递归处理（也就是处理经过子树树根的路径），发现这与原树是一个性质的问题，因此可以递归处理：先找重心（这里就相当于对子树重新选根构造）再递归。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样分治会不会重呢？也就是同一条路径被多次处理？答案当然是不会，因为我们的路径处理只是在以该点为根的子树上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个work函数做什么？这就是处理经过点x的路径的函数。此时可能会有疑问：按理说只需要开头有一个work函数处理就可以了，为什么还要对每一个子结点再work一次？后一个work函数并不是子树的递归处理，而是去重。work函数与问题的性质有关，需要自己设计。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来讨论本问题中如何处理work函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本问题中我们需要找有没有长度为k的路径。那么在work函数中先求出所有点（包括本身，路径长当然是0）到根节点x的路径长，然后如果两个互异点的路径长之和等于k，那么就可以判定存在长度为k的路径。求长度需要$O(n)$，互异点枚举需要$O(n^2)$。效率太低如何解决？先在$O(nlogn)$复杂度下对路径长进行排序，然后枚举每一个点进行二分，可以降低时间复杂度为$O(nlogn)$。当然还有更好的解决方法，那就是双指针扫描，时间复杂度$O(n)$，关于该技巧见本文末。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就完了吗？当然不会，还有前面提到的去重操作！注意到上面给出的图中，当处理点A时，若E到A的距离和F到A的距离之和是k，我们会认为这是一条合法的路径，但事实上它有重边，并不合法，因此需要将这条非法边去除。在第一个work函数中肯定无法知晓哪些点对是合法的，哪些是非法的，因此只能通过容斥原理来将非法边去除，这就是第二个work所做的事情。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何在第二个work中统计非法边个数呢？注意到非法点对一定在同一子树中，并且凡是来源于子树B的非法点对（x,y），它们都满足： dict[x]+dict[y]+2v(A,B)=k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(A,B)是A点与B点之间连边的权值。这样我们在B子树中找到距离和（这里的距离就是到B的距离了，需要重求）为k-2v(A,B)的点对数量，再在答案中减去就可以了。由于两个work拥有同样的功能（都是求符合条件的点对数），因此这两个work可以用一个函数去处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出洛谷P3806点分治模板题的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define N 10005using namespace std;struct Edge &#123; int to, next, v;&#125; edge[N * 2];int head[N], vis[N], cnt = 1, n, m, ans[105], a, b, c, root, minn, size[N], f[N], dict[N], cntDFS;int query[105];inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].v = z, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS1(int x, int fa, int num) &#123; size[x] = 1, f[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS1(edge[i].to, x, num), size[x] += size[edge[i].to], f[x] = max(f[x], size[edge[i].to]); &#125; f[x] = max(f[x], num - f[x]); if (f[x] &lt; minn)minn = f[x], root = x;&#125;inline void findRoot(int x, int num) &#123; minn = 0x7fffffff; DFS1(x, 0, num);&#125;void DFS2(int x, int fa, int v) &#123; dict[cntDFS++] = v; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to] || edge[i].to == fa)continue; DFS2(edge[i].to, x, v + edge[i].v); &#125;&#125;int find1(int l, int r, int p) &#123;//(,] if (l + 1 &gt; r)return -1; if (r == l + 1) &#123; if (dict[r] == p)return r; return -1; &#125; int mid = (l + r) &gt;&gt; 1; if (dict[mid] &gt;= p)return find1(l, mid, p); return find1(mid, r, p);&#125;int find2(int l, int r, int p) &#123;//[,) if (l + 1 &gt; r)return -1; if (r == l + 1) &#123; if (dict[l] == p)return l; return -1; &#125; int mid = (l + r) &gt;&gt; 1; if (dict[mid] &lt;= p)return find2(mid, r, p); return find2(l, mid, p);&#125;inline void work(int x, int p, int w) &#123; cntDFS = 1, DFS2(x, 0, 0), sort(dict + 1, dict + cntDFS); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt; cntDFS; j++) &#123; int l = find1(0, j - 1, query[i] - p - dict[j]), r = find2(1, j, query[i] - p - dict[j]); if (l != -1 &amp;&amp; r != -1)ans[i] += (r - l + 1) * w; &#125; &#125;&#125;void divide(int x) &#123; work(x, 0, 1), vis[x] = 1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to])continue; work(edge[i].to, 2 * edge[i].v, -1); findRoot(edge[i].to, size[edge[i].to]), divide(root); &#125;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++)a = read(), b = read(), c = read(), add(a, b, c), add(b, a, c); for (int i = 1; i &lt;= m; i++)query[i] = read(); findRoot(1, n), divide(root); for (int i = 1; i &lt;= m; i++) &#123; if (ans[i] &gt; 0)cout &lt;&lt; "AYE" &lt;&lt; endl; else cout &lt;&lt; "NAY" &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到了双指针扫描法，这其实是一种技巧。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一串数，如何找是否存在某个数对之和为k？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先排序然后枚举二分在$O(nlogn)$下解决当然可以，但我们也可以这样做：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先取两个指针l、r分别指向第一个元素和最后一个元素，然后判断： 若两个指针所指元素之和小于k，l++ 若两个指针所指元素之和大于k，r— 若两个指针所指元素之和等于k，找到答案 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法对于是否存在的问题是很高效的，但计数并不易做到。快速排序中也有双指针的应用。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的直径与重心]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E4%B8%8E%E9%87%8D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍树的直径与重心的性质与求法。 树的直径&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一棵树，该树中最远的两点间距离称为该树的直径。有两种求解方法： 两次搜索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任选一点开始搜索，找到最大距离的点s，再从s开始搜索，找到最大距离的点t。s和t间距离就是树的直径。这种方法只适用与边权非负的情况，证明略。 树型DP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp[x]表示从x开始，向以x为根的子树上前进可以得到的最大距离。有状态转移方程： dp[x]=\max\{dp[y]+v(x,y)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里y是x的子结点，v是边权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样并不能得出最终的结果，因为最长路有可能跨根结点，这时我们需要在DP过程中记录一下答案。注意到在更新dp[x]时（也就是在其下一个子结点之前），dp[x]已经记录了目前的最大长度，这时可以这样更新答案： ans=\max\{ans,dp[x]+dp[y]+v(x,y)\} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两种方法时间复杂度都是$O(n)$，但两次搜索版可以找到路径，DP版不易找。下面给出树型DP的示例代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;struct Edge &#123; int to, next, v;&#125; edge[20000];int head[10000], n, cnt = 1, dp[10000], ans = -1;inline void add(int x, int y, int z) &#123; edge[cnt].v = z, edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;int DP(int x, int fa) &#123; dp[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to == fa)continue;//防止向父结点回溯 ans = max(ans, dp[x] + DP(edge[i].to, x) + edge[i].v), dp[x] = max(dp[edge[i].to] + edge[i].v, dp[x]); &#125; return dp[x];&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z), add(y, x, z); &#125; DP(1, 0); cout &lt;&lt; ans &lt;&lt; endl;&#125; 树的重心&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是重心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一棵无根树，我们需要选一个点作为根节点将其转化为有根树。如果以某一个点为根可以使得其最大的子树结点数最小，那么这个点称为树的重心。重心可以有多个。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以重心为根可以得到尽可能平衡的有根树，下面是重心的其它性质： 树中所有点到某个点的距离和中，到重心的距离和是最小的。有两个重心时，它们的距离和一样。 把两个树通过一条边相连得到一个新的树，新的树的重心在连接原来两个树的重心的路径上。 把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求重心呢？先随便选一点为根，然后用一遍DFS来在$O(n)$复杂度下求出每一个点的子树结点树和最大子树结点树，更新答案即可。下面用size记录子树结点数，f记录最大结点数。12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;struct Edge &#123; int to, next;&#125; edge[20000];int head[10000], n, cnt = 1, size[10000], f[10000], ans = -1, minn = 0x7fffffff;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS(int x, int fa) &#123; size[x] = 1, f[x] = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to == fa)continue; DFS(edge[i].to, x), size[x] += size[edge[i].to], f[x] = max(f[x], size[edge[i].to]); &#125; f[x] = max(f[x], n - size[x]);//注意！！还要考虑上面的树 if (f[x] &lt; minn)minn = f[x], ans = x;//更新答案，这里只求一个重心&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y), add(y, x); &#125; DFS(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zkw线段树]]></title>
    <url>%2F2019%2F02%2F24%2Fzkw%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：本文不会专门探讨zkw线段树，关于该数据结构见这篇文章。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zkw线段树是不基于递归的线段树，效率在树状数组和递归线段树之间。下面给出可以AC洛谷模板题的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#define N 100005using namespace std;long long tree[N &lt;&lt; 2] = &#123;0&#125;, add[N &lt;&lt; 2] = &#123;0&#125;;int n, m, bit;inline long long read() &#123; char e = getchar(); long long s = 0, k = 0; while ((e &lt; '0' || e &gt; '9') &amp;&amp; e != '-')e = getchar(); if (e == '-')k = 1, e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return k ? -s : s;&#125;inline void build(int x) &#123; for (bit = 1; bit &lt;= x + 1; bit &lt;&lt;= 1); for (int i = bit + 1; i &lt;= bit + x; i++)tree[i] = read(); for (int i = bit - 1; i; i--)tree[i] = tree[i &lt;&lt; 1] + tree[i &lt;&lt; 1 | 1];&#125;inline void modify(int x, long long k) &#123; for (int i = bit + x; i; i &gt;&gt;= 1)tree[i] += k;&#125;inline void modify(int l, int r, long long k) &#123; if (l == r) &#123; modify(l, k); return; &#125; int lNum = 0, rNum = 0, num = 1, s, t; for (s = bit + l - 1, t = bit + r + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1, num &lt;&lt;= 1) &#123; tree[s] += k * lNum, tree[t] += k * rNum; if (~s &amp; 1)add[s ^ 1] += k, tree[s ^ 1] += k * num, lNum += num; if (t &amp; 1)add[t ^ 1] += k, tree[t ^ 1] += k * num, rNum += num; &#125; for (; s; s &gt;&gt;= 1, t &gt;&gt;= 1)tree[s] += lNum * k, tree[t] += rNum * k;&#125;inline long long query(int l, int r) &#123; long long ans = 0; int lNum = 0, rNum = 0, num = 1, s, t; for (s = bit + l - 1, t = bit + r + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1, num &lt;&lt;= 1) &#123; if (add[s])ans += add[s] * lNum; if (add[t])ans += add[t] * rNum; if (~s &amp; 1)ans += tree[s ^ 1], lNum += num; if (t &amp; 1)ans += tree[t ^ 1], rNum += num; &#125; for (; s; s &gt;&gt;= 1, t &gt;&gt;= 1)ans += add[s] * lNum, ans += add[t] * rNum; return ans;&#125;int main() &#123; n = read(), m = read(); build(n); for (int i = 1; i &lt;= m; i++) &#123; long long a, b, c; if (read() == 1)a = read(), b = read(), c = read(), modify(a, b, c); else a = read(), b = read(), cout &lt;&lt; query(a, b) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HLPP算法]]></title>
    <url>%2F2019%2F02%2F24%2FHLPP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍一种求网络流最大流的高效算法：最高标号预流推进算法(HLPP)。这篇文章是网络流的延伸。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法并不是基于增广路的，它的思想是不断进行推流直到除了源点汇点外的点流量平衡，要了解这个算法需要先理解以下几个概念： 额外流：这个点得到但未流出的总流量，存在额外流说明该点没有达到流量平衡。 高度标号：HLPP算法采用的也是分层图思想。它要求结点只能将流推向比它高度小一的结点。这个要求的引入是因为不加限制可能会出现两个点轮番推流最后死循环的局面。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法中允许结点流量不平衡，即流入多于流出，这样的结点称为活动结点。算法中不断将结点中多余的流量推给其余的结点，将活动结点变成非活动结点。如果某个结点无法通过推流变成非活动结点，我们就需要更换其高度标号，这一步称为重贴标签。当所有非汇点源点均为非活动结点时算法结束，得到的就是最大流。普通预留推进算法用队列进行这个过程，但如果将队列换为优先队列（每次取高度最大的结点），就得到效率更高的最高标号预流推进算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是HLPP算法步骤，HLPP算法同样在残量网络上进行。 用BFS算法从汇点开始进行标号（从0开始），这一步与ISAP算法基本相同。 将源点高度标记成n（n为结点数量）。 遍历源点每一条出边，将这些边的容量尽可能地利用，进行最大程度的推流，更新源点与出点的额外流，将其中额外流不为0并且不是源点汇点的结点入队。 不断取优先队列首元素并进行如下操作：遍历所有出边，对出边权值非0并且高度恰好减一的出点进行推流，推流量不得大于边权和额外流，更新两点的额外流和边权，新结点（不为源点汇点时）入队；当遍历完所有出边后若额外流仍存在，进行重新标号：遍历所有边权非0的出边，找到最小出点高度，该点高度更新成最小高度加一，重新入队。 队列为空时结束算法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是几点理解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们第3步进行了源点最大程度的推流，易知最大流不可能多于这些流量，并且这些流量很可能有多余。但不必担心推流过多，这是因为多余的流会逆推回源点。也就是说，源点仅在第三步时向图中“释放了”尽可能多的流量，它们会尽可能多地流向汇点，多余的流量将被回推到源点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将源点高度标记为n（是当时的最高高度）是为了防止过早的回推。我们第三步时的推流是没有高度限制的，如果不修改源点高度可能会导致过早回推，但这些流量不可能再从源点流出（源点只在第3步推流），导致得到的答案往往小于实际答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在任何情况下，源点和汇点都不会入队。这是因为源点在第三步已经完成了推流使命，它只需要等待接收多余的流即可，而汇点根本不需要推流（它本来就是吸收流量的）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这里就可以理解HLPP算法的整体思想了：先尽可能地释放更多的流量，尽可能地推流，多余的推回源点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法又是怎么实现推回源点的呢？当某个结点无法实现推流时，我们会修改它的高度标号以提高它的高度，最终使得这些无法推流的结点高度高于源点的高度n，从而实现回推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HLPP算法也有GAP优化。我们记录每一个高度对应的结点数量，当某一个高度没有结点（即出现断层时，理解与ISAP算法相同），说明断层两侧的汇点源点不可能再实现联系，这时像ISAP算法一样直接退出算法？并不，虽然断层两侧（源点所在的一侧和汇点所在的一侧）已经不可能有联系，位于源点所在侧的结点不可能再将流推到汇点所在的一侧，但是队列中可能还有能够推到汇点的结点（它们位于汇点所在的一侧），因此算法不能直接结束。那么如何实现优化？既然源点所在的一侧无法再向汇点推流，那么只能向源点逆推，我们不妨将它们其中高度不到n+1的结点的高度标号全部改成n+1，以加快逆推速度。这就是HLPP算法的GAP优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出加强模板题洛谷P4722的HLPP算法代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define inf 0x7fffffffusing namespace std;struct &#123; int to, next; int v;&#125; edge[200005 * 2 + 10000];int head[20000 + 5], cnt = 0, n, m, s, t, h[20000 + 5], gap[20005 * 3] = &#123;0&#125;, vis[20000 + 5];int e[20000 + 5], tree[200005 * 2], size = 0;//下面是堆的部分void solve(int x) &#123; int x1 = 2 * x, x2 = 2 * x + 1, maxnn = x; if (x1 &lt;= size &amp;&amp; h[tree[x1]] &gt; h[tree[maxnn]])maxnn = x1; if (x2 &lt;= size &amp;&amp; h[tree[x2]] &gt; h[tree[maxnn]])maxnn = x2; if (maxnn != x)swap(tree[maxnn], tree[x]), solve(maxnn);&#125;void up(int x) &#123; if (x == 1)return; if (h[tree[x / 2]] &lt; h[tree[x]])swap(tree[x / 2], tree[x]), up(x / 2);&#125;void addHeap(int x) &#123; tree[++size] = x; up(size);&#125;int top() &#123; int t = tree[1]; tree[1] = tree[size--]; solve(1); return t;&#125;//上面是堆的部分int read() &#123;//读入优化 char e = getchar(); int s = 0; while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y, int z) &#123;//加边 edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int HLPP() &#123; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++)h[i] = inf;//高度初始化 h[t] = 0;//汇点为0 Q.push(t); while (!Q.empty()) &#123; int now = Q.front(); Q.pop(); for (int i = head[now]; i != -1; i = edge[i].next) &#123; if (edge[i ^ 1].v &gt; 0 &amp;&amp; h[edge[i].to] == inf)h[edge[i].to] = h[now] + 1, Q.push(edge[i].to);//BFS部分 &#125; &#125; if (h[s] == inf)return 0;//源点高度未更新，说明不连通，返回0 h[s] = n;//更新源点高度 for (int i = 1; i &lt;= n; i++)if (h[i] &lt; inf)++gap[h[i]];//统计结点高度数目 for (int i = head[s]; i != -1; i = edge[i].next) &#123;//源点推流 int d = edge[i].v;//找到这条边的权值 if (d &gt; 0) &#123;//权值大于0 edge[i].v -= d, edge[i ^ 1].v += d, e[s] -= d, e[edge[i].to] += d;//更新额外流和权值，别忘了反边 if (edge[i].to != s &amp;&amp; edge[i].to != t &amp;&amp; !vis[edge[i].to])//入堆 addHeap(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; while (size &gt; 0) &#123;//堆非空时 int now = top(); vis[now] = 0; for (int i = head[now]; i != -1; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; h[edge[i].to] + 1 == h[now]) &#123; int d = min(e[now], edge[i].v);//找到最大推流量 edge[i].v -= d, edge[i ^ 1].v += d, e[now] -= d, e[edge[i].to] += d;//更新 if (edge[i].to != s &amp;&amp; edge[i].to != t &amp;&amp; !vis[edge[i].to])addHeap(edge[i].to), vis[edge[i].to] = 1;//入堆 if (!e[now])break;//推流完成，结束 &#125; &#125; if (e[now]) &#123;//推流未成功，更新标号 if (!--gap[h[now]]) &#123;//如果出现断层 for (int i = 1; i &lt;= n; i++) &#123; if (i != s &amp;&amp; i != t &amp;&amp; h[i] &gt; h[now] &amp;&amp; h[i] &lt; n + 1)//高于h[now]的点（就是断层中源点所在的一侧）更新高度 h[i] = n + 1; &#125; &#125; h[now] = inf; for (int i = head[now]; i != -1; i = edge[i].next) &#123;//更新高度 if (edge[i].v &gt; 0)h[now] = min(h[edge[i].to] + 1, h[now]); &#125; gap[h[now]]++, addHeap(now), vis[now] = 1;//重新入堆 &#125; &#125; return e[t];//汇点额外流就是答案&#125;int main() &#123; n = read(), m = read(), s = read(), t = read(); for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int j = 1; j &lt;= m; j++) &#123; int x, y, z; x = read(), y = read(), z = read(); add(x, y, z), add(y, x, 0); &#125; cout &lt;&lt; HLPP(); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2019%2F02%2F22%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文介绍简单的网络流模型和相关算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定源点s和汇点t，中间有若干条结点做中转，有向边表示转运方向，权值代表最大容量。在这样的图下，汇点最多能够接收到的流量最大值是多少？这就是网络流的最大流问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图就是一个网络流的模型图（来自刘汝佳紫书，有改动）： 网络流最大流问题的三个性质&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一条边，它的最大流量转运上限称为容量（capacity），而这条边上的实际转运量称为流量（flow）。在最大流问题中，有三个基本性质： 容量限制：对于任意一条边(u,v)，总是有f(u,v)≤c(u,v)，即流量不可大于容量。 反对称性：f(u,v)=-f(v,u)。理解：把x个物品从u送到v就是把-x个物品从v送到u，-x可以用来描述有多少流量流到该结点。 流量平衡：对于除了源点和汇点的点，总有$\sum f(u,v)=0$（流入流出均衡）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一种转运方案都需要满足上面三个性质。 残量网络&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出了一种转运方案，红色代表实际流量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易验证，这个流量设置满足前文提到的三个性质，这时汇点总流量为16，但是这不一定是最大流量。将每一条边权值变成容量与实际流量之差，可以得到：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的边权代表“这条边还可以流过多少”，一个很直观的想法是：找到一条从s到t的路径，如果这条路上所有边的边权都大于0，那么总流量还可以加上路径上边权的最小值（注：这种路称为增广路）。比如我们发现走上面的三条边（边权为4、4、8）可以从s走到t，故总流量再加上4成为20，更新网络图，变成：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不断这样找，直到找不到增广路，得到的就是最大流吗？事实证明这种方法是错的。这是因为，我们的思路是尽可能地利用每一条边的价值，让它的流量尽可能地接近容量。因此在某一条边的流量确定时，它的流量就只能只增不降了。比如，按照这个算法，我们不可能让V1-&gt;V3的流量减小（也就是残量增大）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了，我们为什么要让好好的流量减小？让流量尽可能大不是更优吗？这只是直观上的感受，但事实上是错的，比如下面这个图（从网上找的图）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大流显然是沿s-&gt;V1-&gt;t和s-&gt;V2-&gt;t时得到的2。可以发现，V1-&gt;V2的边连用都没用上，如果我们上来就把这条边用了（也就是流量为１），而它不能被减小，就只能得到错误的答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以应该有一个可以将边流量减小（也就是怼回去）的机制。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何解决？方法是给每一条边引入对应的反向边，反向边权值就是正向边已用的流量。上文已经说明反对称性，可以把反向边权值理解成反向的残量（反向走不通，容量为0，而流量为负）。原边（原有的边）权值表示这条路还可以走多少流量，反边权值表示这条路最多可以“反悔”多少流量。走正向边就是给这条边增加流量，走反向边就是给这条边减少流量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给每一条边建立与之对应的反向边，并规定正向边权值为容量与流量之差，反向边权值为正向边流量，就得到了残量网络(residual network)。对于重边，我们可以不将它们合并，得到的结果是一样的。一开始的例子可以建立如下的残量网络：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是有著名的增广路定理： 【增广路定理】当且仅当残量网络中不存在增广路时，此时的流是s-&gt;t的最大流。 EK算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出一个图，我们建立它的残量网络图，不断寻找增广路更新最大流即可。如何寻求增广路？一个方法是BFS，这就是Edmonds-Karp算法（EK算法）。它的思想是不断用BFS找增广路，直到找不到为止。凡是找到一条，立即更新最大流和对应的边权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面有一个小技巧：每找到一条边，立即建立它对应的反向边。将边从0开始标号，那么0和1是一对正向边和反向边，2和3也是一对…这样对于编号为x的边，它对应的反向边编号就是x^1，反向边找正向边也是这种方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出洛谷P3376模板题的EK算法代码，不过会T的很惨。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[10005], cnt = 0, n, m, b, e, pre[10005], flow[10005], ans = 0;//pre是点的前导边标号queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int BFS() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)pre[i] = -1; pre[b] = 0; que.push(b), flow[b] = 0x7fffffff;//flow是到这个流的最小边权 while (!que.empty()) &#123;//BFS每次只找一个增广路 int f = que.front(); if (f == e)break;//到达汇点，立即结束 que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; pre[edge[i].to] == -1) &#123; pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v), que.push(edge[i].to); &#125; &#125; &#125; if (pre[e] == -1)return -1;//没有增广路 return flow[e];//返回途径的最小权值&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0);//加边，后边是反向边，权值为0 &#125; int increase; while ((increase = BFS()) != -1) &#123;//直到找不到反向边 int p = e; while (p != b) &#123;//回退找路 edge[pre[p]].v -= increase, edge[pre[p] ^ 1].v += increase; p = edge[pre[p] ^ 1].to;//更新边权值：前导边减去流量，对应的反边加上流量 &#125; ans += increase;//更新答案 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Dinic算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现EK算法效率的确不高，原因就在于进行了太多次BFS，每次只找一条增广路。这于是就有了Dinic算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dinic算法基于分层图思想，它的算法步骤是： 从源点开始给图用BFS分层。每一次只能走边权大于0的边，得到到源点的最小边距。（源点层次序号为0） 从源点开始DFS，找到在当前分层图下的所有增广路。在当前分层图下的含义是：只能走边权大于0的边并且出点深度必须为该点深度加一。每找到一条更新权值和流量。 回到第一步继续分层，直到汇点不再与源点连通（也就是没法从源点开始获得汇点深度）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;queue&gt;#define N 10005using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[N], cnt = 0, n, m, b, e, ans = 0, deep[N];queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int DFS(int x, int limit) &#123;//DFS找增广路，x是当前结点编号，limit是目前的最小边权。返回能够得到的流值（就是还可以扩展多少） if (limit == 0 || x == e)return limit;//最小边权为0或者到汇点，不能再继续走，直接返回。 int f, flow = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (deep[edge[i].to] == deep[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123;//深度满足并且出点能够找到的流值非0，这里已经排除掉了权值为0的边 edge[i].v -= f, edge[i ^ 1].v += f, flow += f, limit -= f;//修改限制，flow加上这个分枝的流值 if (!limit)break;//最小值到0，无法再继续 &#125; &#125; return flow;//返回流值&#125;bool BFS() &#123;//用于分层 while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)deep[i] = n;//全部初始化为n deep[b] = 0, que.push(b);//源点入队，深度为0 while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; deep[edge[i].to] == n) &#123; deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); if (edge[i].to == e)return true;//汇点找到，返回true &#125; &#125; &#125; return deep[e] != n;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; ans = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0); &#125; while (BFS())ans += DFS(b, 0x7fffffff);//每一次都加上可以得到的流值 cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dinic算法就比较高效了，它可以AC掉上面提到的网络流模板题。这里还有一个优化：当前弧优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现上面DFS代码中的break条件是limit==0。如果循环成功地进入了下一条边，说明上一条边的limit没有用完！这说明上一条边“费尽全力”地找增广路已经达到了极限，那么从这条边再找就不可能有增广路了。于是这条边应该被“废弃”以提高效率。我们用cur记录应该从哪一条边开始以优化算法，注意每次BFS时应重置cur。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是加入当前弧优化的Dinic算法代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;queue&gt;#define N 10005using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[N], cnt = 0, n, m, b, e, ans = 0, deep[N], cur[N] = &#123;0&#125;;queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int DFS(int x, int limit) &#123; if (limit == 0 || x == e)return limit; int f, flow = 0; for (int i = cur[x]; ~i; i = edge[i].next) &#123;//从cur开始 cur[x] = i;//记录当前的边 if (deep[edge[i].to] == deep[x] + 1 &amp;&amp; (f = DFS(edge[i].to, min(limit, edge[i].v)))) &#123; edge[i].v -= f, edge[i ^ 1].v += f, flow += f, limit -= f; if (!limit)break; &#125; &#125; return flow;&#125;bool BFS() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)deep[i] = n, cur[i] = head[i];//重置cur deep[b] = 0, que.push(b); while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; deep[edge[i].to] == n) &#123; deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); if (edge[i].to == e)return true; &#125; &#125; &#125; return deep[e] != n;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; ans = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0); &#125; while (BFS())ans += DFS(b, 0x7fffffff); cout &lt;&lt; ans; return 0;&#125; ISAP算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍另一种算法：ISAP算法。这也是一种高效的求最大流的方法。Dinic算法不停地进行BFS重新分层，能不能便DFS边更新深度呢？这就是ISAP算法的思想。它的算法步骤是： BFS分层（这里是从汇点开始），只能走其反向边权值非0的边，相当于逆着正边走，得到深度。 从源点开始找增广路。事实上，我们经常用循环来进行这个过程。每次只能走边权非0并且深度为自身深度减一的出点，走到汇点时更新答案和边权。当该点没有任何合法出点时更新其深度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当源点深度大于或等于n（n为总结点数）时，不存在增广路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新深度的方法：找到该点所有边权非0的出点，在它们的深度中取最小值，那么点深度更新为这个最小值加一。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISAP算法中有一个重要的优化：GAP优化。易知点的深度更新只能让深度不断变大，不可能变小。因此如果深度出现了断层（比如不存在深度为3的点，但是有深度为4和2的点），那么这个断层就不可能接上了（只有某深度为2的点找到一个深度也为2的出点并且边权非0才可能把深度更新成3，然而这种情况不可能发生）。根据我们点前进的顺序（深度递减）可知，源点必然在这个断层的前面，于是源点不可能再走到汇点了，判断出增广路不存在，直接break。这就是GAP优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码不理解就当板子记吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;queue&gt;#define N 10005#define inf 1000000using namespace std;struct &#123; int to, next, v;&#125; edge[100000 * 2];int head[N], cnt = 0, n, m, b, e, ans = 0, deep[N], cur[N] = &#123;0&#125;, pre[N] = &#123;0&#125;, num[N] = &#123;0&#125;;queue&lt;int&gt; que;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;inline void BFS() &#123;//判深度 for (int i = 1; i &lt;= n; i++)deep[i] = n, cur[i] = head[i]; que.push(e), deep[e] = 0; while (!que.empty()) &#123; int f = que.front(); que.pop(); for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i ^ 1].v &gt; 0 &amp;&amp; deep[edge[i].to] == n)deep[edge[i].to] = deep[f] + 1, que.push(edge[i].to); &#125; &#125;&#125;int maxFlow() &#123;//最大流统计 int flow = inf, p = e; while (p != b) &#123; flow = min(flow, edge[pre[p]].v), p = edge[pre[p] ^ 1].to; &#125; p = e; while (p != b) &#123; edge[pre[p]].v -= flow, edge[pre[p] ^ 1].v += flow, p = edge[pre[p] ^ 1].to; &#125; return flow;&#125;inline void ISPA() &#123; int now = b; BFS(); for (int i = 1; i &lt;= n; i++)num[deep[i]]++;//深度数量统计 while (deep[b] &lt; n) &#123; if (now == e) &#123;//找到一条增广路 ans += maxFlow();//更新 now = b;//回到源点再找 &#125; bool flag = false; for (int i = cur[now]; ~i; i = edge[i].next) &#123; if (deep[edge[i].to] == deep[now] - 1 &amp;&amp; edge[i].v &gt; 0) &#123; flag = true, cur[now] = i, pre[edge[i].to] = i, now = edge[i].to; break; &#125; &#125; if (!flag) &#123;//没有合法出点，更新深度 int minn = n; for (int i = head[now]; ~i; i = edge[i].next)if (edge[i].v &gt; 0)minn = min(minn, deep[edge[i].to]); num[deep[now]]--; if (num[deep[now]] == 0)break;//GAP优化！！ deep[now] = minn + 1, num[deep[now]]++, cur[now] = head[now];//更新cur if (now != b)now = edge[pre[now] ^ 1].to;//更新完深度，回退到这个点的前继，源点不用回退。 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; ans = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, 0); &#125; ISPA(); cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出了最大流，怎么得到最佳方案？通过每一条原边（所有偶数边）的权值代表残量（也可以反向边直接得出流量），然后就可以得到最优时的流量分配方案了。 最小割问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将网络流分成两个不相交点集S、T，使得s（源点）在S中，t（汇点）在T中。断开连接起点在S中终点在T中的所有原边，这时s和t不再连通，称这样的集合划分为一个割。割的容量定义为被断开边的容量之和，求最小割是一个与最大流联系紧密的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有定理： 【最小割最大流定理】最小割容量等于最大流。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样我们就可以求最小割容量了，但是如何求最小割呢？EK算法结束时，我们得到了很多flow，它们当中大于0的点就是S集，剩下的是T集。注意这种方法要求在每次BFS前要清空一下flow（全部初始化成0）。Dinic算法和ISAP算法的方案求法待以后更新。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最小割点数量也是经典问题，但是最小割最大流定理只适用于割边。我们可以将每一个点分成两个点，一个连接点的入边，另一个连接点的出边，并在两点间加一条容量为1的边（注意源点和汇点中间边的边权为无穷大，因为通常不能割这两个点），这样就把割点问题转化为割边问题。 费用流问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在原有图的基础上加入“费用”，总费用为单位费用乘以这条边的流量。得到最大流的方案很多，但是其中有一种花费最少。最小费用最大流问题也是一类重要问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法是将EK算法中的BFS改成SPFA，根据最短路径（将费用看成边权）来找增广路。它和普通的EK算法相比，有以下几点区别： 边的属性增加了一个费用，反边的费用是正边的相反数 普通EK算法的BFS中，pre一旦确定便不再改变。但费用流下需要改变。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样优先选择最短路增广，得到的一定是最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出EK算法费用流问题的模板代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct &#123; int to, next, v, price;&#125; edge[100000 * 2];int head[10005], cnt = 0, n, m, b, e, pre[10005], flow[10005], ans = 0, dict[10005], vis[10005], minCost = 0;queue&lt;int&gt; que;inline void add(int x, int y, int z, int p) &#123; edge[cnt].price = p, edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;int SPFA() &#123; while (!que.empty())que.pop(); for (int i = 1; i &lt;= n; i++)flow[i] = dict[i] = 0x7ffffff, vis[i] = 0, pre[i] = -1;//初始化 pre[b] = -1, vis[b] = 1, dict[b] = 0, que.push(b); while (!que.empty()) &#123; int f = que.front(); que.pop(), vis[f] = 0; for (int i = head[f]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; 0 &amp;&amp; dict[edge[i].to] &gt; dict[f] + edge[i].price) &#123;//注意：这里没有要求pre[edge[i].to]==-1的限制，因为前导边需要根据最短路径的改变而改变 dict[edge[i].to] = edge[i].price + dict[f]; pre[edge[i].to] = i, flow[edge[i].to] = min(flow[f], edge[i].v); if (vis[edge[i].to] == 0)que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; if (pre[e] == -1)return -1; return flow[e];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; b &gt;&gt; e; for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w, p; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; p; add(u, v, w, p), add(v, u, 0, -p); &#125; int increase; while ((increase = SPFA()) != -1) &#123; int p = e; while (p != b) &#123; edge[pre[p]].v -= increase, edge[pre[p] ^ 1].v += increase; p = edge[pre[p] ^ 1].to; &#125; ans += increase; minCost += increase * dict[e];//加上费用 &#125; cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; minCost; return 0;&#125; 最大流与二分图匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前的博客提到了二分图匹配的匈牙利算法，其实这种问题可以用网络流解决。 二分图最大基数匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图不带权值，只是单纯的匹配，既可以用网络流也可以用匈牙利算法解决。对于二分图的两个点集A、B，我们建立起点在A中，终点在B中的有向边，权值均为1（这里相当于改造原二分图）；再建立一个源点s，指向所有A中的点，权值为1，建立汇点t，所有B中的点都指向t，权值也为1。在这个图上求得的最大流就是最大匹配数。 二分图最大权完美匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图带权值，需要找到权值和最大的匹配方案，完美匹配是指所有点都需要被匹配进去，这时匈牙利算法便不再适用了。这种问题可以用费用流解决：将原图的费用设置成权值的相反数，其余我们自己加的边费用设为0，求最小费用最大流即可。显然最小费用的相反数就是最大权值。如果从源点s出发的点不是全部满载，则完美匹配不存在，否则原图中流量为1的边为最佳匹配边。 二分图最大权匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要求完美匹配时（即对匹配数不要求）也可以用费用流解决。引入一个新结点P，所有A集合上的点增加一条指向P的边，容量为1，费用为0，同时P引一条边指向汇点t，容量无穷大，费用为0。建完图后求最小费用最大流。这样最大流一定是A中点的个数，但我们给了每个点一个不走B集合点的机会（即从P流向t），这样就得到了最大权。原图中流量为1的边为最佳匹配边。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配与匈牙利算法]]></title>
    <url>%2F2019%2F02%2F22%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E4%B8%8E%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：本文不会介绍匈牙利算法本身，关于该算法见这一篇博客。本文不写是因为这一篇写得实在是很好。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文是这篇文章的延伸。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图匹配是一类图论问题，首先需要认识什么是匹配。 【匹配】给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。(来自百度百科) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在所有匹配中，边数最多的匹配称为二分图最大匹配。求最大匹配的算法便是匈牙利算法，下面用洛谷P2055假期的宿舍来应用匈牙利算法。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学校放假了 · · · · · · 有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已知一共有 n 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个数 T 表示数据组数。接下来 T 组数据，每组数据第一行一个数n 表示涉及到的总人数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来一行 n 个数，第 i 个数表示第 i 个人是否是在校学生 (0 表示不是，1 表示是)。再接下来一行 n 个数，第 i 个数表示第 i 个人是否回家 (0 表示不回家，1 表示回家，注意如果第 i 个人不是在校学生，那么这个位置上的数是一个随机的数，你应该在读入以后忽略它)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 n 行每行 n 个数，第 i 行第 j 个数表示 i 和 j 是否认识 (1 表示认识，0 表示不认识，第 i 行 i 个的值为 0，但是显然自己还是可以睡自己的床)，认识的关系是相互的。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每组数据，如果存在一个方案则输出 “^_^”(不含引号) 否则输出“T_T”(不含引号)。(注意输出的都是半角字符，即三个符号的 ASCII 码分别为94,84,95) 输入输出样例Sample input 131 1 00 1 00 1 11 0 01 0 0 Sample output ^_^ 说明对于 30% 的数据满足 1 ≤ n ≤ 12。 对于 100% 的数据满足 1 ≤ n ≤ 50,1 ≤ T ≤ 20。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是一道二分图最大匹配问题了，匹配是指人与床的匹配。根据认识关系建立二分图，在上面应用匈牙利算法即可找到最大匹配边数，进而判断是否可以为每一个人找到床位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;struct &#123; int to, next;&#125; edge[5000];int head[55], cnt = 1, n, x, vis[5005] = &#123;0&#125;, isSchool[55] = &#123;0&#125;, isHome[55] = &#123;0&#125;, bed[55] = &#123;0&#125;, ans, maxn;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;bool f(int x) &#123;//匈牙利算法部分 for (int i = head[x]; ~i; i = edge[i].next) &#123; if (!vis[edge[i].to]) &#123; vis[edge[i].to] = 1;//可以理解成暂时占用 if (!bed[edge[i].to] || f(bed[edge[i].to])) &#123; bed[edge[i].to] = x; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n, cnt = 1, ans = 0, maxn = 0; for (int i = 1; i &lt;= n; i++)head[i] = -1, bed[i] = 0; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; isSchool[i]; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; isHome[i]; for (int i = 1; i &lt;= n; i++)if (!(isSchool[i] &amp;&amp; isHome[i]))maxn++; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; x; if (isSchool[j] &amp;&amp; x)add(i, j); else if (i == j &amp;&amp; isSchool[i])add(i, i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++)vis[j] = 0; if (!(isSchool[i] &amp;&amp; isHome[i]) &amp;&amp; f(i))ans++; &#125; if (ans &lt; maxn)cout &lt;&lt; "T_T" &lt;&lt; endl; else cout &lt;&lt; "^_^" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP匹配算法]]></title>
    <url>%2F2019%2F02%2F21%2FKMP%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP字符串匹配算法是一种快速检索字符串的算法。本文探讨KMP算法原理及实现。注意下文中的字符串下标均从0开始。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP匹配算法解决的问题是：如何快速判断字符串A（称主串）中是否包含字符串B（称模式串），如果包含，出现在哪些位置？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法是从暴力匹配算法的不足改进而来。判断某个字符串中是否包含另一个字符串通常设置两个变量i、j，分别指向串A和串B的某个位置，依次检索。如果失配，则令j=0重新检索。这种算法时间复杂度O(nm)，不足在于每一次都重新检索，没有利用好之前匹配成功的信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP算法便是在失配后的做法上进行了优化：当发生失配时，串A的检索位置i不动，j指向一个特定的数next[j]，之后再进行匹配。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next数组是KMP算法的精髓，它储存的是模式串第i位（从0开始）失配后的跳转位置。要理解这个概念需要先理解前缀和后缀。对于字符串abcd： 前缀：a、ab、abc 后缀：d、cd、bcd &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是很容易理解的。值得注意的是，这里的前后缀都不能包含字符串本身。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个长度为p的前缀与等长的后缀完全相同，则它们为一对相同前后缀。例如字符串abcdab中，由于前两个ab与后两个ab相同，因此这是一对相同前后缀。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next数组定义即为：next[i]储存模式串的子串[0，i-1]的最长相同前后缀长度。由于abcdab的最长相同前后缀长度为2，因此对于字符串abcdabe，它的next[6]=2（6是末尾e的下标）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面证明当i位失配时，跳转到next[i]的算法正确性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的匹配过程中，模式串第i位失配，说明第0~i-1位都是匹配的。这时我们要做的是固定主串不动，将模式串右移若干位，假设右移p位可以使模式串完全匹配，并假设第i位失配时，主串在第j位。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原有的模式串首端指向主串第j-i位，右移后指向j-i+p位，这时应该有主串第j-i+p位等于模式串第0位，…，主串第j-i+p+l-1位等于模式串第l-1位（l为模式串长度）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下证p ≥ i-next[i]。假设p &lt; i-next[i]：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经知道主串[j-i+p，j-i+p+l-1]部分与模式串[0，l-1]部分完全相同，那么主串[j-i+p，j-1]部分和模式串[0，i-p-1]部分也应该是相同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于第i位前是匹配的，所以主串[j-i+p，j-1]就是模式串[p，i-1]。那么模式串[0，i-p-1]=模式串[p，i-1]，于是我们找到了模式串第0到i-1位的一个相同前后缀，长度为i-p。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而根据假设：i-p &gt; i-(i-next[i]) = next[i]。这与next[i]的最大性矛盾！于是p≥i-next[i]是正确的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p≥i-next[i]说明什么呢？说明至少要向右移动i-next[i]位才可能匹配，从而避免了很多次无意义的移动。从程序角度讲，模式串向右移动i-next[i]位就是将下标换成next[i]，然后与主串第j位比较。至此证明了算法正确性。12345678int i = 0, j = 0;//i是主串下标，j是模式串下标while (i &lt; l1) &#123;//l1是主串长度 if (str1[i] == str2[j]) &#123;//匹配 if (j == l2 - 1)cout &lt;&lt; i - j + 1 &lt;&lt; endl, j = next[j];//完全匹配，输出位置，令j=next[j]（相当于假设这一位没有匹配以开始新的一轮） else i++, j++;//否则继续比较 &#125; else if (j == 0)i++;//没有匹配并且j=0，i++以开始新的一轮 else j = next[j];//j=next[j]进行跳转 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP算法时间复杂度O(n+m)。下面是next数组的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next数组当然可以用最暴力的方法求出，但是也有更好的方法，那就是令模式串自己与自己匹配。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知next[0]=next[1]=0，现考虑能不能用前面已知的next值求后面的next值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设要求next[i]。令j=next[i-1]，拿另一个相同模式串（称拷贝模式串）的第j位对齐到模式串第i-1位上。为什么要这样做呢？此时拷贝模式串的[0，j-1]位与模式串对应位置完全相同，并且容易知道如果将拷贝模式串左移几位，一定是不匹配的（证明与上面类似）。从这里开始进行匹配，如果str[j]==str[i-1]，那么匹配成功，next[i]=j+1；如果失配，注意到前面均匹配，所以可以采用跳转的方式：令j=next[j]，继续判断str[j]是否等于str[i-1]，只要出现相等的情况立即令next[i]=j+1并进行下一个next值的求解。如果直到j=0都没能匹配，那么next[i]=0。由于是从最大可能的长度找过来，所以结果一定是最大长度。123456789void findNext() &#123; next[0] = next[1] = 0; int j = 0, i = 2; while (i &lt; l2) &#123; if (str2[j] == str2[i - 1])next[i++] = ++j; else if (j == 0)next[i++] = 0, j = 0; else j = next[j]; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合这两步即可得到完整的KMP匹配算法代码。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>提高算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2024]食物链]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%B4%9B%E8%B0%B7P2024-%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题是加权并查集模板题。 难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B吃 C，C 吃 A。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有人用两种说法对这 N 个动物所构成的食物链关系进行描述： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种说法是“1 X Y”，表示 X 和 Y 是同类。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种说法是“2 X Y”，表示 X 吃 Y 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话 当前的话中 X 或 Y 比 N 大，就是假话 当前的话表示 X 吃 X，就是假话 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 eat.in 中输入数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个整数，N，K，表示有 N 个动物，K 句话。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行开始每行一句话（按照题目要求，见样例） 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行，一个整数，表示假话的总数。 输入输出样例Sample input 100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5 Sample output 3 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 ≤ N ≤ 5 ∗ 10^4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 ≤ K ≤ 10^5 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察加权并查集。做法：按照每一句话进行操作，推出矛盾。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并查集可以很好地处理相联性问题，在大多数情况下，这种关系是一定的。但是对于多种关系，正常的并查集就不能满足需求。加权并查集用于关系种类多于1时的情景。比如本题中有三个关系：同类、吃、被吃，并查集中的结点通过这三种关系中的任意一种联系起来，并用权值描述具体的关系种类。简单来说，普通并查集维护关系，加权并查集维护相对关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;权值通常描述该结点与父结点的关系。在路径压缩后结点指向根节点，这个法则同样成立，我们需要在路径压缩时修改结点关系值（毕竟父结点被修改了），修改模板如下：123456int find(x) &#123; if (father[x] == x)return x; int r = find(father[x]);//获得根结点，此时父结点以上通过递归调用已经指向了根结点并更新了关系 //更新关系... return father[x] = r;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果父结点与根结点关系是a，子结点与父结点关系为b，那么子结点和根结点关系是可以求得的（需要具体分析）。另外加权并查集只能来维护传递关系唯一的情景。这句话的意思是，如果我们知道A是B的子结点，关系为a，B是C的子结点，关系为b，那么A与C的关系应该是确定而唯一的。这种性质可以使我们通过任意一个第三者判别两个结点的关系，这是加权并查集的原理（第三者就是通过B和A的关系以及B和C的关系来推断A与C的关系，B就是第三者）。关系传递唯一性保证了路径压缩是等价变形，并且在加权并查集的一个等价类中，保证了任意两点的关系都可以推断出来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单概括如下： 加权并查集的任意一个等价类中任意两点相对关系都可以确定；取两个点，分别来自两个不同等价类，它们的关系无法确定。也就是说，只有在一个等价类中的点对才可以确定关系。 当等价类中任意一个点被具体化时，等价类中其余点都会根据关系具体化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于本题，规定权值0表示子结点与父结点为同类，1表示子结点吃父结点，2表示子结点被父结点吃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的关系进行传递的话，是否具有唯一性？答案是肯定的，如果父结点被它的父结点吃（权值为2），而子结点又吃父结点（权值为1），那么子结点与父结点的父结点什么关系？显然是同类（权值为0）。其余情况都可以由此推断出来，把所有的情况全部列出，可以发现： rela[x]=(rela[x]+rela[father[x]])\%3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然关系的传递具有唯一性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目解决起来就很容易了。首先初始化并查集，令所有点权值为0（自己与自己是同类），然后进行合并。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何合并呢？根据上文的讨论，如果将并查集的两个等价类用一条边（合并就是加边的过程）联系起来，那么这两个等价类成为一个等价类，其中所有点对关系就会确定了。如何加边成为问题的重点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在并查集中，合并通常是令其中一个等价类的根节点去作为另一个等价类根节点的子结点。我们只需要选择合适的关系就可以了。假设要合并x和y（x和y分属两个等价类）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路径压缩后，rela[x]是x到其根节点的关系，rela[y]是y到其根节点的关系，这时x与y的关系又已知（假设为p）。从上文的讨论中可见，如果x根节点与y根节点关系为q，那么： rela[x]+q\equiv rela[y]+p(mod\ 3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解：x通过其根节点这个第三者和通过y这个第三者得到的与y根节点的关系应该是相同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此建立x根节点到y根节点的边，修改x根节点权值为(rela[y]+p-rela[x]+3)%3，便把两个等价类合并成一个等价类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了：合并两个等价类会不会本身就会出现矛盾？或者说合并这两个等价类会不会使某些点对关系矛盾？答案是否定的。前文已经说明，只有一个等价类中的两两点对关系确定，但分属两个等价类中的点对一点关系都没有。在两个等价类上连一条边，权值为多少都不会出现矛盾。我们加了一条边，这本身就是在建立这两个等价类点对的相对关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果发现x和y就在一个等价类中，还需要合并吗？显然不需要，这时两点关系已经确定，再修改关系就真的会出现矛盾了。这时需要做的就是找到两点关系并判断，如果不符，则这句话是假话。1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int n, m, ans = 0, father[50005], rela[50005] = &#123;0&#125;;int find(int x) &#123; if (father[x] == x)return x; int r = find(father[x]); rela[x] = (rela[father[x]] + rela[x]) % 3; return father[x] = r;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)father[i] = i; for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; if (y &gt; n || z &gt; n)ans++; else if (x == 2 &amp;&amp; y == z)ans++; else &#123; int fy = find(y), fz = find(z); if (fy != fz)father[fy] = fz, rela[fy] = (rela[z] - rela[y] + (x == 2) + 3) % 3; else &#123; if (x == 1 &amp;&amp; rela[y] != rela[z])ans++; else if (x == 2 &amp;&amp; (1 + rela[z]) % 3 != rela[y])ans++; &#125; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图判定]]></title>
    <url>%2F2019%2F02%2F20%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图是一种常用的图论模型。如果一个图的顶点可以分成两个不相交子集，并且所有边关联的顶点分属于这两个不同的集合，则称这个图为二分图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分图判定具有简洁的方法。 一个图是二分图的充要条件是图中没有奇数环。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际操作中，这个方法可以用染色法代替： 一个图是二分图当且仅当这个图可以被染成两种颜色，并且相邻两点颜色不同。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用DFS/BFS即可进行染色分析。下面用洛谷P1525 关押罪犯来应用二分图。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S城现有两座监狱，一共关押着N名罪犯，编号分别为1-N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为c的冲突事件。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在详细考察了N名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行中两个数之间用一个空格隔开。第一行为两个正整数N,M分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$ 。数据保证$1&lt;a_j≤b_j≤N ,0 &lt; c_j≤ 1,000,000,000$，且每对罪犯组合只出现一次。对于%100的数据有$N≤ 20000,M≤ 100000$。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共1行，为Z市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。 输入输出样例Sample input 4 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884 Sample output 3512 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显需要二分答案。对于一个值mid，从图中找出边权大于mid的所有边，容易知道如果此时的图是一个二分图则可以将大于mid的组合全部分开。DFS染色判断即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct &#123; int to, next, v;&#125; edge[200000 + 5];int head[20000 + 5], cnt = 1, n, m, maxn = -1, vis[20000 + 5], color[20000 + 5];inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y, int z) &#123; edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;bool DFS(int x, int y) &#123; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i].v &gt; y) &#123; if (color[edge[i].to] == color[x])return false; else if (color[edge[i].to] == 0) &#123; color[edge[i].to] = -color[x]; if (!DFS(edge[i].to, y))return false; &#125; &#125; &#125; return true;&#125;bool check(int x) &#123; for (int i = 1; i &lt;= n; i++)color[i] = 0; for (int i = 1; i &lt;= n; i++) if (!color[i]) &#123; color[i] = 1; if (!DFS(i, x))return false; &#125; return true;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++)head[i] = -1; for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; x = read(), y = read(), z = read(), maxn = max(maxn, z); add(x, y, z), add(y, x, z); &#125; int l = 0, r = maxn; while (l &lt; r) &#123; int mid = (l + r) / 2; if (check(mid))r = mid; else l = mid + 1; &#125; cout &lt;&lt; l; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;差分约束系统是很多问题求解的模型，这一类问题可以转化为图的单源最短路径问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓差分约束系统是指如下的若干不等式组成的约束系统： x_i-x_j\leq w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$x_i,x_j$均为变量，w为常数。不等式组要么无解要么有无数种解，这是因为如果存在一组解，易知它们分别加上同样的数d得到的仍是一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将不等式变形： x_i\leq x_j+w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现这与单源最短路径的松弛操作十分类似： dict[i]\leq dict[j]+w(i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此可知，如果将每一个变量看做点，不等关系看做边建图，求单源最短路径，它们的最短路径值一定满足所有的不等关系。这样差分约束问题就可以转化为图的单源最短路径问题。对于不等式$x_i-x_j\leq w$，需要建立j到i，边权为w的有向边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源点如何找呢？我们需要引入一个新变量$x_0$，并建立$x_0$到其余所有变量的有向边，边权为0，这样相当于加了下面几个约束关系： x_1-x_0\leq 0\\ x_2-x_0\leq 0\\ \cdots\\ x_n-x_0\leq 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然加入这些不等式不会影响原不等式的实际结果，可以认为$x_0$是所有变量的上界。这样以$x_0$为源点求单源最短路径即可。在求单源最短路径时，通常令源点的路径长即dict[0]=0，这样相当于规定了$x_0=0$，所有变量的取值便成为非正数。同样地，如果规定dict[0]=p，这样所有变量取值都不会超过p。源点的dict值可以作为变量取值的上界。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不等式组的无解判定：当单源最短路不存在时（即图中有负环），不等式组无解。基于此，常常用SPFA解决差分约束问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，当不等式给出$x_i-x_j\geq w$形式不等式时，两边乘一个-1，即可化为标准形式。如果给出$x_i-x_j&lt;w$形式，可以化为$x_i-x_j\leq w-1$（因为变量取值通常只取整数）。$x_i-x_j=w$可以化为$x_i-x_j\geq w$和$x_i-x_j\leq w$两个不等式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终得出的解只是一组特解，这组特解不一定符合题意，通常需要将所有值同时加上合适的d来使它们都达到合理的范围。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;差分约束还有另一种解决方法，就是求最长路，这种方法针对形如$x_i-x_j\geq w$的方程。仍然建立j到i边权为w的有向边，但是要求最长路，此时dict[0]是所有变量的下界。求最长路方法与最短路类似，都用SPFA算法。无解判定：当图中存在正权环时无解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题：HDU1384 Intervals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道裸的差分约束题目。规定$d_i$为0~i中已经被选的数的个数，那么可以列出不等式： d_{b_i}-d_{a_i-1}\geq c_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决此类问题时需要善于找到隐藏不等关系，比如每一个数最多选一次，因此还有： 0\leq d_i-d_{i-1}\leq 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建图跑最短（长）路即可，然后找到最小的合法解。题目特点决定了差分约束系统一定有解，不用判定无解情况。另外注意这题有多组测试样例，题干中未提及。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#define MAX (50000+5)#define inf (int)1e9using namespace std;struct &#123; int to, next, v;&#125; edge[MAX * 4 + 10000];int head[MAX], cnt = 1, vis[MAX] = &#123;0&#125;, n, a[MAX], b[MAX], c[MAX], dict[MAX], minn, maxn;inline void add(int x, int y, int z) &#123;//建边 edge[cnt].to = y, edge[cnt].next = head[x], edge[cnt].v = z, head[x] = cnt++;&#125;queue&lt;int&gt; que;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; cnt = 1, minn = inf, maxn = -inf; for (int i = 0; i &lt;= 50002; i++)dict[i] = inf, head[i] = -1, vis[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i], cin &gt;&gt; b[i], cin &gt;&gt; c[i]; a[i] += 2, b[i] += 2; add(b[i], a[i] - 1, -c[i]), maxn = max(maxn, b[i]), minn = min(minn, a[i] - 1); &#125; for (int i = 2; i &lt;= maxn; i++)add(i - 1, i, 1), add(i, i - 1, 0);//补充约束关系 dict[0] = 0; for (int i = 1; i &lt;= maxn; i++)add(0, i, 0);//补充x0 que.push(0), vis[0] = 1; while (!que.empty()) &#123;//SPFA算法 int p = que.front(); que.pop(), vis[p] = 0; for (int i = head[p]; ~i; i = edge[i].next) &#123; if (dict[edge[i].to] &gt; dict[p] + edge[i].v) &#123; dict[edge[i].to] = dict[p] + edge[i].v; if (!vis[edge[i].to])que.push(edge[i].to), vis[edge[i].to] = 1; &#125; &#125; &#125; cout &lt;&lt; -dict[minn] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>图的最短路</tag>
        <tag>提高算法</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分]]></title>
    <url>%2F2019%2F02%2F19%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树链剖分是树上的重要的算法，阅读本文需要先了解线段树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树链剖分主要解决维护并求树上最短路径和，子树和的问题，它的思想是将树划分为一条条链，再用数据结构来维护这些链。树链剖分需要保证每一个结点存在且仅存在于一条链中。下面用洛谷P3384来介绍树链剖分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要清楚以下几个概念： 结点数size：这个结点对应子树的总结点数（含自己）。 父结点编号father：这个结点的父结点 重儿子son：某个结点所有子结点中size最大的一个。叶子结点没有重儿子，其余结点有且仅有一个重儿子。 重边：连接父结点和其重儿子的边。 重链：顺次连接重边所得到的链边 深度depth：结点深度 DFS序：结点在DFS中被首次访问的顺序编号 链顶编号top：该结点所在链的顶端（depth最小的结点）标号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍树链剖分步骤。 第一遍DFS：求father、size、son和depth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一遍DFS，求出基础数据，一遍DFS可以完成。12345678910void DFS1(int x, int fa) &#123; int maxn = -1, r = -1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa) &#123;//防止向父结点回溯 father[edge[i].to] = x, depth[edge[i].to] = depth[x] + 1, DFS1(edge[i].to, x), size[x] += size[edge[i].to]; if (size[edge[i].to] &gt; maxn)maxn = size[edge[i].to], r = edge[i].to;//更新son &#125; &#125; son[x] = r, size[x]++;//含自己，size要自加&#125; 第二遍DFS：求top、DFS序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步是关键。这一步的主要目的是建立树链，规则如下： 如果结点存在重儿子，则优先连接重边，继承已有的树链。 所有轻儿子（除了重儿子就是轻儿子）均分别作一条新链的首端，继续向下延伸。 12345678void DFS2(int x, int t) &#123;//现在访问的结点编号、该结点所在树链的顶端编号 id[x] = dCnt, rk[dCnt] = x, dCnt++, top[x] = t;//构造双向映射（id和rk），进行DFS序重新编号并更新top值 if (size[x] == 1)return;//叶子结点直接return if (son[x])DFS2(son[x], t);//存在重儿子优先选重儿子 for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != son[x] &amp;&amp; edge[i].to != father[x])DFS2(edge[i].to, edge[i].to);//所有轻儿子作新的树链起点 &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里可能会有一个疑惑，为什么要重新编号呢？其实这才是树链剖分的目的：将每一条树链上的点编号都变成连续的，这样就可以用数据结构（比如线段树）维护它们的和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步完成后，可以发现，每一个结点（比如x）的所有子树结点编号都成为连续的了，它们的新编号区间为[id[x],id[x]+size[x]-1]。这样有利于我们用线段树解决子树修改求和问题。 最短路径的划分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求两个结点之间最短路径和呢？在树链剖分后容易发现如果两个结点在同一条树链中，它们之间的结点新编号必然是连续的，这样求和和修改就转化为区间求和修改问题，用线段树维护即可。如果两个结点不在一条树链中，就需要采用下面的方法来将它们分到同一个树链中：（原题要取模，这里为了方便省略取模过程）1234567891011121314inline int queL(int x, int y) &#123; int tx = top[x], ty = top[y], ans = 0;//找到两条链的top while (tx != ty) &#123;//top不同说明不在一条链上 if (depth[tx] &gt;= depth[ty]) &#123;//对于更深的top ans += query(id[tx], id[x], 1, n, 1);//从top开始到这个结点的路径必然都在最短路径上，加上它的影响 x = father[tx], tx = top[x]; &#125; else &#123; ans += query(id[ty], id[y], 1, n, 1); y = father[ty], ty = top[y]; &#125; &#125; if (depth[x] &lt;= depth[y])return ans + query(id[x], id[y], 1, n, 1);//划分到同一条链上之后直接处理 return ans + query(id[y], id[x], 1, n, 1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改类比即可。这里可以发现树链剖分的本质是将树上的问题转化为区间上的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出全部代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define MAX (100000+5)using namespace std;struct &#123; int to, next;&#125; edge[MAX * 2];int head[MAX], father[MAX], son[MAX] = &#123;0&#125;, size[MAX] = &#123;0&#125;;int top[MAX], depth[MAX], cnt = 1, dCnt = 1, n, m, root, mod, x, y, z;int id[MAX] = &#123;0&#125;, rk[MAX] = &#123;0&#125;, init[MAX], tree[4 * MAX], lazy[4 * MAX] = &#123;0&#125;;inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void DFS1(int x, int fa) &#123; int maxn = -1, r = -1; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != fa) &#123; father[edge[i].to] = x, depth[edge[i].to] = depth[x] + 1, DFS1(edge[i].to, x), size[x] += size[edge[i].to]; if (size[edge[i].to] &gt; maxn)maxn = size[edge[i].to], r = edge[i].to; &#125; &#125; son[x] = r, size[x]++;&#125;void DFS2(int x, int t) &#123; id[x] = dCnt, rk[dCnt] = x, dCnt++, top[x] = t; if (size[x] == 1)return; if (son[x])DFS2(son[x], t); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (edge[i].to != son[x] &amp;&amp; edge[i].to != father[x])DFS2(edge[i].to, edge[i].to); &#125;&#125;void make(int l, int r, int k) &#123; if (l == r) &#123; tree[k] = init[rk[l]]; return; &#125; int mid = (l + r) &gt;&gt; 1; make(l, mid, 2 * k), make(mid + 1, r, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;inline void down(int k, int l, int r) &#123; int mid = (l + r) &gt;&gt; 1; tree[2 * k] = (tree[2 * k] + (mid - l + 1) * lazy[k] % mod) % mod; tree[2 * k + 1] = (tree[2 * k + 1] + (r - mid) * lazy[k] % mod) % mod; lazy[2 * k] += lazy[k], lazy[2 * k + 1] += lazy[k], lazy[2 * k] %= mod, lazy[2 * k + 1] %= mod, lazy[k] = 0;&#125;int query(int x, int y, int l, int r, int k) &#123; int mid = (l + r) &gt;&gt; 1; if (l &lt; r &amp;&amp; lazy[k] != 0)down(k, l, r); if (x == l &amp;&amp; y == r)return tree[k]; if (mid + 1 &lt;= x)return query(x, y, mid + 1, r, 2 * k + 1); if (mid &gt;= y)return query(x, y, l, mid, 2 * k); return (query(x, mid, l, mid, 2 * k) + query(mid + 1, y, mid + 1, r, 2 * k + 1)) % mod;&#125;void change(int x, int y, int l, int r, int s, int k) &#123; int mid = (l + r) &gt;&gt; 1; if (l &lt; r &amp;&amp; lazy[k] != 0)down(k, l, r); if (x == l &amp;&amp; y == r) &#123; tree[k] = (tree[k] + (r - l + 1) * s % mod) % mod; lazy[k] += s; return; &#125; if (mid + 1 &lt;= x)change(x, y, mid + 1, r, s, 2 * k + 1); else if (mid &gt;= y)change(x, y, l, mid, s, 2 * k); else change(x, mid, l, mid, s, 2 * k), change(mid + 1, y, mid + 1, r, s, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;inline void addL(int x, int y, int s) &#123; int tx = top[x], ty = top[y]; while (tx != ty) &#123; if (depth[tx] &gt;= depth[ty]) &#123; change(id[tx], id[x], 1, n, s, 1); x = father[tx], tx = top[x]; &#125; else &#123; change(id[ty], id[y], 1, n, s, 1); y = father[ty], ty = top[y]; &#125; &#125; if (depth[x] &lt;= depth[y])change(id[x], id[y], 1, n, s, 1); else change(id[y], id[x], 1, n, s, 1);&#125;inline int queL(int x, int y) &#123; int tx = top[x], ty = top[y], ans = 0; while (tx != ty) &#123; if (depth[tx] &gt;= depth[ty]) &#123; ans += query(id[tx], id[x], 1, n, 1), ans %= mod; x = father[tx], tx = top[x]; &#125; else &#123; ans += query(id[ty], id[y], 1, n, 1), ans %= mod; y = father[ty], ty = top[y]; &#125; &#125; if (depth[x] &lt;= depth[y])return (ans + query(id[x], id[y], 1, n, 1)) % mod; return (ans + query(id[y], id[x], 1, n, 1)) % mod;&#125;int main() &#123; n = read(), m = read(), root = read(), mod = read(); for (int i = 1; i &lt;= n; i++)init[i] = read(), head[i] = -1; for (int i = 1; i &lt; n; i++)x = read(), y = read(), add(x, y), add(y, x); depth[root] = 1, DFS1(root, 0), DFS2(root, root), make(1, n, 1); int cmd; for (int i = 0; i &lt; m; i++) &#123; cmd = read(); if (cmd == 1) &#123; x = read(), y = read(), z = read(); addL(x, y, z); &#125; else if (cmd == 2) &#123; x = read(), y = read(); cout &lt;&lt; queL(x, y) &lt;&lt; endl; &#125; else if (cmd == 3) &#123; x = read(), y = read(); change(id[x], id[x] + size[x] - 1, 1, n, y, 1); &#125; else &#123; x = read(); cout &lt;&lt; query(id[x], id[x] + size[x] - 1, 1, n, 1) &lt;&lt; endl; &#125; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后记：最短路径和也可以通过LCA来完成，做法是预处理每一个结点到根结点的前缀和，求出LCA后即可计算出。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan算法(LCA)]]></title>
    <url>%2F2019%2F02%2F19%2FTarjan%E7%AE%97%E6%B3%95(LCA)%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍Tarjan算法求LCA的原理和过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCA已经在之前的日志中提及，当时使用的倍增算法，见这篇文章。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法是基于并查集求LCA的离线算法。所谓离线，是指读入所有的查询，然后在一次遍历中处理所有查询并得出结果。这种算法不能边读入查询边计算，遍历完成后不能再处理额外的查询。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法巧妙地利用了树的遍历规律。在树的DFS遍历中，容易发现当我们在遍历一棵树时，如果它的所有子树结点尚未被完全访问，这棵子树的根结点状态是不能更新的。也就是说，只有访问了所有子结点后，该结点的状态才可以更新。Tarjan算法便是利用了这一点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法可以描述如下，从根结点开始： 遍历所有子结点，每遍历完一个，将子结点合并到该结点上（并查集操作），并标记该结点已被访问。 遍历完成后，找到与该结点有关的所有查询。如果另一个结点v已经被访问，那么这个查询的结果就是find(v)（并查集操作），否则忽略。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法正确性是易于理解的。对于一个刚刚完成访问操作的结点，我们找到所有与之相关的查询。如果此时另一个结点也被访问了，可以肯定两个结点在一个子树下，并且这棵子树的访问操作没有完全完成（毕竟我们正在访问的就是它的一个子结点或者孙子结点等等），根结点（也就是LCA）的并查集属性（也就是father）尚未被更改（如前文所说，只有遍历完所有子结点才能更改）。注意到每访问一个子结点后我们都将其与父结点合并，那么LCA就可以通过find()函数向上追溯的方法找到了，期间可以使用并查集的路径压缩算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法中的并查集算法与普通的并查集几乎完全相同，唯一不同点是合并的顺序。普通并查集合并两个点时合并顺序是随意的，但是Tarjan算法中必须是子结点合并到父结点上。其实这里的并查集可以看做以前树上常用的记录父结点关系的parent数组。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX (500000+5)using namespace std;struct &#123; int to, next;&#125; edge[MAX * 2];struct &#123;//将查询视为图 int to, next, r;//r是查询编号&#125; qEdge[MAX * 2];int head[MAX], qHead[MAX], father[MAX], ans[MAX] = &#123;0&#125;, cnt = 1, qCnt = 1, n, m, root;bool vis[MAX] = &#123;false&#125;;inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;inline void add(int x, int y) &#123;//树的图构建 edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;inline void qAdd(int x, int y, int r) &#123;//查询关系图构建 qEdge[qCnt].to = y, qEdge[qCnt].next = qHead[x], qEdge[qCnt].r = r, qHead[x] = qCnt++;&#125;int find(int x) &#123; if (father[x] == x)return x; return father[x] = find(father[x]);&#125;inline void merge(int x, int y) &#123;//x合并到它的父结点y上! father[x] = find(y);//就是father[find(x)]=find(y)，因为find(x)就是x //father[y]=find(x)是错的&#125;void Tarjan(int x, int fa) &#123; for (int i = head[x]; i != -1; i = edge[i].next) &#123;//访问所有子结点 if (edge[i].to != fa) Tarjan(edge[i].to, x), merge(edge[i].to, x), vis[edge[i].to] = true; &#125; for (int i = qHead[x]; i != -1; i = qEdge[i].next) &#123;//找到所有相关查询 if (!ans[qEdge[i].r] &amp;&amp; vis[qEdge[i].to])ans[qEdge[i].r] = find(qEdge[i].to); &#125;&#125;int main() &#123; int x, y; n = read(), m = read(), root = read(); for (int i = 1; i &lt;= n; i++)qHead[i] = head[i] = -1, father[i] = i; for (int i = 1; i &lt; n; i++)x = read(), y = read(), add(x, y), add(y, x); for (int i = 0; i &lt; m; i++)x = read(), y = read(), qAdd(x, y, i), qAdd(y, x, i); vis[root] = true, Tarjan(root, 0); for (int i = 0; i &lt; m; i++)cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan算法(割点&割边)]]></title>
    <url>%2F2019%2F02%2F19%2FTarjan%E7%AE%97%E6%B3%95(%E5%89%B2%E7%82%B9%26%E5%89%B2%E8%BE%B9)%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节探讨另一种Tarjan算法来求无向图的割点和割边。本文是这篇文章的延伸。 割点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是割点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个连通无向图中，如果删去某一个点以及与其相连的边后图不再联通，则称这个点为一个割点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法可以用来求割点，它的步骤与求强联通分量的算法十分相似，只是多了下面几个判断： 如果该点为搜索树的根结点（一个连通图搜索树有且仅有一个根结点），判断其子结点数目。如果子结点数目多于一个，说明两个子树只能通过根结点来往，由此判断根结点为割点。也就是说，根结点为割点的充要条件是子结点多于一个。 对于非根结点u，如果其有子结点并且存在某个子结点v的LOW值满足LOW[v]≥DFN[u]，则说明该子树上的结点不能访问父结点以上的结点，即父结点为割点。也就是说，非根结点为割点的充要条件是存在至少一个子结点满足LOW[v]≥DFN[u]。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求割点时不需要开栈，如果子结点已经被访问过，直接更新即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在求割点时，事实证明子结点是可以回溯到父结点的。但仍然建议在无向图中不允许子结点回溯父结点，这是为了与割边算法统一（见下文）。1234567891011void tarjan(int x, int last) &#123; DFN[x] = LOW[x] = cunt++; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (!DFN[edge[i].to]) &#123; tarjan(edge[i].to, x), LOW[x] = min(LOW[x], LOW[edge[i].to]); if (x != root &amp;&amp; LOW[edge[i].to] &gt;= DFN[x])Ans[x] = 1; else if (x == root)c++; &#125; else if (edge[i].to != last)LOW[x] = min(LOW[x], DFN[edge[i].to]); &#125; if (x == root &amp;&amp; c &gt;= 2)Ans[x] = 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：Tarjan算法得出的割点可能会重复。 割边&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个连通无向图中，如果删去一条边后图不再连通，则该边为一条割边，也称为桥。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找割边的算法比割点容易，因为它不需要考虑根结点的问题。对于一条边(u，v)，u为父结点，则该边是割边的充要条件是LOW[v]&gt;DFN[u]。这说明子结点不能通过其它边访问包含父结点在内的所有祖先结点，即父子边为割边。值得注意的是，判割边时，子结点不能回溯到父结点。123456789void tarjan(int x, int last) &#123; DFN[x] = LOW[x] = cunt++; for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (!DFN[edge[i].to]) &#123; tarjan(edge[i].to, x), LOW[x] = min(LOW[x], LOW[edge[i].to]); if (LOW[edge[i].to] &gt; DFN[x])Ans[i] = 1;//标记边序号 &#125; else if (edge[i].to != last)LOW[x] = min(LOW[x], DFN[edge[i].to]); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：如果一条边有重边，那么它一定不是割边。Tarjan算法不能排除重边的干扰，需要特判。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan算法(强连通)]]></title>
    <url>%2F2019%2F02%2F18%2FTarjan%E7%AE%97%E6%B3%95(%E5%BC%BA%E8%BF%9E%E9%80%9A)%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍一种求解有向图强连通分量的算法—Tarjan算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是强连通分量的定义：一个有向图的满足强连通性的子图。所谓强连通性是指这个有向图中任意两点都可以相互联通的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tarjan算法基于DFS，要理解这个算法需要先认清一个事实：在强连通图中一定存在一条回路能够遍历所有的点。这也是判定强连通图的充要条件。Tarjan算法就是通过找环来判定强连通性的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是Tarjan算法的实现过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用栈储存搜索树结点路径。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于图中每一个结点，它都有两个量：DFN与LOW。 DFN ：这个结点被访问的次序编号，也就是时间戳。 LOW ：在搜索树中，这个结点的子树中最小的结点编号（也就是最小的DFN值）。LOW保证了求出的是极大强连通子图。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：每访问一个新结点，首先进行初始化：DFN=LOW=cnt++（cnt是时间戳计数器）并入栈。这是因为新的结点尚未向下扩展，这个结点在搜索树中没有子树，LOW即为自身的DFN。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每访问到一个结点，遍历该点所有的出边。这时对于每一个出点，有以下几种情况： 该点从未被访问：对该点进行新的Tarjan算法（递归进行），以更新该点的DFN与LOW值。由于该点是原结点在搜索树中的子结点，以此更新原结点LOW值。若原结点为u，该结点为v，那么LOW[u]=min(LOW[u],LOW[v])。 该点已在栈中：直接更新原结点LOW值。需要注意的是，更新方法是LOW[u]=min(LOW[u],DFN[v])。这是因为出点已在栈中，但它也是搜索树的子结点，需要用它的DFN值来更新原结点。 其余情况忽略该结点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回溯后，如果一个结点的DFN=LOW，说明自己就在以自己为根的搜索树上，即为一个环。此时退栈，直到该点（含该点），得到的序列就是一个强连通分量。12345678910111213void tarjan(int x) &#123; DFN[x] = LOW[x] = index++, vis[x] = 1, sta.push(x); for (int i = head[x]; i != -1; i = edge[i].next) &#123; if (vis[edge[i].to])LOW[x] = min(DFN[edge[i].to], LOW[x]); else if (!DFN[edge[i].to])tarjan(edge[i].to), LOW[x] = min(LOW[x], LOW[edge[i].to]); &#125; if (DFN[x] == LOW[x]) &#123; int t; do cout &lt;&lt; (t = sta.top()) &lt;&lt; " ", vis[t] = 0, sta.pop(); while (t != x); cout &lt;&lt; endl; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题一道：洛谷P2341。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜&gt;欢”是可以传递的——如果A喜欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。 输入输出格式输入格式： 第一行：两个用空格分开的整数：N和M。 第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B。 输出格式：一行：单独一个整数，表示明星奶牛的数量。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题实质上给定了一个有向图，判断有多少点可以让所有点都能连通到该点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于环的出现，本题不能直接用拓扑排序方法去做。首先应认识到，一个环（即一个强连通分量）与一个点等价，于是可以将图中所有强连通分量都分别缩至一个点，这样就得到有向无环图，拓扑排序便可解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缩点方法是染色法，将同一个强连通分量中的点染成同一种颜色。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct Edge &#123; int to, next;&#125; edge[50005];int head[N], cnt = 1, id[N], n, m, vis[N], x, y, DFNt = 1, DFN[N], LOW[N], ID = 1;int all[N], in[N], rk[N], in2[N];//in是点的入度，in2是强连通分量的入度，rk是强连通分量的拓扑序stack&lt;int&gt; sta;queue&lt;int&gt; que;inline void add(int x, int y) &#123; edge[cnt].to = y, edge[cnt].next = head[x], head[x] = cnt++;&#125;void tarjan(int x) &#123; if (DFN[x])return;//已经求出的直接return DFN[x] = LOW[x] = DFNt++, vis[x] = 1, sta.push(x); for (int i = head[x]; i; i = edge[i].next) &#123; if (vis[edge[i].to])LOW[x] = min(LOW[x], DFN[edge[i].to]); else tarjan(edge[i].to), LOW[x] = min(LOW[x], LOW[edge[i].to]); &#125; if (DFN[x] == LOW[x]) &#123; int t; do vis[sta.top()] = 0, id[t = sta.top()] = ID, sta.pop(), all[ID]++;//all计数该强连通分量有几个点 while (t != x); ID++; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x &gt;&gt; y; add(x, y); &#125; for (int i = 1; i &lt;= n; i++)tarjan(i); for (int i = 1; i &lt;= n; i++) &#123; for (int j = head[i]; j; j = edge[j].next) &#123; if (id[i] != id[edge[j].to])in[edge[j].to]++, in2[id[edge[j].to]]++; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!in[i]) &#123; que.push(i);//没有入度的点入队 if (!in2[id[i]])rk[id[i]] = 1;//若强连通分量也没有入度，则标记其拓扑序为1（最低） &#125; &#125; while (!que.empty()) &#123; int t = que.front(); que.pop(); for (int i = head[t]; i; i = edge[i].next) &#123; if (id[edge[i].to] != id[t]) &#123;//同一个强连通分量的点不考虑 in[edge[i].to]--, in2[id[edge[i].to]]--;//出度减少一 if (in[edge[i].to] == 0)que.push(edge[i].to);//入度为0的点入队 if (in2[edge[i].to] == 0)rk[id[edge[i].to]] = rk[id[t]] + 1;//强连通分量入度为0，得出拓扑序 &#125; &#125; &#125; int maxn = 0, tot = 0, ans; for (int i = 1; i &lt; ID; i++) &#123;//找到最大拓扑序 if (rk[i] &gt; maxn)maxn = rk[i], tot = 1, ans = i; else if (rk[i] == maxn)tot++; vis[i] = 0; &#125; if (tot &gt; 1) &#123;//最大拓扑序数量比一个多，一定不成立 cout &lt;&lt; "0"; return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (rk[id[i]] == maxn)continue; for (int j = head[i]; j; j = edge[j].next)if (id[edge[j].to] != id[i])vis[id[i]] = 1; &#125; for (int i = 1; i &lt; ID; i++) &#123; if (rk[i] &lt; maxn &amp;&amp; !vis[i]) &#123;//拓扑序低于最大拓扑序但没有出度，一定不成立 cout &lt;&lt; "0"; return 0; &#125; &#125; cout &lt;&lt; all[ans];//最后输出该强连通分量的点数 return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重背包问题及其优化]]></title>
    <url>%2F2019%2F02%2F04%2F%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文探讨多重背包问题。要认识这个问题需要先熟悉01背包和完全背包的状态转移方程。 01背包 dp(a,p)=\begin{cases} \max\{dp(a-1，p)，dp(a-1，p-v_a)+w_a\}\ \ \ & p\geq w_a\\ dp(a-1,p) \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组降维时需要从大到小遍历来更新状态。 完全背包 dp(a,p)=\begin{cases} \max\{dp(a-1，p)，dp(a，p-v_a)+w_a\}\ \ \ & p\geq w_a\\ dp(a-1,p) \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组降维时需要从小到大遍历来更新状态。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多重背包是指每一个物品有着数量限制时的背包问题，这也是一类经典动态规划问题，解法主要有以下几种。 朴素解法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果第i个物品有ci个，我们可以将这ci个物品看做不同的物品，从而化为01背包问题。这种方法十分简单，但时间复杂度为$O(V\displaystyle\sum_{i=1}^n w_ic_i)$，时间消耗很大。 二进制拆分 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制拆分的做法也是将多重背包转化为01背包，但是二进制拆分更为高效，它基于以下数学原理：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一个自然数x都可以写成如下形式： x=2^0+2^1+\cdots+2^k+p,\ p]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论]中国剩余定理]]></title>
    <url>%2F2019%2F02%2F02%2F%E6%95%B0%E8%AE%BA-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中国剩余定理（又名孙子定理）是数论四大定理（威尔逊定理、中国剩余定理、欧拉定理、费马小定理）之一，这里介绍中国剩余定理以及扩展后的定理内容以及在OI中的应用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先介绍中国剩余定理的内容。 【中国剩余定理】对于一次线性同余方程组： \begin{cases} x\equiv a_1(mod\ m_1)\\ x\equiv a_2(mod\ m_2)\\ \cdots \\ x\equiv a_n(mod\ m_n) \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果$gcd(m_i,m_j)=1,1\leq i&lt;j\leq n$，则$x$在模$M=\displaystyle \prod_{i=1}^n m_i$意义下有唯一解。该解可以通过下面方法得到：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定$M_i=\displaystyle\frac {M} {m_i}$，并设$M_i^{-1}为M_i在模m_i下的乘法逆元$，那么解为： x\equiv \sum_{i=1}^n a_iM_iM_i^{-1}(mod\ M) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明参考数论相关书目，这里略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于乘法逆元可以见这篇文章。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中国剩余定理可以帮助求一次线性同余方程组的解。但是当模数m不满足两两互素时，定理便不再适用，于是需要引入更一般化的定理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先给出一个一次线性同余方程组： \begin{cases} x\equiv a_1(mod\ m_1)\\ x\equiv a_2(mod\ m_2)\end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化同余式为： x=a_1+k_1m_1=a_2+k_2m_2,(k_1,k_2\in \mathbb {Z})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记这个式子为①式，化①为同余式： k_1m_1\equiv a_2-a_1(mod\ m_2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$d=gcd(m_1,m_2)$，由上式可得$d|(a_2-a_1)$，若否则方程组无解。下面仅讨论有解的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上式等价于： k_1\frac {m_1} {d}\equiv \frac{a_2-a_1} {d}(mod\ \frac {m_2} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然$\displaystyle\frac {m_1} {d}$与$\displaystyle\frac {m_2} {d}$互质，于是$\displaystyle\frac {m_1} {d}$在模$\displaystyle\frac {m_2} {d}$意义下存在乘法逆元，那么： k_1\equiv \frac {a_2-a_1} {d} (\frac {m_1} {d})^{-1}(mod\ \frac {m_2} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化上式为： k_1=\frac {a_2-a_1} {d} (\frac {m_1} {d})^{-1}+k\frac {m_2} {d},(k\in \mathbb {Z})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上式代入①式： x=a_1+m_1(\frac {a_2-a_1} {d})(\frac {m_1} {d})^{-1}+k\frac {m_1m_2} {d}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化为同余式： x\equiv a_1+m_1(\frac {a_2-a_1} {d})(\frac {m_1} {d})^{-1}(mod\ \frac {m_1m_2} {d})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是得到了一个同余式。易见上面的变形都是等价变形，故该同余式的解与原方程组相同，这样就将两个同余方程合并成一个，并且这个同余方程的解是显见的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反复利用这个公式，可以将n个方程化为一个同余方程。中国剩余定理可以认为是这个公式的特例，这样就得到了一般化的定理。下面用HDU 1573(X问题)来应用这个公式。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求在小于等于N的正整数中有多少个X满足：X mod a[0] = b[0], X mod a[1] = b[1], X mod a[2] = b[2], …, X mod a[i] = b[i], … (0 &lt; a[i] &lt;= 10,0 &lt; N &lt;= 1000,000,000 , 0 &lt; M &lt;= 10) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这个问题很裸地考察上面推导出的公式，直接应用即可。代码中用扩展欧几里得算法求逆元。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;int N, M, a[15], b[15], flag = 1;int gcd(int x, int y) &#123; if (y == 0)return x; return gcd(y, x % y);&#125;int egcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int p = egcd(b, a % b, y, x); y -= a / b * x; return p;&#125;int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; flag = 1; cin &gt;&gt; N &gt;&gt; M; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; a[i];//模数 for (int i = 1; i &lt;= M; i++)cin &gt;&gt; b[i]; for (int i = 2; i &lt;= M; i++) &#123;//全部合并到a[1],b[1]中 int d = gcd(a[1], a[i]), e = b[i] - b[1], x, y; if (e % d != 0) &#123;//无解 cout &lt;&lt; 0 &lt;&lt; endl, flag = 0; break; &#125; egcd(a[1], a[i], x, y);//扩展欧几里得求逆元 b[1] = b[1] + a[1] * e / d * x; a[1] = a[1] * a[i] / d; b[1] = (b[1] % a[1] + a[1]) % a[1]; &#125; if (flag) &#123; if (b[1] &gt; 0)cout &lt;&lt; (N &gt;= b[1] ? (N - b[1]) / a[1] + 1 : 0) &lt;&lt; endl; else if (b[1] == 0)cout &lt;&lt; N / a[1] &lt;&lt; endl; &#125; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个常用的技巧：C++中的%运算符得到的并不一定是数学上的模（要求非负），可以用表达式$(a\%p+p)\%p$将其化为数学上非负的模。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;康托展开可以建立1~n全排列到n!的一一映射，常用于字符串哈希，这也是优化时间空间的一种方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;康托展开只能用于全排列的映射。对于1~n的一个排列，康托展开可以得到这个排列在全排列中按字典序的序号(12…n序号为0)，这样便可以建立字符串到[0,n!)的一个映射。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设序列为$s_1s_2…s_n$，具体做法如下： 从左到右依次求出$s_i$的逆序数$a_i$，需要两遍循环。 康托展开的值为$\displaystyle\sum_{i=1}^na_i(n-i)!$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要预处理出0~n-1的阶乘，注意0!=1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;康托展开的原理是易于理解的，他通过找逆序数并乘以排列数的方式来求小于已知序列的排列有多少种，这样便得到已知序列在全排列中的序号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么根据康托展开的值如何得到原排列呢？这就是逆康托展开。设值为x，逆展开算法如下： 开一个数组记录哪些数已经被选了，初始化全未被选。 对于序列的第i位（从1开始），计算$x/(n-i)!$（带余除法）的值p。 从未被选的数中找到第p+1小的数m，序列的第i位便为m。标记m已被选，更新$x=x\ mod\ (n-i)!$。 重复2和3步，直到序列的所有数均被求出。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逆展开原理也是易于理解的。易知每一次求出的p就是逆序数，通过逆序数可以方便地推知第i位的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面通过经典八数码问题（洛谷P1379）来应用康托展开。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入初始状态，一行九个数字，空格用0表示 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数(测试数据中无特殊无法到达目标状态数据) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;八数码问题是经典的搜索类问题，难度在于状态的描述（这是一个排列），康托展开可以很好地解决这个问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用康托展开将每一个排列化为数字，用于判重和搜索，必要时再逆展开为排列，可以降低时间空间复杂度。另外需要注意的是本题需要用BFS（因为要求最少步数）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int jc[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;//预处理阶乘bool vis[362880] = &#123;false&#125;;inline int Hash(const char *op) &#123;//康托展开 int ans = 0; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = 0; for (int j = i + 1; j &lt; 9; j++)if (op[j] &lt; op[i])s++; ans += s * jc[p]; &#125; return ans;&#125;inline void cal(int h, char *op) &#123;//逆展开 bool vis[10] = &#123;false&#125;; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = h / jc[p]; for (int z = 0; z &lt; 9; z++) if (!vis[z]) &#123; if (s == 0) &#123; op[i] = static_cast&lt;char&gt;(z + '0'), vis[z] = true; break; &#125; else s--; &#125; h %= jc[p]; &#125;&#125;struct Node &#123; int h, step, begin; Node(int a, int b, int c) : h(a), step(b), begin(c) &#123;&#125;&#125;;char b[9];queue&lt;Node&gt; que;int main() &#123; cin &gt;&gt; b; for (int i = 0; i &lt; 9; i++) &#123; if (b[i] == '0') &#123; que.push(Node(Hash(b), 0, i)), vis[Hash(b)] = true; break; &#125; &#125; Node p(0, 0, 0); int h; while (!que.empty()) &#123; p = que.front(), que.pop(), cal(p.h, b); if (p.h == 46685) &#123;//46685是目标状态的康托展开值 cout &lt;&lt; p.step; return 0; &#125;//下面分四个状态转移 if (p.begin % 3 != 0) &#123; swap(b[p.begin], b[p.begin - 1]), h = Hash(b), swap(b[p.begin], b[p.begin - 1]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin - 1)), vis[h] = true; &#125; if ((p.begin + 1) % 3 != 0) &#123; swap(b[p.begin], b[p.begin + 1]), h = Hash(b), swap(b[p.begin], b[p.begin + 1]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin + 1)), vis[h] = true; &#125; if (p.begin &gt; 2) &#123; swap(b[p.begin], b[p.begin - 3]), h = Hash(b), swap(b[p.begin], b[p.begin - 3]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin - 3)), vis[h] = true; &#125; if (p.begin &lt; 6) &#123; swap(b[p.begin], b[p.begin + 3]), h = Hash(b), swap(b[p.begin], b[p.begin + 3]); if (!vis[h])que.push(Node(h, p.step + 1, p.begin + 3)), vis[h] = true; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地降低时间复杂度，本题最好用双向BFS。双向BFS只适用于目标状态已知的情况（比如本题）。做法是开两个队列，分别从初始状态和目标状态转移，直到两个队列中出现重合状态。在某些情况下，这种方法可以大大提升效率。需要注意双向BFS时,visited数组需要额外记录这个状态是哪一个分枝访问到的。在转移时如果发现下一个状态已经被另一个分枝访问到了，则可以得出答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;using namespace std;int jc[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int vis[362880] = &#123;0&#125;, step1[362880] = &#123;0&#125;, step2[362800] = &#123;0&#125;;inline int Hash(const char *op) &#123; int ans = 0; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = 0; for (int j = i + 1; j &lt; 9; j++)if (op[j] &lt; op[i])s++; ans += s * jc[p]; &#125; return ans;&#125;inline void cal(int h, char *op) &#123; bool vis[10] = &#123;false&#125;; for (int i = 0, p = 8; i &lt; 9; i++, p--) &#123; int s = h / jc[p]; for (int z = 0; z &lt; 9; z++) if (!vis[z]) &#123; if (s == 0) &#123; op[i] = static_cast&lt;char&gt;(z + '0'), vis[z] = true; break; &#125; else s--; &#125; h %= jc[p]; &#125;&#125;inline void print(int x) &#123; cout &lt;&lt; step1[x] + step2[x]; exit(0);&#125;struct Node &#123; int h, begin; Node(int a, int c) : h(a), begin(c) &#123;&#125;&#125;;char b[9];queue&lt;Node&gt; que, que2;int main() &#123; cin &gt;&gt; b; for (int i = 0; i &lt; 9; i++) &#123; if (b[i] == '0') &#123; que.push(Node(Hash(b), i)), vis[Hash(b)] = 1; break; &#125; &#125; if (Hash(b) == 46685) &#123; cout &lt;&lt; 0; return 0; &#125; que2.push(Node(46685, 4)), vis[46658] = 2; Node p(0, 0); int h; while (!que.empty() || !que2.empty()) &#123; if (!que.empty()) &#123;//第一个队列转移 p = que.front(), que.pop(), cal(p.h, b); if (p.begin % 3 != 0) &#123; swap(b[p.begin], b[p.begin - 1]), h = Hash(b), swap(b[p.begin], b[p.begin - 1]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin - 1)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; if ((p.begin + 1) % 3 != 0) &#123; swap(b[p.begin], b[p.begin + 1]), h = Hash(b), swap(b[p.begin], b[p.begin + 1]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin + 1)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; if (p.begin &gt; 2) &#123; swap(b[p.begin], b[p.begin - 3]), h = Hash(b), swap(b[p.begin], b[p.begin - 3]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin - 3)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; if (p.begin &lt; 6) &#123; swap(b[p.begin], b[p.begin + 3]), h = Hash(b), swap(b[p.begin], b[p.begin + 3]); if (vis[h] == 2)step1[h] = step1[p.h] + 1, print(h); if (!vis[h])que.push(Node(h, p.begin + 3)), vis[h] = 1, step1[h] = step1[p.h] + 1; &#125; &#125; if (!que2.empty()) &#123;//第二个队列转移 p = que2.front(), que2.pop(), cal(p.h, b); if (p.begin % 3 != 0) &#123; swap(b[p.begin], b[p.begin - 1]), h = Hash(b), swap(b[p.begin], b[p.begin - 1]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin - 1)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; if ((p.begin + 1) % 3 != 0) &#123; swap(b[p.begin], b[p.begin + 1]), h = Hash(b), swap(b[p.begin], b[p.begin + 1]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin + 1)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; if (p.begin &gt; 2) &#123; swap(b[p.begin], b[p.begin - 3]), h = Hash(b), swap(b[p.begin], b[p.begin - 3]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin - 3)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; if (p.begin &lt; 6) &#123; swap(b[p.begin], b[p.begin + 3]), h = Hash(b), swap(b[p.begin], b[p.begin + 3]); if (vis[h] == 1)step2[h] = step2[p.h] + 1, print(h); if (!vis[h])que2.push(Node(h, p.begin + 3)), vis[h] = 2, step2[h] = step2[p.h] + 1; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2154]虔诚的墓主人]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B4%9B%E8%B0%B7P2154-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小W是一片新造公墓的管理人。公墓可以看成一块N×M的矩形，矩形的每个格点，要么种着一棵常青树，要么是一块还没有归属的墓地。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当地的居民都是非常虔诚的基督徒，他们愿意提前为自己找一块合适墓地。为了体现自己对主的真诚，他们希望自己的墓地拥有着较高的虔诚度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一块墓地的虔诚度是指以这块墓地为中心的十字架的数目。一个十字架可以看成中间是墓地，墓地的正上、正下、正左、正右都有恰好k棵常青树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小W希望知道他所管理的这片公墓中所有墓地的虔诚度总和是多少。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件religious.in的第一行包含两个用空格分隔的正整数N和M，表示公墓的宽和长，因此这个矩形公墓共有(N+1) ×(M+1)个格点，左下角的坐标为(0, 0)，右上角的坐标为(N, M)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含一个正整数W，表示公墓中常青树的个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行起共W行，每行包含两个用空格分隔的非负整数xi和yi，表示一棵常青树的坐标。输入保证没有两棵常青树拥有相同的坐标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行包含一个正整数k，意义如题目所示。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件religious.out仅包含一个非负整数，表示这片公墓中所有墓地的虔诚度总和。为了方便起见，答案对2,147,483,648取模。 输入输出样例Sample input 5 6130 20 31 21 32 02 12 42 52 63 23 34 35 22 Sample output 6 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图中，以墓地(2, 2)和(2, 3)为中心的十字架各有3个，即它们的虔诚度均为3。其他墓地的虔诚度为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，满足1 ≤ N, M ≤ 1,000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于60%的数据，满足1 ≤ N, M ≤ 1,000,000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，满足1 ≤ N, M ≤ 1,000,000,000，0 ≤ xi ≤ N，0 ≤ yi ≤ M，1 ≤ W ≤ 100,000，1 ≤ k ≤ 10。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在50%的数据，满足1 ≤ k ≤ 2。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在25%的数据，满足1 ≤ W ≤ 10000。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识到如果一个墓地上、下、左、右各有a、b、c、d棵常青树，则虔诚度为$C_a^kC_b^kC_c^kC_d^k$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从数据范围想思路。发现N和M特别大，所以需要离散化坐标。具体做法是将没有树的行列去除，再对坐标重新编号，这样N，M就降至1e5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使经过了离散化，如果枚举每一个墓地坐标，也需要相当的时间消耗。注意到如果一个墓地的上方或下方没有常青树，那么这个墓地的虔诚度一定为0，不用考虑。所以只需要考虑第一棵常青树和最后一棵常青树之间的部分即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做这个题的思想是：固定一维（横坐标），移动另一位（纵坐标）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先预处理出组合数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离散化之后，将常青树坐标按横坐标为第一关键字，纵坐标为第二关键字升序排序。这样坐标点就按照横坐标进行了分类，并且每一类中纵坐标升序。用数组记录当前每一个纵坐标已经有的树的数量，再用一个变量记录当前横坐标已经有的树的数量，还需要记录每一个纵坐标横坐标的常青树总数。在每一类中，找到相邻的两个坐标点，枚举它们中间部分的墓地坐标点，依次求它们的虔诚度，最后再求和即可。对于每一个遍历到的常青树，更新其纵坐标横坐标已有的常青藤数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这样仍不是最佳策略。注意到两个相邻常青树之间的所有墓地上下的树的数量是不变的，只有左右的树的数量在随纵坐标的变化而变化。对于每一个纵坐标，它都有自己的$C_c^kC_d^k$值，这样求两个相邻常青树之间墓地虔诚度的和就相当于求一个区间和，再乘以一个$C_a^kC_b^k$。每遍历到一棵常青树，需要更新这个节点的值，因此需要一种可以修改节点值又能求区间和的数据结构，肯定首选树状数组。于是用树状数组维护前缀和，这样时间复杂度降至O(wlogw)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 100000using namespace std;struct Point &#123; int x, y, t;&#125; op[MAX];int n, m, w, k, C[MAX + 1][11] = &#123;0&#125;, ySum[MAX + 1] = &#123;0&#125;, xSum[MAX + 1] = &#123;0&#125;, now[MAX + 1] = &#123;0&#125;;int cnt = 0;int tree[MAX + 1] = &#123;0&#125;;//树状数组bool cmp1(Point x, Point y) &#123; if (x.x == y.x)return x.y &lt; y.y; return x.x &lt; y.x;&#125;bool cmp2(Point x, Point y) &#123; return x.y &lt; y.y;&#125;inline void add(int x, int y) &#123; for (int i = x; i &lt;= m; i += (i &amp; -i))tree[i] += y;&#125;inline int get(int x) &#123; int s = 0; for (int i = x; i &gt; 0; i -= (i &amp; -i))s += tree[i]; return s;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; w; for (int i = 0; i &lt; w; i++)cin &gt;&gt; op[i].x &gt;&gt; op[i].y; cin &gt;&gt; k; C[1][0] = C[1][1] = 1; for (int i = 2; i &lt;= w; i++) &#123;//求组合数 C[i][0] = 1; for (int j = 1; j &lt;= min(k, i); j++)C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; sort(op, op + w, cmp2);//y升序排序，离散化纵坐标 for (int i = 0; i &lt; w; i++) &#123; if (i == 0 || op[i].y != op[i - 1].y)cnt++; op[i].t = cnt; ySum[cnt]++; &#125; m = cnt; for (int i = 0; i &lt; w; i++)op[i].y = op[i].t; sort(op, op + w, cmp1), cnt = 0;//离散化横坐标 for (int i = 0; i &lt; w; i++) &#123; if (i == 0 || op[i].x != op[i - 1].x)cnt++; op[i].t = cnt; xSum[cnt]++; &#125; n = cnt; for (int i = 0; i &lt; w; i++)op[i].x = op[i].t; int ans = 0, np = 0; for (int i = 0; i &lt; w; i++) &#123; add(op[i].y, C[now[op[i].y] + 1][k] * C[ySum[op[i].y] - now[op[i].y] - 1][k] - C[now[op[i].y]][k] * C[ySum[op[i].y] - now[op[i].y]][k]); now[op[i].y]++; if (i == 0 || op[i].x != op[i - 1].x)np = 0; else ans += (get(op[i].y - 1) - get(op[i - 1].y)) * C[np][k] * C[xSum[op[i].x] - np][k]; np++; &#125; cout &lt;&lt; (ans &amp; ((1 &lt;&lt; 31) - 1)); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个小技巧：如果结果是通过加减乘三种运算得到的并且需要对2147483648（即232）取模，可以利用int的自然溢出来完成这个操作。具体做法是不用每一步都取模，最后让答案与(1&lt;&lt;31)-1取按位与，这是一个优化常数的常用方法。该方法可行性可用补码性质证明。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
        <tag>树状数组</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1641]生成字符串]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%B4%9B%E8%B0%B7P1641-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lxhgww最近接到了一个生成字符串的任务，任务需要他把n个1和m个0组成字符串，但是任务还要求在组成的字符串中，在任意的前k个字符中，1的个数不能少于0的个数。现在lxhgww想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据是一行，包括2个数字n和m。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出数据是一行，包括1个数字，表示满足要求的字符串数目，这个数可能会很大，只需输出这个数除以20100403的余数。 输入输出样例Sample input 2 2 Sample output 2 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每点2秒&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，保证1≤m≤n≤1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，保证1≤m≤n≤1000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来源：SCOI 2010 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更让人头秃的计数题（前一个是这个）…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符序号（从1开始）看做横坐标x，前x个字符中1的数目与0的数目之差为纵坐标y，那么字符的选取可以看做坐标系上从点(0，0)开始的一条条连续的折线，它的终点为(n+m，n-m)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据这个思路，从点(0，0)开始，选1就向右上方走，选0向右下方走，直到点(n+m，n-m)。这样的总的连线便对应一个字符串，容易知道若折线终点为(n+m，n-m)，那么整个过程1的数量一定为n，0的数量一定为m，不可能超出这个限制。显然在这种情况下方案数为$C^m_{n+m}$（从n+m步中选m步向下走）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何限制前k个字符中1的数量不小于0的数量呢？如果1的数量小于0的数量，则纵坐标应小于0，连线一定与y=-1有所交集。下面证明与y=-1有交集的方案数与从(0，-2)开始到(n+m，n-m)方案数相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个从(0，0)开始且与y=-1有交集的连线（称之为非法连线），取其与y=-1的第一个交点p，将[0，p]的部分折到y=-1的下方。这样得到的连线显然是唯一的并且起点成为(0，-2)，这还是一个从(0，-2)开始结束于(n+m，n-m)的连线。同样对于一个从(0，-2)开始结束于(n+m，n-m)的连线，它与y=-1必然有交集，取其第一个交点p，将[0，p]的部分折到上方，得到一条从(0，0)开始的非法连线。从上面的讨论可以看出，非法连线与从(0，-2)开始在(n+m，n-m)结束的连线有着一一对应关系，它们的方案数必然是相同的，证毕。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那从(0，-2)到(n+m，n-m)有多少方案呢？由于每一次都一定向右走，但是不一定向上还是向下，不妨假设向上走了x步，则向下走了m+n-x步，由于最后停在了(n+m，n-m)上，故有： x-(m+n-x)=n-m+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解得x=n+1，所以方案数为$C_{n+m}^{n+1}$，这个数也等于$C_{n+m}^{m-1}$。于是题目实质上是求$C_{m+n}^m-C_{m+n}^{m-1}$对20100403的模。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先想到的是杨辉三角递推法，但那样一定会超时。注意到组合数的阶乘公式为： C_n^m=\frac {n!} {m!(n-m)!}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分子分母的模很易求，但除法的模并不那样易求，这里需要乘法逆元来求除法的模（20100403是一个大质数）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需预处理出阶乘，再用费马小定理或者扩展欧几里得算法求出逆元，利用逆元求出除法的模，问题便得以解决。123456789101112131415161718192021222324252627282930//费马小定理求逆元#include&lt;iostream&gt;#define MOD 20100403using namespace std;long long op[2000001], n, m;inline long long find(long long x) &#123;//快速幂 int p = MOD - 2; long long ans = 1; while (p &gt; 0) &#123; if ((p &amp; 1) &gt; 0)ans *= x, ans %= MOD; x *= x; x %= MOD; p &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; op[0] = 1; for (int i = 1; i &lt;= n + m; i++)op[i] = op[i - 1] * i % MOD; long long a = find(op[m] * op[n] % MOD), b = find(op[m - 1] * op[n + 1] % MOD);//a和b是逆元 long long c = op[n + m] * a % MOD, d = op[n + m] * b % MOD; long long ans = c - d; if (ans &lt; 0)ans += MOD; cout &lt;&lt; ans; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435//扩展欧几里得算法求逆元#include&lt;iostream&gt;#define MOD 20100403using namespace std;long long op[2000001], n, m;int exGcd(int a, int b, long long &amp;x, long long &amp;y) &#123;//扩展欧几里得算法 if (b == 0) &#123; x = 1, y = 0; return a; &#125; int t = exGcd(b, a % b, y, x); y -= a / b * x; return t;&#125;inline long long find(int p) &#123; long long x, y; exGcd(MOD, p, x, y); while (y &lt; 0)y += MOD; return y % MOD;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; op[0] = 1; for (int i = 1; i &lt;= n + m; i++)op[i] = op[i - 1] * i % MOD; long long a = find(op[m] * op[n] % MOD), b = find(op[m - 1] * op[n + 1] % MOD); long long c = op[n + m] * a % MOD, d = op[n + m] * b % MOD; long long ans = c - d; if (ans &lt; 0)ans += MOD; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乘法逆元在OI中常用于在除法运算取模，这是一个重要方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先认识什么是乘法逆元，对于整数a，若存在整数x使得$ax\equiv1(mod\ p)$，则称x为a关于1模p的乘法逆元。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将同余式化为整除式可得$ax+py=1$，根据裴蜀定理可知a与p互质，即$gcd(a,p)=1$。这说明当且仅当a与p互质时，a关于模p的乘法逆元才存在。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乘法逆元有什么作用呢？它常用于除法的取模，已知： (a+b)\ mod\ p=(a\ mod\ p+b\ mod\ p)\ mod\ p\\ (a-b)\ mod\ p=(a\ mod\ p-b\ mod\ p)\ mod\ p\\ ab\ mod\ p=(a\ mod\ p)(b\ mod\ p)\ mod\ p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是除法并没有： \frac a b\ mod\ p=\frac {a\ mod\ p} {b\ mod\ p}\ mod\ p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这对计算除法的模带来困难，乘法逆元可以解决这个问题，假设最后结果为x，则有： \frac a b\equiv x(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当b与p互质时，上式等价于： a\equiv bx(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设b的乘法逆元为b-1，即有： bb^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么有： ab^{-1}\equiv b^{-1}bx\equiv x(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以如果要算a/b对p的模，只需计算ab-1对p的模即可，关键在于求b的逆元。下面先介绍两种通用方法。 用费马小定理求解逆元 【费马(Fermat)小定理】当p为质数且a与p互质时，有$a^{p-1}\equiv 1(mod\ p)$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;费马小定理变形一下得到$aa^{p-2}\equiv 1(mod\ p)$，那么逆元就是ap-2。用快速幂算法求出ap-2并取模就是逆元。这个方法需要p为质数，并且a与p互质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;费马小定理其实是欧拉定理的特殊情况，p不为质数时，用欧拉函数值代替p-1然后求逆元也是可以的，这样便不要求p为质数。 用扩展欧几里得算法求解逆元 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当a与p互质时，可以用扩展欧几里得算法求出一个特解x、y使得$ax+bp=1$，也就是$ax\equiv 1(mod\ p)$，这样x就是逆元。本方法只需要a与p互质（这也是逆元存在的条件），缺点是求出的x可能为负数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若用inv(x)来表示x的乘法逆元，则有： inv(ab)\equiv inv(a)inv(b)(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这说明逆元是积性的，很容易证明，这是逆元的一个重要性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后介绍逆元的递推求法。对于一个数a，现欲求a在模p意义下的逆元，根据带余除法原理，可以将p表示为ak+b。假设b的逆元为b-1，那么： bb^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是： (p-ak)b^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即： pb^{-1}-akb^{-1}\equiv -akb^{-1}\equiv 1(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此： -kb^{-1}\equiv a^{-1}(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就得到了一个递推式： inv(a)\equiv -(p/a)inv(p\ mod\ a)(mod\ p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个递推式可以帮助我们在O(n)复杂度下求出1~n的逆元。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1357]花园]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%B4%9B%E8%B0%B7P1357-%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小L有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为1~N(2≤N≤1015)。他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则，任意相邻M(2≤M≤5,M≤N)个花圃中有不超过K(1≤K&lt;M)个C形的花圃，其余花圃均为P形的花圃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，N=10,M=5,K=3。则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCPCPPPPCC 是一种不符合规则的花圃；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCPPPPCPCP 是一种符合规则的花圃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请帮小L求出符合规则的花园种数Mod 1000000007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现请您编写一个程序解决此题。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行，三个数N,M,K。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花园种数Mod 1000000007 输入输出样例Sample input#1 10 5 3 Sample output#1 458 Sample input#2 6 2 1 Sample output#2 18 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道让人头秃的计数题，考察图论、矩阵快速幂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到m和k都很小，十分有利于状态压缩，可以用一个二进制数表示花园的种类序列。比如对于题目中给出的CCPPPPCPCP序列，可以写成：1100001010。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在样例一下，m=5，发现上面给出的例子便是样例一的一个合法解，将它拆成若干个长度为5的连续子序列，得到：11000、10000、00001、00010、00101、01010，由于是环，故还有后面的部分：10101、01011、10110、01100。这里每一个子序列都是合法的，易知它们的种类是有限的，这样总的序列可以看做是这些子序列的一个排列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现这些序列有很明确的后继关系：后一个序列总是前一个序列去掉最高位再在末尾加上0或1得到的。将每一个合法子序列看作节点，这种后继关系看作有向边，可以建立一个图。那么要求的序列就是这个图上的一条路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目要求是环也不影响做法。在上文给出的01序列的最后补充一个11000，这样序列首尾相同，将它们首尾连接得到的一定是一个合法的环。因此题目等价于求图上所有边数为n的回路数量，这是因为回路与要求的环有着一一对应的关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何求长度固定的回路条数便成问题的重点，这里需要邻接矩阵来完成这项操作。有一个基本事实： 设一个图的邻接矩阵为S，则Sn中第i行第j列的元素表示节点i到节点j长度为n的路的数量。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个结论很重要，它是求路数量问题的一个重要解法原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于图的规模很小，邻接矩阵空间占用不大，因此可以对矩阵求n次幂，从而找到路的数量。求幂当然选择矩阵快速幂，而回路怎么找呢？回路可以看作节点i到节点i本身的路，也就是主对角线上的元素，求完幂后将主对角线上的元素加起来再取模就是答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#define MOD 1000000007using namespace std;int m, k, cnt = 0;long long n;int to1[100], to2[100];struct Matrix &#123; long long op[100][100] = &#123;0&#125;; void operator*=(Matrix x) &#123; long long temp[100][100] = &#123;0&#125;; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++) &#123; for (int k = 1; k &lt;= cnt; k++)temp[i][j] += op[i][k] * x.op[k][j], temp[i][j] %= MOD; &#125; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++)op[i][j] = temp[i][j]; &#125; &#125;&#125;;inline int check(int x) &#123; int ans = 0; while (x &gt; 0) &#123; if ((x &amp; 1) &gt; 0)ans++; x &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; (1 &lt;&lt; m); i++) &#123; int tp = check(i); if (tp &lt;= k)cnt++, to1[cnt] = i, to2[i] = cnt;//构造双向映射 &#125; Matrix sta, E; for (int i = 1; i &lt;= cnt; i++) &#123; int temp = (to1[i] &amp; ((1 &lt;&lt; (m - 1)) - 1)) &lt;&lt; 1;//去首并左移 if (check(temp) == k)sta.op[i][to2[temp]] = 1;//填邻接矩阵 else sta.op[i][to2[temp]] = sta.op[i][to2[temp + 1]] = 1; &#125; for (int i = 1; i &lt;= cnt; i++)E.op[i][i] = 1;//单位阵 while (n &gt; 0) &#123;//矩阵快速幂 if ((n &amp; 1) &gt; 0)E *= sta; sta *= sta; n &gt;&gt;= 1; &#125; long long ans0 = 0; for (int i = 1; i &lt;= cnt; i++)ans0 += E.op[i][i], ans0 %= MOD;//对角线求和取模 cout &lt;&lt; ans0; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶梯Nim]]></title>
    <url>%2F2019%2F01%2F23%2F%E9%98%B6%E6%A2%AFNim%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章是简单博弈论和SG定理的延伸。本次介绍博弈论中阶梯Nim游戏及其转化性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识什么是阶梯Nim游戏。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定几个阶梯，编号为1~n，每一个阶梯上有若干个石子。你和队手轮流任意选取一个有石子的阶梯，将任意数量（至少为1）个石子移动到下一个阶梯上（从编号为i的阶梯拿到i-1阶梯上，如果i=1，则直接拿走石子），首先拿走所有石子的一方胜利。给定阶梯数和每一个阶梯上的石子数，若你先手，如何判断你是否必胜策略？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阶梯Nim游戏有一个简洁的性质：阶梯Nim游戏的必胜必败性质（P/N性质）与在奇数编号阶梯上做Nim游戏的性质相同。以操作为证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在奇数阶梯上Nim游戏必胜，那么你可以采取以下策略： 按照Nim游戏的必胜策略将某一奇数阶梯上的一些石子移动到其下的偶数阶梯上（相当于丢弃）。 若对手也移动奇数阶梯上的石子，他的做法也相当于“配合你做Nim游戏”，即将奇数堆上的石子“丢弃”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几轮后，你一定可以移动走某个奇数堆上的最后若干颗石子，这时如果偶数堆上没有石子，那么你已经获胜了，否则所有石子都应该在偶数堆上。对于后者的情况，由于之后对手要再进行操作，他只能将某偶数堆上的石子移动到其下的奇数堆上，你只需要把它们再移动到再其下的偶数堆上即可，若如此做，则游戏又回到仅有偶数堆上有石子的局面，然后对手继续移动……经过这样的操作，对手只能将石子从偶数堆移到奇数堆，而你一直将石子从奇数堆移动到偶数堆。而获胜的局面是什么呢？显然是仅有第一堆上有石子，然后将它们拿走（相当于移动到第0堆），这是一个从奇数堆移动石子到偶数堆的操作，这个操作显然只有你（先手）能做，因此先手必胜。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对手在操作中将偶数堆石子移到奇数堆中又如何做呢？这时只需要将这些石子再移动到再其下的偶数堆即可。两次操作没有影响奇数堆的石子数量，只是影响了偶数堆上石子数目，最终仍可化为上文所述的局面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;必败的等价性质类似证明即可。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2575]高手过招]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%B4%9B%E8%B0%B7P2575-%E9%AB%98%E6%89%8B%E8%BF%87%E6%8B%9B%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AKN玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个n*20的棋盘，以及棋盘上有若干个棋子，问谁赢？akn先手！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏规则是这样的：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个棋子，能将它向右移动一格，如果右边有棋子，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个T，表示T组数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每组数据第一行n，表示n*20的棋盘&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n行每行第一个数m表示第i行有m个棋子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后跟着m个数pj表示第i行的棋子布局 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果AKN能赢，则输出”YES”，否则输出”NO”。 输入输出样例Sample input 212 19 2021 191 18 Sample output NOYES 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10%的数据T≤1，n≤1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外10%的数据m≤1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据T≤100，n≤1000，m≤20，1≤pj≤20 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较裸的状态压缩类博弈论。注意到跳棋只能在一行内操作，不能跨行，于是就可以将每一行都看成是一个子游戏，整个游戏即为原游戏和。用二进制数表示每一行20个格子的有无状态，递推出SG值，最后根据SG定理求Nim和判断即可。SG函数值可以暴力求出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题可以比较好地练习SG函数求法和SG定理应用，故加入博客。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int SG[1 &lt;&lt; 20];bool vis[20] = &#123;false&#125;;inline int solve(int x, int y) &#123; for (int i = y - 1; i &gt;= 0; i--)if ((x &amp; (1 &lt;&lt; i)) == 0)return i; return -1;&#125;int main() &#123; SG[0] = 0; for (int i = 1; i &lt; (1 &lt;&lt; 20); i++) &#123;//暴力求SG函数值 memset(vis, false, sizeof(vis)); for (int j = 0; (1 &lt;&lt; j) &lt;= i; j++) &#123; if ((i &amp; (1 &lt;&lt; j)) &gt; 0) &#123; int p = solve(i, j); if (p != -1) &#123; vis[SG[((~(1 &lt;&lt; j)) &amp; i) | (1 &lt;&lt; p)]] = true;//这是一个玄学的式子，用于mex运算 &#125; &#125; &#125; for (int j = 0; j &lt; 20; j++) if (!vis[j]) &#123; SG[i] = j; break; &#125; &#125; int T; cin &gt;&gt; T; for (int ti = 0; ti &lt; T; ti++) &#123; int n, ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int k, p = 0; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; int x; cin &gt;&gt; x; p |= (1 &lt;&lt; (20 - x)); &#125; ans ^= SG[p];//求Nim和 &#125; if (ans == 0)cout &lt;&lt; "NO" &lt;&lt; endl;//根据SG函数值判断结果 else cout &lt;&lt; "YES" &lt;&lt; endl; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这个方法很粗暴，并不优，但可以在SG函数求取时优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍一种洛谷大佬想出的方法：用阶梯Nim方法解决本问题。要理解该做法，需要先了解什么是阶梯Nim，可以参考这篇博客。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将两个空位之间的部分看做阶梯，其中的棋子数目就是阶梯上的石子数目，那么本问题就相当于做阶梯Nim游戏。比如若仅有18、19处有棋子，那么阶梯就是：第一阶梯2个棋子，之后的阶梯没有棋子，共17个阶梯；又比如仅有18、19、20处有棋子，则阶梯相当于所有阶梯都没有石子，共16个阶梯。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么可以将这个跳棋问题看作阶梯Nim游戏呢？这是由游戏的操作性质决定的。考虑仅有16、17、18处有棋子，那么该局面的二进制表示为011100（只写后几位），对应阶梯为0、3、0（按阶梯编号升序，只写前几位）。这个局面可以转移到001110、010110、011010三个状态，对应的阶梯分别为：（3，0，0）、（2，1，0）、（1，2，0），正好对应了初始阶梯Nim局面的三种移动石子的方式，可见本游戏的棋子移动规则就是阶梯Nim游戏的变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可以用阶梯Nim的方法去求SG值，该方法效率很高，时间复杂度O(20Tn)。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;bool vis[21];int temp[20] = &#123;0&#125;;int main() &#123; int T; cin &gt;&gt; T; for (int ti = 0; ti &lt; T; ti++) &#123; int n, ans = 0, ans0 = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int k, last = -1; ans0 = 0; cin &gt;&gt; k; memset(vis, false, sizeof(vis)); temp[0] = 0; for (int j = 0; j &lt; k; j++) &#123; int x; cin &gt;&gt; x; vis[x] = true; &#125; for (int j = 20; j &gt; 0; j--) &#123; if (!vis[j]) &#123; if (last != -1)temp[++temp[0]] = last - j - 1; last = j; &#125; &#125; if (last != 1)temp[++temp[0]] = last - 1; for (int j = 1; j &lt;= temp[0]; j += 2)ans0 ^= temp[j]; ans ^= ans0; &#125; if (ans == 0)cout &lt;&lt; "NO" &lt;&lt; endl; else cout &lt;&lt; "YES" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单博弈论和SG定理]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%92%8CSG%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博弈论是OI和数学竞赛中的重要一项，它考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看这样一个经典问题（Nim游戏）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定若干堆石子，你和队手轮流选取任意一堆石子，拿走其中的若干颗（没有上界，不能不拿）。首先拿走所有石子的人获胜（也就是面临所有石子都被拿走局面的人判负）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种游戏规则下，给定每一堆石子的数量，如何判断先手有没有必胜的可能？这里直接给出定理： 【Bouton定理】Nim游戏中，先手必败等价于$A_1\ xor\ A_2\ xor\ …\ xor\ A_n=0$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$A_i$为第i堆石子的数量，xor表示按位求和并模2取余，也就是异或，对应C语言中的^。这种操作也称Nim和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nim游戏拥有很简洁的结论，下面的SG函数以及SG定理则将其推广到更一般化的问题上。要了解SG函数，需要理解以下两个概念。 $P-position(P点)：$ 必败点。在P点时，无论如何操作，只要队手不失误，必败。 $N-position(N点)：$ 必胜点。在N点时，无论对手如何操作，只要自己不失误，必胜。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P/N点有以下性质： 当游戏到达没有任何合法操作的局面时（比如Nim游戏中的石子全部被取走时），面临该局面的一方判负，也就是P点。 P点的后继一定是N点。 N点的后继中至少有一个P点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是公平组合游戏(ICG)的概念，它是满足以下几点条件的游戏： 有且仅有两人参与。 游戏局面的状态集合有限。 对于同一个局面，两个游戏者的可操作集合完全相同。 游戏者轮流进行游戏。 当无任何合法操作时游戏结束，面临者判负。 无论游戏如何进行，总可以在有限步数之内结束。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此来看Nim游戏是ICG，象棋不是ICG（因为双方只能操作自己的棋子，不满足第3条）。这里只探讨ICG。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个ICG，可以将其抽象为一个有向无环图，图的节点是游戏的一个局面，有向边表示局面通过合法操作进行的转化。显然没有出度的节点必然代表着游戏的结束。ICG的进行可以看作是在图上移动棋子的过程：起初棋子在最初局面上，然后双方轮流将棋子沿有向边移动到下一个节点，直到有一方无法移动时判负。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一个节点，都可以判定它是P点还是N点，如果可以找到处态的P/N性质，那么判定先手能否获胜的问题就得到解读。终点显然是P点，下面来探讨其余点的P/N性质。根据P点和N点的定义有以下结论： 如果一个节点的后继均为N点，则该点为P点。 如果一个节点的后继存在P点，则该点为N点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种递推关系，可以得到初态的P/N性质。在博弈论中，SG函数用来描述一个局面的P/N性质，要理解SG函数需要先引入mex(minimal excludant)运算。设$N$为自然数集合，对于任何$S\subseteq N$，定义： mexS=\min\{x|x\in N,x\notin S\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，mexS表示不在S中的最小自然数。我们用mex运算来定义SG函数，定义如下： SG(x)=mex\{SG(p_1),SG(p_2),...,SG(p_m)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的$p_i$是x的m个后继。特别地，当x没有后继时（也就是终点），其SG值为$mex\varnothing$，即为0。这样易知一个局面为P点等价于其SG值非0。简单归纳证明如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先所有终点都为P点，SG值为0，成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如若后继中存在P点，则取mex后值一定大于0，该点即为N点；若后继中不存在P点，则取mex后值一定为0，该点即为P点。这与P点N点定义及性质一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SG函数是解决ICG问题的利器。但是既然可以直接递推求出P/N性质，为何还要引入SG函数呢？这是因为SG函数有一个强大的定理——SG（Sprague-Grundy）定理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入SG定理前，先来认识游戏和的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个游戏可能是由多个子游戏组成的（将其记作$G_1,G_2…G_n$），如果整个游戏进行时，玩家可以任意选取一个子游戏进行上面的合法操作，所有子游戏均无法进行合法操作时判负。这时的整个游戏称为子游戏的游戏和，记作$G=G_1+G_2+…+G_n$。于是有SG定理： 【SG定理】游戏和的SG值为所有子游戏SG值的Nim和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样可以将一个游戏分成若干子游戏，从而分而治之，求出SG值。从这里可以发现Bouton定理与SG定理的内在联系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nim游戏其实就是由若干子游戏组成的，每个子游戏都是如下的形式：给一堆石子，从中拿走至少一个石子，先全部拿走者胜。这个子问题很无聊，因为只要一开始石子数非零，则先手必胜（直接全部拿走即可）。但是可以从另一个角度去理解这个问题。注意到当前石子数是局面的唯一描述变量，设其为x。我们证明SG(x)=x，证明如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用归纳证明。显然SG(0)=0；假设x≤k时均成立，由于可以从k+1个石子中任意拿石子，故0~k都是k+1这个局面的后继，所以： SG(k+1)=mex\{SG(k),SG(k-1),...,SG(0)\}=mex\{k,k-1,...,0\}=k+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即对x=k+1也成立，故SG(x)=x是正确的。这样根据SG定理，游戏和（即Nim游戏）的SG值为： SG=SG(A_1)\ xor\ SG(A_2)\ xor\ ...\ xor\ SG(A_n)=A_1\ xor\ A_2\ xor\ ...\ xor\ A_n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个值为0时，说明游戏初态局面为P点，先手必败，于是证明了Bouton定理。可以发现Bouton定理是SG定理在Nim问题上的直接应用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SG函数以及SG定理是解决组合游戏问题的利器，下面举几个例子。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mr.Jia和Boy next door在玩一个游戏。一开始有一个正整数x，可以进行对其进行两种操作：x/2(向下取整)和x-1。现在Mr.Jia和Boy next door轮流进行任意一种操作，先得到0的一方胜利。现在若Mr.Jia先进行操作，给定初始的数x，判断Mr.Jia能否获胜。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要吐槽Boy next door。这是TJU某次编程竞赛的第四题，用SG函数可以轻松做出。注意到SG值非零的时候表示必胜，它的具体值并没有意义，不妨将其统一为1，这样可以简化算法。123456int SG(int x) &#123; if (x == 0)return 0; int a = SG(x / 2), b = SG(x - 1); if (a != 0 &amp;&amp; b != 0)return 0;//后继无0说明x为P点 return 1;//后继有0说明x为N点&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用上面代码求出SG值即可，需要用递推或记忆化优化，这里只点明思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实在做这题时，发现如果把x写成k2s（k为奇数），则s为偶数则Mr.Jia赢，否则Boy next door赢。这是一个靠眼力得出的结论，实际上也是正确的，现在来用SG函数来证明这个结论。这里的SG函数可以看成是一个bool类型的函数，有递推式： SG(x)=\begin{cases}false\ & x=0\\ !SG(x/2)||!SG(x-1)\ & x>0 \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现x=1时SG(1)为true，表示Mr.Jia赢，1对应的s为0，0是偶数，这是正确的。假设x≤p时都正确，下证x=p+1也正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若x为偶数且x=k2s（k为奇数且s&gt;0）。注意到x-1一定是奇数，根据归纳假设SG(x-1)=true。x/2必然为k2s-1，若s为偶数，则s-1为奇数，由归纳假设SG(x/2)=false，则SG(x)=true，成立；若s为奇数，则s-1为偶数，由归纳假设SG(x/2)=true，则SG(x)=false，同样成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若x为奇数（只考虑大于1的情况），设x=k2s+1，这里k为奇数。若s为偶数，则由归纳假设SG(x-1)=true，SG(x/2)=SG(k2s-1)=false，那么SG(x)=true，成立；若s为奇数，则由归纳假设SG(x-1)=false，SG(x)必然为true，也成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，结论是正确的，也就是说可以用给定数中2因子的个数来判定答案，这样对于一个数n，就可以在O(logn)复杂度下判断。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一题（洛谷P1290）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欧几里德的两个后代Stan和Ollie正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数M和N，从Stan开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于&gt;0。然后是Ollie，对刚才得到的数，和M，N中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25，7)两个数游戏的过程：Start：25 7Stan：11 7Ollie：4 7Stan：4 3Ollie：1 3Stan：1 0Stan赢得了游戏的胜利。现在，假设他们完美地操作，谁会取得胜利呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这仍然是一个ICG，可以考虑SG函数，发现有如下的递推式（假设n≥m）： SG(n,m)=mex\{SG(n-m,m),SG(n-2m,m),...,SG(n\%m,m)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递推式通俗易懂，但它并不利于实际操作，这时适当的观察是有益的。发现： SG(n-m,m)=mex\{SG(n-2m,m),...,SG(n\%m,m)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子说明只要知道SG(n%m，m)，就可以递推求出上面式子中的所有值。若SG(n%m，m)=0，则SG(n%m+m，m)=1，SG(n%m+2m，m)=2…之后的值均非零。若SG(n%m，m)=1，则SG(n%m+m，m)=0，之后的值均非零，于是得出一个重要结论：当SG(n%m，m)=0时，SG(n，m)必非零；当SG(n%m，m)=1时，若n/m&gt;1则SG(n，m)非零，若n/m=1则SG(n，m)=0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与上一题思想相似，非零全部按1处理，于是有：123456int getSG(int x, int y) &#123; if (x &lt; y)swap(x, y); if (y == 0)return 0; if (x / y == 1 &amp;&amp; getSG(y, x % y) == 1)return 0; return 1;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求出SG值判断即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三题，洛谷P2148，山东2009年省选题： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小E 与小W 进行一项名为“E&amp;D”游戏。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏的规则如下： 桌子上有2n 堆石子，编号为1..2n。其中，为了方便起见，将第2k-1 堆与第2k 堆 （1 ≤ k ≤ n）视为同一组。第i堆的石子个数用一个正整数Si表示。 一次分割操作指的是，从桌子上任取一堆石子，将其移走。然后分割它同一组的另一堆 石子，从中取出若干个石子放在被移走的位置，组成新的一堆。操作完成后，所有堆的石子 数必须保证大于0。显然，被分割的一堆的石子数至少要为2。 两个人轮流进行分割操作。如果轮到某人进行操作时，所有堆的石子数均为1，则此时 没有石子可以操作，判此人输掉比赛。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小E 进行第一次分割。他想知道，是否存在某种策 略使得他一定能战胜小W。因此，他求助于小F，也就是你，请你告诉他是否存在必胜策略。 例如，假设初始时桌子上有4 堆石子，数量分别为1,2,3,1。小E可以选择移走第1堆， 然后将第2堆分割（只能分出1 个石子）。接下来，小W 只能选择移走第4 堆，然后将第3 堆分割为1 和2。最后轮到小E，他只能移走后两堆中数量为1 的一堆，将另一堆分割为1 和1。这样，轮到小W 时，所有堆的数量均为1，则他输掉了比赛。故小E 存在必胜策略。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个游戏和，子游戏是从两堆石子中任取一堆分割。对于石子堆数为x，y的一个组合，可以用SG(x，y)表示这个子游戏的SG值。x与y均为1时SG值为0，当两者均非1时，显然有两种总的策略：分x和分y。发现分割操作只与一个数有关而与另一个数无关，不妨只探讨一个数p的分割情况，并观察其SG值的规律。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出1~10的SG值（实质上是SG(1，1)~SG(1，10)，自行理解）并写出mex后继集合：用二进制数表示，0表示不存在，1表示存在，那么有： 1：00000002：00000013：00000104：00000115：00001006：00001017：00001108：00001119：000100010：0001001 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惊奇地发现，x对应的mex后继集合居然就是x-1的二进制表示！那么SG(n，m)就是(n-1)|(m-1)的二进制表示中第一个0出现的位置！那么getSG函数可以轻松写出：12345int getSG(int a, int b) &#123; int ans = (a - 1) | (b - 1), r = 0; while ((ans &amp; 1) == 1)ans &gt;&gt;= 1, r++; return r;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那游戏和的SG值如何求呢？整个游戏有2n堆石子，是由n个子游戏组成的。根据SG定理，将这n组的SG值一一求出，取Nim和就可以得到游戏和的SG值，于是问题迎刃而解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这里可以看出，找SG函数的规律是一个很实用的技巧，可以先找到SG函数的规律再用这个规律快速求SG值，从而解出原题。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展欧几里得算法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文探讨扩展欧几里得算法，这是一个基础而常用的数论算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，欧几里得算法（辗转相除法）是求解两数最大公约数的算法，前文又认识到stein算法用于在高精度下代替欧几里得算法。扩展欧几里得算法又是做什么的呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩展欧几里得算法不仅可以求出两数（假如为a，b）的最大公因数，还可以求出方程$ax+by=gcd(a,b)$的一个特解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在过河的题后注解中，已经认识到了模线性方程解的性质，这里不再重复。下面探讨算法思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑数15和36，它们的欧几里得算法过程如下： 36\div 15=2\cdots \cdots 6\\ 15\div6=2\cdots \cdots 3\\ 6\div 3=2\cdots \cdots 0\\ 3\div 0 =X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以最大公约数为3。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现整个过程中出现了4个算式，对于每一个式子中的被除数和除数，将其设为a、b（比如第一个式子中a=36，第二个中a=15），并设gcd(36，15)=g，考虑a和b的一组特解x1、y1，那么有： ax_1+by_1=g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将这个式子扩展下去。根据带余除法原理，可以把a写成如下形式： a=kb+r,0\leq r]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数论</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂与矩阵方法]]></title>
    <url>%2F2019%2F01%2F20%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E7%9F%A9%E9%98%B5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍矩阵快速幂以及矩阵在OI中的简单应用。本文需要一些线性代数知识作铺垫，这里不再重复。关于快速幂的思想，建议先阅读快速幂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先看这么一道题（洛谷P1307）： 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于Fibonacci数列：1,1,2,3,5,8,13……大家应该很熟悉吧~~~但是现在有一个很“简单”问题：第n项和第m项的最大公约数是多少？ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个正整数n和m。（n,m≤109）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：数据很大 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fn和Fm的最大公约数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于看了大数字就头晕，所以只要输出最后的8位数字就可以了。 输入输出样例Sample input 4 7 Sample output 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决本题需要先认识到一个事实（证明略）： gcd(Fib(n),Fib(m))=Fib(gcd(n,m))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是只需要求出n与m的最大公因数，再找它所对应的一位即可。注意在整个过程中对1e8取模，时间复杂度O(gcd(n,m))。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，对于很大的数（比如本题达到1e9的数量级），循环1e9次显然会超时。于是需要借助矩阵这个工具来简化运算过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵是解决线性问题的利器。所谓运用矩阵工具，就是要善于发现题目中的线性关系。注意到斐波那契数列的递推式为： Fib(n+1)=Fib(n)+Fib(n-1),n\geq 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个典型的线性关系，立即可以得到（用f(x)表示Fib(x)）： \begin{bmatrix} f(n+1)\\ \end{bmatrix}= \begin{bmatrix} 1&1 \end{bmatrix} \begin{bmatrix} f(n)\\ f(n-1) \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现两侧的非常数矩阵形式不同，不利于递推，于是把它扩展为： \begin{bmatrix} f(n+1)\\ f(n) \end{bmatrix}= \begin{bmatrix} 1&1\\ 1&0 \end{bmatrix} \begin{bmatrix} f(n)\\ f(n-1) \end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行如下定义： X(n)=\begin{bmatrix}f(n+1)\\f(n)\end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么有递推关系： X(n)=\begin{bmatrix}1&1\\1&0\end{bmatrix}X(n-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是斐波那契数列的矩阵递推式，反复利用递推公式可以得到： X(n)=\begin{bmatrix}1&1\\1&0\end{bmatrix}^{n-1}\begin{bmatrix}1\\1\end{bmatrix}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是斐波那契数列的矩阵通项公式，问题转化为如何快速求矩阵的幂。结合整数快速幂的思想，仍然可以用倍增方法求解矩阵的幂，将求矩阵乘积次数降至对数级别。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵快速幂与整数快速幂有以下几点区别： 矩阵的平方和乘积更复杂，可以采用朴素的行乘列法则暴力求出。 初始化的值由1改为单位矩阵，即：E_n=\begin{bmatrix}1&0\\0&1\end{bmatrix} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用矩阵快速幂优化，本题迎刃而解。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#define MOD 100000000using namespace std;struct Matrix &#123;//2*2矩阵 long long Main[2][2]&#123;&#125;; Matrix(int a, int b, int c, int d) &#123; Main[0][0] = a, Main[0][1] = b, Main[1][0] = c, Main[1][1] = d; &#125; void operator*=(Matrix x) &#123;//重载乘法运算 long long temp[2][2]; temp[0][0] = (Main[0][0] * x.Main[0][0] + Main[0][1] * x.Main[1][0]) % MOD; temp[0][1] = (Main[0][0] * x.Main[0][1] + Main[0][1] * x.Main[1][1]) % MOD; temp[1][0] = (Main[1][0] * x.Main[0][0] + Main[1][1] * x.Main[1][0]) % MOD; temp[1][1] = (Main[1][0] * x.Main[0][1] + Main[1][1] * x.Main[1][1]) % MOD; Main[0][0] = temp[0][0], Main[0][1] = temp[0][1]; Main[1][0] = temp[1][0], Main[1][1] = temp[1][1]; &#125;&#125;;int gcd(int a, int b) &#123; if (a &lt; b)swap(a, b); if (b == 0)return a; return gcd(b, a % b);&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Matrix sta(1, 1, 1, 0), ans(1, 0, 0, 1);//ans为单位阵 int p = gcd(n, m) - 1;//下计算sta的p次方，矩阵快速幂 while (p &gt; 0) &#123; if ((p &amp; 1) == 1)ans *= sta; sta *= sta; p &gt;&gt;= 1; &#125; cout &lt;&lt; (ans.Main[1][0] + ans.Main[1][1]) % MOD; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stein算法]]></title>
    <url>%2F2019%2F01%2F19%2FStein%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次介绍一种在高精度下求最大公约数的算法——stein算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较常规的gcd算法有辗转相除法和更相减损术，但是后者过慢，前者不利于高精度（因为有大量的除法取余运算，对高精度十分不友好），于是需要一种更高效又易于操作的算法。这便是stein算法，它是更相减损术的改进。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法思想如下（比如求x和y的最大公因数）： 如果两个数均为偶数，则两数均取半，答案为2*gcd(x/2，y/2)。 如果两数中有一方为偶数，一方为奇数（假如x为偶数），则偶数取半，答案为gcd(x/2，y)。 如果两数均为奇数，若x=y则答案即为x；否则若x&gt;y，则答案为gcd(x-y，y)，x&lt;y为gcd(x，y-x)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法正确性很容易证明，这里略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复以上过程即可得到答案。容易发现整个过程中只有除以2，乘法和减法运算，在高精度下容易操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面用洛谷P2152 SuperGCD来应用这个算法。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sheng bill有着惊人的心算能力，甚至能用大脑计算出两个巨大的数的GCD（最大公约 数）！因此他经常和别人比赛计算GCD。有一天Sheng bill很嚣张地找到了你，并要求和你比赛，但是输给Sheng bill岂不是很丢脸！所以你决定写一个程序来教训他。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共两行： 第一行：一个数A。 第二行：一个数B。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行，表示A和B的最大公约数。 输入输出样例Sample input 1254 Sample output 6 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于20%的数据，0 &lt; A , B ≤ 1018。 对于100%的数据，0 &lt; A , B ≤ 1010000。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道很裸的高精度gcd，注意压位（这里压8位），用stein算法就可以快速求出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓压位，就是将10进制数按10k进制数储存在数组中（这里选k=8），从而减小时空消耗的方法。压位后的输出是一大坑点，要格外注意前导0数量的准确判定。压位后的运算过程与朴素10进位方法没有大的差别，要注意提前设置好进位base。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题不要用递归，否则MLE，用数组循环即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;string&gt;#define P 8#define Base 100000000using namespace std;long long s1[10000] = &#123;0&#125;, s2[10000] = &#123;0&#125;, ans[10000] = &#123;0&#125;, temp[10000] = &#123;0&#125;;inline int change(string x) &#123;//化字符串为数字 int s = 0; for (int i = 0; i &lt; x.length(); i++)s = s * 10 + x[i] - '0'; return s;&#125;inline bool isEven(const long long *x) &#123;//判断偶数 return x[1] % 2 == 0;&#125;inline void div(long long *x) &#123;//除以2 int r = 0; for (int i = x[0]; i &gt;= 1; i--) &#123; if (x[i] % 2 == 0) &#123; x[i] = (x[i] + r * Base) / 2; r = 0; &#125; else x[i] = (x[i] + r * Base) / 2, r = 1; &#125; if (x[x[0]] == 0)x[0]--;&#125;inline void times(long long *x) &#123;//x=x*2 int r = 0; for (int i = 1; i &lt;= x[0]; i++)x[i] *= 2, x[i] += r, r = x[i] / Base, x[i] %= Base; if (r != 0)x[++x[0]] = r;&#125;inline int cmp(long long *x, long long *y) &#123;//x&lt;y? if (x[0] &lt; y[0])return 1; if (x[0] &gt; y[0])return -1; for (int i = x[0]; i &gt;= 1; i--) if (x[i] &lt; y[i])return 1; else if (x[i] &gt; y[i])return -1; return 0;//=&#125;inline void times2(long long *x, const long long *y) &#123;//x=x*y for (int i = 1; i &lt;= x[0]; i++) &#123; for (int j = 1; j &lt;= y[0]; j++) &#123; temp[j + i - 1] += x[i] * y[j]; &#125; &#125; long long r = 0; x[0] = y[0] + x[0] - 1; for (int i = 1; i &lt;= x[0]; i++) &#123; long long t = temp[i] + r; x[i] = t % Base; r = t / Base; &#125; while (r != 0)x[++x[0]] = r % Base, r /= Base;&#125;inline void sub(long long *x, long long *y) &#123;//x=x-y for (int i = 1; i &lt;= x[0]; i++) &#123; if (x[i] &gt;= y[i])x[i] -= y[i]; else &#123; x[i] = x[i] + Base - y[i];//不够借位 x[i + 1]--; &#125; &#125; for (int i = x[0]; i &gt;= 1; i--)//重新找右值 if (x[i] != 0) &#123; x[0] = i; return; &#125;&#125;inline void print(long long *x) &#123;//输出x int te; for (int i = x[0]; i &gt;= 1; i--) &#123; if (i == x[0]) cout &lt;&lt; x[i]; else &#123; te = Base / 10; while (te &gt; 0)cout &lt;&lt; x[i] / te, x[i] %= te, te /= 10; &#125; &#125; cout &lt;&lt; endl;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = a.length() - 1; i &gt;= 0; i -= P) &#123;//压位 if (i - P + 1 &gt;= 0)s1[++s1[0]] = change(a.substr(i - P + 1, P)); else s1[++s1[0]] = change(a.substr(0, i + 1)); &#125; for (int i = b.length() - 1; i &gt;= 0; i -= P) &#123;//压位 if (i - P + 1 &gt;= 0)s2[++s2[0]] = change(b.substr(i - P + 1, P)); else s2[++s2[0]] = change(b.substr(0, i + 1)); &#125; ans[1] = ans[0] = 1; while (true) &#123;//stein算法执行 if (isEven(s1) &amp;&amp; isEven(s2))div(s1), div(s2), times(ans); else if (isEven(s1))div(s1); else if (isEven(s2))div(s2); else &#123; int status = cmp(s1, s2); if (status == 0) &#123; times2(ans, s1); print(ans); return 0; &#125; else if (status == 1)sub(s2, s1); else sub(s1, s2); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P.S.据说Python代码就两行…Orz]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3084]Photo]]></title>
    <url>%2F2019%2F01%2F19%2F%E6%B4%9B%E8%B0%B7P3084-Photo%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;农夫约翰决定给站在一条线上的N(1 ≤ N ≤ 200,000)头奶牛制作一张全家福照片，N头奶牛编号1到N。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是约翰拍摄了M(1 ≤ M ≤ 100,000)张照片，每张照片都覆盖了连续一段奶牛：第i张照片中包含了编号ai 到 bi的奶牛。但是这些照片不一定把每一只奶牛都拍了进去。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在拍完照片后，约翰发现了一个有趣的事情：每张照片中都有且仅有一只身上带有斑点的奶牛。约翰意识到他的牛群中有一些斑点奶牛，但他从来没有统计过它们的数量。 根据照片，请你帮约翰估算在他的牛群中最多可能有多少只斑点奶牛。如果无解，输出“-1”。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个整数：N和M。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2到M+1行，两个整数，ai和bi。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，牛群中斑点奶牛的最大数目。如果无解输出-1。 输入输出样例Sample input 5 31 42 53 4 Sample output 1 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这其实是差分约束的题目，也可以用DP做。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定r(i)为包含i这个点的所有区间的左端点最小值-1，l(i)表示在i左侧的所有区间左端点的最大值。这两个量是后面DP的基础，可以用两遍for循环解决。初始化l(i)=0，r(i)=i-1，并在读入数据时预处理。有方程： l(i)=\max\{l(i),l(i-1)\};r(i)=\min\{r(i),r(i+1)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个思路很重要，可以用于一些区间DP的预处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(i)为1~i的奶牛最大数量并且i处必须有奶牛，仅有i=n+1时为i处没有奶牛的值。有状态转移方程： dp(i)=\begin{cases}\max\{dp(k)\}+1,l(i)\leq k \leq r(i)\ \ \ & i\leq n\\ \max\{dp(k)\},l(i)\leq k \leq r(i)\ \ \ & i=n+1 \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果l(i)&gt;r(i)则dp(i)=-inf。最终答案即为dp(n+1)，如果为负输出-1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到l和r都是单调递增的，可以用单调队列优化。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#define N 200000+1#define inf 0x7ffffffusing namespace std;inline int read() &#123; char e = getchar(); int s = 0; while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return s;&#125;int deq[N + 100], fr = 0, ba = -1;int n, m, l[N] = &#123;0&#125;, r[N], dp[N];int x, y;inline void Push(int x) &#123;//单调队列 while (ba &gt;= fr &amp;&amp; dp[deq[ba]] &lt; dp[x])ba--; deq[++ba] = x;&#125;inline int Front(int x) &#123; while (deq[fr] &lt; x)fr++; return deq[fr];&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n + 1; i++)r[i] = i - 1; for (int i = 1; i &lt;= m; i++) &#123; x = read(), y = read(); l[y + 1] = max(l[y + 1], x), r[y] = min(r[y], x - 1); &#125; for (int i = 2; i &lt;= n + 1; i++)l[i] = max(l[i], l[i - 1]); for (int i = n; i &gt;= 1; i--)r[i] = min(r[i], r[i + 1]); dp[0] = 0; int key = 0; for (int i = 1; i &lt;= n + 1; i++) &#123; for (int k = key; k &lt;= r[i]; k++)Push(k); key = r[i] + 1; if (l[i] &gt; r[i])dp[i] = -inf; else if (i &lt;= n)dp[i] = dp[Front(l[i])] + 1; else dp[i] = dp[Front(l[i])]; &#125; if (dp[n + 1] &lt; 0)cout &lt;&lt; -1; else cout &lt;&lt; dp[n + 1]; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LYH注：这法真是妙，深深感受到自己的渺小]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列优化DP]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的日志中提到了单调队列的一个用途——求固定长区间最值。这里介绍单调队列的另一种用途——优化DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在状态转移方程中，有一种方程十分常见，它的形式如下所示： dp(i)=\min/\max\{s(k)\}+c(i),l(i)\leq k \leq r(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里dp由s转移而来（s可以就是dp本身），s的取值范围由l(i)和r(i)确定，c(i)为转移代价，与k的选取无关。在求解这个方程时，需要for一遍i，还要for一遍k才可以得到dp值。如果l和r的距离很大，时间复杂度将达到O(n2)，转移时间消耗不可忽视。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当从小到大递推dp值时，如果发现l和r均单调递增，这时可以用单调队列优化DP过程，降低时间复杂度。这里的单调队列仍然存下标，具体算法如下： 定义开始点key，key初始化为最小的l值，如果从0开始计数则key=l(0)。 对于枚举到的每一个i，将[key，r(i)]的下标加入单调队列，并更新key=r(i)+1。 取队首元素。如果队首元素不在[l(i)，r(i)]中，忽略该元素继续取队首。最终得到的队首元素所指的元素即为最值。 算法正确性证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下证i=k+1时可以求出最值：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若l(k+1)&gt;r(k)，那么由于key更新为r(k)+1≤l(k+1)，易知[l(k+1)，r(k+1)]中的所有元素都在i=k+1时入队，显然可以得到最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若l(k)≤l(k+1)≤r(k)，如果i=k+1的最优解出现在[r(k)+1,r(k+1)]中，那么这一个区间的值一定在i=k+1时入队，一样可以求出最优解。如果i=k+1的最优解出现在[l(k+1)，r(k)]中（假设为p），现证明p这个元素不可能被“剔除”。倘若存在q由于比p更优将p剔除出队列，那么一定有q&gt;p，容易知q也在[l(k+1)，r(k)]中，那么q应该是i=k+1时比p更优的解，这与p最优矛盾。因此p最优时不可能被剔除，最终仍可以得到最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，算法正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单调队列求固定长区间最值其实是这种方法的特殊情况。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四边形不等式]]></title>
    <url>%2F2019%2F01%2F18%2F%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍DP的优化方法之一————四边形不等式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在列状态转移方程时，常常会遇到如下形式的方程： dp(i,j)=\min\{dp(i,k)+dp(k+1,j)\}+m(i,j),i\leq k < j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方程很常见，比如题目合并石子的方程就满足这种形式。m为转移的代价。dp时间复杂度为O(n2)，转移枚举为O(n)，故总体时间复杂度为O(n3)。可以用四边形不等式将其减至O(n2)复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于a≤i&lt;j≤b，总有： m(a,j)+m(i,b)\leq m(i,j)+m(a,b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则称m满足四边形不等式，一句话概括为：交叉小于包含。下面介绍三个重要定理。 【定理一】m满足四边形不等式的充要条件是 $m(i,j)+m(i+1,j+1)≤m(i+1,j)+m(i,j+1),i&lt;j$。 证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然这个不等式是m满足四边形不等式的特殊情形，于是必要性成立，下证充分性。只需证明$m(i,j)+m(i+a,j+b)≤m(i+a,j)+m(i,j+b),i\leq i+a &lt; j \leq j+b$，这里只对i的情况进行讨论，采用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由已知可知，$m(i,j)+m(i+1,j+1)\leq m(i+1,j)+m(i,j+1)$是成立的。假设$m(i,j)+m(i+k,j+1)\leq m(i+k,j)+m(i,j+1)$成立，那么由已知，应有： m(i+k,j)+m(i+k+1,j+1)\leq m(i+k+1,j)+m(i+k,j+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与假设的式子联立，立即得到： m(i,j)+m(i+k,j+1)+m(i+k,j)+m(i+k+1,j+1)\leq m(i+k,j)+m(i,j+1)+m(i+k+1,j)+m(i+k,j+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是： m(i,j)+m(i+k+1,j+1)\leq m(i,j+1)+m(i+k+1,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由归纳法便知$m(i,j)+m(i+a,j+1)≤m(i+a,j)+m(i,j+1)$是成立的，j类似证明即可。两个结合便可证明四边形不等式，于是定理一得证。这个定义可以帮助判断m是否满足四边形不等式。 【定理二】若m满足四边形不等式，则dp也满足四边形不等式。 证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需证明$dp(a,j)+dp(i,b)\leq dp(i,j)+dp(a,b),a\leq i &lt; j\leq b$。采用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=i&lt;i+1=j=b时显然成立。对于固定的a、i，假设在a≤i&lt;j≤b≤P时成立，那么在b=P+1时：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设dp(i,j)在k=x处取得最优解，dp(a,P+1)在k=y处取到最优解，假设x≤y(x &gt;y时类似可证)，那么上式等价于： dp(a,j)+dp(i,P+1)\leq dp(i,x)+dp(x+1,j)+dp(a,y)+dp(y+1,P+1)+m(i,j)+m(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到： dp(a,j)+dp(i,P+1)\leq dp(a,x)+dp(x+1,j)+dp(i,y)+dp(y+1,P+1)+m(a,j)+m(i,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而m满足四边形不等式，也就是有： m(a,j)+m(i,P+1)\leq m(i,j)+m(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于a≤i&lt;x≤y&lt;P+1由归纳假设，有(i=x时也成立)： dp(a,x)+dp(i,y)\leq dp(i,x)+dp(a,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是有： dp(a,x)+dp(x+1,j)+dp(i,y)+dp(y+1,P+1)+m(a,j)+m(i,P+1)\leq dp(i,x)+dp(x+1,j)+dp(a,y)+dp(y+1,P+1)+m(i,j)+m(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么： dp(a,j)+dp(i,P+1)\leq dp(i,j)+dp(a,P+1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是对P+1也成立，由归纳法可知dp也满足四边形不等式。这个定理是定理三的基础。 【定理三】若dp满足四边形不等式，设S(i,j)为dp(i,j)取最优解的k值，那么有$S(i,j-1)\leq S(i,j)\leq S(i+1,j)$ 证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$dp_k(i,j)=dp(i,k)+dp(k+1,j)+m(i,j)，S(i,j)=d$那么：$(dp_k(i+1,j)-dp_d(i+1,j))-(dp_k(i,j)-dp_d(i,j))$$=(dp_k(i+1,j)+dp_d(i,j))-(dp_d(i+1,j)+dp_k(i,j))$$=(dp(i+1,k)+dp(k,j)+dp(i,d)+dp(d,j)+m(i+1,j)+m(i,j))-\\(dp(i+1,d)+dp(d,j)+dp(i,k)+dp(k,j)+m(i+1,j)+m(i,j))$$=(dp(i+1,k)+dp(i,d))-(dp(i+1,d)+dp(i,k))$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若k&lt;d，那么有i&lt;i+1&lt;k&lt;d。由dp的四边形不等式，有： dp(i,k)+dp(i+1,d)\leq dp(i+1,k)+dp(1,d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是$(dp_k(i+1,j)-dp_d(i+1,j))-(dp_k(i,j)-dp_d(i,j))\geq 0$，即： dp_k(i+1,j)-dp_d(i+1,j)\geq dp_k(i,j)-dp_d(i,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于S(i,j)=d，故$dp_k(i,j)\geq dp_d(i,j)$，所以： dp_k(i+1,j)\geq dp_d(i+1,j)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子说明，k&lt;d时不能取到比k=d更优的解，所以S(i+1,j)≥d。S(i,j-1)≤d同理可证，定理三成立。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定理三表明，k的取值可以优化到一个很小的范围内，即[S(i,j-1),S(i+1,j)]，开一个数组S储存这个结果，时间复杂度便压缩到O(n2)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是对于最大值又如何做呢？最大值不能用四边形不等式，但是它有另一个性质：最大值的k值一定在端点处取到。这个性质仍然可以帮助优化算法。容易验证石子合并的m是满足四边形不等式的，于是可以用四边形不等式优化DP过程，下面给出优化版代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#define N 100*2+1using namespace std;int n, op[N], sum[N] = &#123;0&#125;;int dp1[N][N], dp2[N][N], S[N][N];int ans1 = 0x7fffffff, ans2 = -1;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; op[i + n] = op[i]; &#125; for (int i = 1; i &lt;= 2 * n; i++)sum[i] = op[i] + sum[i - 1];//前缀和 for (int j = 2 * n; j &gt;= 1; j--) &#123;//最大值 for (int z = j; z &lt;= 2 * n; z++) &#123; if (j == z)dp2[j][z] = 0; else dp2[j][z] = max(dp2[j + 1][z], dp2[j][z - 1]) + sum[z] - sum[j - 1]; &#125; &#125; for (int j = 2 * n; j &gt;= 1; j--) &#123;//最小值 for (int z = j; z &lt;= 2 * n; z++) &#123; if (j == z)S[j][z] = j, dp1[j][z] = 0; else &#123; dp1[j][z] = 0x7fffffff; for (int k = S[j][z - 1]; k &lt;= S[j + 1][z] &amp;&amp; k &lt; z; k++) &#123; if (dp1[j][k] + dp1[k + 1][z] + sum[z] - sum[j - 1] &lt; dp1[j][z]) dp1[j][z] = dp1[j][k] + dp1[k + 1][z] + sum[z] - sum[j - 1], S[j][z] = k; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++)ans1 = min(ans1, dp1[i][i + n - 1]), ans2 = max(ans2, dp2[i][i + n - 1]); cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于环的处理，仍然是剪环为链，但是这里的做法比原先的做法高明的多（直接将n个石子扩展为2n个，再寻找答案），于是时间复杂度降了一维。再用四边形不等式降一维，总体时间复杂度便为O(n2)。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P3652]时间复杂度]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%B4%9B%E8%B0%B7P3652-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOIP2017 D1 T2原题，难度较大的模拟 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。A++语言的循环结构如下： F i x y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环体E &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中F i x y表示新建变量 i（变量 i 不可与未被销毁的变量重名）并初始化为 x， 然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 i 都会被修改成 i +1，一旦 i 大于 y 终止循环。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x 和 y 可以是正整数（x 和 y 的大小关系不定）或变量 n。n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件第一行一个正整数 t，表示有 t（t≤10）个程序需要计算时间复杂度。 每个程序只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构 允许嵌套。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来每个程序的第一行包含一个正整数 L 和一个字符串，L 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为n^w，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 L 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 i 是一个小写字母（保证不为n），表示新建的变量名，x 和 y 可能是正整数或 n ，已知若为正整数则一定小于 100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序行若以E开头，则表示循环体结束。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件共 t 行，对应输入的 t 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入输出样例Sample input 82 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE Sample output YesYesERRYesNoYesYesERR 说明【输入输出样例解释1】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个程序 i 从 1 到 1 是常数复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个程序 x 从 1 到 n 是 n 的一次方的复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个程序有一个 F 开启循环却没有 E 结束，语法错误。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四个程序二重循环，n 的平方的复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五个程序两个一重循环，n 的一次方的复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第六个程序第一重循环正常，但第二重循环开始即终止（因为n远大于100，100大于4）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第七个程序第一重循环无法进入，故为常数复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第八个程序第二重循环中的变量 x 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 【数据规模与约定】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 L/2 行一定为以 F 开头的语句，第 L/2+1行至第 L 行一定为以 E 开头的语句，L≤10，若 x、y 均为整数，x 一定小于 y，且只有 y 有可能为 n。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据：不存在语法错误，L≤100，且若 x、y 均为整数，x 一定小于 y， 且只有 y 有可能为 n。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于70%的数据：不存在语法错误，L≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据：L≤100。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路还是比较清晰的，用栈模拟循环嵌套过程，并不断记录已经存在的变量。详细过程见代码注释。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;bool vis[26];stack&lt;int&gt; sta;inline int find(string x) &#123;//字符串解析 if (x[2] == '1')return 0; int s = 0; for (int i = 4; x[i] != ')'; i++)s = s * 10 + x[i] - '0'; return s;&#125;inline int solve(string x, string y) &#123;//循环开始结束时间解析，0表示可执行的常数次数，1表示可执行的线性次数，-1表示不可执行 if (x[0] == 'n' &amp;&amp; y[0] == 'n')return 0; if (y[0] == 'n')return 1;//一定可以执行，与n成正比 if (x[0] == 'n')return -1;//一定不能被执行 if (x.length() &gt; y.length())return -1; if (x.length() &lt; y.length())return 0;//可以被执行，常数复杂度 for (int i = 0; i &lt; x.length(); i++)if (x[i] &lt; y[i])return 0; else if (x[i] &gt; y[i])return -1; return 0;//x=y，常数复杂度&#125;int main() &#123; int T, L, ans0, ans, depth; //T 样例数、L 行数、ans0 给定的时间复杂度答案(只存指数，O(1)存0)、ans 实际的答案(语法错误即为-1)，depth为有效深度 //有效深度指可以被执行的并且与n有线性时间关系的循环嵌套层数，ans就是depth的最大值 bool key;//是否会执行 string op, n1, n2; char e; cin &gt;&gt; T; for (int ti = 0; ti &lt; T; ti++) &#123; cin &gt;&gt; L &gt;&gt; op; ans0 = find(op), memset(vis, 0, sizeof(vis)), ans = 0, key = true, depth = 0;//初始化 while (!sta.empty())sta.pop();//清空栈 for (int i = 0; i &lt; L; i++) &#123;//逐行读取 cin &gt;&gt; e;// if (e == 'E') &#123;//循环结束标志 if (sta.empty())ans = -1;//栈已空，ERR else &#123; if (sta.top() / 100 == 1)key = true, vis[sta.top() - 100] = false;//找到不可执行开始符，标记又可以执行 else if (sta.top() / 100 == 2) &#123;//找到有效深度标识符 if (key)depth--;//可以被执行的情况下深度减一 vis[sta.top() - 200] = false; &#125; else vis[sta.top()] = false;//直接去除重名标记 sta.pop();//出栈 &#125; if (ans == -1)continue;//语法错误跳过 &#125; else &#123;//循环开始标志 cin &gt;&gt; e &gt;&gt; n1 &gt;&gt; n2; if (vis[e - 'a'])ans = -1;//重名，ERR else vis[e - 'a'] = true;//加上重名限制 if (ans == -1)continue;//已经有语法错误，后面跳过即可 int temp = solve(n1, n2);//储存循环结果 if (temp == 1) &#123;//随n线性时间复杂度情况 if (key)depth++;//如果可以执行，更新有效深度 sta.push(200 + e - 'a');//入栈，打上有效深度标记 &#125; else if (temp == -1) &#123;//不能执行 if (key)sta.push(100 + e - 'a'), key = false;//标记不可执行开始符，标记key，之后不可执行 else sta.push(e - 'a'); &#125; else sta.push(e - 'a');//常数复杂度不影响结果，不更新有效深度，直接入栈即可 &#125; ans = max(ans, depth);//ans在不为-1时记录最大有效深度 &#125; if (!sta.empty())ans = -1;//栈没空，说明少E，ERR if (ans == -1)cout &lt;&lt; "ERR" &lt;&lt; endl; else if (ans0 != ans)cout &lt;&lt; "No" &lt;&lt; endl; else cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2467]地精部落]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%B4%9B%E8%B0%B7P2467-%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录一道简单的省选题 难度：省选/NOI-（个人感觉难度虚高） 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传说很久以前，大地上居住着一种神秘的生物：地精。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为N的山脉H可分为从左到右的N段，每段有一个独一无二的高度Hi，其中Hi是1到N之间的正整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;地精们希望这N段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你希望知道，长度为N的可能有地精居住的山脉有多少种。两座山脉A和B不同当且仅当存在一个i，使得Ai≠Bi。由于这个数目可能很大，你只对它除以P的余数感兴趣。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件goblin.in仅含一行，两个正整数N, P。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件goblin.out仅含一行，一个非负整数，表示你所求的答案对P取余之后的结果。 输入输出样例Samplle input 4 7 Sample output 3 说明【样例说明】共有十种可能的情况，分别为：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1324&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1423&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2143&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2314&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2413&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3241&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3412&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4132&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4231&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加下划线的数位表示可以设立瞭望台的山峰，其它表示可以设立酒馆的山谷。【数据规模和约定】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于20%的数据，满足N≤10；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于40%的数据，满足N≤18；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于70%的数据，满足N≤550；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，满足3≤N≤4200，P≤1e9。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以说是一道很水的省选题了。考察动态规划，题目本质上是对于一个数N，求1~N能够组成的大小相间的排列方案数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(x，p，y)表示长度为x，末尾数字作p(0为山谷、1为山峰)，末尾数不超过y时的方案数，则有状态转移方程： dp(x,0,i)=dp(x,0,i-1)+dp(x-1,1,x-1)-dp(x-1,1,i-1),1\leq i \leq x\\ dp(x,1,i)=dp(x,1,i-1)+dp(x-1,0,i-1),1\leq i \leq x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对状态转移方程的理解是本题唯一难点。之后将数组第一维滚动掉，最终空间复杂度O(N)，时间复杂度O(N2)。123456789101112131415161718192021#include&lt;iostream&gt;#define N 4200+1using namespace std;int n, mod, dp[2][2][N] = &#123;0&#125;;bool k = false;//0山谷，1山峰int main() &#123; cin &gt;&gt; n &gt;&gt; mod; dp[0][0][2] = dp[0][0][1] = dp[0][1][2] = 1; for (int i = 3; i &lt;= n; i++) &#123; k = !k; for (int j = 1; j &lt;= i; j++) &#123; dp[k][0][j] = (dp[k][0][j - 1] + (dp[!k][1][i - 1] - dp[!k][1][j - 1] + mod) % mod) % mod; dp[k][1][j] = (dp[k][1][j - 1] + dp[!k][0][j - 1]) % mod; &#125; &#125; cout &lt;&lt; (dp[k][0][n] + dp[k][1][n]) % mod; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2331]最大子矩阵]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%B4%9B%E8%B0%B7P2331-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。注意：选出的k个子矩阵不能相互重叠。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为n,m,k（1≤n≤100,1≤m≤2,1≤k≤10），接下来n行描述矩阵每行中的每个元素的分值(每个元素的分值的绝对值不超过32767)。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一行为k个子矩阵分值之和最大为多少。 输入输出样例Sample input 3 2 21 -32 3-2 3 Sample output 9 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先好好读题，m只能取1或2（坑了很多人了！）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于构造数据的缘故，本题考虑和不考虑空矩阵（分值为0）都是可以的。如果考虑空矩阵，题意即为选取不超过k个不重叠的子矩阵使得分值之和最大。介绍两种解法，其中第一种解法不考虑空矩阵，第二种考虑。 辣鸡解法（也就是我第一次的解法） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我第一次AC本题时用的方法，时间空间复杂度都很高。但是因为数据量太小，轻松水过~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路是矩阵先划分再分配。如果规定dp(x1,y1,x2,y2,p)表示从坐标(x1，y1)到(x2，y2)的矩阵区域中选取p个子矩阵时的分值最大值，那么在p&gt;1时，一定可以将这p个子矩阵划分到两个区域中。既可以横向划分（有x2-x1种情况）也可以纵向划分（y1≠y2时才可以划分，显然这时仅有1种情况），之后再对这两个划分区域进行子矩阵数量的分配，注意分配时不要超出区域最大承受的范围（因为没有考虑空矩阵）。本方法难点在于如何求解p=1时的情况，思路是先用dp手段求连续区间的最大值（要限制左端点），需要求三次（第一列，第二列以及两列对应元素和），再在这些dp数据中找到最大值即可。注意到这里找最大值是一个区间最值问题，用ST表维护。总体时间复杂度O(kn3m2)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int dp[100][2][100][2][11] = &#123;0&#125;, dp2[2][100][100], op[100][2], op2[100] = &#123;0&#125;, dp3[100][100], n, m, k;int ST[2][100][100][10], ST2[100][100][10];int Log[101], bin[10];int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; op[i][j]; dp2[j][i][i] = op[i][j]; op2[i] += op[i][j]; &#125; for (int i = 0; i &lt; n; i++) &#123;//求区间连续最大值 for (int j = i; j &lt; n; j++) &#123; if (j == i)dp2[0][i][i] = op[i][0], dp2[1][i][i] = op[i][1], dp3[i][j] = op2[i]; else &#123; if (dp2[0][i][j - 1] &lt; 0)dp2[0][i][j] = op[j][0]; else dp2[0][i][j] = op[j][0] + dp2[0][i][j - 1]; if (dp2[1][i][j - 1] &lt; 0)dp2[1][i][j] = op[j][1]; else dp2[1][i][j] = op[j][1] + dp2[1][i][j - 1]; if (dp3[i][j - 1] &lt; 0)dp3[i][j] = op2[j]; else dp3[i][j] = op2[j] + dp3[i][j - 1]; &#125; ST[0][i][j][0] = dp2[0][i][j], ST[1][i][j][0] = dp2[1][i][j], ST2[i][j][0] = dp3[i][j]; &#125; &#125; Log[0] = -1, bin[0] = 1; for (int i = 1; i &lt;= 100; i++)Log[i] = Log[i / 2] + 1; for (int i = 1; i &lt; 10; i++)bin[i] = bin[i - 1] * 2;//ST表初始化 for (int i = 0; i &lt; n; i++) for (int j = 1; j &lt;= Log[n]; j++) for (int p = i; p &lt; n; p++) if (p + bin[j] &lt;= n) &#123; ST[0][i][p][j] = max(ST[0][i][p][j - 1], ST[0][i][p + bin[j - 1]][j - 1]); ST[1][i][p][j] = max(ST[1][i][p][j - 1], ST[1][i][p + bin[j - 1]][j - 1]); ST2[i][p][j] = max(ST2[i][p][j - 1], ST2[i][p + bin[j - 1]][j - 1]); &#125; for (int l = 1; l &lt;= k; l++) &#123;//数量枚举 for (int x1 = 0; x1 &lt; n; x1++) &#123; for (int y1 = 0; y1 &lt; m; y1++) &#123; for (int x2 = x1; x2 &lt; n; x2++) &#123; for (int y2 = y1; y2 &lt; m; y2++) &#123; dp[x1][y1][x2][y2][l] = -0x7fffffff; if (l == 1) &#123; int len = x2 - x1 + 1; if (y1 == 0) dp[x1][y1][x2][y2][l] = max(ST[0][x1][x1][Log[len]], ST[0][x1][x2 - bin[Log[len]] + 1][Log[len]]); if (y2 == 1) dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], max(ST[1][x1][x1][Log[len]], ST[1][x1][x2 - bin[Log[len]] + 1][Log[len]])); if (y1 != y2) dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], max(ST2[x1][x1][Log[len]], ST2[x1][x2 - bin[Log[len]] + 1][Log[len]])); &#125; else &#123; for (int i = x1; i &lt; x2; i++) &#123; int last = min(l, (i - x1 + 1) * (y2 - y1 + 1)); for (int j = max(0, l - (x2 - i) * (y2 - y1 + 1)); j &lt;= last; j++)//分配 dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], dp[x1][y1][i][y2][j] + dp[i + 1][y1][x2][y2][l - j]); &#125; if (y1 != y2) &#123; int last = min(l, x2 - x1 + 1); for (int i = max(0, l + x1 - x2 - 1); i &lt;= last; i++) dp[x1][y1][x2][y2][l] = max(dp[x1][y1][x2][y2][l], dp[x1][0][x2][0][i] + dp[x1][1][x2][1][l - i]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[0][0][n - 1][m - 1][k]; return 0;&#125; 更好的解法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;划分为m=1和m=2两种情况。m=1时就是一个改编的连续区间和最值问题，直接上DP求出即可。方法是令dp(x，p)表示在序号为1~x（从1开始计数）的区间中找到不超过p个连续子区间分值之和的最大值，那么有状态转移方程： dp(x，p)=\max\{\max\{dp(i,p),dp(i,p-1)+S(i+1,x)\}\},0\leq i < x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S(a，b)为[a，b]的分值之和，用前缀和维护。初始化dp(1，i)=max(0,value(1,1))(1≤i≤k)，其余为0，递推即可。答案即为dp(n，k)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m=2时令dp(i，j，p)表示从第一列前i行，第二列前j行组成的区域中选取不超过p个子矩阵的分值之和最大值。在末行元素不选时有： dp(i,j,p)=\max\{dp(i-1,j,p),dp(i,j-1,p)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里类似最长公共子序列的解法。而选取第一列末行元素时有： dp(i,j,p)=\max\{dp(l,j,p-1)+S1(l+1,i)\},0\leq l < i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S1(a，b)表示第一列区间[a，b]的分值之和，同样用前缀和维护。同理可得选取第二列末行元素时有： dp(i,j,p)=\max\{dp(i,l,p-1)+S2(l+1,j)\},0\leq l < j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S2维护第二列区间分值之和。特殊地，在i=j时，可以将它们同时选取，分到同一个子矩阵中： dp(i,j,p)=\max\{dp(l,l,p-1)+S1(l+1,i)+S2(l+1,j)\},0\leq l < i=j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从它们当中找到最大值即可，初始化方法类似m=1时的情形。答案即为dp(n，n，k)，时间复杂度为O(knm+1)。这种方法代码量较小，效率较高。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;int op[101][3], dp1[101][11] = &#123;0&#125;, dp2[101][101][11] = &#123;0&#125;, sum[3][101] = &#123;0&#125;;int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; op[i][j]; if (i == 1)sum[j][i] = op[i][j];//前缀和 else sum[j][i] = sum[j][i - 1] + op[i][j]; &#125; &#125; if (m == 1) &#123; for (int i = 1; i &lt;= k; i++)dp1[1][i] = max(0, op[1][1]); for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; for (int p = i - 1; p &gt;= 0; p--) &#123; dp1[i][j] = max(dp1[i][j], dp1[p][j - 1] + sum[1][i] - sum[1][p]); dp1[i][j] = max(dp1[i][j], dp1[p][j]); &#125; &#125; &#125; cout &lt;&lt; dp1[n][k]; &#125; else &#123; for (int i = 1; i &lt;= k; i++)dp2[0][1][i] = max(0, op[1][2]), dp2[1][0][i] = max(0, op[1][1]); for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (!i &amp;&amp; !j)continue; for (int p = 1; p &lt;= k; p++) &#123; if (i &gt; 0)dp2[i][j][p] = max(dp2[i][j][p], dp2[i - 1][j][p]);//不选的情况 if (j &gt; 0)dp2[i][j][p] = max(dp2[i][j][p], dp2[i][j - 1][p]); for (int z = i - 1; z &gt;= 0; z--)//第一列枚举 dp2[i][j][p] = max(dp2[i][j][p], dp2[z][j][p - 1] + sum[1][i] - sum[1][z]); for (int z = j - 1; z &gt;= 0; z--)//第二列枚举 dp2[i][j][p] = max(dp2[i][j][p], dp2[i][z][p - 1] + sum[2][j] - sum[2][z]); if (i == j) &#123; for (int z = i - 1; z &gt;= 0; z--)//全枚举 dp2[i][j][p] = max(dp2[i][j][p], dp2[z][z][p - 1] + sum[1][i] - sum[1][z] + sum[2][i] - sum[2][z]); &#125; &#125; &#125; &#125; cout &lt;&lt; dp2[n][n][k]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>ST表</tag>
        <tag>动态规划</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2157]学校食堂]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%B4%9B%E8%B0%B7P2157-%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题难度不算小，2007山东省选题。 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是a，这一道为b，则做这道菜所需的时间为（a or b）-（a and b），而做第一道菜是不需要计算时间的。其中，or 和and 表示整数逐位或运算及逐位与运算，C语言中对应的运算符为“|”和“&amp;”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第i 个同学，最多允许紧跟他身后的Bi 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 现在，小F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数C，表示测试点的数据组数。 每组数据的第一行包含一个正整数N，表示同学数。 每组数据的第二行起共N行，每行包含两个用空格分隔的非负整数Ti和Bi，表示按队伍顺序从前往后的每个同学所需的菜的口味和这个同学的忍受度。 每组数据之间没有多余空行。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含C行，每行一个整数，表示对应数据中食堂完成所有菜所需的最少时间。 输入输出样例Sample input 255 24 112 03 32 225 04 0 Sample output 161 说明对于第一组数据：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同学1允许同学2或同学3在他之前拿到菜；同学2允许同学3在他之前拿到菜；同学3比较小气，他必须比他后面的同学先拿菜……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种最优的方案是按同学3、同学2、同学1、同学4、同学5做菜，每道菜所需的时间分别是0、8、1、6及1。【数据规模和约定】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，满足1 ≤ N ≤ 20。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，满足1 ≤ N ≤ 1,000，0 ≤ Ti ≤ 1,000，0 ≤ Bi ≤ 7，1 ≤ C ≤ 5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在30%的数据，满足0 ≤ Bi ≤ 1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在65%的数据，满足0 ≤ Bi ≤ 5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在45%的数据，满足0 ≤ Ti ≤ 130。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察状态压缩DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(r,k,p)表示从第r（从0开始）个人开始，上一个人打饭的人距离r位置为k，且r后面七个人（含自己）的打饭状态为p（状态压缩，0表示未打饭、1表示已经打饭），那么可知状态转移方程： dp(r,k,p)=\begin{cases} dp(r+1,k-1,p>>1)\ \ \ & p\&1=1\\ \min\{dp(r,l,p|(1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列与固定长区间最值]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%B8%8E%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里探讨一种求固定长度区间最值的高效方法—用单调队列求最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先认识什么是单调队列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列是一种先进先出(FIFO)的线性表，而单调队列则是指队列中元素符合单调性的特殊队列，可以分为单调增和单调减队列。前者队首元素总是最大的，后者总是最小的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当有元素需要加入队列时（这里以单调增队列为例），我们需要考察这个元素与队尾元素的大小关系。如果它比队尾元素小，则元素入队后仍符合单调性，直接入队即可；若否，则队尾元素出队，然后继续比较，直到队空或队尾元素大于或等于待入队元素，之后该元素入队。也就是说，单调队列中有元素入队时，会把比它小的所有元素“挤出”。这里还可以发现入队操作需要访问队尾元素，这是STL中的queue做不到的。通常单调队列用STL中的deque(双向队列)实现，当然也可以手写。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如何用单调队列维护固定长度的区间最值？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓固定长度区间最值，即是给定一段区间(长度为n)，维护区间内所有长度为m的区间最值。通常用一个一维数组（比如ans[]）来记录结果。这时ans[i]表示[i,i+n-1]的最值。这里值得注意的是，用单调队列维护固定长区间最值时，队列中存放的不是元素本身，而是元素在区间中的编号，检验大小关系时，利用编号到元素的映射里比较。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体算法如下： 区间前n个元素入单调队列，这时队首所指元素即为前n个元素最值，将其记录在ans[0]中（下标从0开始）。 对于第n+1以及以后的元素（假设编号是k），该元素先入队，再取队首元素，如果队首元素（是一个编号）不在区间[k-n+1,k]中，那么忽略该元素，直到队首元素在区间中，这个编号所指元素即为最值。 附算法正确性证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,n-1]的最值显然可以得到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设单调队列中成功地维护了[a,a+n-1]的最值p，在第a+n个元素入队后，下证明队列可以维护[a+1,a+n]的最值q。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果p就是编号为a的元素。q编号在[a+1,a+n]中，假如有q≤p。编号在[a+1,a+n]中的所有元素x都应满足x≤q。根据单调队列的构造方法，可知q一定不会被“挤出”，并且一定在p的紧跟着的后面。根据算法，q因为编号不在[a+1,a+n]中，会被忽略，然后立刻得到q，即为最值，成立。若q&gt;p，则q会将p“挤出”并且其编号成为队首，并且之后一定不会再被“挤出”，取出即为最值，成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果p编号在[a+1,a+n-1]中，只需比较编号为a+n的元素x和p即可。如果x≤p，则p仍然在队首，取出即为最值。若x&gt;p，则x会将p“挤出”，于是x成为队首，取出即为最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此算法正确。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>区间最值</tag>
        <tag>单调队列</tag>
        <tag>区间</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2216]理想的正方形]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%B4%9B%E8%B0%B7P2216-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题目为矩阵最值问题的模板题 难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个a*b的整数组成的矩阵，现请你从中找出一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为3个整数，分别表示a,b,n的值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅一个整数，为a*b矩阵中所有“n*n正方形区域中的最大整数和最小整数的差值”的最小值。 输入输出样例Sample input 5 4 21 2 5 60 17 16 016 17 2 12 10 2 11 2 2 2 Sampe output 1 说明问题规模 矩阵中的所有数都不超过1,000,000,000 20%的数据2≤a,b≤100,n≤a,n≤b,n≤10 100%的数据2≤a,b≤1000,n≤a,n≤b,n≤100 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一道很好的矩阵最值问题。下面介绍3种方法。 暴力DP法（不能AC）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果用dp(x，y，k)表示以坐标(x，y)为左上方点，边长为k的方阵最大值，显然有状态转移方程（最小值类比）： dp(x,y,k)=\max\{dp(x+1,y,k-1),dp(x,y+1,k-1),dp(x+1,y+1,k-1)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种思想即是将大方阵分成了三个小方阵，并且这三个小方阵可以覆盖原来的大方阵。按照该方程递推，即可以得出答案。时间复杂度O(abn)，预计得分60，开O2优化可以AC。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三维数组过大会爆空间，需要滚动数组优化。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAX 1000using namespace std;unsigned int op[MAX][MAX], a, b, n, dpMax[MAX][MAX][2], dpMin[MAX][MAX][2];bool key = false;int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; s = s * 10 + e - '0'; e = getchar(); &#125; return s;&#125;int main() &#123; a = read(), b = read(), n = read(); memset(dpMax, 0, sizeof(dpMax)), memset(dpMin, -1, sizeof(dpMin)); for (int i = 0; i &lt; a; i++) &#123; for (int j = 0; j &lt; b; j++)op[i][j] = read(); &#125; unsigned int ans = dpMin[0][0][0]; for (int k = 1; k &lt;= n; k++) &#123; for (int i = a - k; i &gt;= 0; i--) &#123; for (int j = b - k; j &gt;= 0; j--) &#123; if (k == 1)dpMax[i][j][key] = dpMin[i][j][key] = op[i][j]; else &#123; dpMax[i][j][key] = max(op[i][j], max(dpMax[i + 1][j][!key],max(dpMax[i][j + 1][!key], dpMax[i + 1][j + 1][!key]))); dpMin[i][j][key] = min(op[i][j], min(dpMin[i + 1][j][!key],min(dpMin[i][j + 1][!key], dpMin[i + 1][j + 1][!key]))); &#125; if (k == n)ans = min(ans, dpMax[i][j][key] - dpMin[i][j][key]); &#125; &#125; key = !key; &#125; cout &lt;&lt; ans; return 0;&#125; 倍增DP法（二维ST表）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前的日志记录了一维ST表。建立ST表是一种基于倍增思想的求区间最值方法，本质上是DP。这里将一维ST表推广到二维。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令ST(x，y，k)表示以坐标(x，y)为左上方点，边长为2k的方阵的最大值。那么有状态转移方程： ST(x,y,k)=\max\{ST(x,y,k),ST(x+bin(k-1),y,k-1),ST(x,y+bin(k-1),k-1),ST(x+bin(k-1),y+bin(k-1),k-1)\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方程容易理解，这里是将大方阵分成四个等大的小方阵，它们彼此没有交集但覆盖了整个大方阵。根据方程递推即可，重点在于如何用ST表求边长为n的方阵最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一维ST表，应将方阵化为四个小方阵。容易得出边长为n的方阵最值即为： \max\{ST(x,y,log(n)),ST(x+n-bin(log(n)),y,log(n)),ST(x,y+n-bin(log(n)),log(n)),ST(x+n-bin(log(n)),y+n-bin(log(n)),log(n))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log以及bin与一维ST表相同，详见一维ST表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最小值类比。时间复杂度O(ablog(n))。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX 1000using namespace std;int a, b, n, op[MAX][MAX], ST1[MAX][MAX][10], ST2[MAX][MAX][10];int bin[10], log[101];inline int read() &#123;//读入优化 char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; s = s * 10 + e - '0'; e = getchar(); &#125; return s;&#125;int main() &#123; a = read(), b = read(), n = read(); for (int i = 0; i &lt; a; i++) for (int j = 0; j &lt; b; j++) &#123; op[i][j] = read(); ST1[i][j][0] = ST2[i][j][0] = op[i][j]; &#125; log[0] = -1, bin[0] = 1; for (int i = 1; i &lt;= 100; i++)log[i] = log[i / 2] + 1;//log for (int i = 1; i &lt; 10; i++)bin[i] = bin[i - 1] * 2;//bin for (int k = 1; k &lt;= log[n]; k++) &#123; for (int i = 0; i &lt; a; i++) &#123; for (int j = 0; j &lt; b; j++) &#123; if (i + bin[k] &gt; a || j + bin[k] &gt; b)continue; ST1[i][j][k] = max(ST1[i][j][k - 1],max(ST1[i + bin[k - 1]][j][k - 1],max(ST1[i][j + bin[k - 1]][k - 1], ST1[i + bin[k - 1]][j + bin[k - 1]][k - 1]))); ST2[i][j][k] = min(ST2[i][j][k - 1],min(ST2[i + bin[k - 1]][j][k - 1],min(ST2[i][j + bin[k - 1]][k - 1], ST2[i + bin[k - 1]][j + bin[k - 1]][k - 1]))); &#125; &#125; &#125; int ans = 0x7fffffff; for (int i = 0; i &lt;= a - n; i++) &#123; for (int j = 0; j &lt;= b - n; j++) &#123; int maxn = max(ST1[i][j][log[n]],max(ST1[i + n - bin[log[n]]][j][log[n]],max(ST1[i][j + n - bin[log[n]]][log[n]],ST1[i + n - bin[log[n]]][j + n - bin[log[n]]][log[n]]))); int minn = min(ST2[i][j][log[n]],min(ST2[i + n - bin[log[n]]][j][log[n]],min(ST2[i][j + n - bin[log[n]]][log[n]],ST2[i + n - bin[log[n]]][j + n - bin[log[n]]][log[n]]))); ans = min(ans, maxn - minn); &#125; &#125; cout &lt;&lt; ans; return 0;&#125; 单调队列法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单调队列可以维护固定长度的区间最值，可以用单调队列维护每一行长度为n的所有区间最值，由此可以得到一个二维表(行数为a，列数为b-n+1)。在这个二维表上再用单调队列维护每一列长度为n的所有区间最值，又可以得到一个二维表(行数为a-n+1，列数为b-n+1)，它记录的即是所有边长为n的方阵的最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单调队列维护固定区间最值详见这篇日志。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;cstdio&gt;#define MAX 1000using namespace std;deque&lt;int&gt; q1, q2;int a, b, n, op[MAX][MAX], X[MAX][MAX], x[MAX][MAX], Y[MAX][MAX], y[MAX][MAX];inline int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); int s = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; s = s * 10 + e - '0'; e = getchar(); &#125; return s;&#125;inline void push1(int x, int y) &#123;//单调增队列 while (!q1.empty() &amp;&amp; op[x][q1.back()] &lt; op[x][y])q1.pop_back(); q1.push_back(y);&#125;inline void push2(int x, int y) &#123;//单调减队列 while (!q2.empty() &amp;&amp; op[x][q2.back()] &gt; op[x][y])q2.pop_back(); q2.push_back(y);&#125;inline void push3(int x, int y) &#123; while (!q1.empty() &amp;&amp; X[q1.back()][y] &lt; X[x][y])q1.pop_back(); q1.push_back(x);&#125;inline void push4(int x0, int y0) &#123; while (!q2.empty() &amp;&amp; x[q2.back()][y0] &gt; x[x0][y0])q2.pop_back(); q2.push_back(x0);&#125;inline int front1(int x) &#123; while (q1.front() &lt;= x)q1.pop_front(); return q1.front();&#125;inline int front2(int x) &#123; while (q2.front() &lt;= x)q2.pop_front(); return q2.front();&#125;int main() &#123; a = read(), b = read(), n = read(); for (int i = 0; i &lt; a; i++) for (int j = 0; j &lt; b; j++)op[i][j] = read(); for (int i = 0; i &lt; a; i++) &#123; q1.clear(), q2.clear(); for (int j = 0; j &lt; n; j++)push1(i, j), push2(i, j); X[i][0] = op[i][front1(-1)], x[i][0] = op[i][front2(-1)]; for (int poi = 1, j = n; j &lt; b; j++, poi++) push1(i, j), push2(i, j), X[i][poi] = op[i][front1(j - n)], x[i][poi] = op[i][front2(j - n)]; &#125; for (int i = 0; i &lt;= b - n; i++) &#123; q1.clear(), q2.clear(); for (int j = 0; j &lt; n; j++)push3(j, i), push4(j, i); Y[i][0] = X[front1(-1)][i], y[i][0] = x[front2(-1)][i]; for (int poi = 1, j = n; j &lt; a; j++, poi++) push3(j, i), push4(j, i), Y[i][poi] = X[front1(j - n)][i], y[i][poi] = x[front2(j - n)][i]; &#125; int ans = 0x7fffffff; for (int i = 0; i &lt;= b - n; i++) &#123; for (int j = 0; j &lt;= a - n; j++)ans = min(ans, Y[i][j] - y[i][j]); &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>区间最值</tag>
        <tag>ST表</tag>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>区间</tag>
        <tag>队列</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1415]拆分数列]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%B4%9B%E8%B0%B7P1415-%E6%8B%86%E5%88%86%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[作者Lyh注：本题解法并不优&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录一道费一天时间才A的一道省选难度题 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出一列数字，需要你添加任意多个逗号将其拆成若干个严格递增的数。如果有多组解，则输出使得最后一个数最小的同时，字典序最大的解（即先要满足最后一个数最小；如果有多组解，则使得第一个数尽量大；如果仍有多组解，则使得第二个数尽量大，依次类推……）。【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于10%的数据，输入长度≤5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，输入长度≤15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，输入长度≤50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，输入长度≤500 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，为初始的数字。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，为拆分之后的数列。每个数之间用逗号分隔。行尾无逗号。 输入输出样例Sample input [1]3456[2]3546[3]3526[4]0001[5]100000101 Sample output [1]3,4,5,6[2]35,46[3]3,5,26[4]0001[5]100,000101 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题还是有难度的，考察动态规划上的字符串问题。答案字典序最大和末尾数最小限制是坑点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，找到末尾最小的那个数。若记dp1(i，r)表示第i个元素前已经加了逗号，是否在区间[0,i-1]存在一种加逗号方案使得它们严格递增且小于[i,r]表示的数。若有值为1，否则为0。这样便有状态转移方程：(区间表示的数的关系暂且记作区间的关系) dp1(i,r)=dp1(k_1,i-1)||dp1(k_2,i-1)||...||dp1(k_m,i-1)||false,[k,i-1]]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2051]中国象棋]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%B4%9B%E8%B0%B7P2051-%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次不看任何解析A出的省选难度题，留作纪念。 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。你也来和小可可一起锻炼一下思维吧！ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行包含两个整数N，M，之间由一个空格隔开。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。 输入输出样例Sample input 1 3 Sample output 7 说明【样例说明】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有2*2*2-1=7种方案。【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据中N和M均不超过100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50%的数据中N和M至少有一个数不超过8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30%的数据中N和M均不超过6 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划，还是有一定难度的，但在省选题中算简单的了。这里的状态转移是性质转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记dp(x，y，t)表示x行y列的棋盘在满足P(t)性质的条件下所有的方案数，P性质定义如下： P(0)：第一行不能有棋子 P(1)：第一行仅有一个棋子 P(2)：第一行有两个棋子 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有这三种情况，因为每一行一列不可能有三个及以上数目的棋子。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于t=0的情况很容易进行状态转移，这是因为首行没有棋子，不会对下面的棋子选取产生任何影响。 dp(x，y，0)=dp(x-1，y，0)+dp(x-1，y，1)+dp(x-1，y，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t=1的情况就复杂很多。注意到第一行仅有且必须有一个棋子，它所在的一列的后x-1行可能有0个或1个棋子。可以最这两个子情况分别讨论，方案总数即是它们的和。当后x-1行没有棋子时，删去这一列和首行，得到一个x-1行y-1列的棋盘。这时发现首行的棋子对这个x-1行y-1列的棋盘棋子选取没有任何影响，方案总数即为dp(x-1，y-1，0)+dp(x-1，y-1，1)+dp(x-1，y-1，2)，再乘上y（被删去的一列有y种选法）就是第一个子情况的方案数。当后x-1行有一个棋子时，删去首行并将这一列拿到最左端，将这个棋盘（看作矩阵）转置，这是一个y行x-1列的棋盘且首行仅有一个棋子，故方案数即为dp(y，x-1，1)，再乘上y（理解同上）就是第二个子情况的方案数。于是有： dp(x，y，1)=(dp(x-1，y-1，0)+dp(x-1，y-1，1)+dp(x-1，y-1，2)+dp(y，x-1，1))*y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后再来看t=2的情况。仍然可以这种情况归结为三种子情况：两个棋子下面均没有其他棋子、一个棋子下面有一个棋子但另一个没有、两个棋子下面均有一个棋子。将它们三个的值加起来即可。第一种子情况理解与t=1相同，删去这两列，得到一个x-1行y-2列的棋盘，方案数为dp(x-1，y-2，0)+dp(x-1，y-2，1)+dp(x-1，y-2，2)，还需要乘上y*(y-1)/2（两个空列的组合数）。第二个子情况理解仍然同t=1时，删去没有棋子的那一列，将有一个棋子的一列拿到最左端，转置后得到一个y-1行x-1列的棋盘且满足P(1)性质，方案数即为dp(y-1，x-1，1)，需要再乘上y*(y-1)（乘一个排列数，将这两列作排列）。最后一种子情况很复杂，仍然需要划分为两种情况：下面的两个棋子不在同一行、下面的两个棋子在同一行。前者可以删去首行，再将两列合并，移到最左边，转置后得到一个y-1行x-1列并且满足性质P(2)的棋盘，方案数即为dp(y-1，x-1，2)，再乘上y*(y-1)即可。后者从棋盘中合并首行和两个棋子所在的一行，移到最顶端，这时下面的x-2行y列的棋盘在首行两个棋子所在的列不应有棋子，也就是两个空列。删去这两个空列，得到一个x-2行y-2列的棋盘，它的棋子选取没有受到影响，方案数为dp(x-2，y-2，0)+dp(x-2，y-2，1)+dp(x-2，y-2，2)，再乘上y*(y-1)/2（这里是一个组合数，是两个空列的选取情况），再乘上x-1（下面棋子所在行的情况）就是后一种情况的答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此t=2时的状态转移方程为： dp(x，y，2)=(dp(x-1，y-2，0)+dp(x-1，y-2，1)+dp(x-1，y-2，2))*y*(y-1)/2+dp(y-1，x-1，1)*y*(y-1)+(dp(x-2，y-2，0)+dp(x-2，y-2，1)+dp(x-2，y-2，2))*y*(y-1)/2*(x-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意边界处理和取模，递推即可。答案即为dp(n，m，0)+dp(n，m，1)+dp(n，m，2)对9999973的模。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAX 101#define MOD 9999973using namespace std;long long dp[MAX][MAX][3] = &#123;0&#125;;int n, m;long long DP(int x, int y, int t) &#123; if (x == 0 || y == 0)return 0; if (x == 1) &#123; if (t == 0)return 1; if (t == 1)return y; if (t == 2)return y * (y - 1) / 2; &#125; if (y == 1) &#123; if (t == 0)return (DP(x - 1, 1, 0) + DP(x - 1, 1, 1) + DP(x - 1, 1, 2)) % MOD; if (t == 1)return x; if (t == 2)return 0; &#125; if (t == 2) &#123; if (x == 2)return y * (y - 1) / 2 * (y * y + y + 2) / 2; if (y == 2)return x * x; &#125; //上面是边界处理 if (dp[x][y][t] &gt;= 0)return dp[x][y][t];//记忆化 //下面是状态转移，t=2时方程太长，分开计算 if (t == 0)return dp[x][y][t] = (DP(x - 1, y, 0) + DP(x - 1, y, 1) + DP(x - 1, y, 2)) % MOD; if (t == 1)return dp[x][y][t] = ((DP(x - 1, y - 1, 0) + DP(x - 1, y - 1, 1) + DP(x - 1, y - 1, 2)) % MOD + DP(y, x - 1, 1)) * y % MOD; int ans = 0; ans += (DP(x - 1, y - 2, 0) + DP(x - 1, y - 2, 1) + DP(x - 1, y - 2, 2)) * y * (y - 1) / 2 % MOD; ans += DP(y - 1, x - 1, 1) * y * (y - 1) % MOD; ans %= MOD; ans += DP(y - 1, x - 1, 2) * y * (y - 1) % MOD + (DP(x - 2, y - 2, 0) + DP(x - 2, y - 2, 1) + DP(x - 2, y - 2, 2)) % MOD * y * (y - 1) / 2 * (x - 1) % MOD; return dp[x][y][t] = ans % MOD;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(dp, -1, sizeof(dp)); cout &lt;&lt; (DP(n, m, 0) + DP(n, m, 1) + DP(n, m, 2)) % MOD &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然花了我3个小时去想它的解法（太弱），但评测用时36ms，内存占0.93mb AC这题还是值得的。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1070]道路游戏]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%B4%9B%E8%B0%B7P1070-%E9%81%93%E8%B7%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小新正在玩一个简单的电脑游戏。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏中有一条环形马路，马路上有n个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这n个机器人工厂编号为1~n，因为马路是环形的，所以第 n个机器人工厂和第1个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这n段马路也编号为1~n，并规定第i段马路连接第i个机器人工厂和第i+1个机器人工厂（1≤i≤n-1），第n段马路连接第n个机器人工厂和第1个机器人工厂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在i（1≤i≤n）号机器人工厂购买了一个机器人，这个机器人会从i号机器人工厂开始，顺时针在马路上行走，第一次行走会经过i号马路，到达i+1号机器人工厂（如果 i=n，机器人会到达第1个机器人工厂），并将i号马路上的所有金币收集给小新。 游戏中，环形马路上不能同时存在2个或者2个以上的机器人，并且每个机器人最多能够在环形马路上行走p次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为1~p之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。 以下是游戏的一些补充说明： 游戏从小新第一次购买机器人开始计时。 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过m个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行3个正整数n,m,p意义如题目所述。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的n行，每行有m个正整数，每两个整数之间用一个空格隔开，其中第i行描&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;述了i号马路上每个单位时间内出现的金币数量（1≤金币数量≤100），即第i行的第j（1≤j≤m）个数表示第j个单位时间内i号马路上出现的金币数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行，有n个整数，每两个整数之间用一个空格隔开，其中第i个数表示在i号机器人工厂购买机器人需要花费的金币数量（1≤金币数量≤100）。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，包含1个整数，表示在m个单位时间内，扣除购买机器人&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花费的金币之后，小新最多能收集到多少金币。 输入输出样例Sample input 2 3 21 2 32 3 41 2 Sample output 5 说明【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 40%的数据，2≤n≤40,1≤m≤40。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 90%的数据，2≤n≤200,1≤m≤200。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 100%的数据，2≤n≤1000,1≤m≤1000,1≤p≤m。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道很有趣的题目，考察动态规划。这里介绍一种O(n3)的做法，本以为会TLE，但是由于某些原因（数据太水），导致这种方法也是可以AC的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路就是规定dp(x)为x时刻开始购置一个机器人，到游戏结束可以得到的最多金币数。这样写的状态转移方程十分复杂。转移时遍历所有可能的购置和选择步数的方案，结合机器人的价格，进行之后时间状态的转移，取最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历是一件特别低效的做法。但是可以注意到dp(x)只能转移到dp(x+k)（1≤k≤p），每一个转移都固定了步数，只是选择哪一个机器人不定。可以开一个数组记录这个量，从而加快速度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以开一个T数组记录第t时刻，设置步数为x时可以得到的最大金币收益（实质上就是机器人的选择）。求这个金币收益可以用矩阵的对角前缀和加速。再来点inline和读入优化黑魔法这题就A了。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#define N 1000#define inf 1e8using namespace std;int op[N][N], dp[N], T[N][N], n, m, p, sum[N][N] = &#123;0&#125;, value[N];inline int solve(int t, int a, int b) &#123; int s = 0; if (t &amp;&amp; a)s = sum[a - 1][t - 1]; if (a + b - 1 &lt; n) return sum[a + b - 1][t + b - 1] - s; return sum[n - 1][t + n - 1 - a] - s + sum[(a + b - 1) % n][t + b - 1];&#125;inline int f(int t, int x) &#123; if (T[t][x] &gt; -1e7)return T[t][x]; for (int i = 0; i &lt; n; i++)T[t][x] = max(T[t][x], solve(t, i, x) - value[i]); return T[t][x];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; op[i][j]; if (!i || !j)sum[i][j] = op[i][j]; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 1; j &lt;= p; j++)T[i][j] = (int) (-inf); &#125; for (int i = 0; i &lt; n; i++)cin &gt;&gt; value[i]; for (int i = 1; i &lt; m; i++) &#123;//求对角前缀和 for (int j = i; j &lt; m; j++)sum[i][j] = sum[i - 1][j - 1] + op[i][j]; for (int j = i + 1; j &lt; n; j++)sum[j][i] = sum[j - 1][i - 1] + op[j][i]; &#125; dp[m] = 0; for (int i = m - 1; i &gt;= 0; i--) &#123;//时刻 dp[i] = (int) (-inf); for (int j = 1; j &lt;= m - i &amp;&amp; j &lt;= p; j++)dp[i] = max(dp[i], f(i, j) + dp[i + j]); &#125; cout &lt;&lt; dp[0]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2577]午餐]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2577-%E5%8D%88%E9%A4%90%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数N，代表总共有N个人。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数T，代表所有人吃完饭的最早时刻。 输入输出样例Sample input 52 27 71 36 48 5 Sample output 17 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有输入数据均为不超过200的正整数。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划和贪心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先应明确：在所有人都在一个队列中时，按照每个人吃饭时间降序排列才可以获得最优解。这是一种贪心思想，是比较容易发现的，下面给出它的数学证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑两个相邻的人，假设他们前面的人总共打饭时间为p，那么如果第一个人在前，他们两人的吃完饭最晚时刻为 \max\{p+a1+b1，p+a1+a2+b2\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反之为 \max\{p+a2+b2，p+a1+a2+b1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设第一个在前更优，则有 \max\{p+a1+b1，p+a1+a2+b2\} \leq \max\{p+a2+b2，p+a1+a2+b1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到$p+a1+b1&lt;p+a1+a2+b1$并且$p+a2+b2&lt;p+a1+a2+b2$，因此上式等价于 p+a1+a2+b1\geq p+a1+a2+b2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是$b1≥b2$，即吃饭时间长的在前更优。根据相邻全局最优化原理（还记得皇后游戏吗？）可知按照吃饭时间降序排列的贪心策略是正确的。证毕。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是先对这些数据按照第二元素（也就是吃饭用时）降序排列，那么问题的重点就是如何对他们进行分队安排，这是一个动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于每一个人都有进入两个队列任意一个的决策，于是考虑决策转移。记dp(i，j，k)表示到第i个人，在第一个队列已用时j单位时间，第二个队列已用时k个单位时间的情况下，能得到的最早的吃饭完成时刻。这里的j、k已经包含了i这个人本身的打饭时间。那么有状态转移方程： dp(i，j，k)=\min\{\max\{dp(i-1，j-i.a，k)，j+i.b\}，\max\{dp(i-1，j，k-i.a)，k+i.b\}\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方程比较容易理解，两个状态分别表示将第i个人分配到第一个队列和第两个队列。如果无法分配，则直接分配到另一个合法的队列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是注意到这样开三维数组很容易MLE，又发现j+k=sum(i)恒成立，这也就是说j和k本身就有关系，在这个情况下j和k这两个状态参量可以去除一个，另一个只需求出即可。所以排序后应该求一个前缀和。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200#define inf (int)1e8using namespace std;int n, dp[N][N * N + 1];int sum[N] = &#123;0&#125;;struct node &#123; int a, b; bool operator&lt;(node x) &#123; return b &gt; x.b; &#125;&#125; op[N];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; op[i].a &gt;&gt; op[i].b; sort(op, op + n); sum[0] = op[0].a; for (int i = 1; i &lt; n; i++)sum[i] = sum[i - 1] + op[i].a; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= sum[n - 1]; j++)dp[i][j] = inf; &#125; dp[0][0] = dp[0][op[0].a] = op[0].a + op[0].b; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt;= sum[i]; j++) &#123; if (j &gt;= op[i].a)dp[i][j] = min(dp[i][j], max(dp[i - 1][j - op[i].a], j + op[i].b)); if (sum[i] - j &gt;= op[i].a)dp[i][j] = min(dp[i][j], max(dp[i - 1][j], sum[i] - j + op[i].b)); &#125; &#125; int ans = inf; for (int i = 0; i &lt;= sum[n - 1]; i++)ans = min(ans, dp[n - 1][i]); cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步观察可发现，状态转移方程的量仅限于相邻两行之间，于是可以把数组压缩至一维，这也是本题目前最好的解法。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200#define inf (int)1e8using namespace std;int n, dp[N * N];int sum[N] = &#123;0&#125;;struct node &#123; int a, b; bool operator&lt;(node x) &#123; return b &gt; x.b; &#125;&#125; op[N];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; op[i].a &gt;&gt; op[i].b; sort(op, op + n); sum[0] = op[0].a; for (int i = 1; i &lt; n; i++)sum[i] = sum[i - 1] + op[i].a; for (int j = 0; j &lt;= sum[n - 1]; j++)dp[j] = inf; dp[0] = dp[op[0].a] = op[0].a + op[0].b; for (int i = 1; i &lt; n; i++) &#123; for (int j = sum[i]; j &gt;= 0; j--) &#123; int p = inf; if (j &gt;= op[i].a)p = min(p, max(dp[j - op[i].a], j + op[i].b)); if (sum[i] - j &gt;= op[i].a)p = min(p, max(dp[j], sum[i] - j + op[i].b)); dp[j] = p; &#125; &#125; int ans = inf; for (int i = 0; i &lt;= sum[n - 1]; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1273]有线电视网]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很不容易独立A出的一道题，做做纪念。 难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行包含两个用空格隔开的整数N和M，其中2≤N≤3000，1≤M≤N-1，N为整个有线电视网的结点总数，M为用户终端的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个转播站即树的根结点编号为1，其他的转播站编号为2到N-M，用户终端编号为N-M+1到N。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的N-M行每行表示—个转播站的数据，第i+1行表示第i个转播站的数据，其格式如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K A1 C1 A2 C2 … Ak Ck&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K表示该转播站下接K个结点(转播站或用户)，每个结点对应一对整数A与C，A表示结点编号，C表示从当前转播站传输信号到结点A的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。 输入输出样例Sample input 5 32 2 2 5 32 3 2 4 33 4 2 Sample output 2 说明[样例解释]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，共有五个结点。结点①为根结点，即现场直播站，②为一个中转站，③④⑤为用户端，共M个，编号从N-M+1到N，他们为观看比赛分别准备的钱数为3，4，2，从结点①可以传送信号到结点②，费用为2，也可以传送信号到结点⑤，费用为3(第二行数据所示)，从结点②可以传输信号到结点③，费用为2。也可传输信号到结点④，费用为3(第三行数据所示)，如果要让所有用户(③④⑤)都能看上比赛，则信号传输的总费用为:2+3+2+3=10，大于用户愿意支付的总费用3+4+2=9，有线电视网就亏本了，而只让③④两个用户看比赛就不亏本了。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题实际上在考察树上的分组背包DP问题，属于树型DP。这里先介绍一种转二叉树的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先注意到题目没有给定价格和边权的数据范围，若以此为依据DP，连数组范围都难以确定。于是不妨令dp(r，k)表示以r为根的子树中满足k个用户时可以得到的最大收益，这样状态就可以得到确定，答案即为使dp(1，k)为非负时的最大k(假设1是整棵树的根)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样状态转移会很难写，因为需要把这k个用户分配给其子树，这显然有很多情况，是难以分配的。但是注意到二叉树很容易分配，于是考虑转多叉树为二叉树的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认清一个事实，以下两棵树是等价的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里新建了一个节点和一条边，并令这条边的边权为0，这样就把三叉树转成了一棵等价的二叉树。其余如四叉树等的转法与之同理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预处理出每一个节点所含的叶子节点数child(i)，DP时严格保证dp(r，k)中k≤child(r)，这样状态转移方程就可以列出:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任何节点i，dp(i，0)=0。 若i为叶子节点，则dp(i，1)=money(i)，即这个用户支付的费用。 若i有一个儿子，则dp(i，k)=dp(c1，k)-v1。c1为儿子节点，v1为到儿子的边的边权。 若i有两个儿子，则需要进行分配。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果k=child(c1)+child(c2)，则不需进行分配，直接结果就是 dp(r，k)=dp(c1，child(c1))+dp(c2，child(c2))-v1-v2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果k&lt;child(c1)+child(c2): dp(r，k)=\min\{dp(c1，k1)+dp(c2，k2)-v1-v2\}，1\leq k1\leq child(c1)，1\leq k2\leq child(c2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对只分配给一棵子树的情况需要之后另行特判。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若k≤child(c1)，则: dp(r，k)=\min\{dp(r，k)，dp(c1，k)-v1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若k≤child(c2)。则: dp(r，k)=\min\{dp(r，k)，dp(c2，k)-v2\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据状态转移方程推出结果即可，这种方法其实很快。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include &lt;cstring&gt;#include&lt;cstdio&gt;#define NUM 3000*2using namespace std;int head[NUM], to[NUM], nxt[NUM], value[NUM], child[NUM] = &#123;0&#125;;int money[3000];int dp[NUM][3000] = &#123;0&#125;;int cnt = 1, ncnt = 0;int N, M;inline void add(int x, int y, int z) &#123; nxt[cnt] = head[x], to[cnt] = y, value[cnt] = z, head[x] = cnt++;&#125;int DFS(int x) &#123; for (int i = head[x]; i != -1; i = nxt[i])child[x] += DFS(to[i]); if (child[x] == 0)return child[x] = 1; return child[x];&#125;int DP(int root, int n) &#123; if (n == 0)return 0; if (dp[root][n] &gt; -1e7)return dp[root][n]; int l1, l2; if (head[root] == -1)return dp[root][n] = money[root]; l1 = to[head[root]];//左儿子 if (nxt[head[root]] == -1)return dp[root][n] = DP(l1, n) - value[head[root]]; l2 = to[nxt[head[root]]];//右儿子 if (n == child[root])return dp[root][n] = DP(l1, child[l1]) + DP(l2, child[l2]) - value[head[root]] - value[nxt[head[root]]]; if (child[l1] &gt;= n)dp[root][n] = max(dp[root][n], DP(l1, n) - value[head[root]]); if (child[l2] &gt;= n)dp[root][n] = max(dp[root][n], DP(l2, n) - value[nxt[head[root]]]); for (int i = max(1, n - child[l2]); i &lt;= child[l1] &amp;&amp; i &lt; n; i++)dp[root][n] = max(dp[root][n], DP(l1, i) + DP(l2, n - i) - value[head[root]] - value[nxt[head[root]]]); return dp[root][n];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M; ncnt = N + 1; memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= N - M; i++) &#123; int x; cin &gt;&gt; x; if (x &lt;= 2) &#123; for (int j = 1; j &lt;= x; j++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(i, a, b); &#125; &#125; else &#123; int from = i; for (int j = 1; j &lt;= x; j++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(from, a, b); if (j &lt;= x - 2)add(from, ncnt, 0), from = ncnt++;//转二叉树 &#125; &#125; &#125; for (int i = N - M + 1; i &lt;= N; i++)cin &gt;&gt; money[i]; DFS(1); for (int i = 1; i &lt; ncnt; i++) &#123; for (int j = 0; j &lt;= child[i]; j++)dp[i][j] = static_cast&lt;int&gt;(-1e8); &#125; for (int i = M; i &gt;= 0; i--) &#123; if (DP(1, i) &gt;= 0) &#123; cout &lt;&lt; i; return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的k级覆盖问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%A0%91%E7%9A%84k%E7%BA%A7%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一棵树，约定选定一个点，被选点可以覆盖与其距离不大于k的所有节点，问覆盖整棵树的最小选点数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇《动态规划与状态设计》中提及了k=2的DP做法，但是随着k的增大，状态数也会随之增多，这里介绍一种贪心方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心思路：选择树中最深的没有被覆盖的节点，标记其k级祖先，直到整棵树都被覆盖。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体实现时，要先确定树根，计算出每一个节点的深度，每次选最深的节点，判断其是否被覆盖。若无则标记k级祖先，否则继续选点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何判断是否被标记。只需要开一个数组来记录每一个节点到与它最近的被标记点的距离即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出上一篇文章中的第一道题目(洛谷P2279，k=2)的示例代码。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 1001#define inf 10000using namespace std;int n;int father[MAX] = &#123;0&#125;, depth[MAX];//标记节点的父节点编号和深度,认为根节点为1号节点int rk[MAX];//序号,用于深度排序int dict[MAX];//离被标记点最近的距离bool cmp(int a, int b) &#123; return depth[b] &lt; depth[a]; &#125;//比较函数,用于深度排序int main() &#123; cin &gt;&gt; n; depth[1] = 1, rk[1] = 1, dict[0] = dict[1] = inf;//初始化,0是虚拟父节点 for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; father[i]; depth[i] = depth[father[i]] + 1, rk[i] = i, dict[i] = inf;//利用题目输入规则,直接确定深度和父节点 &#125; sort(rk + 1, rk + n + 1, cmp);//排序 int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int f = father[rk[i]], gf = father[f];//获取父节点和祖父 dict[rk[i]] = min(dict[rk[i]], min(dict[f] + 1, dict[gf] + 2));//更新距离 if (dict[rk[i]] &gt; 2) &#123;//没被覆盖 dict[gf] = 0, ans++;//标记父节点,计数器加一 dict[father[gf]] = min(dict[father[gf]], 1), dict[father[father[gf]]] = min(dict[father[father[gf]]], 2); //更新祖父的父节点和祖父的距离 &#125; &#125; cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记祖父时，其所有子节点孙子节点都会在它们的距离更新中被发现已被覆盖，同时祖父的父节点和祖父节点也会更新距离，从而使兄弟节点也会得到覆盖。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，如果一个节点没有父节点或者祖父节点，那么就用到了虚拟父节点的概念。当任何时候一个节点没有父节点或祖父节点时，都认为它是节点0。0就是虚拟父节点。这种方法是正确的，这是因为当一个节点未被覆盖但又没有父节点或祖父节点时，由于它是目前深度最深的未被标记的节点，只需标记根节点即可完成整棵树的全覆盖。标记0节点和标记根节点显然是等价的，它们都能覆盖整棵树，结果都是计数器加一。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，标记虚拟父节点就是标记根节点，答案不变。所以不需要对没有父节点或祖父节点时特判。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法很普适，可以推广到k级半径的问题，不用存图。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划与状态设计]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一篇文章谈谈动态规划(Dynamic Programming， DP)。本材料中大量地出现动态规划类题目，这里做一个总结。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态规划是一种解决多阶段决策问题的高效算法设计思路，它的本质是分治思想。对于一个问题，它通常由若干子问题组成，解决了这些子问题，原问题也迎刃而解。例如树这种数据结构，它的分枝仍是一棵树，又如将区间分割，得到的仍是一个区间…很多事物都满足这种性质，可以考虑用DP思路解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍一些DP术语。 状态。当前阶段所面临的客观条件称为一种状态。状态需要一定的量去描述，称为状态变(参)量。同时状态也拥有一定的值，称为状态量。 状态转移。状态可以视为一个问题，它由若干子问题构成，这些子问题也是一个个状态。由当前状态到它的子状态的过程称为状态转移。转移的数学表达式称为状态转移方程。 无后效性。每一个状态都是客观的。一个状态所对应的问题可能是多个不同问题的子问题，但是无论它从哪一个状态转移过来，这个状态都应该是客观独立的，它的任何属性都不会随受前一个状态的影响。这种性质称为无后效性，能用DP解决的问题必须满足无后效性。 最优化原理。一个问题是最优的，它的子问题必然也是最优的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用DP解决问题实际上就是设计合适的状态，列出对应的状态转移方程。DP的重点在于看清问题和子问题以确定状态，状态的设计是很重要的，它必须满足以下几点要求: 状态参量到状态量是一个多数值到单数值的映射，也就是说，每一个状态必须是确定的，唯一的，并且满足无后效性。 状态必须是可转移的，也就是能够列出明确的状态转移方程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面思考这样一个题目，来认识状态设计: 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，称基地A到基地B的距离为d。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行为n （n&lt;=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]&lt;i。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目实质上是给定一棵树，其中一个选定的点可以覆盖两层的其余顶点，求覆盖整棵树的选点最小值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个显然的状态设计思路是令f(x)表示以x为根的子树的选点最小值。这样做状态的确是唯一的并且有明确的值，但是它无法列出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，f(x)=$\sum f(k)$(k表示x的子节点)是否成立呢?显然不可，这是因为即使每一个子树都被覆盖掉了，根节点x也可能没被覆盖到;同时，每一个子树的选点覆盖范围可能有所包含，使得全局仍可以删掉几个点，结果不最优。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的状态设计显然是失败的，问题便出在状态描述不清上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时状态虽唯一，但是无法转移，就需要增加状态描述量来细化状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识到一个事实，原问题满足某种性质时，往往意味这它的子问题也要满足某种性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果定义f(x，y)表示根节点为x的子树，在满足性质P(y)的前提下最小选点数。P定义如下: P(0):子树完全被覆盖，且根节点被选。 P(1):子树完全被覆盖，子节点被选。 P(2):子树完全被覆盖，孙子节点被选。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子树被完全覆盖仅有这三种状态 P(3):所有子节点及其子树都被覆盖，但根节点未知。 P(4):所有孙子节点及其子树都被覆盖，但根节点和子节点未知。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实还可以有P(5):所有孙子节点的子节点及其子树都被覆盖，但根节点子节点，孙子节点未知。但之后可以看到这种状态不参与转移，是无用的。仅这样就是可以转移的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若原树满足P(0)，则根节点向下两层(儿子和孙子)都一定被覆盖，但是倘若全树都被覆盖，所有子树都必须满足其孙子节点及其子树都被覆盖的性质。发现P(0~4)都符合条件，可以证明其余的任何状态都不符合，又发现全树的选点数是所有子树上选点数加一，于是有: f(x，0)=\sum(min\{f(k，0...4)\})+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一个子树，取其五个性质中选点最少的一个，这样既满足性质又能使解最优。这样直接作和是不会出现漏选多选的情况的。这是因为，子树都满足了需要的性质，全树一定可以完全被覆盖，不会缺选;同时，由于每一个子树都是满足性质的，并且选的是最小值，其余状态又不能使性质成立，删掉一个点必然使性质不再成立，所以不会多点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若原树满足P(1)，则根节点下一层全被覆盖，此时因为全树都被覆盖，所有子树都必须满足其子节点和子树都被覆盖的性质(即P(0~3))，被选的点满足P(0)性质。所以有: f(x，1)=\min\{f(k，0)+\sum (\min\{f(k’，0...3)\})\}，k是任意子节点，k’是剩余的子节点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解同上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理可得: f(x，2)=\min\{f(k，1)+\sum (\min\{f(k’，0...2)\})\}，k是任意子节点，k’是剩余的子节点\\ f(x，3)=\sum (\min\{f(k，0...2)\})\\ f(x，4)=\sum (\min\{f(k，0...3)\})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种转移方法称为性质转移，它的原理是当原问题满足状态指定的某种性质时，其子问题也要满足特定的性质，这时原问题状态可以转移到所有满足特定性质的子问题状态。这里给出的五个状态就是所有满足的状态，少一个都会难以转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种转移方式即为决策转移，它的原理通常是不同的决策，例如背包问题。本题用决策转移很难列方程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地理解状态设计，来重新认识一下01背包问题这种经典DP问题。本材料第2题就是这类问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01背包属于决策转移型，决策是选不选当前的这个物品。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当从所有物品中随机拿出一个时，如果背包可以装下的话，便会面临选还是不选的问题，这便是一个决策。规定物品全集为S，拿出的物品为x，物品i价值为wi，则两种决策得到的价值分别为: 选该物品:wx+?不选该物品:0+? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的?表示后面加上的价值暂时无法确定。但是注意到，如果选了该物品，对于剩下的物品集合S-{x}与原问题集合S，它们的问题本质上是同一类问题，都是从一个集合中取一些物品使价值总和最大，不选与之同理。这样就把问题拆成了两个本质相同的子问题。同时子问题最优时，原问题才最优，这是显然的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是定义dp(Q)表示对于集合Q，从中拿走若干个物品得到的价值最大值。但是很快便发现，这其中忽略了物品体积的问题，物品体积显然会影响决策(太大时一定不能选)，并且这样描述状态并不能唯一地确定状态。于是应定义dp(Q，p)表示背包容量为p时，从集合Q中拿走若干物品得到的价值最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么就有关系(vi表示物品i的体积): 若p\geq v_x时:dp(Q，p)=\max\{dp(Q-\{x\}，p)，dp(Q-\{x\}，p-v_x)+w_x\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里从不选和选中取一个较大值。 p]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1373]小a和uim之大逃离]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1373-%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小a和uim来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个披头散发，青面獠牙的怪物，低沉着声音说：“呵呵，既然你们来到这，只能活下来一个！”。小a和他的小伙伴都惊呆了！ 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;瞬间，地面上出现了一个n*m的巨幅矩阵，矩阵的每个格子上有一坨0~k不等量的魔液。怪物各给了小a和uim一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小a用魔瓶吸收地面上的魔液，下一步由uim吸收，如此交替下去，并且要求最后一步必须由uim吸收。魔瓶只有k的容量，也就是说，如果装了k+1那么魔瓶会被清空成零，如果装了k+2就只剩下1，依次类推。怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小a和uim感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小a灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小a和他的小伙伴都笑呆了！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在他想知道他们都能活下来有多少种方法。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行，三个空格隔开的整数n，m，k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n行，m列，表示矩阵每一个的魔液量。同一行的数字用空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示方法数。由于可能很大，输出对1 000 000 007取余后的结果。 输入输出格式Sample input 2 2 31 11 1 Sample output 4 说明[样例解释]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四种方案是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)-&gt;(1，2)，(1，1)-&gt;(2，1)，(1，2)-&gt;(2，2)，(2，1)-&gt;(2，2)。[数据范围]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于20%的数据，n，m≤10，k≤2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，n，m≤100，k≤5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，n，m≤800，1≤k≤15 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划。本题对时间空间复杂度都有考验。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定f(a，b，x，y，t)表示在坐标(x，y)，两人魔液值为a，b(已吸收(x，y)处的)，在t状态(0表示小a吸收，1表示uim吸收)的方案数，则有递推关系: f(a，b，x，y，0)=f(a，(b+value(x+1，y))\%(1+k)，x+1，y，1)+f(a，(b+value(x，y+1)\%(1+k))，x，y+1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时有: f(a，b，x，y，1)=f((a+value(x+1，y))\%(1+k)，b，x+1，y，0)+f((a+value(x，y+1))\%(1+k)，b，x，y+1，0)+∂(a，b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∂(a，b)在a=b时为1，否则为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$\sum f(value(x，y)，0，x，y，0)$，1≤x≤n且1≤y≤m。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个5维的递推式，需要用一个5维数组储存数据，极易MLE。注意到递推式只与两个相邻行有关，可以考虑压缩数组(这个思想已经用过很多次了)。但是不能直接将其压缩至4维，这是因为其余维度的数据很难保证不被异常覆盖。这时采用滚动数组的方法，这是压缩数组维数不可行时的另一种解决方案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动数组很容易理解。将控制行的一维压缩至2个元素，分别储存待计算的一行和提供递推数据的一行(即相邻的两行)。两行交替进行递推，便可递推出所有的数值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出原版代码和滚动数组优化的代码，请读者观察其区别。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)#define S2(x) (x&lt;MOD?x:x-MOD)using namespace std;int dp[16][16][805][805][2] = &#123;0&#125;;int op[805][805];int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; k++;//k自加,后边不用再+1 for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)cin &gt;&gt; op[i][j]; &#125; for (int i = 0; i &lt; k; i++)dp[i][i][n][m][1] = 1;//递推奠基 for (int i = n; i ≥ 1; i--) &#123; for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int a = 0; a &lt; k; a++) &#123; for (int b = 0; b &lt; k; b++) &#123; dp[a][b][i][j][0] = dp[a][S1(b + op[i + 1][j])][i + 1][j][1] + dp[a][S1(b + op[i][j + 1])][i][j + 1][1]; dp[a][b][i][j][1] = dp[S1(a + op[i + 1][j])][b][i + 1][j][0] + dp[S1(a + op[i][j + 1])][b][i][j + 1][0]; if (a == b)dp[a][b][i][j][1]++; dp[a][b][i][j][0] = S2(dp[a][b][i][j][0]); dp[a][b][i][j][1] = S2(dp[a][b][i][j][1]); &#125; &#125; &#125; &#125; int ans = 0; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)ans += dp[op[i][j]][0][i][j][0], ans = S2(ans);//求和 &#125; cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动数组优化版本(65分)(外加读入优化)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)int dp[16][16][2][805][2] = &#123;0&#125;;//第三维压至2个元素short int op[805][805];int n, m, k;inline int ID(int x) &#123; if (x == 1)return 0; return 1;&#125;short int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); short int sum = 0; while (e ≥ '0' &amp;&amp; e ≤ '9') &#123; sum = sum * 10 + e - '0'; e = getchar(); &#125; return sum;&#125;int main() &#123; n = read(), m = read(), k = read(); k++; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)op[i][j] = read(); &#125; for (int i = 0; i &lt; k; i++)dp[i][i][0][m][1] = 1; bool key = true; int ans = 0; for (int i = n; i ≥ 1; i--) &#123; key = !key;//控制交替 for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int a = 0; a &lt; k; a++) &#123; for (int b = 0; b &lt; k; b++) &#123; dp[a][b][key][j][0] = dp[a][S1(b + op[i + 1][j])][!key][j][1] + dp[a][S1(b + op[i][j + 1])][key][j + 1][1]; dp[a][b][key][j][1] = dp[S1(a + op[i + 1][j])][b][!key][j][0] + dp[S1(a + op[i][j + 1])][b][key][j + 1][0]; if (a == b)dp[a][b][key][j][1]++; if (dp[a][b][key][j][0] ≥ MOD) dp[a][b][key][j][0] -= MOD; if (dp[a][b][key][j][1] ≥ MOD)dp[a][b][key][j][1] -= MOD; &#125; &#125; ans += dp[op[i][j]][0][key][j][0];//答案必须即时更新,因为数组经压缩,数据得不到保存 if (ans ≥ MOD)ans -= MOD; &#125; &#125; printf("%d", ans); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这样并不是最优解，这里需要注意到两人的魔液值其实没有实质意义，它们的差才是最重要的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义f(h，x，y，t)表示两人魔液值差为h(若为负则转化为k最小剩余系中与h对1+k同余的数)，其余意义不变。差值为h表示小a要么比uim多h，要么比他少1+k-h，当其中任一人的值确定时，另一人的值通过h必然唯一确定。由此可知，这样定义的差值是合理的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知h=(V(0)-V(1))%(1+k)，V(0)，V(1)分别为小a，uim的魔液值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小a吸收p个单位的魔液时: h=((p+V(0))\%(1+k)-V(1))\%(1+k)=(p+V(0)-V(1))\%(1+k)=(p+h)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当uim吸收p个单位的魔液时: h=(V(0)-(V(1)+p)\%(1+k))\%(1+k)=(V(0)-V(1)-p)\%(1+k)=(h-p)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际计算中，由于计算机计算余数并不一定得到正数，故后一个式子要写成: h=(h-p+k+1)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可知无论两人实际的魔液值为多少，只要确定了差值，经过一定的吸收变化，其差值总是唯一确定的。所以可以将前两维压缩至1维，仅表示差值的大小。0即表示两人魔液值相同。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)int dp[16][2][805][2] = &#123;0&#125;;short int op[805][805];int n, m, k;inline short int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); short int sum = 0; while (e ≥ '0' &amp;&amp; e ≤ '9') &#123; sum = sum * 10 + e - '0'; e = getchar(); &#125; return sum;&#125;int main() &#123; n = read(), m = read(), k = read(); k++; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)op[i][j] = read(); &#125; dp[0][0][m][1] = 1; bool key = true; int ans = 0; for (int i = n; i ≥ 1; i--) &#123; key = !key; for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int b = 0; b &lt; k; b++) &#123; dp[b][key][j][0] = dp[S1(b - op[i + 1][j] + k)][!key][j][1] + dp[S1(b - op[i][j + 1] + k)][key][j + 1][1]; dp[b][key][j][1] = dp[S1(b + op[i + 1][j])][!key][j][0] + dp[S1(b + op[i][j + 1])][key][j + 1][0]; if (b == 0)dp[0][key][j][1]++; if (dp[b][key][j][0] ≥ MOD) dp[b][key][j][0] -= MOD; if (dp[b][key][j][1] ≥ MOD)dp[b][key][j][1] -= MOD; &#125; ans += dp[op[i][j]][key][j][0]; if (ans ≥ MOD)ans -= MOD; &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1850]换教室]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1850-%E6%8D%A2%E6%95%99%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在可以选择的课程中，有2n节课程安排在n个时间段上。在第i(1≤i≤n)个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室ci上课，而另一节课程在教室di进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第i个时间段去教室di上课，否则仍然在教室ci上课。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第i节课程的教室时，申请被通过的概率是一个已知的实数ki，并且对于不同课程的申请，被通过的概率是互相独立的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多m节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请;牛牛可以申请自己最希望更换教室的m门课程，也可以不用完这m个申请的机会，甚至可以一门课程都不申请。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;牛牛所在的大学有v个教室，有e条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第i(1≤i≤n−1)节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行四个整数 n，m，v，e。n表示这个学期内的时间段的数量;m表示牛牛最多可以申请更换多少节课程的教室;v表示牛牛学校里教室的数量;e表示牛牛的学校里道路的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行n个正整数，第i(1≤i≤n)个正整数表示ci，即第i个时间段牛牛被安排上课的教室;保证1≤ci≤v。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行n个正整数，第i(1≤i≤n)个正整数表示di，即第i个时间段另一间上同样课程的教室;保证1≤di≤v。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四行n个实数，第i(1≤i≤n)个实数表示ki，即牛牛申请在第i个时间段更换教室获得通过的概率。保证0≤ki≤1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来e行，每行三个正整数aj，bj，wj，表示有一条双向道路连接教室aj，bj，通过这条道路需要耗费的体力值是wj;保证1≤aj，bj≤v，1≤wj≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证1≤n≤2000，0≤m≤2000，1≤v≤300，0≤e≤90000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证输入的实数最多包含3位小数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出一行，包含一个实数，四舍五入精确到小数点后恰好2位，表示答案。你的输出必须和标准输出完全一样才算正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于4×10−3。(如果你不知道什么是浮点误差，这段话可以理解为:对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理) 输入输出样例Sample input 3 2 3 32 1 21 2 10.8 0.2 0.51 2 51 3 32 3 1 Sample output 2.80 说明[样例1说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有可行的申请方案和期望收益如下表:[提示]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道路中可能会有多条双向道路连接相同的两间教室。也有可能有道路两端连接的是同一间教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意区分n，m，v，e的意义，n不是教室的数量， m不是道路的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊性质1:图上任意两点ai，bi，ai≠bi间，存在一条耗费体力最少的路径只包含一条道路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊性质2:对于所有的1≤i≤n，ki=1。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察图的最短路和期望DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道路和教室视为图，用Floyd算法求出各个节点对的最短路。注意考虑自环和重边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题重点在于期望DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期望DP的原则是:只能作各阶段期望的和，不允许用子阶段期望乘概率。我就曾因试图用子阶段期望乘概率而出问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若令dp(i，j，t)表示经过1~i节课，用了j次申请机会，第i节课申请状态为t(只能是0或1)所得的期望最小值。容易发现，这样设计状态可以完整地描述状态并且能够进行状态转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且有状态转移方程: dp(i，j，0)=\min\{dp(i-1，j，0)+dict(c_{i-1}，c_i)，dp(i-1，j，1)+dict(c_{i-1}，c_i)*k_{i-1}+dict(d_{i-1}，c_i)*(1-k_{i-1})\}，j\leq i-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出，这是阶段期望的相加运算。 dp(i，j，1)=\min\{dp(i-1，j-1，0)+dict(c_{i-1}，d_i)*k_i+dict(c_{i-1}，c_i)*(1-k_i)，dp(i-1，j-1，1)+dict(c_{i-1}，c_i)*(1-k_{i-1})*(1-k_i)+dict(c_{i-1}，d_i)*(1-k_{i-1})*k_i+dict(d_{i-1}，c_i)*k_{i-1}*(1-k_i)+dict(d_{i-1}，d_i)*k_{i-1}*k_i\}，j≠0且j\leq i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;史上最长状转方程没有之一&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化dp(1，0，0)=dp(1，1，1)=0.0，其余inf。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即是min{dp(n，q，0)，dp(n，q，1)}，0≤q≤m。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;iomanip&gt;#define inf (int)1e8using namespace std;int dict[301][301];int c[2001], d[2001];double k[2001];int n, m, v, e;double dp[2001][2001][2];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; v &gt;&gt; e; for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++)if (i == j)dict[i][i] = 0; else dict[i][j] = inf; &#125; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; c[i];//原有 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; d[i];//欲更换 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; k[i];//概率 for (int i = 1; i &lt;= e; i++) &#123;//读图 int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; dict[x][y] = dict[y][x] = min(dict[x][y], z); &#125; for (int k = 1; k &lt;= v; k++) &#123;//Floyed算法 for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i != j &amp;&amp; j != k &amp;&amp; k != i)dict[i][j] = min(dict[i][j], dict[i][k] + dict[k][j]); &#125; for (int i = 1; i &lt;= n; i++)//预处理 for (int j = 0; j &lt;= m; j++)dp[i][j][0] = dp[i][j][1] = inf; dp[1][0][0] = 0.0, dp[1][1][1] = 0.0; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i; j++) &#123; if (j &lt; i) dp[i][j][0] = min(dp[i - 1][j][0] + dict[c[i - 1]][c[i]], dp[i - 1][j][1] + dict[d[i - 1]][c[i]] * k[i - 1] +dict[c[i - 1]][c[i]] * (1 - k[i - 1])); if (j != 0) dp[i][j][1] = min(dp[i - 1][j - 1][0] + dict[c[i - 1]][d[i]] * k[i] +dict[c[i - 1]][c[i]] * (1 - k[i]), dp[i - 1][j - 1][1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]) + dict[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i] +dict[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]) +dict[d[i - 1]][d[i]] * k[i - 1] * k[i]); &#125; &#125; double ans = inf; for (int i = 0; i &lt;= m; i++)ans = min(ans, min(dp[n][i][0], dp[n][i][1])); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，状态转移方程前两维只与上边一行的元素有关，且有关的列不大于当前列。于是可以压缩数组至2维，此时枚举j时要倒序枚举。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;iomanip&gt;#define inf (int)1e8using namespace std;int dict[301][301];int c[2001], d[2001];int n, m, v, e;double k[2001];double dp[2001][2];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; v &gt;&gt; e; for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++)if (i == j)dict[i][i] = 0; else dict[i][j] = inf; &#125; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; c[i];//原有 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; d[i];//欲更换 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; k[i];//概率 for (int i = 1; i &lt;= e; i++) &#123;//读图 int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; dict[x][y] = dict[y][x] = min(dict[x][y], z); &#125; for (int k = 1; k &lt;= v; k++) &#123;//Floyed算法 for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i != j &amp;&amp; j != k &amp;&amp; k != i)dict[i][j] = min(dict[i][j], dict[i][k] + dict[k][j]); &#125; for (int j = 0; j &lt;= m; j++)dp[j][0] = dp[j][1] = inf; dp[0][0] = dp[1][1] = 0.0; for (int i = 2; i &lt;= n; i++) &#123; for (int j = min(m, i); j &gt;= 0; j--) &#123; if (j &lt; i) dp[j][0] = min(dp[j][0] + dict[c[i - 1]][c[i]], dp[j][1] + dict[d[i - 1]][c[i]] * k[i - 1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1])); if (j != 0) dp[j][1] = min(dp[j - 1][0] + dict[c[i - 1]][d[i]] * k[i] + dict[c[i - 1]][c[i]] * (1 - k[i]), dp[j - 1][1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]) + dict[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i] + dict[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]) + dict[d[i - 1]][d[i]] * k[i - 1] * k[i]); &#125; &#125; double ans = inf; for (int i = 0; i &lt;= m; i++)ans = min(ans, min(dp[i][0], dp[i][1])); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>图的最短路</tag>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1242]新汉诺塔]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1242-%E6%96%B0%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 本文题解改编自洛谷题解第二篇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在洛谷上看到了一种新奇的解法，记录一下。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设有n个大小不等的中空圆盘，按从小到大的顺序从1到n编号。将这n个圆盘任意的迭套在三根立柱上，立柱的编号分别为A，B，C，这个状态称为初始状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移动时有如下要求: 一次只能移一个盘; 不允许把大盘移到小盘上面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件第一行是状态中圆盘总数;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二到第四行分别是初始状态中A，B，C柱上圆盘的个数和从上到下每个圆盘的编号;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五到第七行分别是目标状态中A，B，C柱上圆盘的个数和从上到下每个圆盘的编号。输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行一步移动方案，格式为：move I from P to Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行输出最少的步数。 输入输出样例Sample input 53 3 2 12 5 401 23 5 4 31 1 Sample output move 1 from A to Bmove 2 from A to Cmove 1 from B to Cmove 3 from A to Bmove 1 from C to Bmove 2 from C to Amove 1 from B to C7 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;圆盘总数≤45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行的圆盘描述是从下到上的圆盘编号。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题解用了随机数…竟然A了，这应该是和模拟退火算法类似的一种算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知大盘要在小盘之前就位，否则小盘最终仍要移动。为了得到最简洁的步骤，应从大到小使各个盘子依次就位。但每一个盘子有两种移动方式:直接就位和先移到辅助位再移到目标位。通常前者更优但后者在某些情况下优于前者。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个盘子移动时，比其小的盘子不能出现在原位和要移动的位置上，必须全部放到辅助位上。于是事先要先移动较小盘，这是一个递归过程，模拟这个过程即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个通俗的做法是每一次都同时考虑这两种情况并进行状态转移。这里采用另一种方法—随机数转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次使用后一种(见上文)转移方法时都有一定的概率，这个概率随着时间的推移不断减小(这是模拟退火算法的思想)。也就是说用随机数来判别下一次的状态转移方式。这样做显然偶然性太大，可以使这个过程进行更多次(比如500次)，来获得很高概率的正确性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随机数转移法将总路径压缩到一定的值，比起朴素盲目搜索算法大大简化了总状态数。但缺点是具有一定偶然性，可以通过参数调整的方法来尽可能地提高正确率。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;using namespace std;int first[46], last[46];int first2[46], last2[46];int n, ans = static_cast&lt;int&gt;(1e8);int ANS[233333], size = 0;int an[233333];void mv(int p, int from, int to) &#123; if (from == to)return;//就在目标位上,不用动 for (int i = p - 1; i &gt;= 1; i--)mv(i, first2[i], 6 - from - to);//小盘全移到辅助位上 ANS[size++] = p * 100 + from * 10 + to;//记录移动步骤 first2[p] = to;//修改&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= 3; i++) &#123; int x, y; cin &gt;&gt; x; for (int j = 1; j &lt;= x; j++) &#123; cin &gt;&gt; y; first[y] = i; &#125; &#125; for (int i = 1; i &lt;= 3; i++) &#123; int x, y; cin &gt;&gt; x; for (int j = 1; j &lt;= x; j++) &#123; cin &gt;&gt; y; last[y] = i; &#125; &#125; srand(23333);//随机种子 for (int g = 1; g &lt;= 500; g++) &#123; size = 0; for (int i = 1; i &lt;= n; i++)first2[i] = first[i], last2[i] = last[i];//先复制一遍数据 for (int i = n; i &gt;= 1; i--) &#123; if (rand() % (n - i + 2) == 0)mv(i, first2[i], 6 - first2[i] - last2[i]), mv(i, first2[i], last2[i]);//第二种转移 else mv(i, first2[i], last2[i]);//第一种转移 &#125; if (ans &gt; size) &#123;//获得更优解,记录 ans = size; for (int i = 0; i &lt; size; i++)an[i] = ANS[i]; &#125; &#125; for (int i = 0; i &lt; ans; i++) cout &lt;&lt; "move " &lt;&lt; an[i] / 100 &lt;&lt; " from " &lt;&lt; char(an[i] % 100 / 10 + 'A' - 1) &lt;&lt; " to " &lt;&lt; char(an[i] % 10 + 'A' - 1) &lt;&lt; endl; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>随机数</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2827]蚯蚓]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2827-%E8%9A%AF%E8%9A%93%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题中，我们将用符号⌊c⌋表示对c向下取整，例如:⌊3.0⌋ = ⌊3.1⌋ = ⌊3.9⌋ = 3。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国里现在共有n只蚯蚓(n为正整数)。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为ai(i=1，2，… ，n)，并保证所有的长度都是非负整数(即:可能存在长度为0的蚯蚓)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只(如有多个则任选一个)将其切成两半。神刀手切开蚯蚓的位置由常数p(是满足0 &lt; p &lt; 1的有理数)决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为⌊px⌋和x - ⌊px⌋的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q(是一个非负整常数)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来……(m为非负整数)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m秒内，每一秒被切断的蚯蚓被切断前的长度(有m个数);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m秒后，所有蚯蚓的长度(有n+m个数)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王当然知道怎么做啦！但是他想考考你…… 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含六个整数 n，m，q，u，v，t其中:n，m，q的意义见[问题描述];u，v，t均为正整数;你需要自己计算 p=u/v(保证0]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2831]愤怒的小鸟]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我第一年竞赛(NOIP2016)的最后一题，考状压DP，当时拿了5分，印象十分深刻，现在特此记录一下AC过程。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kiana 最近沉迷于一款神奇的游戏无法自拔。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说，这款游戏是在一个平面上进行的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一架弹弓位于 (0，0)处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx的曲线，其中a，b是Kiana 指定的参数，且必须满足a &lt; 0，a，b 都是实数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小鸟落回地面(即x轴)时，它就会瞬间消失。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在游戏的某个关卡里，平面的第一象限中有n只绿色的小猪，其中第i只小猪所在的坐标为(xi，yi)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某只小鸟的飞行轨迹经过了(xi，yi)，那么第i只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一只小鸟的飞行轨迹没有经过(xi，yi)，那么这只小鸟飞行的全过程就不会对第i只小猪产生任何影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，若两只小猪分别位于(1，3)和(3，3)，Kiana可以选择发射一只飞行轨迹为y=-x2+4x的小鸟，这样两只小猪就会被这只小鸟一起消灭。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这款神奇游戏的每个关卡对 Kiana来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在[输入格式]中详述。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设这款游戏一共有T个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数T，表示游戏的关卡总数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面依次输入这T个关卡的信息。每个关卡第一行包含两个非负整数n，m分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的n行中，第i行包含两个正实数xi，yi，表示第i只小猪坐标为(xi，yi)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=0，表示Kiana输入了一个没有任何作用的指令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=1，则这个关卡将会满足:至多用⌈n/3+1⌉只小鸟即可消灭所有小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=2，则这个关卡将会满足:一定存在一种最优解，其中有一只小鸟消灭了至少⌊n/3⌋只小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证1≤n≤18，0≤m≤2，0 &lt; xi，yi &lt; 10，输入中的实数均保留到小数点后两位。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文中，符号⌈c⌉和⌊c⌋分别表示对c向上取整和向下取整，例如:⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个关卡依次输出一行答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。 输入输出样例Sample input#1 22 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.00 Sample output#1 11 Sample input#2 32 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.00 Sample output#2223 Sample input#3 110 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99 Sample output#3 6 说明[样例解释1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这组数据中一共有两个关卡。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个关卡与[问题描述]中的情形相同，2只小猪分别位于(1.00，3.00)和(3.00，3.00)，只需发射一只飞行轨迹为y = -x2 + 4x的小鸟即可消灭它们。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个关卡中有5只小猪，但经过观察我们可以发现它们的坐标都在抛物线 y = -x2 + 6x上，故Kiana只需要发射一只小鸟即可消灭所有小猪。[数据范围] 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察状态压缩DP，与上一个题目思想类似，但实现更复杂。另外其实我没看出来指令的作用…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据状压DP的思路，仍用一个二进制数来表示状态。对于一个二进制数x，当第i位为0时表示第i只小猪未被消灭，为1表示已被消灭，令f(x)表示在x的状态下需要发射的最少的小鸟数量，则有状态转移方程: f(x)=1+\min(f(x|1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJUOJ]难以置信的竞赛]]></title>
    <url>%2F2019%2F01%2F10%2FTJUOJ-%E9%9A%BE%E4%BB%A5%E7%BD%AE%E4%BF%A1%E7%9A%84%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[难度：估计在普及+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;天津大学OJ上的一道题，最早来自The 7th UESTC Programming Contest Preliminary。看rank list发现这道题都做的特别惨烈…一看这题感觉是状压DP，一写果然A了，在这里做一个总结。之后应该还会有类似的情景。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题在http://acm.tju.edu.cn/toj/vcontest/showp10518_B.html ，下面是翻译。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上周，应用数学学院举办了放风筝比赛，参赛者分成两组，一对选手与另一名参赛者竞争。众所周知，划分对的不同方式可能带来不同的精彩等级值，精彩等级值是一个数。现在，叶小姐想知道如何划分竞争对手，以达到最高的精彩等级。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行包含一个整数T，表示测试样例的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每个测试样例，在第一行中有一个整数N(N≤16，N总是偶数)，表示有N名参赛者参加比赛。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下一个N行中，每行包含N个数。当第i个选手和第j个常数在一对中进行时，第i行中的第j个数是对应的精彩等级值。数据保证第i行中的第j个数等于第j行中的第i个数，即输入的矩阵是对称的。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每种情况，输出最大的精彩等级值，保留两位小数。 输入输出样例Sample input 120.0 1.01.0 0.0 Sample output 1.00 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察状态压缩DP(状压DP)，这是继离散化，压缩数组等DP技巧后的又一个重要方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态压缩DP是指用二进制编码的方法记录状态。这类的问题通常状态很多，但个体总数是不大的，比如本题小于16。这时可以用一个16位二进制数的01序列顺序来记录这些状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于一个二进制数x，用第i位为0表示第i+1个人未被安排，为1表示已被安排。f(x)表示在此情况下所得的最大精彩等级值，那么有状态转移方程： f(x)=\max\{f(x|(1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1514]引水入城]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1514-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N行×M列的矩形，如下图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，只有与湖泊毗邻的第1行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第N行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢?如果能，请计算最少建造几个蓄水厂;如果不能，求干旱区中不可能建有水利设施的城市数目。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行两个数，之间用一个空格隔开。输入的第一行是两个正整数N，M表示矩形的规模。接下来N行，每行M个正整数，依次代表每座城市的海拔高度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两行。如果能满足要求，输出的第一行是整数1，第二行是一个整数，代表最少建造几个蓄水厂;如果不能满足要求，输出的第一行是整数0，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。 输入输出样例Sample input#1 2 59 1 5 4 38 7 6 1 2 Sample output#1 11 Sample input#2 3 68 4 5 6 4 47 3 4 3 3 33 2 2 1 1 2 Sample output#2 13 说明[样例1 说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需要在海拔为9的那座城市中建造蓄水厂，即可满足要求。[样例2 说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图中，在3个粗线框出的城市中建造蓄水厂，可以满足要求。以这3个蓄水厂为源头在干旱区中建造的输水站分别用3 种颜色标出。当然，建造方法可能不唯一。[数据范围] 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察搜索算法和区间覆盖问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将水的流向关系抽象成有向无环图。实际操作中没有必要存图，只需在搜索中现找到邻边即可，这样时间差距不大但空间消耗大大减小，只有在无法现搜边的情况下才存图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样经过DFS或BFS即可找到第一行每一个城市能够联通的节点。本题中推荐BFS，因为图的规模过大很容易使DFS递归深度过高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过m次BFS，可以确定末行那些节点是与第一行联通的，若有k个无法联通，说明该处不可能建有水利工程，输出0即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题关键在于求最少数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先要知道如果每一个末行节点都与第一行某节点联通，则任何一个首行节点在末行与之联通的节点必定是连续的(可以画图验证)。这样可以得到每一个首行节点在末行的覆盖区间。问题便转化为区间完全覆盖问题，用贪心算法求解即得。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意本题中的一处剪枝:若首行中某一个节点值小于其左边或右边的节点值，则该节点不用考虑。这是因为其周围的节点覆盖区间一定包含该节点的覆盖区间，去除这一个子区间对于解区间完全覆盖问题是没有任何影响的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;struct Temp &#123; int l, r, rank; Temp() : l(static_cast&lt;int&gt;(1e8)), r(static_cast&lt;int&gt;(-1e8)) &#123;&#125; bool operator&lt;(Temp t) &#123; return this-&gt;l &lt; t.l; &#125;&#125; can[550];int op[250500];bool vis[250500] = &#123;false&#125;;bool mainVis[550] = &#123;false&#125;;int n, m;inline void BFS(int x) &#123; queue&lt;int&gt; que; que.push(x); while (!que.empty()) &#123; int a = que.front(); if (a &gt;= n * m - m)can[x].l = min(can[x].l, a % m), can[x].r = max(can[x].r, a % m), mainVis[a % m] = true; que.pop(); if (a &gt;= m &amp;&amp; op[a - m] &lt; op[a] &amp;&amp; !vis[a - m])que.push(a - m),vis[a - m] = true; if (a &lt; n * m - m &amp;&amp; op[a + m] &lt; op[a] &amp;&amp; !vis[a + m])que.push(a + m), vis[a + m] = true; if (a % m != 0 &amp;&amp; op[a - 1] &lt; op[a] &amp;&amp; !vis[a - 1])que.push(a - 1), vis[a - 1] = true; if (a % m != m - 1 &amp;&amp; op[a + 1] &lt; op[a] &amp;&amp; !vis[a + 1])que.push(a + 1), vis[a + 1] = true; &#125;&#125;inline int read() &#123; char e = static_cast&lt;char&gt;(getchar()); while (e &lt; '0' || e &gt; '9')e = static_cast&lt;char&gt;(getchar()); int sum = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10, sum += e - '0'; e = static_cast&lt;char&gt;(getchar()); &#125; return sum;&#125;int main() &#123; n = read(), m = read(); int c = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; op[c++] = read(); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; memset(vis, 0, sizeof(vis)); if (m != 1) &#123; if (i == 0 &amp;&amp; op[0] &lt; op[1])continue; if (i == m - 1 &amp;&amp; op[m - 1] &lt; op[m - 2])continue; if (i != 0 &amp;&amp; i != m - 1 &amp;&amp; (op[i] &lt; op[i - 1] || op[i] &lt; op[i + 1]))continue; &#125; BFS(i); &#125; bool key = true; int ans1 = 0; for (int i = 0; i &lt; m; i++) &#123; if (!mainVis[i])key = false, ans1++; &#125; if (key) &#123; cout &lt;&lt; 1 &lt;&lt; endl; sort(can, can + m); int r = 0, ans2 = 0, i = 0; while (r &lt; m) &#123; int p = 0; while (i &lt; m &amp;&amp; can[i].l &lt;= r)p = max(p, can[i++].r); r = p + 1; ans2++; &#125; cout &lt;&lt; ans2; &#125; else cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>区间</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1312]Mayan游戏]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1312-Mayan%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个7行5列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下: 每步移动可以且仅可以沿横向(即向左或向右)拖动某一方块一格:当拖动这一方块时，如果拖动后到达的位置(以下称目标位置)也有方块，那么这两个方块将交换位置(参见输入输出样例说明中的图6到图7 );如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落(直到不悬空，参见下面图1 和图2); 任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除(参见图1 到图3)。 注意: 如果同时有多组方块满足消除条件，几组方块会同时被消除(例如下面图4 ，三个颜色为1的方块和三个颜色为2的方块会同时被消除，最后剩下一个颜色为2的方块)。 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除(例如下面图5 所示的情形，5 个方块会同时被消除)。 方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意:掉落的过程中将不会有方块的消除。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面图1到图3给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为(0，0)，将位于(3，3)的方块向左移动之后，游戏界面从图1变成图2所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图3所示的局面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共 6 行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为一个正整数n，表示要求游戏通关的步数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的5行，描述7×5的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个0结束，自下向上表示每竖列方块的颜色编号(颜色不多于10种，从1开始顺序编号，相同数字表示相同颜色)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据保证初始棋盘中没有可以消除的方块。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有解决方案，输出n行，每行包含 3 个整数x，y，g表示一次移动，每两个整数之间用一个空格隔开，其中(x，y)(x，y)表示要移动的方块的坐标，g表示移动的方向，1表示向右移动，-1表示向左移动。注意:多组解时，按照x为第一关健字，y为第二关健字，1优先于-1，给出一组字典序最小的解。游戏界面左下角的坐标为(0，0)(0，0)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有解决方案，输出一行，包含一个整数-1。 输入输出样例Sample input 31 02 1 02 3 4 03 1 02 4 3 4 0 Sample output 2 1 13 1 13 0 1 说明[输入输出样例说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按箭头方向的顺序分别为图6到图11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;样例输入的游戏局面如上面第一个图片所示，依次移动的三步是:(2，1)处的方格向右移动，(3，1)处的方格向右移动，(3，0)处的方格向右移动，最后可以将棋盘上所有方块消除。[数据范围]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，初始棋盘上的方块都在棋盘的最下面一行;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，0&lt;n≤5。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察DFS。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到题目规则很复杂，动态规划状态太多压不下，并且数据量固定为5×7，可以考虑时间复杂度很高的暴力DFS法。本题很考验码力。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本做法正如题目中所言，按部就班模拟即可，还要注意一处剪枝:若一个方块左侧有方块时没有必要进行向左交换，因为之前必定有与之等价的右交换发生了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其余见示例代码注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;struct node &#123; int x, y, status;//相当于队列节点&#125; ans[5];//存答案int op[5][7] = &#123;0&#125;, n;//存当前的图案信息和移动次数int sum = 0;//记录还没有解决的色块数目inline void copy(int a[5][7], int b[5][7]) &#123;//复制数组函数 for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++)a[i][j] = b[i][j]; &#125;&#125;inline void findR(int x, int y, int &amp;last, int &amp;end) &#123;//找行上相同色块范围 for (int i = x; op[i][y] == op[x][y] &amp;&amp; i &gt;= 0; i--)last = i; for (int i = x; op[i][y] == op[x][y] &amp;&amp; i &lt; 5; i++)end = i;&#125;inline void findC(int x, int y, int &amp;last, int &amp;end) &#123;//找列上相同色块范围 for (int i = y; op[x][i] == op[x][y] &amp;&amp; i &gt;= 0; i--)last = i; for (int i = y; op[x][i] == op[x][y] &amp;&amp; i &lt; 7; i++)end = i;&#125;int update() &#123;//更新当前的图案信息 bool key[10][20] = &#123;false&#125;;//标志那个色块需要被解决 int l1, e1, l2, e2, t = 0; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; if (op[i][j] == 0)continue;//没有色块不考虑 findR(i, j, l1, e1), findC(i, j, l2, e2);//找到它的相同色块范围 if (e1 - l1 &gt;= 2) &#123; for (int p = l1; p &lt;= e1; p++)key[p][j] = true;//标记为true &#125; if (e2 - l2 &gt;= 2) &#123; for (int p = l2; p &lt;= e2; p++)key[i][p] = true; &#125; &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123;//解决所有被标记的色块 for (int j = 0; j &lt; 7; j++) &#123; if (!key[i][j])continue; t++;//统计被解决色的数目 op[i][j] = 0;//置为0,表示没有色块 &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123;//处理落下的色块 int begin = 0; while (op[i][begin] != 0 &amp;&amp; begin &lt; 7)begin++; for (int j = begin + 1; j &lt; 7; j++)if (op[i][j] != 0)op[i][begin++] = op[i][j]; for (int j = begin; j &lt; 7; j++)op[i][j] = 0; &#125; if (t != 0) &#123; return t + update();//如果本次处理了色块就可能有其余色块需要被解决,继续递归 &#125; return 0;//没有被解决的就返回0&#125;void DFS(int rank, int tot) &#123; if (rank == n) &#123; if (tot == 0) &#123;//全部的色块被解决,输出答案 for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ans[i].x &lt;&lt; " " &lt;&lt; ans[i].y &lt;&lt; " " &lt;&lt; ans[i].status &lt;&lt; endl; &#125; exit(0);//然后立即结束程序 &#125; else return;//否则返回 &#125; int temp[5][7];//储存没被处理的图案信息 copy(temp, op);//复制数组 for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; if (temp[i][j] == 0)continue; copy(op, temp);//每一次都要还原图案信息,相当于朴素DFS中的visit标记清零 if (i &lt; 4) &#123; ans[rank].x = i, ans[rank].y = j, ans[rank].status = 1; if (temp[i + 1][j] == 0) &#123;//右移落下的情况 int begin = 0; while (temp[i + 1][begin] != 0)begin++; op[i + 1][begin] = temp[i][j]; for (int z = j + 1; z &lt; 7; z++)op[i][z - 1] = op[i][z]; op[i][6] = 0; DFS(rank + 1, tot - update()); &#125; else &#123;//右移交换的情况 if (op[i + 1][j] == op[i][j])continue; swap(op[i + 1][j], op[i][j]); DFS(rank + 1, tot - update()); &#125; &#125; copy(op, temp); if (i &gt;= 1) &#123;//左移落下的情况 ans[rank].x = i, ans[rank].y = j, ans[rank].status = -1; if (temp[i - 1][j] == 0) &#123; int begin = 0; while (temp[i - 1][begin] != 0)begin++; op[i - 1][begin] = temp[i][j]; for (int z = j + 1; z &lt; 7; z++)op[i][z - 1] = op[i][z]; op[i][6] = 0; DFS(rank + 1, tot - update()); &#125; else continue;//左移交换,由于之前必有等价的右移在先,可知其不可行,直接剪枝,不考虑这一步 &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; 5; i++) &#123; int x, j = 0; while (cin &gt;&gt; x) &#123; if (x == 0)break; op[i][j++] = x; sum++; &#125; &#125; DFS(0, sum);//sum表示有多少色块 cout &lt;&lt; -1;//DFS过程中没有结束程序,说明无解,输出-1 return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合方案数问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E7%BB%84%E5%90%88%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里介绍组合方案数的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定N个正整数和M，用这N个数中的一些数进行求和，使得和为M，问方案数。该问题可以采用动态规划的方法快速求得。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设dp(x，y)表示从序号为1~x的数中选使得和为y的方案数，则有状态转移方程: dp(x,y)=\begin{cases}dp(x-1，y)+1 & y=value(x)\\ dp(x-1，y)+dp(x-1，y-value(x)) & y>value(x)\\ dp(x-1，y) & y]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间问题专题]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次探讨区间问题，这大多是基于贪心算法的，在很多题目中都能用到。下面讨论仅限于闭区间，开区间只需稍作调整即可。 区间完全覆盖问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间和这个区间上的m个子区间，求其中尽量少的区间，使得它们的并集覆盖整个区间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法:将各个区间的左端点升序排序;确定左值p，初始化p=0。从所有左端点小于等于左值的区间中选出右端点最大的一个，并加入集合，更新左值为右端点值+1。贪心正确性证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设总区间[1，n]，分区间[a1，b1]，[a2，b2]，… ，[am，bm]。规定f(x)表示覆盖[x，n]的最小区间数，则有状态转移方程: f(x)=\min\{1+f(b_k+1)\}，a_k\leq x\leq b_k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然f(x)是单调减的，所以取bk的最大值，即有f(x)=1+f(bt+1)，bt是最大的一个。这样就把动态规划问题转化为贪心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在题目保证有解的前提下，bt一定是不小于x的，可知算法的正确性。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int l, r; bool operator&lt;(node x) &#123; return this-&gt;l &lt; x.l; &#125;&#125; op[50];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++)cin &gt;&gt; op[i].l &gt;&gt; op[i].r; sort(op, op + m); int p = 0, i = 0, ans = 0; while (p &lt; m) &#123; int maxn = 0; while (op[i].l &lt;= p)maxn = max(maxn, op[i].r), i++;//根据序列的有序性,i不必初始化为0,直接按上一次的继续即可 p = maxn + 1; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 最大不相交区间问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间和它的m个子区间，求尽量多的区间使得它们两两不相交。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法:将区间按右端点升序排序，对于一簇右端点相同的区间，取左端点最大一个加入集合(如果可以加入的话)，然后继续找后面右端点相同的区间簇。贪心正确性证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设总区间[1，n]，分区间[a1，b1]，[a2，b2]，… ，[am，bm]。规定f(x)表示[1，x]中的最大不相交区间数目，则有状态转移方程:当x是某个区间右端点时: f(x)=\max\{1+f(a_k-1)\}，b_k=x否则: f(x)=f(p)，p=\max\{b_k\}，b_k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>区间</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串哈希]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[本文改编自https://blog.csdn.net/pengwill97/article/details/80879387&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多题目涉及字符串问题，但是字符串不如整数那样容易处理，尤其是涉及图时。这时需要构造映射string-&gt;int来将字符串转化为int，这就是字符串哈希算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希方案有很多种，这里选择很常用的一个—BKDR Hash。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希思路是将字符串看成是一个base位进制数(base为一个大质数)，具体思路如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于字符串的第i位，有: hash(0)=str(i)-’a’+1\\ hash(i)=(hash(i-1)*base+str(i)-’a’+1)%P，i\geq 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一个算出的hash值作为整个字符串的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P是一个大于base的质数。hash为一个unsigned long long的数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出这是计算这个base进制数的公式并且每个值都对P取了模，这个方法可以将字符串映射到[0，P)的正整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是可能有两个字符串不同但哈希值相同的情况，称为哈希冲突。在base，P足够大时这种冲突概率很低。这里列举几个质数，读者可以参考使用。 素数 冲突率% 53 10.416667 97 1.0416670 193 0.520833 389 1.302083 769 0.130208 1543 0.455729 3079 0.227865 6151 0.113932 12289 0.008138 24593 0.069173 49157 0.010173 98317 0.013224 196613 0.002543 393241 0.006358 786433 0.000128 1572869 0.000318 3145739 0.000350 6291469 0.000207 12582917 0.000040 25165843 0.000075 50331653 0.000010 100663319 0.000023 201326611 0.000009 402653189 0.000001 805306457 0.000011 1610612741 0.000000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;洛谷P3370用字符串哈希求互异字符串个数，下面给出代码:12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int P1 = 19260817, P2 = 100663319;int vis[P2] = &#123;0&#125;;unsigned long long h[1050] = &#123;0&#125;;inline int Hash(string s) &#123; h[0] = s[0] - 'a' + 1; for (int i = 1; i &lt; s.length(); i++) &#123; h[i] = (h[i - 1] * P1 + s[i] - 'a' + 1) % P2; &#125; return h[s.length() - 1];&#125;int main() &#123; ios::sync_with_stdio(false); int n, ans = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string str; cin &gt;&gt; str; int h = Hash(str); if (vis[h] == 0)vis[h] = 1, ans++; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增法求LCA]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%80%8D%E5%A2%9E%E6%B3%95%E6%B1%82LCA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次讨论树这种数据结构上的一种算法—用倍增算法求最近公共祖先(LCA)。首先介绍倍增算法的原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若给定一个正整数x且有x &lt; 2k，若从2k开始，令x从大到小依次减去2的方幂p(2k，2k-1…，1)，第一个能够使x-p≥0的数p必定在数x的二进制拆分表达式中。这个很容易用二进制解释证明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用depth[]储存每一个节点的深度(认为根节点深度为1)，用grand[][]储存每个节点的祖先并定义grand[x][y]表示x节点向上2y处的祖先。若越界则置为0。显然grand[x][0]是每个节点的父节点编号。这两个数组均可由DFS求出，详见示例代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定两个待求LCA的节点标号，首先要做的是将两个节点排到同一深度。操作方法是令深度较大的节点向上”跳跃”，直至深度与较小节点相同。一种朴素的方法是一层一层地向上跳，但时间消耗明显。这里可以用与快速幂类似的倍增思想加快跳跃速度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先确定k的大小，容易知道k=ceil{log_2(DEPTH)}，这里DEPTH为树的最大深度。通常取20即可。从大到小枚举2的方幂p，最终能使较大深度节点达到与较小深度节点相同的深度。这时如果两个节点重合，则它即为LCA。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若两个节点不相同，就需要让这两个节点同时向上跳，加快跳跃速度的方式与之前类似，也是通过倍增实现，跳跃后会到达LCA的正下方，直接返回父节点即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int MAX = 500001;struct edge &#123;//链式前向星存边 int to, next;&#125; op[MAX * 2];int head[MAX];//链式前向星节点首边int cnt = 0;//边编号int root = 1;//根节点编号int depth[MAX] = &#123;0&#125;;//存各个节点深度int grand[MAX][21] = &#123;0&#125;;//倍增使用int N, M;//存节点数和询问数int read() &#123;//读入优化 char e = static_cast&lt;char&gt;(getchar()); while (e &lt; '0' || e &gt; '9')e = static_cast&lt;char&gt;(getchar()); int sum = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10, sum += e - '0'; e = static_cast&lt;char&gt;(getchar()); &#125; return sum;&#125;void add(int x, int y) &#123;//构建链式前向星,从x到y有一条边 op[cnt].to = y; op[cnt].next = head[x]; head[x] = cnt++;&#125;void DFS(int x) &#123; for (int i = head[x]; i != -1; i = op[i].next) &#123;//遍历各个子节点 if (depth[op[i].to] != 0)continue;//不能向父节点回溯 depth[op[i].to] = depth[x] + 1;//深度加一 grand[op[i].to][0] = x;//初始化递推 for (int j = 1; j &lt; 21; j++)grand[op[i].to][j] = grand[grand[op[i].to][j - 1]][j - 1];//递推 DFS(op[i].to);//下一个子节点 &#125;&#125;int LCA(int x, int y) &#123;//求LCA的函数 if (depth[x] &gt; depth[y])swap(x, y);//认为y的深度较大 for (int i = 20; i &gt;= 0; i--) &#123; if (depth[grand[y][i]] &gt;= depth[x])y = grand[y][i];//y倍增至与x同深度 &#125; if (x == y)return x;//节点相同就是LCA 直接返回 for (int i = 20; i &gt;= 0; i--) &#123;//两个节点倍增至LCA的正下方 if (grand[x][i] != grand[y][i])x = grand[x][i], y = grand[y][i]; &#125; return grand[x][0];//父节点即为LCA&#125;int main() &#123; N = read(), M = read(), root = read(); memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= N - 1; i++) &#123; int x, y; x = read(), y = read(); add(x, y), add(y, x); &#125;//读入树的信息 depth[root] = 1;//初始化 DFS(root);//深搜求depth和grand for (int i = 0; i &lt; M; i++) &#123; int x, y; x = read(), y = read(); printf("%d\n", LCA(x, y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST表]]></title>
    <url>%2F2019%2F01%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST表是一种求区间最值的高效数据结构，不支持动态维护，建表时间复杂度O(nlogn)，查询复杂度O(1)。在不需要修改原数据的情况下ST表要比线段树更简洁，但在需要修改原数据时只能用线段树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST表可以定义为二维数组ST[][]，其中ST[i][j]表示从第j的元素开始的长度为2i的区间中的最值，也就是区间[j，j+2i-1]中的最值。这个表可以用DP思想建立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建表前，需要两个辅助数组log[]与bin[]。其中log[i]储存使2k&lt;=i的整数k的最大值;bin[i]储存2i。这两个数组都可以通过递推实现: log[0]=-1，log[x]=log[x/2]+1\\ bin[0]=1，bin[x]=bin[x/2]*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log数组大小达到数据量n，bin达到logn。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辅助数组构建完毕后开始建ST表。首先对ST表首行初始化，即ST[0][x]。它们都表示从x号元素开始长度为1的区间的最值，显然就是该元素本身。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外ST表中有递推公式: ST[i][x]=\max/\min\{ST[i-1][x]，ST[i-1][x+bin[i-1]]\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即将区间分成两半，求取其中的最值，这里注意x+bin[i]-1≤n。递推后即可完成建表。 下面探讨查询操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也可以用将区间平均拆分的分治思想来求给定区间的最值，但是给定区间长度不一定就是2的方幂，于是需要其它分治方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到有不等式2log[l]*2&gt;l。这是显然的。这个不等式启示我们可以将长度为l的区间拆分成两个长度为2log[l]的区间，这两个区间已然覆盖了区间所有的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此区间[a，b]的最值即为$\max/\min\{ST[log[l]][a]，ST[log[l]][b-bin[log[l]]+1]\}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里l=b-a+1，为区间长度。123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int ST[20][10000];//储存ST表数据int op[10000], n;//储存区间数据int log[10000], bin[20];//储存log值以及指数值int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; ST[0][i] = op[i]; &#125;//第一行初始化 log[0] = -1; for (int i = 1; i &lt;= n; i++)log[i] = log[i / 2] + 1;//log初始化 bin[0] = 1; for (int i = 1; i &lt; 20; i++)bin[i] = bin[i - 1] * 2;//bin初始化 for (int i = 1; i &lt; 20; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (j + bin[i] - 1 &lt;= n) &#123; ST[i][j] = min(ST[i - 1][j], ST[i - 1][j + bin[i - 1]]);//递推建表,DP思想 &#125; &#125; &#125; int k; cin &gt;&gt; k;//查询k次 while (k-- &gt; 0) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; int t = log[r - l + 1]; cout &lt;&lt; min(ST[t][l], ST[t][r - bin[t] + 1]) &lt;&lt; endl;//输出查询结果 &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>区间最值</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在来认识一种新的求幂算法—快速幂算法。这个算法可以在O(logn)的时间复杂度下计算nm的值(要求m为自然数)。相比朴素O(n)累乘算法，效率大大提升。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速幂算法基于倍增思想，是倍增算法的一个应用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个自然数都可以写出它唯一的二进制数，即有: m=2^{k_1}+2^{k_2}+...+2^{k_m}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里$0\leq k_1 &lt; k_2&lt; …&lt; k_m$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么$n^m$可以表示为$n^{2^{k_1}+2^{k_2}+…+2^{k_m}}$，即$n^{2^{k_1}} × n^{2^{k_2}} × … × n^{2^{k_m}}$，从而化为几个数的乘积，并且这几个数有这平方级的关系。这样就可以把求幂运算压至O(logn)复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码(答案对P取模):12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; const int P = 10000007; long long int n, m; cin &gt;&gt; n &gt;&gt; m; long long int t = n; long long int ans = 1; while (m &gt; 0) &#123; if (m % 2 == 1)ans *= t, ans %= P; t *= t; t %= P; m /= 2; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法]]></title>
    <url>%2F2019%2F01%2F09%2FFloyd%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了Dijkstra算法和SPFA算法，另一种求最短路方法是Floyd算法。这个算法可以求出任意两点之间的最短路径长度，支持负边权，需要用邻接矩阵存图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法缺点是耗时过大，时间复杂度O(n3)。算法步骤:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 初始化dist数组，邻接节点dist值即为相邻边权值，否则为inf(无穷大)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 枚举每一个节点，用这个节点作中介，更新所有节点对的最短路径值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后dist即为最短路径数组，如果为inf则两点不连通。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下:12345678for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i != j &amp;&amp; i != k &amp;&amp; j != k) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); &#125; &#125;&#125; 算法正确性证明:首先要清楚，最短路只有三种情况:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 两点直接相连且路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 两点经一个中介点路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 两点经多个中介点路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况1已经求出，且算法全程对这个值没有影响。情况2在枚举到中介点k时就已经求出了所有以k为单个中介的两点最短路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于情况3，假设中介点为a1 &lt; a2 &lt; … &lt; am。两点靠m个中介点获得最短路。令集合S={x，y，a1，a2…am}(x，y分别是源点和终点)。当k枚举到a1时，必然会更新这样一对属于情况2的节点对(ai，aj)，其中ai，aj∈S。这时可以看作是ai，aj直接相连而不经过a1，然后从S中清除a1，这样m个中介就减少至m-1个。后面的过程每次都使中介点减一，在枚举完成之前必可以将其转化为情况2并求出最短路径值。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
        <tag>图的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法与SPFA]]></title>
    <url>%2F2019%2F01%2F09%2FDijkstra%E7%AE%97%E6%B3%95%E4%B8%8ESPFA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dijkstra算法是一种基于贪心思想的求单源最短路算法，时间复杂度为O(n2)。Dijkstra算法要求边权为正。步骤:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 一个数组dis[]保存最短路径长的结果，源点值置为0，其余为inf。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 一个集合S保存所有已求出最短路径长的节点，初始化S为空。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 从不在S中的节点集合中找到dis最小的节点，用这个节点更新与之相邻的的节点dis值(这个过程叫松弛)，并将这个节点加入S。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复③，直到所有节点都加入S中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们证明，不在S中的节点集合里面dis最小的节点，设为min，它的dis最小值必为当前值。这是因为若存在另外一条路径使得点dis值更小，必定会经过其余的某一个点，假设该点dis值为k，则应该有k+p &lt; min，然而p ≥ 0且k ≥ min，可知这是不可能的。从这个原理上就可以明白Dijkstra要求边权非负的原因。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际操作中可以用小根堆来维护最小值，这样时间复杂度降至稳定的O((m+n)logn)。这里值得注意的是，由于堆中经常进行调整，对于一个dis值已经被修改然而已在堆中的节点，我们应该对其进行调整。所以构造一个从节点序号到堆中具体位置的映射，来更新节点在堆中的位置。具体细节见示例代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本示例代码采用链式前向星+小根堆优化的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n, m, from;const int MAX = 100000;struct edge &#123; int to, value, next;&#125; op[2 * MAX + 1];//链式前向星存图int head[MAX + 1], dis[MAX + 1];int heap[MAX + 1], size = 0;//小根堆使用int ID[MAX + 1] = &#123;0&#125;;//构造映射inline void solve(int x) &#123; int x1 = 2 * x, x2 = 2 * x + 1, minn = x; if (x1 &lt;= size &amp;&amp; dis[heap[x1]] &lt; dis[heap[minn]])minn = x1; if (x2 &lt;= size &amp;&amp; dis[heap[x2]] &lt; dis[heap[minn]])minn = x2; if (minn != x) &#123; ID[heap[minn]] = x, ID[heap[x]] = minn; swap(heap[minn], heap[x]); solve(minn); &#125;&#125;inline int top() &#123; int r = heap[1]; heap[1] = heap[size--]; ID[heap[1]] = 1; solve(1); return r;&#125;inline void up(int x) &#123; if (x == 1)return; if (dis[heap[x / 2]] &gt; dis[heap[x]]) ID[heap[x / 2]] = x, ID[heap[x]] = x / 2, swap(heap[x / 2], heap[x]), up(x / 2);&#125;inline void add(int x) &#123; heap[++size] = x; ID[x] = size; up(size);&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; from; memset(head, -1, sizeof(head)); for (register int i = 1; i &lt;= n; i++)dis[i] = 2147483647; dis[from] = 0; for (register int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; op[i].next = head[x], op[i].to = y, op[i].value = z; head[x] = i; &#125; add(from);//将源点加入堆 while (size &gt; 0) &#123; int t = top();//取堆中dis值最小节点,并将其移出堆,此后这个节点不可能再被加入堆中 for (register int i = head[t]; i != -1; i = op[i].next) &#123;//找到该节点邻接节点 if (dis[t] + op[i].value &lt; dis[op[i].to]) &#123; dis[op[i].to] = dis[t] + op[i].value;//修改该邻接点dis值 if (ID[op[i].to] != 0) &#123;//已在堆中,更新其在堆中的位置 up(ID[op[i].to]); &#125; else &#123; add(op[i].to);//不在堆中,将其加入堆 &#125; &#125; &#125; &#125; for (register int i = 1; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; " "; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来介绍SPFA，SPFA本质上是基于队列的Bellman-Ford算法，支持负边权并且可以判断负环。该算法时间复杂度达O(km)。该算法不稳定，在某些情况下时间复杂度会达到朴素Bellman-Ford级别。算法思想:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 将源点加入队列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 弹出队首元素，用该元素松弛其邻接点，若松弛后的节点不在队列中，让该节点入队。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复②，直到队列为空为止。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当图存在负环时，最短路径是不存在的。可以证明存在负环的充要条件是某一个节点入队次数大于或等于n次。利用这个结论可以方便地判定负环，这是BFS版的SPFA判负环方法。SPFA还有DFS版本，即用栈代替队列，只要需要松弛的点在栈中就可以判断有负环。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int n, m, from;const int MAX = 100000;struct edge &#123; int to, value, next;&#125; op[2 * MAX + 1];//链式前向星存图int head[MAX + 1];int dis[MAX + 1];bool vis[MAX + 1] = &#123;false&#125;;int num[MAX + 1] = &#123;0&#125;;int main() &#123; ios::sync_with_stdio(false); queue&lt;int&gt; que; cin &gt;&gt; n &gt;&gt; m &gt;&gt; from; memset(head, -1, sizeof(head)); for (register int i = 1; i &lt;= n; i++)dis[i] = 2147483647; dis[from] = 0; for (register int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; op[i].next = head[x], op[i].to = y, op[i].value = z; head[x] = i; &#125; que.push(from), vis[from] = true, num[from]++; while (!que.empty()) &#123; int r = que.front(); que.pop(); vis[r] = false; for (int i = head[r]; i != -1; i = op[i].next) &#123; if (dis[r] + op[i].value &lt; dis[op[i].to]) &#123; dis[op[i].to] = dis[r] + op[i].value; if (!vis[op[i].to])que.push(op[i].to), vis[op[i].to] = true, num[op[i].to]++; if (num[op[i].to] &gt;= n) &#123; cout &lt;&lt; "ERR" &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; for (register int i = 1; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; " "; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过洛谷上的测试，Dijkstra+heap优化可以通过P3371和强化版的P4779。SPFA可以通过前者，但由于在后者被卡，无法通过。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，Dijkstra+heap与SPFA的速度比较存在争议，对上面算法的正确性和算法选择请读者自行理解。推荐在没有负边时使用堆优化Dijkstra算法，仅在含负边或者需要判负环时使用SPFA。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于SPFA的两个优化： SLF（Small Label First）优化：设当前队首元素为f（要取出队首），待入队元素为x，若dict[x]&lt;dict[f]，则将x插入队首，否则插入队尾。 LLL（Large Label First）优化：若队首为f，如果dict[f]大于当前队列中dict的平均值，则取出f放到队尾，跳过该元素判断下一个，直到队首元素的dict不大于平均值，将其拿出进行松弛。实际操作中我们需要不停记录队列中的元素个数和dict和来维护平均值。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基础算法</tag>
        <tag>图的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分解质因数]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分解质因数算法是一种很重要的数论算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; for (int i = 2; i &lt;= n / 2; i++) &#123; if (n % i == 0) &#123; cout &lt;&lt; i &lt;&lt; " "; n /= i--; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法通俗易懂。易知第一个可以整除n的i必然是n最小的质因数，这时我们将其输出，并令n除掉i，再令i自减1以在后来的循环中消除n的所有i因子。最后的n将成为一个质数，循环将退出，再将剩下的n输出即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间与n的大小呈对数关系。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2123]皇后游戏]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2123-%E7%9A%87%E5%90%8E%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游戏的另一个问题。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;皇后有 n 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 n 位大臣颁发奖金，其中第 i 位大臣所获得的奖金数目为第i－1 位大臣所获得奖金数目与前 i 位大臣左手上的数的和的较大值再加上第 i 位大臣右手上的数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;形式化地讲:我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则第 i 位大臣获得的奖金数目为 ci可以表达为: c_i=\begin{cases} a_1+b_1 & i=1\\ \max\{c_{i-1},\displaystyle\sum_{j=1}^ia_j\} & 2\leq i\leq n \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。注意:重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 T，表示测试数据的组数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 T 个部分，每个部分的第一行包含一个正整数 n，表示大臣的数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个部分接下来 n 行中，每行两个正整数，分别为 ai和 bi，含义如上文所述。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共 T 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 输入输出样例Sample input#1 134 12 21 2 Sample output#1 8 Sample input#2 2585 10095 9976 8760 9779 85129 6818 4552 6139 8363 6745 9952 5482 10023 5499 9463 10052 68 Sample output#2 528902 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 1，2，3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 1，3，2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 2，1，3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 2，3，1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 3，1，2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 3，2，1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当按照 3，2，1 这样排列队伍时，三位大臣左右手的数分别为:(1， 2)，(2， 2)，(4， 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 1 位大臣获得的奖金为 1 + 2 = 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 2 位大臣获得的奖金为 max{3， 3} + 2 = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 3 为大臣获得的奖金为 max{5， 7} + 1 = 8。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于全部测试数据满足:T≤10，1≤n≤20000，1≤ai，bi≤109。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察数学推导，排序和贪心，难度很高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个相邻的大臣i，j，假定i前方的a之和为p，i前的大臣c值为q，那么可以求出j的c值: c_j=\max\{c_i，p+a_i+a_j\}+b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里ci也可以求出: c_i= \max\{q，p+a_i\}+b_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以有 c_j=\max\{\max\{q，p+a_i\}+b_i，p+a_i+a_j\}+b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即 c_j=\max\{q+b_i+b_j，p+a_i+b_i+b_j，p+a_i+a_j+b_j\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理交换后有 c_j=\max\{q+b_j+b_i，p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定不交换更优，那么有 \max\{q+b_i+b_j，p+a_i+b_i+b_j，p+a_i+a_j+b_j\}\leq \max\{q+b_j+b_i，p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把这个式子记作①。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现其中都有q+bi+bj这一项，把它们归结为max{a，b}≤max{a，c}。容易发现当b≤时max{a，b}≤max{a，c}必成立。在b&gt;c时可能max{a，b}≤max{a，c}，也可能max{a，b}&gt;max{a，c}。这时我们会交换两个元素使b≤c，从而使max{a，b}≤max{a，c}一定成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此我们可以不考虑q+bi+bj，只考虑后边式子的大小关系: \max\{p+a_i+b_i+b_j，p+a_i+a_j+b_j\}\leq \max\{p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记作②。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当②成立时，①必然也是成立的;而②不成立时交换后即可使①成立。所以可以通过②来判别是否要交换。另外可以发现②取等时，①也取等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将②变形 \max\{b_i，a_j\}+a_i+b_j\leq \max\{b_j，a_i\}+b_i+a_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移项得 \max\{b_i，a_j\}-b_i-a_j\leq \max\{b_j，a_i\}-a_i-b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等价于 -\min\{b_i，a_j\}\leq -\min\{b_j，a_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即为 \min\{a_i，b_j\}\leq \min\{a_j，b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记为③。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地理解本题，下面给出几个概念和定理。 [判别元素]参与相邻元素判别的因子。比如这里的min{ai，bj}和min{aj，bi}。 [相邻子条件]可以使相邻元素在某种次序下更优的判别元素所满足的条件。如果记A=min{ai，bj}，B=min{aj，bi}，则相邻子条件为A≤B，此时i在j前更优。记相邻子条件为P(X，Y)，在判别元素X，Y满足相邻子条件(X≤Y)时为真。 [逆序]对于一个序列A1，A2，A3，…An，若存在i，j$(1 \leq i &lt; j \leq n)$使得P(Ai，Aj)为假，则称Ai，Aj组成一个逆序。逆序会破坏序列的最优性。 [相邻全局最优化原理]一个序列，其判别元素序列为A1，A2，A3，…An。当序列不存在逆序时，序列最优。 [等价序列转化原理]交换相邻相等元素的位置，答案不变，这时两个序列等价。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个两两相邻元素都满足子条件的序列不一定是最优的，因为它可能存在逆序。比如序列ABC满足A≤B，B≤C，但是A&gt;C(一个逆序)，此时若B=C，可以进行等价变形得到ACB，此时AC违背了子条件，交换AC得到序列CAB，显然CAB是比ABC更优的序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是存在逆序并不一定使序列不最优，也就是说存在逆序的序列得到的答案可能与最优序列答案是相同的。但是没有逆序的序列一定是最优的，化为没有逆序的序列是最保险，最稳妥的做法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于国王游戏，可以采用按照左右手数值乘积升序排列的做法。这是因为排序后得到的序列没有逆序。这种两两相邻元素满足子条件就可以保证全局没有逆序的性质称为传递性。国王游戏中小于号是可传递的，但本题不可以。在本题中如果A≤B，B≤C，可能有A&gt;C的情况发生。如果只像国王游戏那样按照相邻子条件排序，得到的序列可能有逆序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该设法创造一个具有传递性的排序思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察③式，发现a与b的情况可以归结为以下几种: 第一种:ai &lt; bi且aj &gt; bj，此时必有ai≤aj，也就是说a是升序的。 第二种:ai = bi且aj = bj。a与b都是不变的，③式显然成立。 第三种:ai &gt; bi且aj &gt; bj，此时必有bj≤bi，也就是说b是降序的。 第四种:ai &lt; bi且aj &gt; bj，③式显然成立。 当然还有第五种:ai &gt; bi且aj &lt; bj，此时③式显然不成立 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先将I组(ab)的元素。在I组中按照a升序排列，在III组中按b降序排列。可以证明这是一种可行且可传递的排序方法。可以证明它没有逆序，任取两个元素X，Y(Y在X后)，可以归结为以下六种情况来判别P(X，Y)的成立与否: X，Y都来自I:符合第一种情况，成立。 X来自I，Y来自II:显然成立 X来自I，Y来自III:符合第四种，成立。 X来自II，Y来自II:这时两者是相等的，成立。 X来自II，Y来自III:显然成立。 X来自III，Y来自III:符合第三种，成立。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就找到了一种排序策略得到一个满足全局最优化原理的序列，从中找到的答案必然为最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这个题，可以发现相邻交换法并不只是按照相邻子条件排序就可以的，排序后的序列不能只让两两相邻元素符合子条件，还要没有逆序。这是相邻交换法的重要理论依据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，虽然a=b时可以任意排序(依据等价序列转化原理)，但是不能在重载时直接返回一个true或者false，这样会出现矛盾(a &lt; b且b &lt; a)造成RE。示例代码中把它归到了I组中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; long long a, b; int d; void make(long long x, long long y) &#123; a = x, b = y; if (a == b)d = 0; else if (a &lt; b)d = -1; else d = 1; &#125; bool operator&lt;(node p) &#123; if (this-&gt;d != p.d)return this-&gt;d &lt; p.d; if (this-&gt;d &lt;= 0)return this-&gt;a &lt; p.a; else return this-&gt;b &gt; p.b; &#125;&#125; op[20001];long long c[20001];int n;int main() &#123; int T; cin &gt;&gt; T; for (int t = 1; t &lt;= T; t++) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; long long x, y; cin &gt;&gt; x &gt;&gt; y; op[i].make(x, y); &#125; sort(op + 1, op + n + 1); long long ans = c[1] = op[1].a + op[1].b, temp = op[1].a; for (int i = 2; i &lt;= n; i++) &#123; temp += op[i].a; c[i] = max(c[i - 1], temp) + op[i].b; ans = max(ans, c[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2258]子矩阵]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2258-%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出如下定义:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子矩阵:从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵(保持行与列的相对顺序)被称为原矩阵的一个子矩阵。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，下面左图中选取第2，4行和第2，4，5列交叉位置的元素得到一个2×3的子矩阵如图所示。9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1的其中一个2×3的子矩阵是4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相邻的元素:矩阵中的某个元素与其上下左右四个元素(如果存在的话)是相邻的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵的分值:矩阵中每一对相邻元素之差的绝对值之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题任务:给定一个n行m列的正整数矩阵，请你从这个矩阵中选出一个r行c列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含用空格隔开的四个整数n，m，r，c意义如问题描述中所述，每两个整数之间用一个空格隔开。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的n行，每行包含m个用空格隔开的整数，用来表示问题描述中那个n行m列的矩阵。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示满足题目描述的子矩阵的最小分值。 输入输出样例Sample input#1 5 5 2 39 3 3 3 99 4 8 7 41 7 4 6 66 8 5 6 97 4 5 6 1 Sample output#1 6 Sample input#2 7 7 3 37 7 7 6 2 10 55 8 8 2 1 6 22 9 5 5 6 1 77 9 3 6 1 7 81 9 1 4 7 8 810 5 9 1 1 8 101 3 1 5 4 8 6 Sample output#2 16 说明[输入输出样例1说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该矩阵中分值最小的2行3列的子矩阵由原矩阵的第4行，第5行与第1列，第3列，第4列交叉位置的元素组成为6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6其分值为:|6−5| + |5−6| + |7−5| + |5−6| + |6−7| + |5−5| + |6−6| =6[输入输出样例2说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该矩阵中分值最小的3行3列的子矩阵由原矩阵的第4行，第5行，第6行与第2列，第6列，第7列交叉位置的元素组成，选取的分值最小的子矩阵为9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10[数据说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，1 ≤ n ≤ 12，1 ≤ m ≤ 12矩阵中的每个元素1≤aij≤20;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，1 ≤ n ≤ 16，1 ≤ m ≤ 16，矩阵中的每个元素1≤aij≤1000，1≤r≤n，1≤c≤m。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察动态规划和DFS，实际上本题考察这两种方法的结合。由于涉及到行和列的全排，直接进行DP无法写出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现给定矩阵的型很小(不大于16)，在这种情况下用指数级时间复杂度的DFS枚举出所有的行排列，在这个基础上对列进行DP。这时DFS时间复杂度为$O(C_n^r)$，DP时间复杂度为$O(n^3)$。总时间复杂度即为$O(C_n^r*n^3)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一种行的枚举情况，令f(x，y)表示从前x列中取y列可以获得的最小绝对值之和(第x列必须在其中且x≥y)，那么有状态转移方程: f(x，y)=\min\{f(k，y-1)+S1(k，x)\}+S2(x)，1\leq k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>矩阵</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1108]低价购买]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1108-%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买;再低价购买”。每次你购买一支股票，你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价(216范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买;再低价购买”的原则。写一个程序计算最大购买次数。这里是某支股票的价格清单:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日期 1 ， 2 ， 3 ， 4 ， 5 ， 6 ， 7 ， 8， 9 ，10 ，11， 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;价格68 ，69 ，54， 64，68 ，64 ，70 ，67 ，78 ，62， 98， 87最优秀的投资者可以购买最多4次股票，可行方案中的一种是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日期 2 ， 5 ， 6 ，10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;价格 69， 68 ，64 ，62 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行: N(1≤N≤5000)，股票发行天数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行: N个数，是每天的股票价格。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个数:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大购买次数和拥有最大购买次数的方案数(≤231)当二种方案“看起来一样”时(就是说它们构成的价格队列一样的时候)，这2种方案被认为是相同的。 输入输出样例Sample input 1268 69 54 64 68 64 70 67 78 62 98 87 Sample output 4 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划/递推，与本材料第四题导弹拦截非常类似(只是多了一个求方案数的步骤)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问很容易求得，既可以使用O(n2)的经典动态规划思路也可以使用O(nlogn)的二分和贪心思路(详见第四题的加强版本解析)。示例代码给出的是前者。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨方案数的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令f(x)为以下标为x的元素为末尾的最长序列方案数。则dp(x)不为1时有如下的递推关系(不正确的版本): f(x)=\sum f(k)，1\leq kvalue(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化f(x)为0，dp(x)为1时直接令f(x)=1。这样答案即为所有dp(x)取到最大值的f(x)之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里注意到f(x)是很多函数值的和，它们其中重复的组合一定会被重复计算。容易发现，对于一个给定的x，value(x)即是确定的。倘若对于两个k1，k2满足递推式中的条件但是value(k1)≠value(k2)，可以肯定k1和k2这两个序列必不存在相同的序列组合。倘若value(k1)=value(k2)且有k1&lt;k2，可以肯定以k1所指元素为末尾的所有序列都在k2对应的序列集合中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上可知若令S(x)表示以下标为x的元素为末尾的序列组成的集合，那么有: value(a)≠value(b)时: S(a)\cap S(b)=\varnothing \\ value(a)=value(b)(a]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1736]创意吃鱼法]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1736-%E5%88%9B%E6%84%8F%E5%90%83%E9%B1%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考:到底要以何种方法吃鱼呢(猫猫就是这么可爱，吃鱼也要想好吃法 ^_*)。她发现，把大池子视为01矩阵(0表示对应位置无鱼，1表示对应位置有鱼)有助于决定吃鱼策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有多组输入数据，每组数据:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有两个整数n和m(n，m≥1)，描述池塘规模。接下来的n行，每行有m个数字(非“0”即“1”)。每两个数字之间用空格隔开。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，有n，m≤100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于60%的数据，有n，m≤1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，有n，m≤2500 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一个整数——猫猫一口下去可以吃掉的鱼的数量，占一行，行末有回车。 输入输出样例Sample input 4 60 1 0 1 0 00 0 1 0 1 01 1 0 0 0 10 1 1 0 1 0 Sample output 3 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察二维DP。该题目与本材料第一题最大正方形有类似之处。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，从左下角开始向右上方吸和从右上角开始向左下方吸本质是一样的。不妨强制要求只能向上吸，这样吸的方向就只有两种:向左上方和向右上方。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定dp(x，y，z)为从坐标(x，y)开始向z方向吸到的鱼的最大数目。这里z的定义是:向左上方为0，向右上方为1。dp全初始化为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样很难进行状态转移，这是因为在方阵中只有对角线有鱼时才可以吸。如果没有这个限制，状态转移方程很容易列出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于加上了限制，需要三个辅助数组来帮助完成状态转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取R1(x，y)表示坐标(x，y)的左方离它最近的鱼与其的距离;R2(x，y)表示坐标(x，y)的右方离它最近的鱼与其的距离;C(x，y)表示坐标(x，y)的上方离它最近的鱼与其的距离。不需要与下方鱼的距离，这是因为已经强制规定只能向上吸，下方的鱼对求解没有意义。这里的三个数组都在坐标(x，y)有鱼时才有定义。在某个方向上没有鱼时，直接赋上与边界的距离即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的话，状态转移方程就可以列出了，在坐标(x，y)有鱼时，有如下递推式: dp(x，y，0)=\min\{R1(x，y)，C(x，y)，dp(x-1，y-1，0)+1\}\\ dp(x，y，1)=\min\{R2(x，y)，C(x，y)，dp(x-1，y+1，1)+1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;坐标(x，y)没有鱼时，直接赋值为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从所有dp值中找到最大值即为答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码的数组记录的是鱼的坐标值，在递推时现算出距离。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;int dp[2505][2505][2] = &#123;0&#125;;int n, m;short int op[2501][2501] = &#123;0&#125;;short int sumR_1[2505][2505] = &#123;0&#125;;short int sumR_2[2505][2505] = &#123;0&#125;;short int sumC[2505][2505] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) &#123; int temp = 0; for (register int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; op[i][j]; if (op[i][j])sumR_2[i][temp] = j, sumR_1[i][j] = temp, temp = j; &#125; sumR_2[i][temp] = 2501; &#125; for (register int i = 1; i &lt;= m; i++) &#123; int temp = 0; for (register int j = 1; j &lt;= n; j++) if (op[j][i])sumC[i][j] = temp, temp = j; &#125; int ans = 0; for (register int i = 1; i &lt;= n; i++) &#123; for (register int j = 1; j &lt;= m; j++) &#123; if (!op[i][j])continue; dp[i][j][0] = min(min(j - sumR_1[i][j], i - sumC[j][i]), dp[i - 1][j - 1][0] + 1); dp[i][j][1] = min(min(sumR_2[i][j] - j, i - sumC[j][i]), dp[i - 1][j + 1][1] + 1); ans = max(ans, max(dp[i][j][0], dp[i][j][1])); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2185]仪仗队]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2185-%E4%BB%AA%E4%BB%97%E9%98%9F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。 现在，C君希望你告诉他队伍整齐时能看到的学生人数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一个数N(1≤N≤40000)。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一个数，即C君应看到的学生人数。 输入输出样例Sample input 4 Sample output 9 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以左下方的观察点为原点建系，发现可以观察到的人总在正上方和正右方以及右上方一个n-1阶的方阵中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以图中n=6为例，考察右上方5阶方阵中的观察情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中红色标出的是观察不到的人的坐标。发现可以被观察到等价于其横纵坐标互素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么若令f(x)表示n阶方阵中横纵坐标互素的点的个数，则答案即为f(N)+2。注意N=1时特判为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨f(x)的求法，很自然想到递推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图，在n=4(绿色部分)的基础上递推到n=5的情况，容易发现(5，5)一定会被剔除，然后(5，5)的正左方和正下方一定是成对剔除的。显然，如果令φ(x)表示小于x且与x互素的正整数的个数，则有以下递推式: f(x)=f(x-1)+2*φ(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在问题的关键在于求解φ(x)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;φ(x)在数论上是有定义的，称为欧拉函数(Euler’s totient function)。现在介绍欧拉函数的线性筛法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了理解这个筛法，要了解以下三个基本原理: 若p为素数，则φ(p)=p-1 若p为素数且p†k，则φ(kp)=(p-1)φ(k) 若p为素数且p|k，则φ(kp)=pφ(k) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明见题后注解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用这三个原理结合欧拉筛素数法，可得到下面筛法: 123456789101112131415int euler[40001] = &#123;0&#125;;//记录欧拉函数值int mark[40001] = &#123;0&#125;;//记录是不是素数int prim[40001], tot = 0;//储存当前已知的素数,tot 记录个数for (int i = 2; i &lt;= 40000; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; euler[i] = i - 1;//判断为素数,直接给欧拉函数赋值 &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (i * prim[j] &gt; 40000)break; mark[i * prim[j]] = 1;//标记这个数一定不是素数 if (i % prim[j] == 0)euler[i * prim[j]] = euler[i] * prim[j]; else euler[i * prim[j]] = euler[i] * (prim[j] - 1); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个筛法的可行性除了与欧拉筛法有关外，还利用了一个事实:每一个合数都可以写成k*p的形式并且p&lt;=k。prim数组中存放了所有不大于i的质数，由上面的原理可知在计算φ(i*prim[j])时φ(i)一定已经被求出了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个筛法很重要，它是很多数论方面题目的重要算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这个算法再结合递推式，本题目迎刃而解。1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int euler[40001] = &#123;0&#125;;int mark[40001] = &#123;0&#125;;int prim[40001], tot = 0;int A[40001] = &#123;0&#125;;int main() &#123; for (int i = 2; i &lt;= 40000; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; euler[i] = i - 1; &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (i * prim[j] &gt; 40000)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0)euler[i * prim[j]] = euler[i] * prim[j]; else euler[i * prim[j]] = euler[i] * (prim[j] - 1); &#125; &#125; A[1] = 1; for (int i = 2; i &lt;= 40000; i++)A[i] = A[i - 1] + 2 * euler[i]; int n; cin &gt;&gt; n; if (n == 1)cout &lt;&lt; 0; else cout &lt;&lt; A[n - 1] + 2; return 0;&#125; 注解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出欧拉函数性质后两个的证明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先欧拉函数是积性函数，即在(a，b)=1时有φ(ab)=φ(a)φ(b)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么在p†k时，由于p是素数，必有(p，k)=1，故φ(pk)=φ(p)φ(k)=(p-1)φ(k)。在p|k时，不妨设k=qps(p†q)，那么φ(pk)=φ(ps+1q)=φ(ps+1)φ(q)。这里φ(ps+1)为ps+1-ps，即ps(p-1)，因此φ(pk)=(p-1)psφ(q)。并且φ(k)=φ(q)φ(ps)=φ(q)ps-1(p-1)。代入即得φ(pk)=pφ(k)。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1052]过河]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1052-%E8%BF%87%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点:0，1，… ，L(其中L是桥的长度)。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数(包括S，T)。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目给出独木桥的长度L，青蛙跳跃的距离范围S，T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有1个正整数L(1≤L≤109)，表示独木桥的长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行有3个正整数S，T，M分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中1≤S≤T≤10，1≤M≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行有M个不同的正整数分别表示这M个石子在数轴上的位置(数据保证桥的起点和终点处没有石子)。所有相邻的整数之间用一个空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示青蛙过河最少需要踩到的石子数。 输入输出样例Sample input 102 3 52 3 5 6 7 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察线性动态规划，难点在于离散化数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(x)表示到达x这个点时踩到的最少的石子数，则状态转移方程为: dp(x)=\min\{dp(x-k)+status(x)\}，S \leq k \leq T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里status(x)在x处没有石子时为0，否则为1。起初dp均置为inf，dp(0)置为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$\max\{dp(L+k)，0 \leq k&lt;T\}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是注意到L非常大，一维数组会直接爆掉，必须采取离散化的方法降低数组大小。这里利用石子数很少的特点压缩。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了讲清楚压缩的方法，下面先介绍几个概念和原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引理：若dp(x)已知，青蛙经过合理的跳跃次序从x跳到y，[x，y]中没有任何石子，则dp(y)=dp(x)。引理显然。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源区间：对于一个石子，假定其坐标是x，那么称区间[x-T，x)为源区间。很容易证明，如果青蛙想要跳过这个石子，一定会经过源区间。这也就是说，倘若源区间中的所有DP值全部求得，那么这个石子所在位置及其后面的所有点的DP值都可以由状态转移方程推出。由此我们得到了一个重要结论。某一石子及其后的所有DP值只与这个石子源区间的值有关。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，源区间的长度是T。如若两个石子距离本身就不大于T，则我们称这个石子对应的源区间是不完整的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上面的结论可以发现，对于拥有完整源区间的一个石子，倘若在其前方的区间段中有一段与源区间同样长的区间且它们的值完全相等，则这两个区间是等价的，此时把石子移动到新的区间的右端点上，不影响结果。由引理可知，只需找到一段区间可以使其中任一点都可以经合理的次序跳到源区间的对应位置上即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨缩点方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2520缩：取1，2，… ，10的最小公倍数2520。容易发现，无论S，T为何值，青蛙总可以从x点跳跃至x+2520处的点。也就是说，将石子向前挪动2520个单位(如果可以移动的话)，不影响结果，类似地，将石子后移2520个单位同样不影响结果。这样的操作我们称之为同解变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72缩：经过数论上的证明(见题后注解)，可以发现方程:Sx1+(S+1)x2+…+TxT-S+1=72在1 ≤ S &lt; T ≤ 10时一定是有自然数解的。同样可以知道对于任意的S，T(S &lt; T)，青蛙总可以从x跳跃至x+72处。将石子向前向后移动72个单位仍然是同解变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然还有其它缩点方案，但原理都是一致的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，无论怎么变形，都必须保证两个源区间中没有石子，否则引理条件不满足，无法证明两个区间等价。比如两个石子距离2521而T为5时，不能将后一个石子向前挪2520个单位，这是因为新的源区间包含了前一个石子。72缩同理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，72缩必须对S=T的情况进行特判。2520缩不需要是因为即使S=T，2520仍然可以整除S，青蛙跳跃2520/S次仍然可以跳跃2520个单位。但72缩时由数论内容，只有S &lt; T时方程有自然数解，当S=T时，也仅有S=1，2，3，4，6，8，9时有解。倘若数据给定S=T=7，那么青蛙不可能跳跃若干步达到72个单位距离。因此S=T时需要特判(实际上只需特判S=T且为5，7，10即可)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要跳过最后一个石子迟早能到达桥的末端，直接置L为最后一个石子的位置即可，这样可以从最后一个石子的”后源区间”取答案。12345678910111213141516171819202122232425262728293031323334352520缩：#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e8using namespace std;int L, S, T, M;int op[101] = &#123;0&#125;, op2[101] = &#123;0&#125;;int status[258000] = &#123;0&#125;;int dp[258000];int main() &#123; cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; op[i]; sort(op + 1, op + M + 1); for (int i = 1; i &lt;= M; i++) &#123; if (op[i] - op[i - 1] &gt; 2520) &#123; op2[i] = (op[i] - op[i - 1]) % 2520 + op2[i - 1]; if (op2[i] - op2[i - 1] &lt;= T)op2[i] += 2520; &#125; else op2[i] = op2[i - 1] + op[i] - op[i - 1]; status[op2[i]] = 1; &#125; L = op2[M]; for (int i = 1; i &lt; L + T; i++)dp[i] = inf; dp[0] = 0; for (int i = 0; i &lt; L; i++) &#123; for (int j = S; j &lt;= T; j++) dp[i + j] = min(dp[i + j], dp[i] + status[i + j] ); &#125; int ans = inf; for (int i = L; i &lt; L + T; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404172缩：#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e8using namespace std;int L, S, T, M;int op[101] = &#123;0&#125;, op2[101] = &#123;0&#125;;int status[8000] = &#123;0&#125;;int dp[8000];int main() &#123; cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M; int ans = inf; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; op[i]; sort(op + 1, op + M + 1); if (S == T &amp;&amp; (S == 5 || S == 7 || S == 10)) &#123; //写成 if(S==T)同样正确 ans = 0; for (int i = 1; i &lt;= M; i++)if (op[i] % S == 0)ans++; cout &lt;&lt; ans; return 0; &#125; for (int i = 1; i &lt;= M; i++) &#123; if (op[i] - op[i - 1] &gt; 72) &#123; op2[i] = (op[i] - op[i - 1]) % 72 + op2[i - 1]; if (op2[i] - op2[i - 1] &lt;= T)op2[i] += 72; &#125; else op2[i] = op2[i - 1] + op[i] - op[i - 1]; status[op2[i]] = 1; &#125; L = op2[M]; for (int i = 1; i &lt; L + T; i++)dp[i] = inf; dp[0] = 0; for (int i = 0; i &lt; L; i++) &#123; for (int j = S; j &lt;= T; j++) dp[i + j] = min(dp[i + j], dp[i] + status[i + j] ); &#125; for (int i = L; i &lt; L + T; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125; 注解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出72缩的数学证明，以下内容涉及初等数论的相关内容，建议读者在熟悉初等数论的基础上阅读。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先介绍一个定理。 [赛瓦维斯特定理]给定两个互素的正整数a，b。若$ax+by=z$没有非负的整数解，则z具有最大值，该值为$ab-a-b$。 证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由$(a，b)=1$可知任意整数z，不定线性方程$ax+by=z$都是有解的。容易知道，对于不定方程的一个特解$x_0，y_0$，知$x_0+bt，y_0-at$也是方程的解，也就是说这些解x，y满足：$x \equiv x_0(mod\ b)，y \equiv y_0(mod\ a)$，它们本质上是同一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们证明$ax+by=z$在a，b互素时，仅有这样的一组解。假设x，y满足$ax+by=z$，而$ax_0+by_0=z$，作差得$a(x-x_0)+b(y-y_0)=0$，故有$ax \equiv ax_0(mod\ b)$。由于$(a，b)=1$，所以$ax \equiv ax_0(mod\ b)$就是$x \equiv x_0(mod\ b)$。故仅有一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(扩展:$ax\equiv b(mod\ m)$在$(a，m)|b$时有解，且有$(a，m)$组解)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这样的一系列解，必存在这样的一个解$x_1$，$y_1$满足$-b\leq x_10$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候若$x_1$加上$b$，就一定可以使x对应的解非负，但同时$y_1$要减去$a$。倘若$y_1 \geq a$，则对应的$ax+by=z$必然是有非负整数解的。倘若$y_1 &lt; a$，容易知道此时无论$x_1$加上多少倍的$b$，都不能使x和y同时非负，这时方程是无解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此，我们得到方程无解等价于$-b\leq x_1&lt;0$时有$y_1&lt;a$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个基础上令x1，y1分别取它们的最大值-1，a-1，代入原方程得到: z=-a+b(a-1)=ab-a-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是无解的z的最大值。证毕。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由这个定理，我们就可以更好地理解72缩的原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知道相邻的两个自然数是互素的，那么这两个自然数a，a+1不能线性表示的最大数是a*(a+1)-a-a-1=a2-a-1。给定S和T(S]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
        <tag>动态规划</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1156]垃圾陷阱]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1156-%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卡门――农夫约翰极其珍视的一条Holsteins奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为D(2≤D≤100)英尺。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设卡门预先知道了每个垃圾扔下的时间t(0 &lt; t ≤ 1000)，以及每个垃圾堆放的高度h(1 ≤ h ≤ 25)和吃进该垃圾能维持生命的时间f(1 ≤ f ≤ 30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续10小时的能量，如果卡门10小时内没有进食，卡门就将饿死。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为2个整数，D和G(1≤G≤100)，G为被投入井的垃圾的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二到第G+1行每行包括3个整数:T(0&lt;T&lt;=1000)，表示垃圾被投进井中的时间;F(1≤F≤30)，表示该垃圾能维持卡门生命的时间;和H(1≤H≤25)，该垃圾能垫高的高度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果卡门可以爬出陷阱，输出一个整数表示最早什么时候可以爬出;否则输出卡门最长可以存活多长时间。 输入输出样例Sample input 20 45 4 99 3 212 6 1013 1 1 Sample output 13 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察动态规划。这里提供三种解决思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要先对垃圾投入时间升序排列，确定序号。 三维DP法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析题目，状态量有垃圾序号，生命值，高度和绝对时间四种。一种解决思路是将垃圾序号，生命值和高度作为状态描述参量，对绝对时间求DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若令dp(r，l，h)表示在处理到第r个垃圾，生命值为l，高度为h时的最优逃出时间，则状态转移方程为:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time(r+1)&gt;l时: dp(r，l，h)=inf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h+height(r)&lt;d时: dp(r，l，h)=\min\{dp(r+1，l+life(r)，h)，dp(r+1，l，h+height(r))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;否则: dp(r，l，h)=time(r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起初，dp所有元素均置为0。inf表示无穷大。考虑到数据量大小，可以递归而非递推求解，但缺点是空间消耗过大，状态参量过多。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为dp(1，10，0)，若其为inf，说明无法逃出。在递归过程中用一个变量记录最长生存期，最后输出这个值即可。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e9using namespace std;int dp[3200][101][101] = &#123;0&#125;;int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxh = 0;int DP(int l, int r, int h) &#123; if (dp[l][r][h] != 0)return dp[l][r][h]; if (op[r].t &gt; l || r == g + 1) &#123; maxh = max(maxh, l); return dp[l][r][h] = inf; &#125; if (h + op[r].h &gt;= d)return dp[l][r][h] = op[r].t; return dp[l][r][h] = min(DP(l + op[r].v, r + 1, h), DP(l, r + 1, h + op[r].h));&#125;int main() &#123; cin &gt;&gt; d &gt;&gt; g; for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); if (DP(10, 1, 0) &lt; inf)cout &lt;&lt; DP(10, 1, 0); else cout &lt;&lt; maxh; return 0;&#125; 二维DP法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只考虑垃圾序号和高度两个参量，对生命值求dp。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(r，h)表示处理了前r个垃圾，高度达到h时的最大生存期。状态转移方程为:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time(r+1)≤dp(r，h)时: dp(r+1，h)=\max\{dp(r，h)+life(r+1)，dp(r，h-height(r+1))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起初所有dp元素全置为-1并初始化dp[0][0]=10，按照上述方程递推。结合方程特点，递推应按照从左到右，从上到下的顺序。行坐标范围为[0，G)，列坐标范围[0，D)。当其中出现dp(i，j)不为-1且j&gt;=d的情况时，记录逃出时间为time(i)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后遍历一遍二维表获得最大的dp(i，j)，此为最大生存期，注意行坐标范围为[0，G]。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度O(D×G)。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define inf (int)1e9using namespace std;int dp[3200][150];int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxt = 0;int mint = inf;int main() &#123; cin &gt;&gt; d &gt;&gt; g; memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); dp[0][0] = 10; for (int i = 0; i &lt; g; i++) &#123; for (int j = 0; j &lt;= d; j++) &#123; if (op[i + 1].t &lt;= dp[i][j]) &#123; dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + op[i + 1].v); if (j + op[i + 1].h &gt;= d)mint = min(mint, op[i + 1].t); dp[i + 1][j + op[i + 1].h] = max(dp[i + 1][j + op[i + 1].h], dp[i][j]); &#125; &#125; &#125; for (int i = 0; i &lt;= g; i++) for (int j = 0; j &lt; d; j++)maxt = max(maxt, dp[i][j]); if (mint != inf)cout &lt;&lt; mint; else cout &lt;&lt; maxt; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;善于发现的读者可能会注意到，这个二维DP只与两个相邻的行有关，容易发现dp数组可以压缩至一维。考虑到每一个元素只可能影响它正下方和正下方右边的某一值，我们应采取从上到下，从右到左的顺序进行DP。除此之外还要注意值修改顺序的不同。这便是解决本题的第三个方法，也是最优的方法。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define inf (int)1e9using namespace std;int dp[200];int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxt = 0;int mint = inf;int main() &#123; cin &gt;&gt; d &gt;&gt; g; memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); dp[0] = 10; for (int i = 0; i &lt; g; i++) &#123; for (int j = d - 1; j &gt;= 0; j--) &#123; if (op[i + 1].t &lt;= dp[j]) &#123; if (j + op[i + 1].h &gt;= d)mint = min(mint, op[i + 1].t); dp[j + op[i + 1].h] = max(dp[j + op[i + 1].h], dp[j]); maxt = max(maxt, dp[j]); dp[j] = max(dp[j], dp[j] + op[i + 1].v); maxt = max(maxt, dp[j]); &#125; &#125; &#125; if (mint != inf)cout &lt;&lt; mint; else cout &lt;&lt; maxt; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里总结一下动态规划问题的求解模型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 确定状态和状态之间的关系，理清那些是状态的描述量，那些是所求量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 列出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 观察状态转移方程，确定递推顺序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4#. 必要时应采取状态压缩DP，离散化(后文详述)和数组维数压缩的方法降低空间复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DP降维的方法有以下几种:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 状态之间可以互相表示，这时可以去除一些状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 该状态没有必要或者不影响递推过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上文的讲述，可以发现选取正确的状态参量来描述状态是一件很有意义的事情。选取状态时不仅要紧抓题目要点，还要尽可能精简。状态参量过少会难以描述状态甚至无法转移，过多很容易造成时间和空间的浪费。这一种能力既需要深厚的经验积累，有时又需要一点点灵感和大胆的猜想。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1120]小木棍[数据加强版]]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1120-%E5%B0%8F%E6%9C%A8%E6%A3%8D-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共二行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为一个单独的整数N表示砍过以后的小木棍的总数，其中N≤65。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行为N个用空个隔开的正整数，表示N根小木棍的长度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个数，表示要求的原始木棍的最小可能长度。 输入输出样例Sample input 95 2 1 5 2 1 5 2 1 Sample output 6 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察DFS及剪枝，对搜索和剪枝能力要求很高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入时过滤掉大于50的数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知最小的木棍长度可能值一定不小于当前木棍长度的最大值，不大于所有木棍长度的和。从可能的最小值开始只到最大值依次检验，但凡找到一个值可行，该值显然最小，输出该值并结束程序。另外答案只可能是长度和的因子，非因子直接continue即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检验方式为DFS，从搭建第一个木棍开始，遍历所有尚未访问的木棍数值，将其加入到新的木棍中。若所有木棍都可以加入到新木棍中以拼成若干根等长的木棍，则该值可行。这样的做法时间复杂度相当高，极易超时。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于值只有在DFS完成后才可以知道其可行性，并且得到最值后立即结束程序，我们不可在DFS过程中通过值的最优性剪枝。下面探讨其它剪枝方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自排序原则：每一根新的长木棍是由许多小木棍组成的，本质上是若干个数相加，这些数之间一定有次序关系。由于我们只考虑它们的和而并不关心它们的次序，所以可以规定每一个长木棍由若干长度递减的木棍组成，从而避免很多次序不同但本质相同的组合。这里不推荐升序排列，这是因为较小的木棍有更高的机动性，升序后每一个新的长木棍末端都由较长的木棍组成，由于较长的木棍机动性差，会导致频频回溯，最终使程序性能下降。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一剪枝法则：一个待完成的长木棍在加入一根木棍后刚好完成，若在此基础上拼凑剩余长木棍不可行，则用其他木棍拼凑该待完成长木棍一定也是不可行的。结论证明:已知剩余长度为a1，a2，…，an的木棍，在加入ai后刚好拼凑了一根长木棍，之后用剩余的n-1根木棍拼凑剩下的长木棍不可行。假设加入ap1，ap2，…，aps这s根木棍(满足ap1+ap2+…+aps=ai)后拼凑好了最初的长木棍，剩下的n-s根木棍同样可以拼凑剩下的长木棍。这n-s根木棍中必有ai，此时交换ai和ap1，ap2，…，aps的位置，这显然是一种可行的方案，与已知条件矛盾，从而得证其余拼凑方案必不可行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二剪枝法则：对于一根完全没有完成的长木棍(长度为0)，向其中加入一根木棍，若在此基础上不可行，则向其中加入剩余木棍中的任何一个都不可行。该结论证明与第一剪枝法则类似，从略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合上述三点策略，容易写出完整DFS代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结:递归时尽量小起点，避免频繁回溯。另外注意自排序原则，这是很重要的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(int x, int y) &#123; return x &gt; y;&#125;int op[100], n, sum[100] = &#123;0&#125;, vis[100], length, number;void DFS(int rank, int start, int temp) &#123; if (rank == number + 1) &#123; cout &lt;&lt; length; exit(0); &#125; if (sum[start] &lt; length - temp)return; int t = 100; for (register int i = start; i &lt;= n; i++) &#123; if (vis[i])continue; if (op[i] + temp &gt; length)continue; if (t == op[i])continue; vis[i] = 1; t = op[i]; if (op[i] + temp == length) &#123; DFS(rank + 1, 1, 0); vis[i] = 0; return; &#125; else DFS(rank, i + 1, temp + op[i]); vis[i] = 0; if (!temp)return; &#125;&#125;int main() &#123; cin &gt;&gt; n; int j = 1; for (register int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[j]; if (op[j] &lt;= 50)j++; &#125; n = j - 1; sort(op + 1, op + n + 1, cmp); for (register int i = n; i &gt;= 1; i--)sum[i] = op[i] + sum[i + 1]; for (register int i = n; i &gt;= 1; i--) &#123; if (sum[1] % i != 0)continue; memset(vis, 0, sizeof(vis)); length = sum[1] / i, number = i; DFS(1, 1, 0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1080]国王游戏]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1080-%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恰逢H国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左，右手上面分别写下一个整数，国王自己也在左，右手上各写一个整数。然后，让这n位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是:排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数n，表示大臣的人数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含两个整数 a和b，之间用一个空格隔开，分别表示国王左手和右手上的整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 n行，每行包含两个整数a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 输入输出样例Sample input 31 12 37 44 6 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察高精度算法和数学推导，难度较大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个大臣x，y。假定x前面的大臣左手上数字之积为p(p&gt;0)，那么两者金币数分别为: p*x.r， p*x.l/y.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调换位置后，金币数分别为: p/y.r， p*y.l/x.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然有$p*x.l/y.r&gt;p/y.r$且有$p*y.l/x.r&gt;p/x.r$，倘若大臣x在前时金币最大值更小，那么必有$p*x.l/y.r \leq p*y.l/x.r$，即: x.l*x.r \leq y.l*y.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个不等式是解决本题的关键，它给出了排序的策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知当大臣站序按照l*r升序时最大值最小，否则必有一组违反上述的不等式，这个时候两人金币最大值会变大，不利于整体最大值尽量小的条件。也就是说，按照该标准排序后，可以保证任何相邻两人的金币最大值尽可能的小，从而整体最大值尽可能小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照该不等式排序，再用高精度算法计算结果并输出即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意不要重载&lt;=，仅重载&lt;即可获得不降序的结果。重载&lt;=很容易导致RE。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int king_l, king_r;struct node &#123; int l, r; bool operator&lt;(node y) &#123; if (y.r * y.l &gt; this-&gt;l * this-&gt;r)return true; return false; &#125;&#125; op[1005];int read() &#123; int sum = 0; char e; e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10; sum += e - '0'; e = getchar(); &#125; return sum;&#125;bool check(int *p, int *q) &#123; if (p[0] &lt; q[0])return true; if (p[0] &gt; q[0])return false; for (register int i = 1; i &lt;= p[0]; i++) &#123; if (p[i] &lt; q[i])return true; if (p[i] &gt; q[i])return false; &#125; return false;&#125;void copy(int *p, int *q) &#123; p[0] = q[0]; for (register int i = 1; i &lt;= q[0]; i++)p[i] = q[i];&#125;void mutiple(int *p, int q) &#123; int r = 0, tp = 0, i; for (i = 10000; i &gt; p[0]; i--)tp = p[i], p[i] = (p[i] * q + r) % 10, r = (tp * q + r) / 10; while (r &gt; 0)p[i--] = r % 10, r /= 10; p[0] = i;&#125;void divide(int *x, int y, int *z) &#123; int tp = 0, i = x[0] + 1, j = 1; while (tp &lt; y)tp *= 10, tp += x[i++]; while (i &lt;= 10001) &#123; z[j++] = tp / y, tp %= y; tp *= 10, tp += x[i++]; &#125; z[0] = j - 1;&#125;void print(int *x) &#123; for (register int i = 1; i &lt;= x[0]; i++)cout &lt;&lt; x[i]; cout &lt;&lt; endl;&#125;int main() &#123; int num[10001] = &#123;0&#125;, temp[10000], ans[10000] = &#123;0&#125;; num[0] = 9999; num[10000] = 1; n = read(); king_l = read(), king_r = read(); for (register int i = 1; i &lt;= n; i++)op[i].l = read(), op[i].r = read(); sort(op + 1, op + n + 1); mutiple(num, king_l); for (register int i = 1; i &lt;= n; i++) &#123; divide(num, op[i].r, temp); if (check(ans, temp))copy(ans, temp); mutiple(num, op[i].l); &#125; print(ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>贪心</tag>
        <tag>高精度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1074]靶型数独]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1074-%E9%9D%B6%E5%9E%8B%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;靶形数独的方格同普通数独一样，在9格宽×9格高的大九宫格中有9个3格宽×3格高的小九宫格(用粗黑色线隔开的)。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 1 到 9的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行，每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图具体的分值分布是:最里面一格(黄色区域)为 10 分，黄色区域外面的一圈(红色区域)每个格子为9分，再外面一圈(蓝色区域)每个格子为8 分，蓝色区域外面一圈(棕色区域)每个格子为7分，最外面一圈(白色区域)每个格子为6分，如上图所示。比赛的要求是:每个人必须完成一个给定的数独(每个给定数独可能有不同的填法)，而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一共 9 行。每行9个整数(每个数都在0-9的范围内)，表示一个尚未填满的数独方格，未填的空格用“0”表示。每两个数字之间用一个空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共 1 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1。 输入输出样例Sample input#1 7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2 Sample output#1 2829 Sample input#2 0 0 0 7 0 2 4 5 39 0 0 0 0 8 0 0 07 4 0 0 0 5 0 1 01 9 5 0 8 0 0 0 00 7 0 0 0 0 0 2 50 3 0 5 7 9 1 0 80 0 0 6 0 1 0 0 00 6 0 9 0 0 0 0 10 0 0 0 0 0 0 0 6 Sample output#2 2852 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察深度优先搜索(DFS)，有一定难度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个基本思路是，从首行首列开始进行DFS，将未填数的格子填上数。在填数过程中要注意符合数独的规则，也就是说要开数组记录当前行当前列和当前九宫格已有数字的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照这种方法，在填完末行末列的格子时，整个数独已经填好且符合规则。此时计算数独的分数，记录分数最大值。这里可以开一个常量数组记录每个格子的分数以简化运算。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，倘若首行待填格很多，则可能会导致DFS频繁向底层回溯，加大函数调用次数，很容易导致TLE。一种解决方法是从待填格最少的行开始DFS，将待填格最多的行后置，这样DFS向底层回溯的次数会减小，高层回溯次数增加，能够提高效率。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#define ID(x, y) x/3*3+y/3+1using namespace std;const int Point[9][9] = &#123;&#123;6, 6, 6, 6, 6, 6, 6, 6, 6&#125;, &#123;6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 10, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;6, 6, 6, 6, 6, 6, 6, 6, 6&#125;&#125;;int row[9][10] = &#123;0&#125;, colum[9][10] = &#123;0&#125;, form[10][10] = &#123;0&#125;;int op[9][9], rank2[10];int temp[9];int ans = -1;void calculate() &#123; int sum = 0; for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++)sum += op[i][j] * Point[i][j]; ans = max(ans, sum);&#125;void DFS(int x, int y, int r) &#123; if (y == 9) &#123; if (r &lt; 8) DFS(rank2[r + 1], 0, r + 1); else calculate(); return; &#125; if (op[x][y]) &#123; DFS(x, y + 1, r); return; &#125; for (int i = 1; i &lt;= 9; i++) &#123; if (row[x][i] || colum[y][i] || form[ID(x, y)][i])continue; row[x][i] = colum[y][i] = form[ID(x, y)][i] = 1; op[x][y] = i; DFS(x, y + 1, r); op[x][y] = 0; row[x][i] = colum[y][i] = form[ID(x, y)][i] = 0; &#125;&#125;int main() &#123; for (int i = 0; i &lt; 9; i++) &#123; temp[i] = i * 10 + 9; for (int j = 0; j &lt; 9; j++) &#123; cin &gt;&gt; op[i][j]; if (op[i][j]) row[i][op[i][j]] = colum[j][op[i][j]] = form[ID(i, j)][op[i][j]] = 1, temp[i]--; &#125; &#125; for (int i = 8; i &gt;= 0; i--) for (int j = 0; j &lt; i; j++) if (temp[j] % 10 &gt; temp[j + 1] % 10)swap(temp[j], temp[j + 1]); for (int i = 0; i &lt; 9; i++)rank2[i] = temp[i] / 10; DFS(rank2[0], 0, 0); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次介绍线段树，线段树是一种可以维护区间和，区间最值的高效数据结构。线段树本质上是一棵平衡二叉树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先探讨线段树的构造。由于线段树基于平衡二叉树，且仅有叶子节点储存实际的序列信息，故线段树的空间消耗是比较大的，实际空间消耗大约为给定序列的四倍。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以维护区间和的线段树为例。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造线段树时，假定f(l，r)为将[l，r]的序列构造为线段树，f(l，r)可以拆分成f(l，mid)和f(mid+1，r)，其中mid=(l+r)/2。按照二叉树的节点规律向下构造，并给相应的节点赋值即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:123456789void make(int x, int y, int k) &#123; if (x == y) &#123; tree[k] = op[x]; return; &#125; int mid = (x + y) / 2; make(x, mid, 2 * k), make(mid + 1, y, 2 * k + 1); tree[k] = tree[2 * k] + tree[2 * k + 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求特定区间[l，r]的区间和则通过拆分区间，从线段树中读出分区和，再相加即可。通过这种操作可以将线段树的时间复杂度降至O(logn)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何进行区间拆分。实际上区间拆分可分为四种情况:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 给定区间和线段树划分区间恰好相同。直接返回该区间的值即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 给定区间在划分区间的右半部分。将右半部分作为新的划分区间再进行拆分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 给定区间在划分区间的左半部分。将左半部分作为新的划分区间再进行拆分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 给定区间部分在左区间，部分在右区间。分别将左半部分和右半部分作为新的划分区间，再分别在两个划分区间中拆分各自的给定区间部分，返回两者结果的和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:1234567int find(int x, int y, int l, int r, int k) &#123; if (l &lt;= x &amp;&amp; y &lt;= r)return tree[k]; int mid = (x + y) / 2; if (l &gt;= mid + 1)return find(mid + 1, y, l, r, 2 * k + 1); if (r &lt;= mid)return find(x, mid, l, r, 2 * k); return find(x, mid, l, mid, 2 * k) + find(mid + 1, y, mid + 1, r, 2 * k + 1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，通过这两个函数已经可以处理一个不再修改的线段树。但是在实际操作中，有时不仅需要频繁求出区间和，还要不断地修改数据。下面介绍线段树的值修改方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种显而易见的思路是直接修改数据再重新构造线段树，或者直接在线段树中查找到相关的节点，修改这些节点的值。显然后者要优于前者，但是倘若修改的区间之后不再参与查找区间和的操作，那么时间就会白白浪费。所以，需要一种方法，在求区间和时才对相关节点进行实际的值修改操作，否则只作个标记即可。这种方法可以大大提升效率。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现值修改的标记，需要引入懒标记(Lazy)的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给每一个节点添加变量Lazy并初始化为0，它的意义是标明这个节点的所有子节点都要在原有的基础上加上Lazy。值得注意的是，该节点本身不在标记的范围内，并且Lazy标记仅是一个标记，子节点的值实际上并没有改变。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要将区间[l，r]全体加上x时，需要进行如下操作:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 将每一个拆分区间(假定为[a，b])的值加上(b-a+1)*x。((b-a+1)是该拆分区间的数据量)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 用与查找区间和相同的方法拆分区间[l，r]，给每一个拆分的区间的Lazy加上x。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 更新拆分区间节点的祖先节点和父节点的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:123456789101112void add(int x, int y, int l, int r, int c, int k) &#123; if (l &lt;= x &amp;&amp; y &lt;= r) &#123; tree[k] += (r - l + 1) * c; lazy[k] += c; return; &#125; int mid = (x + y) / 2; if (l &gt;= mid + 1)add(mid + 1, y, l, r, c, 2 * k + 1); else if (r &lt;= mid)add(x, mid, l, r, c, 2 * k); else add(x, mid, l, mid, c, 2 * k), add(mid + 1, y, mid + 1, r, c, 2 * k + 1); tree[k] = tree[2 * k] + tree[2 * k + 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何使用这个标记?这里需要用到down()函数来完成Lazy下压实现操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了构造线段树，当任何时候需要使用一个节点时，需要先检查该节点的Lazy是否为0。若为0，不必调用down();否则应调用down()来下压标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;down()的具体实现如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 两个子节点的值自加上它们数据量与该节点Lazy的乘积，更新自身数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 两个子节点的Lazy自加该节点的Lazy，来继承父节点的标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 该节点Lazy清空为0，表示下压完成。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，叶子节点由于没有子节点，它的Lazy是没有意义的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:1234567void down(int l, int r, int k) &#123; if (l == r)return; int mid = (l + r) / 2; tree[2 * k] += (mid - l + 1) * lazy[k], tree[2 * k + 1] += (r - mid) * lazy[k]; lazy[2 * k] += lazy[k], lazy[2 * k + 1] += lazy[k]; lazy[k] = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护区间最值类比即可。 线段树进阶&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新加一种操作：给区间[l,r]上的所有数乘上某个数，如何用线段树维护区间和？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新引入一个懒标记表示乘法是显然的，但是问题并没有想像中那样简单。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果下压标记时发现该结点同时有加法标记和乘法标记，究竟是先加再乘还是先乘再加？顺序的不同显然会影响结果。如果原有的数为a，考虑先加上b再乘上c的结果$(a+b)c=ac+bc$和顺序反过来的结果$ac+b$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，无论是先乘再加还是先加再乘，原数一定会被乘，区别只是加数要不要乘的问题。显然先加再乘可以转化为先乘然后再加上一个“处理后”的加数，这就是我们之后操作的原理。我们所有的步骤都基于先乘再加的思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给每一个结点开两个标记：add、muti，（下面代码中用的lazy1和lazy2）分别表示加法标记和乘法标记。初始化add=0，muti=1（注意是1）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;懒标记的意义是：这个结点的所有子结点需要先乘上muti，再加上add。（先乘再加思想）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有关加法的任何操作都与普通的线段数相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乘法的步骤便有所不同： 将该结点值乘上p（假设需要乘的是p） 乘法标记乘上p（表示下面的子树也要乘p） 加法标记乘上p（这是很重要的一步!!） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么还要处理加法标记呢？前文已经说明我们要先乘再加，先加则用处理加数的方法实现。如果发现当前结点已经有了加法标记，说明“先加”，那么必须给这个加数也乘上p，这就相当于处理了加数，从而把先加再乘转化为等价的先乘再加问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;懒标记下压也有所不同，根据先乘再加的思想，有以下步骤： 该两个子结点值乘上muti（先乘） 两个子结点乘法标记乘上muti（乘法标记继承） 两个子结点加法标记乘上muti（处理加数!!） 恢复muti=1（清空乘法标记） 两个子结点加上区间长度乘以add（再加） 两个子结点加法标记加上add（加法标记继承） 恢复add=0（清空加法标记） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是线段树模板2的示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX (100000+5)using namespace std;long long tree[MAX * 4], op[MAX], lazy1[MAX * 4], lazy2[MAX * 4], n, m, mod;inline long long read() &#123; char e = getchar(); while ((e &lt; '0' || e &gt; '9') &amp;&amp; (e != '-'))e = getchar(); bool k = false; long long s = 0; if (e == '-')k = true, e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return k ? -s : s;&#125;void build(int l, int r, int k) &#123; lazy1[k] = 0, lazy2[k] = 1; if (l == r) &#123; tree[k] = op[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, 2 * k), build(mid + 1, r, 2 * k + 1), tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;void down(int x, int l, int r) &#123; int ls = 2 * x, rs = 2 * x + 1, mid = (l + r) / 2; lazy2[ls] = (lazy2[ls] * lazy2[x]) % mod, lazy2[rs] = (lazy2[rs] * lazy2[x]) % mod; lazy1[ls] = (lazy1[ls] * lazy2[x]) % mod, lazy1[rs] = (lazy1[rs] * lazy2[x]) % mod; tree[ls] = (tree[ls] * lazy2[x]) % mod, tree[rs] = (tree[rs] * lazy2[x]) % mod; lazy2[x] = 1; lazy1[ls] = (lazy1[ls] + lazy1[x]) % mod, lazy1[rs] = (lazy1[rs] + lazy1[x]) % mod; tree[ls] = (tree[ls] + (mid - l + 1) * lazy1[x]) % mod; tree[rs] = (tree[rs] + (r - mid) * lazy1[x]) % mod; lazy1[x] = 0;&#125;long long find(int a, int b, int l, int r, int k) &#123; if (l &gt;= a &amp;&amp; r &lt;= b)return tree[k]; if (l &lt; r &amp;&amp; (lazy1[k] != 0 || lazy2[k] != 1))down(k, l, r); int mid = (l + r) &gt;&gt; 1; if (a &gt;= mid + 1)return find(a, b, mid + 1, r, 2 * k + 1); if (b &lt;= mid)return find(a, b, l, mid, 2 * k); return (find(a, mid, l, mid, 2 * k) + find(mid + 1, b, mid + 1, r, 2 * k + 1)) % mod;&#125;void add(int a, int b, int l, int r, long long s, int k) &#123; if (l &gt;= a &amp;&amp; r &lt;= b) &#123; tree[k] = ((r - l + 1) * s + tree[k]) % mod; lazy1[k] += s, lazy1[k] %= mod; return; &#125; if (l &lt; r &amp;&amp; (lazy1[k] != 0 || lazy2[k] != 1))down(k, l, r); int mid = (l + r) &gt;&gt; 1; if (mid + 1 &lt;= a)add(a, b, mid + 1, r, s, 2 * k + 1); else if (b &lt;= mid)add(a, b, l, mid, s, 2 * k); else add(a, mid, l, mid, s, 2 * k), add(mid + 1, b, mid + 1, r, s, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;void times(int a, int b, int l, int r, long long s, int k) &#123; if (l &gt;= a &amp;&amp; r &lt;= b) &#123; tree[k] = tree[k] * s % mod, lazy2[k] *= s, lazy2[k] %= mod, lazy1[k] *= s, lazy1[k] %= mod; return; &#125; if (l &lt; r &amp;&amp; (lazy1[k] != 0 || lazy2[k] != 1))down(k, l, r); int mid = (l + r) &gt;&gt; 1; if (mid + 1 &lt;= a)times(a, b, mid + 1, r, s, 2 * k + 1); else if (b &lt;= mid)times(a, b, l, mid, s, 2 * k); else times(a, mid, l, mid, s, 2 * k), times(mid + 1, b, mid + 1, r, s, 2 * k + 1); tree[k] = (tree[2 * k] + tree[2 * k + 1]) % mod;&#125;int main() &#123; n = read(), m = read(), mod = read(); for (int i = 1; i &lt;= n; i++)op[i] = read(); build(1, n, 1); for (int i = 0; i &lt; m; i++) &#123; long long x, a, b, c; x = read(); if (x == 1)a = read(), b = read(), c = read(), times(a, b, 1, n, c, 1); else if (x == 2)a = read(), b = read(), c = read(), add(a, b, 1, n, c, 1); else a = read(), b = read(), cout &lt;&lt; find(a, b, 1, n, 1) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1282]多米诺骨牌]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1282-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多米诺骨牌有上下2个方块组成，每个方块中有1~6个点。现有排成行的若干多米诺骨牌。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上方块中点数之和记为S1，下方块中点数之和记为S2，它们的差为|S1-S2|。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如在图中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转180°，使得上下两个方块互换位置。 编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行是一个正整数n(1≤n≤1000)，表示多米诺骨牌数。接下来的n行表示n个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数a和b，且1≤a，b≤6。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅一行，包含一个整数。表示求得的最小旋转次数。 输入输出样例Sample input 46 11 51 31 2 Sample output 1 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察线型动态规划，难度较大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定value[i]表示第i个骨牌上下两行的差值，f(x，y)表示第1~x骨牌上下差值为y时的最小交换次数，则有状态转移方程: f(x，y)=\min\{f(x-1，y-value[x])，f(x-1，y+value[x])+1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可用数组来保存结果，由于y可能为负，要构造一个映射将其与一个正整数相联系并作为数组下标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期初将数组初始化为INF(无穷大)，表示不能翻转到此值。再将f(1，value[1])置为0，f(1，-value[1])置为1即可。最后在f(n，y)中寻找y绝对值最小又使f(n，y) &lt; INF的f(n，y)作为结果。1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#define ID(x) 6000+xusing namespace std;int n;int value[1001];int res[1001][12000];const int INF = 1e9;int main() &#123; cin &gt;&gt; n; int x, y; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; value[i] = x - y; &#125; for (register int i = 1; i &lt;= 1000; i++) for (register int j = 0; j &lt; 12000; j++)res[i][j] = INF; res[1][ID(value[1])] = 0, res[1][ID(-value[1])] = 1; for (register int i = 2; i &lt;= n; i++) &#123; for (register int j = 0; j &lt;= 5 * i; j++) &#123; res[i][ID(j)] = min(res[i - 1][ID(j - value[i])], res[i - 1][ID(j + value[i])] + 1); res[i][ID(-j)] = min(res[i - 1][ID(-j - value[i])], res[i - 1][ID(value[i] - j)] + 1); &#125; &#125; for (register int i = 0; i &lt;= 5 * n; i++) &#123; if (res[n][ID(i)] &lt; INF || res[n][ID(-i)] &lt; INF) &#123; cout &lt;&lt; min(res[n][ID(i)], res[n][ID(-i)]); return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1417]烹调方案]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1417-%E7%83%B9%E8%B0%83%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于你的帮助，火星只遭受了最小的损失。但gw懒得重建家园了，就造了一艘飞船飞向遥远的earth星。不过飞船飞到一半，gw发现了一个很严重的问题:肚子饿了~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw希望能在T时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的gw只好求助于你了。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一共有n件食材，每件食材有三个属性，ai，bi和ci，如果在t时刻完成第i样食材则得到ai-t*bi的美味指数，用第i件食材做饭要花去ci的时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，gw的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行是两个正整数T和n，表示到达地球所需时间和食材个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，ai&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，bi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，ci 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出最大美味指数 数据范围&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于40%的数据1≤n≤10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据1≤n≤50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有数字均小于100，000 输入输出样例Sample input 74 1502247 Sample output 408 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划，也属于基本的01背包问题，但本题相比背包问题更能体现出问题的本质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在经典的01背包问题即第二题采药中，物品的顺序是不影响最终结果的。这个结论显然，因为物品无论先加入还是后加入，它们占据背包的空间不变，价值也不变，对其它物品也不会造成实质上的影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但本题不同，本题中物品的价值随着时间的增长而减小，所以对于两个物品，将哪一个放到前面会直接影响结果。也就是说只有把B放于A前或反之时才有最优解。我们在DP时必须遵从这个会出现最优解的顺序来加入物品，即要先对物品进行排序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，排序的标准是什么?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑两个物品，假定在时刻p开始加入背包，则将第一个物品先放入随机放入第二个时的价值为: v_1=a_1-(p+c_1-1)b_1+a_2-(p+c_1+c_2-1)b_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反之时总价值为: v_2=a_2-(p+c_2-1)b_2+a_1-(p+c_2+c_1-1)b_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令$v_1&lt;v_2$，进行运算，得到: c_2b_1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1880]石子合并]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1880-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个圆形操场的四周摆放N堆石子，现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试设计出1个算法，计算出将N堆石子合并成1堆的最小得分和最大得分。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据的第1行为正整数N，1≤N≤100，表示有N堆石子。第2行有N个数，分别表示每堆石子的个数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共2行，第1行为最小得分，第2行为最大得分。 输入输出样例Sample input 44 5 9 4 Sample output 4354 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与贪心算法不同的是，本题要求只能合并相邻的两堆石子，环形排布又加大了题目难度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种思路是将已知的序列首尾相接，从中截取长度为n的子序列，来模拟环形。这是因为在环形结构中，若只合并相邻的两个数，最后必有两个数待合并，从这两个数中间剪环为链，容易知这两者是等价的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是期初并不知从何处剪环，故要将所有情况都考虑到，从每个剪环策略中选取最值即可。在这个思路中，从何处截取序列便是剪环的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定在一个剪环策略下，令左元素为l，右元素为r。设从x到y的序列合并得分最值为f(x，y)，那么可列出状态转移方程(设value(l，r)表示l到r的石子总和): f(x，y)=\min/\max\{f(l，k)+f(k+1，r)\}+value(l，r),l \leq k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次谈谈树状数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先考虑一个问题，对于一个给定的数组，如何快速地求出其前缀和?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最通俗的做法是循环求出前n项和，时间复杂度O(n)。如果数组相当大又多次修改其中数据，求和过程时间消耗巨大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了快速求和，可以用树状数组来完成这一操作。树状数组可以维护并快速求出数组前缀和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要理解树状数组原理，先介绍lowbit的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任何一个数，设lowbit(x)表示这个数能够整除的最大的2的方幂。容易知道，将x写成二进制后，lowbit(x)表示从右向左第一个1所对应的二进制数。例如，对于二进制数x: x=1101101100，lowbit(x)=100;x=1011000，lowbit(x)=1000;x=1010000，lowbit(x)=10000.…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowbit有一个重要性质:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定数x，则对于满足条件x-lowbit(x)&lt;y&lt;x的数均可以在有限次地进行运算y = y + lowbit(y)后，使得y=x。并且其余的y一定不能在有限次的上述运算后得到x。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如给定x=101100，则对于y=101001，进行一次运算，得到101010，再进行一次得到101100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明从略。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对于一个数组tree[i]，tree[i]储存所有满足i-lowbit(i)&lt;x&lt;=i的x的和。这个和是易求的。对于一个符合条件的x，由上面的定理，给x作若干次运算。对于每一次合法的运算结果y，都进行tree[y]+=value[x]，这些y中一定有i，从而将所有符合条件的x都计入了tree[i]。由定理又知，其余不符合条件的x一定不会计入tree[i]。记得将tree[i]+=value[i]，就得到完整的求和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对1~n的所有数，都进行上述操作，就可以得到tree数组，这就是树状数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面研究如何用tree数组求前缀和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如求前10110010前缀和([x，y]表示第x到第y元素的和): tree[10000000]储存[1，10000000]的数的和，tree[10100000]储存[10000001，10100000]的和，tree[10110000]储存[10100001，10110000]的和，tree[10110010]储存[10110001，10110010]的和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，10110010前缀和就是树状数组中这4项的和。并且这4项的下标都是重复进行运算y = y - lowbit(y)得到的，直到y=0。这样，计算10110010前缀和只需进行4次加法，比进行传统的10110010(=178)次运算相比，效率大大提升。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为何叫作树状数组?下图给出解释。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粗体表示树状数组中的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知lowbit(x)=x&amp;-x，这样就有了树状数组的完整编写思路：123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int NUM = 1000000;int op[NUM + 1], tree[NUM + 1] = &#123;0&#125;, n;void add(int x, int y) &#123; for (; x &lt;= n; x += (x &amp; -x))tree[x] += y;&#125;int sum(int x) &#123; int res = 0; for (; x &gt;= 1; x -= (x &amp; -x))res += tree[x]; return res;&#125;int main() &#123; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; add(i, op[i]); &#125; int x; cin &gt;&gt; x; cout &lt;&lt; sum(x) &lt;&lt; endl; return 0;&#125; 树状数组进阶&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树状数组能很好地实现单点查询和前缀和维护，但对于区间求改却无能为力，此时多用线段树来代替。其实树状数组也可以进行区间修改。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开数组c储存原数组差分，差分即： c[i]=\begin{cases} a[i] & i=1\\ a[i]-a[i-1] & i>1\\ \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用树状数组维护c数组，易知c数组前缀和就是原数组对应元素的值。在修改区间时，只需修改c数组两个点即可。比如需要将[l,r]上的数都加p，只需将c[l]加上p，c[r+1]减去p。结合树状数组即可快速原数组元素值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那区间和如何求呢？注意到： \sum_{i=1}^ka_i=\sum_{i=1}^k\sum_{j=1}^ic_j=k\sum_{i=1}^kc_i-\sum_{i=1}^k(i-1)c_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是开数组d记录(i-1)c[i]，并用树状数组维护。在修改c数组时同步修改d数组，结合上面公式即可求出区间和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种思路可以使树状数组代替线段树维护区间和，可以过线段树模板题：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX 100000+5using namespace std;long long op[MAX], tree1[MAX] = &#123;0&#125;, tree2[MAX] = &#123;0&#125;, n, m;inline long long read() &#123; char e = getchar(); while((e &lt; '0' || e &gt; '9') &amp;&amp; (e != '-'))e = getchar(); bool k = false; long long s = 0; if (e == '-')k = true, e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9')s = s * 10 + e - '0', e = getchar(); return k ? -s : s;&#125;void add(int x, long long z, long long tree[]) &#123; for (int i = x; i &lt;= n; i += (i &amp; -i))tree[i] += z;&#125;long long find(int x, const long long tree[]) &#123; long long s = 0; for (int i = x; i &gt;= 1; i -= (i &amp; -i))s += tree[i]; return s;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) &#123; op[i] = read(); if (i == 1)add(1, op[i], tree1), add(1, 0, tree2); else add(i, op[i] - op[i - 1], tree1), add(i, (i - 1) * (op[i] - op[i - 1]), tree2); &#125; for (int i = 0; i &lt; m; i++) &#123; int x, a, b, c; x = read(); if (x == 1) &#123;//区间修改 a = read(), b = read(), c = read(); add(a, c, tree1), add(a, (a - 1) * c, tree2); add(b + 1, -c, tree1), add(b + 1, -c * b, tree2); &#125; else &#123;//区间查询 a = read() - 1, b = read(); long long s1 = a * find(a, tree1) - find(a, tree2), s2 = b * find(b, tree1) - find(b, tree2); cout &lt;&lt; s2 - s1 &lt;&lt; endl; &#125; &#125; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树状数组另一个作用是统计当前大于或小于某个数的元素个数，比如下题： 给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B中所有整数的和小于K。1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举每一个子数组求和的$O(n^2)$做法一定会TLE，另一个思路是先预处理前缀和，然后从左到右顺次枚举，根据当前的前缀和推算出使子区间和小于k的前缀和范围，然后查找当前有多少前缀和满足这个条件，有几个合法前缀和便有几个合法的子数列。这个过程可以用树状数组维护。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了方便起见，先将问题等价转化：将所有数变为其相反数，问题转化为有多少自数列和大于-k。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求前缀和，然后从左到右枚举。如果当前的前缀和为s，那么合法的前缀和x应满足： s-x>-k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是x &lt; s-k，我们找出之前有多少小于s-k的前缀和就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开一个与数据范围一样大的树状数组，每找到一个前缀和q，我们令q处的元素加一，这样对于一个大于q的数p，它的前缀和就增大了一，从而达到计数目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，数据范围确实过大（达到10^10）。可以采用离散化的方法：前缀和最多有100000种可能，给它们按照小大顺序重新编号，编号的相对大小就是原数据的相对大小。开100000大小的数组完全是可以的，本题便得以解决。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;map&lt;long long, int&gt; m;long long sum[100000 + 5], sumCopy[100000 + 5], tree[100000 + 5] = &#123;0&#125;, ans = 0;int id = 1, n, k;int ID(long long x, int l, int r) &#123;//[,) if (r == l + 1) &#123; if (sumCopy[l] &lt;= x)return m[sumCopy[l]]; return -1; &#125; int mid = (l + r) &gt;&gt; 1; if (sumCopy[mid] &lt;= x)return ID(x, mid, r); return ID(x, l, mid);&#125;inline int query(int x) &#123; int s = 0; for (int i = x; i &gt;= 1; i -= (i &amp; -i))s += tree[i]; return s;&#125;inline void add(int x) &#123; for (int i = x; i &lt;= n; i += (i &amp; -i))tree[i]++;&#125;int main() &#123; ios::sync_with_stdio(false);//关掉同步，加速读入 cin &gt;&gt; n &gt;&gt; k; k = -k;//先对k取相反数 sumCopy[0] = sum[0] = 0;//copy一下前缀和 for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; sumCopy[i] = sum[i] = sum[i - 1] - x;//求前缀和 &#125; sort(sumCopy + 1, sumCopy + n + 1);//排序 for (int i = 1; i &lt;= n; i++) &#123; if (m.count(sumCopy[i]) == 0) &#123; m[sumCopy[i]] = id++;//用map判重并重新编号 &#125; &#125; for (int i = 1; i &lt;= n; i++)if (sum[i] &gt; k)ans++;//首先把前缀和本身对应的合法子数列加上 for (int i = 1; i &lt;= n; i++) &#123; int p = ID(sum[i] - k - 1, 1, n + 1);//找到第一个不大于sum[i]-k-1的前缀和编号，二分 if (p != -1)ans += query(p);//存在满足条件的前缀和编号，用树状数组找数量 add(m[sum[i]]);//把这个前缀和加入树状数组 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1090]合并果子]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1090-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 ， 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力=3+12=15。可以证明 15为最小的体力耗费值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共两行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行是一个整数 n(1≤n≤10000) ，表示果子的种类数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 n个整数，用空格分隔，第 i 个整数 ai(1≤ai≤20000) 是第 i 种果子的数目。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 231 。 输入输出样例Sample input 31 2 9 Sample output 15 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察贪心算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次只需选取序列中最小的两个数相加，将和计入答案中，再将和加入序列。当序列为空时结束算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于序列要频繁地选取最小数并有数据的写入，推荐使用数据结构小根堆积树来完成操作。使用STL中的优先队列(priority_queue)也是可以的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;class heap &#123;private: int tree[10005]; int size;public: heap(int *p, int n) &#123; for (register int i = 1; i &lt;= n; i++)tree[i] = p[i]; size = n; for (register int i = size / 2; i &gt;= 1; i--)solve(i); &#125; void solve(int x) &#123; int l1 = 2 * x, l2 = 2 * x + 1, l = x; if (l1 &lt;= size &amp;&amp; tree[l1] &lt; tree[l])l = l1; if (l2 &lt;= size &amp;&amp; tree[l2] &lt; tree[l])l = l2; if (l != x) &#123; swap(tree[x], tree[l]); solve(l); &#125; &#125; int top() &#123; int temp = tree[1]; tree[1] = tree[size--]; solve(1); return temp; &#125; void up(int x) &#123; if (x == 1)return; if (tree[x] &lt; tree[x / 2])swap(tree[x], tree[x / 2]), up(x / 2); &#125; void add(int x) &#123; tree[++size] = x; up(size); &#125; bool empty() &#123; if (size == 0)return true; return false; &#125;&#125;;int main() &#123; int ans = 0; int op[10005]; int n; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; heap h(op, n); while (1) &#123; int x = h.top(), y = h.top(); ans += x + y; if (h.empty())break; h.add(x + y); &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一串数，在有频繁的加入删除操作时，如何维护它们的最大值和最小值?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的O(n)做法即为遍历整个数组，找到最值。这种方法简单但效率低下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆积树是一种基于完全二叉树的数据结构，可以在O(logn)的时间复杂度下维护序列最值。堆积树的特点是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 是一棵完全二叉树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 每一个节点的值都大于(或小于)其儿子节点的值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点值大于儿子节点的为大根堆，小于即为小根堆。显然，在根节点处可以取到最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面谈论堆的构造与维护算法(以小根堆为例)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先讲堆的节点交换算法，它的作用是在两棵子树已经为堆的基础上将这棵树转化为堆积树。 节点的交换算法是堆的基本算法。算法的步骤是先找到根节点与两个儿子节点的最小值，将根节点与最小值所在节点交换。此时根节点所在的局部具有小根堆性质。倘若一开始根节点就最小，依照算法的前提(两棵子树已为堆)，此时堆积树构造完毕，算法结束。但是倘若根节点起初不是最小值，交换后参与交换的子树由于根节点值变大，小根堆性质可能局部被破坏，但是由于该子树的两棵子树仍为堆，符合算法前提，再对该子树进行同样的递归操作，直到树的叶子节点。此时整棵树已经成为小根堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法的示例代码如下:12345678910void solve(int x) &#123; if (x &gt; n)return; int l1 = 2 * x, l2 = 2 * x + 1, l = x; if (l1 &lt;= n &amp;&amp; heap[l1] &lt; heap[l])l = l1; if (l2 &lt;= n &amp;&amp; heap[l2] &lt; heap[l])l = l2; if (l != x) &#123; swap(heap[l], heap[x]); solve(l); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆的构造过程即为从堆的最后一个非叶子节点开始，直至根节点，顺次执行堆的节点交换算法。由完全二叉树的性质易得这个非叶子节点编号为n/2(n为节点数量)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码如下:123void build() &#123; for (register int i = n / 2; i &gt;= 1; i--)solve(i);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点交换算法定义上不难理解这个方法的可行性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何找到最小值并将其删除?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上文讨论，heap[1]即为最小值。删除该元素只需将堆中最后一个元素覆盖到根节点处并令节点数减一，再在根节点处调用节点交换函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下:123456int top() &#123; int t = heap[1]; heap[1] = heap[n--]; solve(1); return t;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向堆中添加一个元素只需在堆的末尾加上该元素，该重新构造一遍堆即可。这个方法可行，但不最优。这里介绍一种更高效的算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于此时除了该元素之外，其余均维持小根堆性质。所以只需将该元素“上浮”，即将该元素与其父节点比较，若其比父节点值小，交换两个节点，从父节点开始继续上浮，直到父节点不比其大或者到达根节点时为止。1234void up(int x) &#123; if (x == 1)return; if (tree[x] &lt; tree[x / 2])swap(tree[x], tree[x / 2]), up(x / 2);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大根堆类比即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于堆可以维护最值，可以将其与选择排序算法结合，形成一种时间复杂度为O(nlogn)的新算法，称为堆排序算法。堆排序是不稳定的排序算法。算法思想是先将数据构造成堆，从中不断选出最值，再将其从堆中删除，重复该过程直到堆为空，此时即可获得有序的序列。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1040]加分二叉树]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1040-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设一个n个节点的二叉树tree的中序遍历为(1，2，3，… ，n)，其中数字1，2，3，… ，n为节点编号。每个节点都有一个分数(均为正整数)，记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree(也包含tree本身)的加分计算方法如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree的左子树的加分 × subtree的右子树的加分＋subtree的根的分数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试求一棵符合中序遍历为(1，2，3，… ，n)且加分最高的二叉树tree。要求输出;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)tree的最高加分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)tree的前序遍历 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行:1个整数n(n&lt;30)，为节点个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行:n个用空格隔开的整数，为每个节点的分数(分数&lt;100)。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行:1个整数，为最高加分(Ans≤4，000，000，000)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行:n个用空格隔开的整数，为该树的前序遍历。 输入输出样例Sample input 55 7 1 2 10 Sample output 1453 1 2 4 5 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察树型动态规划和二叉树遍历。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x，y)表示中序遍历为x，x+1，…，y-1，y的子树的最高加分，则有: f(x，y)=\begin{cases}\max\{f(x，k-1)*f(k+1，y)+value[k]\}(x≤k≤y) & xy \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递推即得结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二问可以设置一个数组tree[x][y]表示x~y的子树的根节点，递归遍历可得前序遍历序列。123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int op[50], n;int rem[50][50] = &#123;0&#125;;int tree[50][50] = &#123;0&#125;;int DP(int x, int y) &#123; if (x &gt; y)return 1; if (x == y)return op[x]; if (rem[x][y] != 0)return rem[x][y]; int ans = 0; for (register int i = x; i &lt;= y; i++) if (DP(x, i - 1) * DP(i + 1, y) + op[i] &gt; ans) ans = DP(x, i - 1) * DP(i + 1, y) + op[i], tree[x][y] = i; return rem[x][y] = ans;&#125;void print(int x, int y) &#123; if (x &gt; y)return; if (x == y) &#123; cout &lt;&lt; x &lt;&lt; '\x20'; return; &#125; cout &lt;&lt; tree[x][y] &lt;&lt; '\x20'; print(x, tree[x][y] - 1); print(tree[x][y] + 1, y);&#125;int main() &#123; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; cout &lt;&lt; DP(1, n) &lt;&lt; endl; print(1, n); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1126]机器人搬重物]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1126-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AC%E9%87%8D%E7%89%A9%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器人移动学会(RMI)现在正尝试用机器人搬运物品。机器人的形状是一个直径$1。6米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个N×M的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有:向前移动1步(Creep);向前移动2步(Walk);向前移动3步(Run);向左转(Left);向右转(Right)。每个指令所需要的时间为1秒。请你计算一下机器人完成任务所需的最少时间。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为两个正整数N，M(N，M≤50)，下面N行是储藏室的构造，0表示无障碍，1表示有障碍，数字之间用一个空格隔开。接着一行有4个整数和1个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向(东E，南S，西W，北N)，数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出-1。 输入输出样例Sample input 9 100 0 0 0 0 0 1 0 0 00 0 0 0 0 0 0 0 1 00 0 0 1 0 0 0 0 0 00 0 1 0 0 0 0 0 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 0 00 0 0 1 1 0 0 0 0 00 0 0 0 0 0 0 0 0 01 0 0 0 0 0 0 0 1 07 2 2 7 S Sample output 12 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题考察广度优先搜索(BFS)，比较常规。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用二维数组储存输入的01序列，用一个结构体储存当前点信息，开队列储存节点，还要记得保存当前已入队的节点信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何判定机器人是否可以前移以及边界处理问题。还有一个值得注意的是输入数据不一定合法，比如机器人初始坐标四周已有障碍物，此时直接输出-1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题有一个小技巧是将方向代数表示，这时机器人的转向可以转化为代数运算。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct node &#123; int time; int x, y; int turn;&#125;;int n, m;int op[55][55];int vis[55][55][4] = &#123;0&#125;;int a_x, a_y, b_x, b_y;queue&lt;node&gt; que;int check(int &amp;x, int &amp;y, int z) &#123; switch (z) &#123; case 0: if (x &lt;= 1 || op[x - 1][y] || op[x - 1][y + 1])return 0; else &#123; x--; return 1; &#125; break; case 1: if (y &gt;= m - 1 || op[x][y + 2] || op[x + 1][y + 2])return 0; else &#123; y++; return 1; &#125; break; case 2: if (x &gt;= n - 1 || op[x + 2][y] || op[x + 2][y + 1])return 0; else &#123; x++; return 1; &#125; break; case 3: if (y &lt;= 1 || op[x][y - 1] || op[x + 1][y - 1])return 0; else &#123; y--; return 1; &#125; break; &#125;&#125;int BFS() &#123; while (!que.empty()) &#123; node p = que.front(); if (p.x == a_x &amp;&amp; p.y == a_y)return p.time; que.pop(); p.time++; int t = p.turn; if (!vis[p.x][p.y][(p.turn + 1) % 4]) &#123; vis[p.x][p.y][(p.turn + 1) % 4] = 1; p.turn = (p.turn + 1) % 4; que.push(p); &#125; p.turn = t; if (!vis[p.x][p.y][(p.turn + 3) % 4]) &#123; vis[p.x][p.y][(p.turn + 3) % 4] = 1; p.turn = (p.turn + 3) % 4; que.push(p); &#125; p.turn = t; for (register int i = 1; i &lt;= 3; i++) &#123; if (!check(p.x, p.y, p.turn))break; if (vis[p.x][p.y][p.turn])continue; vis[p.x][p.y][p.turn] = 1; que.push(p); &#125; &#125; return -1;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) for (register int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; cin &gt;&gt; b_x &gt;&gt; b_y &gt;&gt; a_x &gt;&gt; a_y; node temp; temp.time = 0, temp.x = b_x, temp.y = b_y; char e; cin &gt;&gt; e; switch (e) &#123; case 'S': temp.turn = 2; break; case 'N': temp.turn = 0; break; case 'E': temp.turn = 1; break; case 'W': temp.turn = 3; &#125; if (op[b_x][b_y] || op[b_x + 1][b_y + 1] || op[b_x + 1][b_y] || op[b_x][b_y + 1]) &#123; cout &lt;&lt; "-1"; return 0; &#125; vis[b_x][b_y][temp.turn] = 1; que.push(temp); cout &lt;&lt; BFS(); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1316]丢瓶盖]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1316-%E4%B8%A2%E7%93%B6%E7%9B%96%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;陶陶是个贪玩的孩子，他在地上丢了A个瓶盖，为了简化问题，我们可以当作这A个瓶盖丢在一条直线上，现在他想从这些瓶盖里找出B个，使得距离最近的2个距离最大，他想知道，最大可以到多少呢？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个整数，A，B。(B≤A≤100000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行，A个整数，分别为这A个瓶盖坐标。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅一个整数，为所求答案。 输入输出样例Sample input 5 31 2 3 4 5 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题是一道典型的二分答案题目。考察二分和贪心思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分答案是一种寻求答案的方法，其原理利用了答案的单调性。在给定的答案域中，判断中点答案的可行性，根据其可行性再在答案域的左半区间或右半区间寻求答案，直到找到最终答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解释地更加清晰，下面说明几个概念。 答案域：答案可能的取值区间。在本题中答案域的左值为当前最小距离，最大值为最末与最初瓶盖坐标的差值。 可行：当存在一种方案使得在取出不小于B个瓶盖时，可以使任意两个相邻瓶盖间距都大于或等于x，则称x是可行的。也就是说，存在一种符合题目要求的选取策略，使得瓶盖间距最小值大于或等于x。同样，当不存在任何一种方案使得上述条件成立，则称x不可行。 答案单调性：当一个x可行时，由于要求最大值，故正确答案一定大于或等于x;类似地，当x不可行时，易知所有大于x的值都不可行，正确答案一定小于x。这就是答案的单调性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据以上说明，用二分查找方法，判定中点值的可行性，从而缩小区间，确定答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定一个值可行性的方法可用贪心策略，详见代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，本题中并未说明输入数据有序，必须先对输入的数据进行排序，再二分答案。12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int op[100005], a, b;int check(int x) &#123; int p = op[1], q = a - b; for (register int i = 2; i &lt;= a; i++) &#123; if (op[i] - p &lt; x) &#123; if (!q)return 0; q--; &#125; else p = op[i]; &#125; return 1;&#125;int find(int l, int r)//[,)&#123; if (r == l + 1)return l; int mid = (l + r) / 2; if (check(mid))return find(mid, r); else return find(l, mid);&#125;int main() &#123; cin &gt;&gt; a &gt;&gt; b; int minn = 1e8; for (register int i = 1; i &lt;= a; i++)cin &gt;&gt; op[i]; sort(op + 1, op + a + 1); for (register int i = 2; i &lt;= a; i++)minn = min(minn, op[i] - op[i - 1]); cout &lt;&lt; find(minn, op[a] - op[1]); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>二分查找</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F01%2F09%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍二分查找的相关内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个已经排好序的数组，如何快速从中找出值为x的元素的位置?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个通俗的做法是从第一个数开始遍历数组，直到找到x。时间复杂度O(n)。这种方法在数据量很大又频繁查找时效率低下。为了充分利用数据的有序性，可以使用二分查找算法在O(logn)复杂度下快速找到特定值的元素位置。二分查找是用来在已排序序列中找到特定值元素位置的高效算法，它的原理是一个基本事实: 在升序序列中[l，r]中，若mid=(l+r)/2且value[mid]&lt;x，那么x对应的元素必位于(mid，r]中，否则必位于[l，mid]中。降序排列类似。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个升序排序，不难写出代码:123456int binary_find(int l, int r, int x) &#123; if (l == r)return l; int mid = (l + r) / 2; if (value[mid] &lt; x)return binary_find(mid + 1, r, x); else return binary_find(l, mid, x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，假定在[2，3]中寻找元素x，value[2] &lt; x，value[3]=x，运行这段代码，会发现函数无限递归导致段错误。这是因为(2+3)/2=2，函数不断地在[2，3]中查找，无法跳出这个循环。这也是这种二分查找算法的重要缺陷。那么如何优化?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当函数传入参数l，r时，规定函数只能在(l，r]中查找，那么代码就变成:1234567int binary_find(int l, int r, int x)//(,]&#123; if (r == l + 1)return r; int mid = (l + r) / 2; if (value[mid] &lt; x)return binary_find(mid, r, x); else return binary_find(l, mid, x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时调用函数binary_find(-1，n-1，x)即可(n为数据量)。这种半开半闭式二分查找思想可以完美解决上面的问题。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1020]导弹拦截]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入导弹依次飞来的高度(雷达给出的高度数据是≤50000的正整数)，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1行，若干个整数(个数≤100000) 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例Sample input 389 207 155 300 299 170 158 65 Sample output 62 题解未强化版本:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的求最长上升(下降…)子序列问题，属于线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问即求序列中最长不上升子序列的长度，第二问即求序列中最少的最长不上升子序列数量。由Dilworth定理，该问即为求序列的最长上升子序列长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x)为以第x个数为序列起点，可得到的最长序列长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则对于第一问，状态转移方程为: f(x)=\max\{f(i)\}+1，x]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1606]疯狂的采药]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1606-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说:“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你是LiYuxiang，你能完成这个任务吗？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此题和原题的不同点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1。每种草药可以无限制地疯狂采摘。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2。药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入第一行有两个整数T(1 ≤ T ≤ 100000)和M(1 ≤ M ≤ 10000)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间(包括1和10000)的整数，分别表示采摘某种草药的时间和这种草药的价值。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 输入输出样例Sample input 70 371 10069 11 2 Sample output 140 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无限背包问题，属于经典的线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与01背包不同的是，无限背包允许每个物品无穷次加入背包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x，y)表示在容量剩余y时，将x~m物品加入背包的最大价值。则可列出状态转移方程: f(x，y)=\begin{cases} \max\{f(x，y-time[x])+value[x]，f(x+1，y)\}\ \ & y \geq time[x]\\ f(x+1，y) & y]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1048]采药]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1048-%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[难度：普及- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说:“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”如果你是辰辰，你能完成这个任务吗？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有2个整数T(1≤T≤1000)M(1≤M≤100)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间(包括1和100)的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1个整数，表示在规定的时间内可以采到的草药的最大总价值。 输入输出样例Sample input 70 371 10069 11 2 Sample output 3 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典01背包问题，考察线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x,y)表示在x时间内对于物品y~m的最大价值。显然,物品顺序对结果无影响，容易列出状态转移方程: f(x,y)=\max\{f(x,y+1),f(x-time[x],y+1)+value[x]\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当xm时，f(x,y)均为0。12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int time2[1005], value[105];int dp[1005][105] = &#123;0&#125;;int main() &#123; int t, m; cin &gt;&gt; t &gt;&gt; m; for (register int i = 1; i &lt;= m; i++)cin &gt;&gt; time2[i] &gt;&gt; value[i]; for (register int i = m; i &gt;= 1; i--) &#123; for (register int j = 1; j &lt;= t; j++) &#123; if (j &lt; time2[i])dp[j][i] = dp[j][i + 1]; else dp[j][i] = max(dp[j][i + 1], dp[j - time2[i]][i + 1] + value[i]); &#125; &#125; cout &lt;&lt; dp[t][1]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1387]最大正方形]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1387-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个n*m的只包含0和1的矩阵里找出一个不包含0的最大正方形，输出边长。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件第一行为两个整数n，m(1≤n,m≤100)，接下来n行，每行m个数字，用空格隔开，0或1。 输出格式:一个整数,最大正方形的边长。 输入输出样例:Sample input 4 40 1 1 11 1 1 00 1 1 01 1 0 1 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察二维动态规划及递推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若设f(x,y)示以此点为左上点正方形的最大边长。则易得: f(x,y)=\min\{f(x+1,y),f(x,y+1), f(x+1,y+1)\}+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意若点(x,y)为0或者超出边界，则f(x,y)=0，从f(x,y)中找出最大值即可。1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int op[105][105], n, m;int ans[105][105] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) for (register int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; int res = 0; for (register int i = n; i &gt;= 1; i--) for (register int j = m; j &gt;= 1; j--) &#123; if (op[i][j] == 0)continue; ans[i][j] = min(ans[i + 1][j], min(ans[i][j + 1], ans[i + 1][j + 1])) + 1; res = max(res, ans[i][j]); &#125; cout &lt;&lt; res; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬线法]]></title>
    <url>%2F2019%2F01%2F08%2F%E6%82%AC%E7%BA%BF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个矩阵中找到满足某种性质的最大子矩阵问题是一个很常见的问题，悬线法是求解此类问题的高效算法。现在来看这样一题(洛谷 P1169)来认识悬线法。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 8×8 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小 Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小 W 决定将棋盘扩大以适应他们的新规则。小 Q 找到了一张由 N×M$(N,M \leq 2000)$个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小 Q 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。不过小 Q 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘(当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色)，所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。于是小 Q 找到了即将参加全国信息学竞赛的你，你能帮助他么? 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含两个整数 N 和 M ，分别表示矩形纸片的长和宽。接下来的 N 行包含一个 N × M 的 01 矩阵，表示这张矩形纸片的颜色( 0 表示白色， 1 表示黑色)。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积(注意正方形和矩形是可以相交或者包含的)。可以看出，本题实质上在求一个矩阵中满足 01 相间排列性质的最大方阵和最大矩阵的面积，可以用悬线法高效解决。 悬线法思想：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 up(x，y)表示点(x，y)所在的满足性质(本题就是点的值互异)的“最大”矩形的高度 ，left(x，y) 表 示 点 (x，y) 所 在 的 满 足 性 质 的 同 一 个 “ 最 大 ” 矩 形 向 左 延 伸 的 距离，right(x，y)是向右的距离。那么横向延伸距离为 a=right+left-1，纵向即为 b=up，方阵面积为 min(a，b)2 ，矩阵面积即为 ab。对“最大”矩形的理解其实是一个较困难的问题。它要求每一个点的“最大”矩形必须继承自其正上方点，所在的矩形并且高度必须加一，也就是说这个点的最大矩形必须是在其正上方点所在点的矩形的子集基础上只作左右延伸得到的。除非正上方的点无法延伸到这个点(本题中即是这两个点同为 1 或同为 0)，这个点所在的矩形才可以完全独立于正上方点所在的矩形而没有交集，否则它们一定有所交集。“最大”即是指在满足这个继承性质的前提下可以得到的最大矩阵，它显然是唯一的。由于这种方法就像一根悬线左右摆动，不断求左右延伸量，来求子矩阵，故名悬线法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化全部点的三个值均为 1，这是第一次初始化。首先认为每一个点所在的最大矩形均为 1，在其所在的一行中更新 left 和 right。这是第二次初始化，这也是完全没有继承上一行矩阵时的值。自上而下从左到右遍历整个矩阵，按照 up，left，right 的定义更新值，算出面积。如果可以更新的话，递推公式为(首行不必更新)： up(x，y)=up(x-1，y)+1\\ left(x，y)=\min\{left(x，y)，left(x-1，y)\}\\ right(x，y)=\min\{right(x，y)，right(x-1，y)\}\\ x \geq 1下面证明这个思想的正确性，考虑用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先首行是完全满足三个值的定义的。因为作为首行，up 值必须为 1，left 和 right 在第二次初始化中得到的结果本身就是满足定义的。之后的操作中，倘若第 k 行所有点的三个值都满足定义，那么对于一个点(k，i)，若其正下方的点满足性质，可以做延伸，那么点(k+1，i)的 up 值必须是 up(k，i)+1。并且 left 取自己第二次初始化的值和 left(k，i)的较小值是合理的，这是因为前者是点(k+1，i)所在行可以向左延伸的最大距离，而 left(k，i)是点(k，i)所在的矩形向左延伸的最大距离，取较小值才是这个点在继承自上一个矩阵的基础上向左延伸的最大距离。right 同理，均满足定义。如果不能正下方的点不满足性质，无法作延伸也就无法继承，那么这两个矩形独立，这个点的三个值保持初始化状态不变。显然这也是满足定义的。于是递推公式成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是为什么仅仅作矩阵的继承操作，在遍历整个矩阵后一定可以找到最优解呢?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设 P(x，y)是实际上的最大的矩形中的某一点：红色矩形为 P 实际所在的最大矩形，黑色矩形是 P 继承正上方的点所在矩形得到的最大矩形。这时黑色矩形的最优性很可能不如红色矩形。但是注意到红色矩形的首行一行中至少有一点 Q(x’，y’)无法继承自其正上方的点，其 up 值便仍为 1，红色矩形向左向右延伸的最大距离也便在 Q 的第二次初始化中确定。Q 正下方的点列要继承 Q 所在的矩形，会将这个矩形的高度层层扩大，于是在 Q 正下方且在红色矩形的末行上的某点 Q’处取到最优解。这便证明了算法的最优性，并且给出了最优解的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出本题的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include &lt;cstring&gt;#define MAX 2001using namespace std;int n, m;int op[MAX][MAX];int l[MAX][MAX], r[MAX][MAX], u[MAX][MAX];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++)cin &gt;&gt; op[i][j], l[i][j] = r[i][j] = 1, u[i][j] = 1;//初始化 for (int i = 0; i &lt; n; i++) for (int j = 1; j &lt; m; j++) if (op[i][j] != op[i][j - 1]) l[i][j] = l[i][j - 1] + 1;//一行中更新 left for (int i = 0; i &lt; n; i++) for (int j = m - 2; j &gt;= 0; j--) if (op[i][j] != op[i][j + 1]) r[i][j] = r[i][j + 1] + 1;//一行中更新 right int ans1 = 0, ans2 = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int a, b; if (i == 0) &#123; a = r[i][j] + l[i][j] - 1; b = min(a, u[i][j]); ans1 = max(ans1, b * b), ans2 = max(ans2, a * u[i][j]); &#125; else if (op[i][j] != op[i - 1][j]) &#123; u[i][j] = u[i - 1][j] + 1; l[i][j] = min(l[i][j], l[i - 1][j]); r[i][j] = min(r[i][j], r[i - 1][j]); a = r[i][j] + l[i][j] - 1; b = min(a, u[i][j]); ans1 = max(ans1, b * b), ans2 = max(ans2, a * u[i][j]); &#125; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
</search>
