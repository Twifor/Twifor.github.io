<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[洛谷P1415]拆分数列]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%B4%9B%E8%B0%B7P1415-%E6%8B%86%E5%88%86%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[作者Lyh注：本题解法并不优&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录一道费一天时间才A的一道省选难度题 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出一列数字，需要你添加任意多个逗号将其拆成若干个严格递增的数。如果有多组解，则输出使得最后一个数最小的同时，字典序最大的解（即先要满足最后一个数最小；如果有多组解，则使得第一个数尽量大；如果仍有多组解，则使得第二个数尽量大，依次类推……）。【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于10%的数据，输入长度≤5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，输入长度≤15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，输入长度≤50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，输入长度≤500 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，为初始的数字。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，为拆分之后的数列。每个数之间用逗号分隔。行尾无逗号。 输入输出样例Sample input [1]3456[2]3546[3]3526[4]0001[5]100000101 Sample output [1]3,4,5,6[2]35,46[3]3,5,26[4]0001[5]100,000101 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题还是有难度的，考察动态规划上的字符串问题。答案字典序最大和末尾数最小限制是坑点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，找到末尾最小的那个数。若记dp1(i，r)表示第i个元素前已经加了逗号，是否在区间[0,i-1]存在一种加逗号方案使得它们严格递增且小于[i,r]表示的数。若有值为1，否则为0。这样便有状态转移方程：(区间表示的数的关系暂且记作区间的关系) dp1(i,r)=dp1(k_1,i-1)||dp1(k_2,i-1)||...||dp1(k_m,i-1)||false,[k,i-1]]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2051]中国象棋]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%B4%9B%E8%B0%B7P2051-%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次不看任何解析A出的省选难度题，留作纪念。 难度：省选/NOI- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。你也来和小可可一起锻炼一下思维吧！ 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一行包含两个整数N，M，之间由一个空格隔开。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。 输入输出样例Sample input 13 Sample output 7 说明【样例说明】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有2*2*2-1=7种方案。【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%的数据中N和M均不超过100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50%的数据中N和M至少有一个数不超过8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30%的数据中N和M均不超过6 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划，还是有一定难度的，但在省选题中算简单的了。这里的状态转移是性质转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记dp(x，y，t)表示x行y列的棋盘在满足P(t)性质的条件下所有的方案数，P性质定义如下： P(0)：第一行不能有棋子 P(1)：第一行仅有一个棋子 P(2)：第一行有两个棋子 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有这三种情况，因为每一行一列不可能有三个及以上数目的棋子。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于t=0的情况很容易进行状态转移，这是因为首行没有棋子，不会对下面的棋子选取产生任何影响。 dp(x，y，0)=dp(x-1，y，0)+dp(x-1，y，1)+dp(x-1，y，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t=1的情况就复杂很多。注意到第一行仅有且必须有一个棋子，它所在的一列的后x-1行可能有0个或1个棋子。我们可以最这两个子情况分别讨论，方案总数即是它们的和。当后x-1行没有棋子时，删去这一列和首行，得到一个x-1行y-1列的棋盘。这时我们发现首行的棋子对这个x-1行y-1列的棋盘棋子选取没有任何影响，方案总数即为dp(x-1，y-1，0)+dp(x-1，y-1，1)+dp(x-1，y-1，2)，再乘上y（被删去的一列有y种选法）就是第一个子情况的方案数。当后x-1行有一个棋子时，删去首行并将这一列拿到最左端，将这个棋盘（看作矩阵）转置，这是一个y行x-1列的棋盘且首行仅有一个棋子，故方案数即为dp(y，x-1，1)，再乘上y（理解同上）就是第二个子情况的方案数。于是有： dp(x，y，1)=(dp(x-1，y-1，0)+dp(x-1，y-1，1)+dp(x-1，y-1，2)+dp(y，x-1，1))*y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后再来看t=2的情况。我们仍然可以这种情况归结为三种子情况：两个棋子下面均没有其他棋子、一个棋子下面有一个棋子但另一个没有、两个棋子下面均有一个棋子。将它们三个的值加起来即可。第一种子情况理解与t=1相同，删去这两列，得到一个x-1行y-2列的棋盘，方案数为dp(x-1，y-2，0)+dp(x-1，y-2，1)+dp(x-1，y-2，2)，还需要乘上y*(y-1)/2（两个空列的组合数）。第二个子情况理解仍然同t=1时，删去没有棋子的那一列，将有一个棋子的一列拿到最左端，转置后得到一个y-1行x-1列的棋盘且满足P(1)性质，方案数即为dp(y-1，x-1，1)，需要再乘上y*(y-1)（乘一个排列数，将这两列作排列）。最后一种子情况很复杂，仍然需要划分为两种情况：下面的两个棋子不在同一行、下面的两个棋子在同一行。前者可以删去首行，再将两列合并，移到最左边，转置后得到一个y-1行x-1列并且满足性质P(2)的棋盘，方案数即为dp(y-1，x-1，2)，再乘上y*(y-1)即可。后者从棋盘中合并首行和两个棋子所在的一行，移到最顶端，这时下面的x-2行y列的棋盘在首行两个棋子所在的列不应有棋子，也就是两个空列。我们删去这两个空列，得到一个x-2行y-2列的棋盘，它的棋子选取没有受到影响，方案数为dp(x-2，y-2，0)+dp(x-2，y-2，1)+dp(x-2，y-2，2)，再乘上y*(y-1)/2（这里是一个组合数，是两个空列的选取情况），再乘上x-1（下面棋子所在行的情况）就是后一种情况的答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此t=2时的状态转移方程为： dp(x，y，2)=(dp(x-1，y-2，0)+dp(x-1，y-2，1)+dp(x-1，y-2，2))*y*(y-1)/2+dp(y-1，x-1，1)*y*(y-1)+(dp(x-2，y-2，0)+dp(x-2，y-2，1)+dp(x-2，y-2，2))*y*(y-1)/2*(x-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意边界处理和取模，递推即可。答案即为dp(n，m，0)+dp(n，m，1)+dp(n，m，2)对9999973的模。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAX 101#define MOD 9999973using namespace std;long long dp[MAX][MAX][3] = &#123;0&#125;;int n, m;long long DP(int x, int y, int t) &#123; if (x == 0 || y == 0)return 0; if (x == 1) &#123; if (t == 0)return 1; if (t == 1)return y; if (t == 2)return y * (y - 1) / 2; &#125; if (y == 1) &#123; if (t == 0)return (DP(x - 1, 1, 0) + DP(x - 1, 1, 1) + DP(x - 1, 1, 2)) % MOD; if (t == 1)return x; if (t == 2)return 0; &#125; if (t == 2) &#123; if (x == 2)return y * (y - 1) / 2 * (y * y + y + 2) / 2; if (y == 2)return x * x; &#125; //上面是边界处理 if (dp[x][y][t] &gt;= 0)return dp[x][y][t];//记忆化 //下面是状态转移，t=2时方程太长，分开计算 if (t == 0)return dp[x][y][t] = (DP(x - 1, y, 0) + DP(x - 1, y, 1) + DP(x - 1, y, 2)) % MOD; if (t == 1)return dp[x][y][t] = ((DP(x - 1, y - 1, 0) + DP(x - 1, y - 1, 1) + DP(x - 1, y - 1, 2)) % MOD + DP(y, x - 1, 1)) * y % MOD; int ans = 0; ans += (DP(x - 1, y - 2, 0) + DP(x - 1, y - 2, 1) + DP(x - 1, y - 2, 2)) * y * (y - 1) / 2 % MOD; ans += DP(y - 1, x - 1, 1) * y * (y - 1) % MOD; ans %= MOD; ans += DP(y - 1, x - 1, 2) * y * (y - 1) % MOD + (DP(x - 2, y - 2, 0) + DP(x - 2, y - 2, 1) + DP(x - 2, y - 2, 2)) % MOD * y * (y - 1) / 2 * (x - 1) % MOD; return dp[x][y][t] = ans % MOD;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(dp, -1, sizeof(dp)); cout &lt;&lt; (DP(n, m, 0) + DP(n, m, 1) + DP(n, m, 2)) % MOD &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然花了我3个小时去想它的解法（太弱），但评测用时36ms，内存占0.93mb AC这题还是值得的。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1070]道路游戏]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%B4%9B%E8%B0%B7P1070-%E9%81%93%E8%B7%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小新正在玩一个简单的电脑游戏。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏中有一条环形马路，马路上有n个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这n个机器人工厂编号为1~n，因为马路是环形的，所以第 n个机器人工厂和第1个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这n段马路也编号为1~n，并规定第i段马路连接第i个机器人工厂和第i+1个机器人工厂（1≤i≤n-1），第n段马路连接第n个机器人工厂和第1个机器人工厂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在i（1≤i≤n）号机器人工厂购买了一个机器人，这个机器人会从i号机器人工厂开始，顺时针在马路上行走，第一次行走会经过i号马路，到达i+1号机器人工厂（如果 i=n，机器人会到达第1个机器人工厂），并将i号马路上的所有金币收集给小新。 游戏中，环形马路上不能同时存在2个或者2个以上的机器人，并且每个机器人最多能够在环形马路上行走p次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为1~p之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。 以下是游戏的一些补充说明： 游戏从小新第一次购买机器人开始计时。 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过m个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行3个正整数n,m,p意义如题目所述。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的n行，每行有m个正整数，每两个整数之间用一个空格隔开，其中第i行描&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;述了i号马路上每个单位时间内出现的金币数量（1≤金币数量≤100），即第i行的第j（1≤j≤m）个数表示第j个单位时间内i号马路上出现的金币数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行，有n个整数，每两个整数之间用一个空格隔开，其中第i个数表示在i号机器人工厂购买机器人需要花费的金币数量（1≤金币数量≤100）。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一行，包含1个整数，表示在m个单位时间内，扣除购买机器人&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花费的金币之后，小新最多能收集到多少金币。 输入输出样例Sample input 2 3 21 2 32 3 41 2 Sample output 5 说明【数据范围】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 40%的数据，2≤n≤40,1≤m≤40。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 90%的数据，2≤n≤200,1≤m≤200。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 100%的数据，2≤n≤1000,1≤m≤1000,1≤p≤m。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一道很有趣的题目，考察动态规划。这里介绍一种O(n3)的做法，本以为会TLE，但是由于某些原因（数据太水），导致这种方法也是可以AC的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路就是规定dp(x)为x时刻开始购置一个机器人，到游戏结束可以得到的最多金币数。这样写的状态转移方程十分复杂。转移时遍历所有可能的购置和选择步数的方案，结合机器人的价格，进行之后时间状态的转移，取最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历是一件特别低效的做法。但是我们可以注意到dp(x)只能转移到dp(x+k)（1≤k≤p），每一个转移都固定了步数，只是选择哪一个机器人不定。我们可以开一个数组记录这个量，从而加快速度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们开一个T数组记录第t时刻，设置步数为x时可以得到的最大金币收益（实质上就是机器人的选择）。求这个金币收益可以用矩阵的对角前缀和加速。再来点inline和读入优化黑魔法这题就A了。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#define N 1000#define inf 1e8using namespace std;int op[N][N], dp[N], T[N][N], n, m, p, sum[N][N] = &#123;0&#125;, value[N];inline int solve(int t, int a, int b) &#123; int s = 0; if (t &amp;&amp; a)s = sum[a - 1][t - 1]; if (a + b - 1 &lt; n) return sum[a + b - 1][t + b - 1] - s; return sum[n - 1][t + n - 1 - a] - s + sum[(a + b - 1) % n][t + b - 1];&#125;inline int f(int t, int x) &#123; if (T[t][x] &gt; -1e7)return T[t][x]; for (int i = 0; i &lt; n; i++)T[t][x] = max(T[t][x], solve(t, i, x) - value[i]); return T[t][x];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; op[i][j]; if (!i || !j)sum[i][j] = op[i][j]; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 1; j &lt;= p; j++)T[i][j] = (int) (-inf); &#125; for (int i = 0; i &lt; n; i++)cin &gt;&gt; value[i]; for (int i = 1; i &lt; m; i++) &#123;//求对角前缀和 for (int j = i; j &lt; m; j++)sum[i][j] = sum[i - 1][j - 1] + op[i][j]; for (int j = i + 1; j &lt; n; j++)sum[j][i] = sum[j - 1][i - 1] + op[j][i]; &#125; dp[m] = 0; for (int i = m - 1; i &gt;= 0; i--) &#123;//时刻 dp[i] = (int) (-inf); for (int j = 1; j &lt;= m - i &amp;&amp; j &lt;= p; j++)dp[i] = max(dp[i], f(i, j) + dp[i + j]); &#125; cout &lt;&lt; dp[0]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2577]午餐]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2577-%E5%8D%88%E9%A4%90%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数N，代表总共有N个人。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数T，代表所有人吃完饭的最早时刻。 输入输出样例Sample input 52 27 71 36 48 5 Sample output 17 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有输入数据均为不超过200的正整数。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划和贪心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先应明确：在所有人都在一个队列中时，按照每个人吃饭时间降序排列才可以获得最优解。这是一种贪心思想，是比较容易发现的，下面给出它的数学证明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑两个相邻的人，假设他们前面的人总共打饭时间为p，那么如果第一个人在前，他们两人的吃完饭最晚时刻为 \max\{p+a1+b1，p+a1+a2+b2\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反之为 \max\{p+a2+b2，p+a1+a2+b1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设第一个在前更优，则有 \max\{p+a1+b1，p+a1+a2+b2\} \leq \max\{p+a2+b2，p+a1+a2+b1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到$p+a1+b1&lt;p+a1+a2+b1$并且$p+a2+b2&lt;p+a1+a2+b2$，因此上式等价于 p+a1+a2+b1\geq p+a1+a2+b2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是$b1≥b2$，即吃饭时间长的在前更优。根据相邻全局最优化原理（还记得皇后游戏吗？）可知我们按照吃饭时间降序排列的贪心策略是正确的。证毕。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我们先对这些数据按照第二元素（也就是吃饭用时）降序排列，那么我们问题的重点就是如何对他们进行分队安排，这是一个动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于每一个人都有进入两个队列任意一个的决策，于是我们考虑决策转移。记dp(i，j，k)表示到第i个人，在第一个队列已用时j单位时间，第二个队列已用时k个单位时间的情况下，能得到的最早的吃饭完成时刻。这里的j、k已经包含了i这个人本身的打饭时间。那么有状态转移方程： dp(i，j，k)=\min\{\max\{dp(i-1，j-i.a，k)，j+i.b\}，\max\{dp(i-1，j，k-i.a)，k+i.b\}\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方程比较容易理解，两个状态分别表示将第i个人分配到第一个队列和第两个队列。如果无法分配，则直接分配到另一个合法的队列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是注意到这样开三维数组很容易MLE，又发现j+k=sum(i)恒成立，这也就是说j和k本身就有关系，在这个情况下j和k这两个状态参量可以去除一个，另一个只需求出即可。所以我们排序后应该求一个前缀和。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200#define inf (int)1e8using namespace std;int n, dp[N][N * N + 1];int sum[N] = &#123;0&#125;;struct node &#123; int a, b; bool operator&lt;(node x) &#123; return b &gt; x.b; &#125;&#125; op[N];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; op[i].a &gt;&gt; op[i].b; sort(op, op + n); sum[0] = op[0].a; for (int i = 1; i &lt; n; i++)sum[i] = sum[i - 1] + op[i].a; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= sum[n - 1]; j++)dp[i][j] = inf; &#125; dp[0][0] = dp[0][op[0].a] = op[0].a + op[0].b; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt;= sum[i]; j++) &#123; if (j &gt;= op[i].a)dp[i][j] = min(dp[i][j], max(dp[i - 1][j - op[i].a], j + op[i].b)); if (sum[i] - j &gt;= op[i].a)dp[i][j] = min(dp[i][j], max(dp[i - 1][j], sum[i] - j + op[i].b)); &#125; &#125; int ans = inf; for (int i = 0; i &lt;= sum[n - 1]; i++)ans = min(ans, dp[n - 1][i]); cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步观察可发现，状态转移方程的量仅限于相邻两行之间，于是我们可以把数组压缩至一维，这也是本题目前最好的解法。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200#define inf (int)1e8using namespace std;int n, dp[N * N];int sum[N] = &#123;0&#125;;struct node &#123; int a, b; bool operator&lt;(node x) &#123; return b &gt; x.b; &#125;&#125; op[N];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; op[i].a &gt;&gt; op[i].b; sort(op, op + n); sum[0] = op[0].a; for (int i = 1; i &lt; n; i++)sum[i] = sum[i - 1] + op[i].a; for (int j = 0; j &lt;= sum[n - 1]; j++)dp[j] = inf; dp[0] = dp[op[0].a] = op[0].a + op[0].b; for (int i = 1; i &lt; n; i++) &#123; for (int j = sum[i]; j &gt;= 0; j--) &#123; int p = inf; if (j &gt;= op[i].a)p = min(p, max(dp[j - op[i].a], j + op[i].b)); if (sum[i] - j &gt;= op[i].a)p = min(p, max(dp[j], sum[i] - j + op[i].b)); dp[j] = p; &#125; &#125; int ans = inf; for (int i = 0; i &lt;= sum[n - 1]; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1273]有线电视网]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很不容易独立A出的一道题，做做纪念。 难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行包含两个用空格隔开的整数N和M，其中2≤N≤3000，1≤M≤N-1，N为整个有线电视网的结点总数，M为用户终端的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个转播站即树的根结点编号为1，其他的转播站编号为2到N-M，用户终端编号为N-M+1到N。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的N-M行每行表示—个转播站的数据，第i+1行表示第i个转播站的数据，其格式如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K A1 C1 A2 C2 … Ak Ck&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K表示该转播站下接K个结点(转播站或用户)，每个结点对应一对整数A与C，A表示结点编号，C表示从当前转播站传输信号到结点A的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。 输入输出样例Sample input 5 32 2 2 5 32 3 2 4 33 4 2 Sample output 2 说明[样例解释]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，共有五个结点。结点①为根结点，即现场直播站，②为一个中转站，③④⑤为用户端，共M个，编号从N-M+1到N，他们为观看比赛分别准备的钱数为3，4，2，从结点①可以传送信号到结点②，费用为2，也可以传送信号到结点⑤，费用为3(第二行数据所示)，从结点②可以传输信号到结点③，费用为2。也可传输信号到结点④，费用为3(第三行数据所示)，如果要让所有用户(③④⑤)都能看上比赛，则信号传输的总费用为:2+3+2+3=10，大于用户愿意支付的总费用3+4+2=9，有线电视网就亏本了，而只让③④两个用户看比赛就不亏本了。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题实际上在考察树上的分组背包DP问题，属于树型DP。这里先介绍一种转二叉树的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先注意到题目没有给定价格和边权的数据范围，若以此为依据DP，连数组范围都难以确定。于是我们不妨令dp(r，k)表示以r为根的子树中满足k个用户时可以得到的最大收益，这样状态就可以得到确定，答案即为使dp(1，k)为非负时的最大k(假设1是整棵树的根)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样状态转移会很难写，因为我们需要把这k个用户分配给其子树，这显然有很多情况，是难以分配的。但是注意到二叉树很容易分配，于是考虑转多叉树为二叉树的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认清一个事实，以下两棵树是等价的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们新建了一个节点和一条边，并令这条边的边权为0，这样就把三叉树转成了一棵等价的二叉树。其余如四叉树等的转法与之同理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预处理出每一个节点所含的叶子节点数child(i)，DP时严格保证dp(r，k)中k≤child(r)，这样状态转移方程就可以列出:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任何节点i，dp(i，0)=0。 若i为叶子节点，则dp(i，1)=money(i)，即这个用户支付的费用。 若i有一个儿子，则dp(i，k)=dp(c1，k)-v1。c1为儿子节点，v1为到儿子的边的边权。 若i有两个儿子，则需要进行分配。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果k=child(c1)+child(c2)，则不需进行分配，直接结果就是 dp(r，k)=dp(c1，child(c1))+dp(c2，child(c2))-v1-v2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果k&lt;child(c1)+child(c2): dp(r，k)=\min\{dp(c1，k1)+dp(c2，k2)-v1-v2\}，1\leq k1\leq child(c1)，1\leq k2\leq child(c2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对只分配给一棵子树的情况需要之后另行特判。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若k≤child(c1)，则: dp(r，k)=\min\{dp(r，k)，dp(c1，k)-v1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若k≤child(c2)。则: dp(r，k)=\min\{dp(r，k)，dp(c2，k)-v2\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据状态转移方程推出结果即可，这种方法其实很快。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include &lt;cstring&gt;#include&lt;cstdio&gt;#define NUM 3000*2using namespace std;int head[NUM], to[NUM], nxt[NUM], value[NUM], child[NUM] = &#123;0&#125;;int money[3000];int dp[NUM][3000] = &#123;0&#125;;int cnt = 1, ncnt = 0;int N, M;inline void add(int x, int y, int z) &#123; nxt[cnt] = head[x], to[cnt] = y, value[cnt] = z, head[x] = cnt++;&#125;int DFS(int x) &#123; for (int i = head[x]; i != -1; i = nxt[i])child[x] += DFS(to[i]); if (child[x] == 0)return child[x] = 1; return child[x];&#125;int DP(int root, int n) &#123; if (n == 0)return 0; if (dp[root][n] &gt; -1e7)return dp[root][n]; int l1, l2; if (head[root] == -1)return dp[root][n] = money[root]; l1 = to[head[root]];//左儿子 if (nxt[head[root]] == -1)return dp[root][n] = DP(l1, n) - value[head[root]]; l2 = to[nxt[head[root]]];//右儿子 if (n == child[root])return dp[root][n] = DP(l1, child[l1]) + DP(l2, child[l2]) - value[head[root]] - value[nxt[head[root]]]; if (child[l1] &gt;= n)dp[root][n] = max(dp[root][n], DP(l1, n) - value[head[root]]); if (child[l2] &gt;= n)dp[root][n] = max(dp[root][n], DP(l2, n) - value[nxt[head[root]]]); for (int i = max(1, n - child[l2]); i &lt;= child[l1] &amp;&amp; i &lt; n; i++)dp[root][n] = max(dp[root][n], DP(l1, i) + DP(l2, n - i) - value[head[root]] - value[nxt[head[root]]]); return dp[root][n];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M; ncnt = N + 1; memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= N - M; i++) &#123; int x; cin &gt;&gt; x; if (x &lt;= 2) &#123; for (int j = 1; j &lt;= x; j++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(i, a, b); &#125; &#125; else &#123; int from = i; for (int j = 1; j &lt;= x; j++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(from, a, b); if (j &lt;= x - 2)add(from, ncnt, 0), from = ncnt++;//转二叉树 &#125; &#125; &#125; for (int i = N - M + 1; i &lt;= N; i++)cin &gt;&gt; money[i]; DFS(1); for (int i = 1; i &lt; ncnt; i++) &#123; for (int j = 0; j &lt;= child[i]; j++)dp[i][j] = static_cast&lt;int&gt;(-1e8); &#125; for (int i = M; i &gt;= 0; i--) &#123; if (DP(1, i) &gt;= 0) &#123; cout &lt;&lt; i; return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的k级覆盖问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%A0%91%E7%9A%84k%E7%BA%A7%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一棵树，约定选定一个点，被选点可以覆盖与其距离不大于k的所有节点，问覆盖整棵树的最小选点数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇《动态规划与状态设计》中提及了k=2的DP做法，但是随着k的增大，状态数也会随之增多，这里介绍一种贪心方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心思路：选择树中最深的没有被覆盖的节点，标记其k级祖先，直到整棵树都被覆盖。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体实现时，要先确定树根，计算出每一个节点的深度，每次选最深的节点，判断其是否被覆盖。若无则标记k级祖先，否则继续选点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何判断是否被标记。我们只需要开一个数组来记录每一个节点到与它最近的被标记点的距离即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出上一篇文章中的第一道题目(洛谷P2279，k=2)的示例代码。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 1001#define inf 10000using namespace std;int n;int father[MAX] = &#123;0&#125;, depth[MAX];//标记节点的父节点编号和深度,认为根节点为1号节点int rk[MAX];//序号,用于深度排序int dict[MAX];//离被标记点最近的距离bool cmp(int a, int b) &#123; return depth[b] &lt; depth[a]; &#125;//比较函数,用于深度排序int main() &#123; cin &gt;&gt; n; depth[1] = 1, rk[1] = 1, dict[0] = dict[1] = inf;//初始化,0是虚拟父节点 for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; father[i]; depth[i] = depth[father[i]] + 1, rk[i] = i, dict[i] = inf;//利用题目输入规则,直接确定深度和父节点 &#125; sort(rk + 1, rk + n + 1, cmp);//排序 int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int f = father[rk[i]], gf = father[f];//获取父节点和祖父 dict[rk[i]] = min(dict[rk[i]], min(dict[f] + 1, dict[gf] + 2));//更新距离 if (dict[rk[i]] &gt; 2) &#123;//没被覆盖 dict[gf] = 0, ans++;//标记父节点,计数器加一 dict[father[gf]] = min(dict[father[gf]], 1), dict[father[father[gf]]] = min(dict[father[father[gf]]], 2); //更新祖父的父节点和祖父的距离 &#125; &#125; cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记祖父时，其所有子节点孙子节点都会在它们的距离更新中被发现已被覆盖，同时祖父的父节点和祖父节点也会更新距离，从而使兄弟节点也会得到覆盖。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，如果一个节点没有父节点或者祖父节点，那么就用到了虚拟父节点的概念。当任何时候一个节点没有父节点或祖父节点时，我们都认为它是节点0。0就是虚拟父节点。这种方法是正确的，这是因为当一个节点未被覆盖但又没有父节点或祖父节点时，由于它是目前深度最深的未被标记的节点，我们只需标记根节点即可完成整棵树的全覆盖。标记0节点和标记根节点显然是等价的，它们都能覆盖整棵树，结果都是计数器加一。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，标记虚拟父节点就是标记根节点，答案不变。所以我们不需要对没有父节点或祖父节点时特判。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法很普适，可以推广到k级半径的问题，不用存图。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划与状态设计]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一篇文章谈谈动态规划(Dynamic Programming， DP)。本材料中大量地出现动态规划类题目，这里做一个总结。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态规划是一种解决多阶段决策问题的高效算法设计思路，它的本质是分治思想。对于一个问题，它通常由若干子问题组成，解决了这些子问题，原问题也迎刃而解。例如树这种数据结构，它的分枝仍是一棵树，又如将区间分割，得到的仍是一个区间…很多事物都满足这种性质，可以考虑用DP思路解决。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍一些DP术语。 状态。当前阶段所面临的客观条件称为一种状态。状态需要一定的量去描述，称为状态变(参)量。同时状态也拥有一定的值，称为状态量。 状态转移。状态可以视为一个问题，它由若干子问题构成，这些子问题也是一个个状态。由当前状态到它的子状态的过程称为状态转移。转移的数学表达式称为状态转移方程。 无后效性。每一个状态都是客观的。一个状态所对应的问题可能是多个不同问题的子问题，但是无论它从哪一个状态转移过来，这个状态都应该是客观独立的，它的任何属性都不会随受前一个状态的影响。这种性质称为无后效性，能用DP解决的问题必须满足无后效性。 最优化原理。一个问题是最优的，它的子问题必然也是最优的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用DP解决问题实际上就是设计合适的状态，列出对应的状态转移方程。DP的重点在于看清问题和子问题以确定状态，状态的设计是很重要的，它必须满足以下几点要求: 状态参量到状态量是一个多数值到单数值的映射，也就是说，每一个状态必须是确定的，唯一的，并且满足无后效性。 状态必须是可转移的，也就是能够列出明确的状态转移方程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们思考这样一个题目，来认识状态设计: 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行为n （n&lt;=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]&lt;i。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目实质上是给定一棵树，其中一个选定的点可以覆盖两层的其余顶点，求覆盖整棵树的选点最小值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个显然的状态设计思路是令f(x)表示以x为根的子树的选点最小值。这样做状态的确是唯一的并且有明确的值，但是它无法列出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，f(x)=$\sum f(k)$(k表示x的子节点)是否成立呢?显然不可，这是因为即使每一个子树都被覆盖掉了，根节点x也可能没被覆盖到;同时，每一个子树的选点覆盖范围可能有所包含，使得全局仍可以删掉几个点，结果不最优。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的状态设计显然是失败的，问题便出在状态描述不清上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时状态虽唯一，但是无法转移，我们就需要增加状态描述量来细化状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先认识到一个事实，原问题满足某种性质时，往往意味这它的子问题也要满足某种性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们定义f(x，y)表示根节点为x的子树，在满足性质P(y)的前提下最小选点数。P定义如下: P(0):子树完全被覆盖，且根节点被选。 P(1):子树完全被覆盖，子节点被选。 P(2):子树完全被覆盖，孙子节点被选。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子树被完全覆盖仅有这三种状态 P(3):所有子节点及其子树都被覆盖，但根节点未知。 P(4):所有孙子节点及其子树都被覆盖，但根节点和子节点未知。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实还可以有P(5):所有孙子节点的子节点及其子树都被覆盖，但根节点子节点，孙子节点未知。但之后我们可以看到这种状态不参与转移，是无用的。仅这样就是可以转移的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若原树满足P(0)，则根节点向下两层(儿子和孙子)都一定被覆盖，但是倘若全树都被覆盖，所有子树都必须满足其孙子节点及其子树都被覆盖的性质。我们发现P(0~4)都符合条件，可以证明其余的任何状态都不符合，又发现全树的选点数是所有子树上选点数加一，于是有: f(x，0)=\sum(min\{f(k，0...4)\})+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一个子树，我们取其五个性质中选点最少的一个，这样既满足性质又能使解最优。这样直接作和是不会出现漏选多选的情况的。这是因为，子树都满足了需要的性质，全树一定可以完全被覆盖，不会缺选;同时，由于每一个子树都是满足性质的，并且我们选的是最小值，其余状态又不能使性质成立，删掉一个点必然使性质不再成立，所以不会多点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若原树满足P(1)，则根节点下一层全被覆盖，此时因为全树都被覆盖，所有子树都必须满足其子节点和子树都被覆盖的性质(即P(0~3))，被选的点满足P(0)性质。所以有: f(x，1)=\min\{f(k，0)+\sum (\min\{f(k’，0...3)\})\}，k是任意子节点，k’是剩余的子节点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解同上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理我们可得: f(x，2)=\min\{f(k，1)+\sum (\min\{f(k’，0...2)\})\}，k是任意子节点，k’是剩余的子节点\\ f(x，3)=\sum (\min\{f(k，0...2)\})\\ f(x，4)=\sum (\min\{f(k，0...3)\})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种转移方法称为性质转移，它的原理是当原问题满足状态指定的某种性质时，其子问题也要满足特定的性质，这时原问题状态可以转移到所有满足特定性质的子问题状态。我们这里给出的五个状态就是所有满足的状态，少一个都会难以转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种转移方式即为决策转移，它的原理通常是不同的决策，例如背包问题。本题用决策转移很难列方程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地理解状态设计，我们来重新认识一下01背包问题这种经典DP问题。本材料第2题就是这类问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01背包属于决策转移型，决策是选不选当前的这个物品。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们从所有物品中随机拿出一个时，如果背包可以装下的话，便会面临选还是不选的问题，这便是一个决策。我们规定物品全集为S，拿出的物品为x，物品i价值为wi，则两种决策得到的价值分别为: 选该物品:wx+?不选该物品:0+? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的?表示后面加上的价值我们暂时无法确定。但是注意到，如果我们选了该物品，对于剩下的物品集合S-{x}与我们的原问题集合S，它们的问题本质上是同一类问题，都是从一个集合中取一些物品使价值总和最大，不选与之同理。这样就把问题拆成了两个本质相同的子问题。同时子问题最优时，原问题才最优，这是显然的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我们定义dp(Q)表示对于集合Q，从中拿走若干个物品得到的价值最大值。但是很快我们便发现，这其中忽略了物品体积的问题，物品体积显然会影响决策(太大时一定不能选)，并且这样描述状态并不能唯一地确定状态。于是我们应定义dp(Q，p)表示背包容量为p时，从集合Q中拿走若干物品得到的价值最大值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么就有关系(vi表示物品i的体积): 若p\geq v_x时:dp(Q，p)=\max\{dp(Q-\{x\}，p)，dp(Q-\{x\}，p-v_x)+w_x\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里从不选和选中取一个较大值。 p]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1373]小a和uim之大逃离]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1373-%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小a和uim来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个披头散发，青面獠牙的怪物，低沉着声音说：“呵呵，既然你们来到这，只能活下来一个！”。小a和他的小伙伴都惊呆了！ 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;瞬间，地面上出现了一个n*m的巨幅矩阵，矩阵的每个格子上有一坨0~k不等量的魔液。怪物各给了小a和uim一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小a用魔瓶吸收地面上的魔液，下一步由uim吸收，如此交替下去，并且要求最后一步必须由uim吸收。魔瓶只有k的容量，也就是说，如果装了k+1那么魔瓶会被清空成零，如果装了k+2就只剩下1，依次类推。怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小a和uim感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小a灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小a和他的小伙伴都笑呆了！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在他想知道他们都能活下来有多少种方法。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行，三个空格隔开的整数n，m，k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来n行，m列，表示矩阵每一个的魔液量。同一行的数字用空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示方法数。由于可能很大，输出对1 000 000 007取余后的结果。 输入输出格式Sample input 2 2 31 11 1 Sample output 4 说明[样例解释]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四种方案是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)-&gt;(1，2)，(1，1)-&gt;(2，1)，(1，2)-&gt;(2，2)，(2，1)-&gt;(2，2)。[数据范围]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于20%的数据，n，m≤10，k≤2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，n，m≤100，k≤5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，n，m≤800，1≤k≤15 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察动态规划。本题对时间空间复杂度都有考验。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定f(a，b，x，y，t)表示在坐标(x，y)，两人魔液值为a，b(已吸收(x，y)处的)，在t状态(0表示小a吸收，1表示uim吸收)的方案数，则有递推关系: f(a，b，x，y，0)=f(a，(b+value(x+1，y))\%(1+k)，x+1，y，1)+f(a，(b+value(x，y+1)\%(1+k))，x，y+1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时有: f(a，b，x，y，1)=f((a+value(x+1，y))\%(1+k)，b，x+1，y，0)+f((a+value(x，y+1))\%(1+k)，b，x，y+1，0)+∂(a，b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∂(a，b)在a=b时为1，否则为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$\sum f(value(x，y)，0，x，y，0)$，1≤x≤n且1≤y≤m。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个5维的递推式，需要用一个5维数组储存数据，极易MLE。注意到递推式只与两个相邻行有关，可以考虑压缩数组(这个思想已经用过很多次了)。但是我们不能直接将其压缩至4维，这是因为其余维度的数据很难保证不被异常覆盖。我们这时采用滚动数组的方法，这是压缩数组维数不可行时的另一种解决方案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动数组很容易理解。将控制行的一维压缩至2个元素，分别储存待计算的一行和提供递推数据的一行(即相邻的两行)。两行交替进行递推，便可递推出所有的数值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出原版代码和滚动数组优化的代码，请读者观察其区别。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)#define S2(x) (x&lt;MOD?x:x-MOD)using namespace std;int dp[16][16][805][805][2] = &#123;0&#125;;int op[805][805];int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; k++;//k自加,后边不用再+1 for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)cin &gt;&gt; op[i][j]; &#125; for (int i = 0; i &lt; k; i++)dp[i][i][n][m][1] = 1;//递推奠基 for (int i = n; i ≥ 1; i--) &#123; for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int a = 0; a &lt; k; a++) &#123; for (int b = 0; b &lt; k; b++) &#123; dp[a][b][i][j][0] = dp[a][S1(b + op[i + 1][j])][i + 1][j][1] + dp[a][S1(b + op[i][j + 1])][i][j + 1][1]; dp[a][b][i][j][1] = dp[S1(a + op[i + 1][j])][b][i + 1][j][0] + dp[S1(a + op[i][j + 1])][b][i][j + 1][0]; if (a == b)dp[a][b][i][j][1]++; dp[a][b][i][j][0] = S2(dp[a][b][i][j][0]); dp[a][b][i][j][1] = S2(dp[a][b][i][j][1]); &#125; &#125; &#125; &#125; int ans = 0; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)ans += dp[op[i][j]][0][i][j][0], ans = S2(ans);//求和 &#125; cout &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动数组优化版本(65分)(外加读入优化)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)int dp[16][16][2][805][2] = &#123;0&#125;;//第三维压至2个元素short int op[805][805];int n, m, k;inline int ID(int x) &#123; if (x == 1)return 0; return 1;&#125;short int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); short int sum = 0; while (e ≥ '0' &amp;&amp; e ≤ '9') &#123; sum = sum * 10 + e - '0'; e = getchar(); &#125; return sum;&#125;int main() &#123; n = read(), m = read(), k = read(); k++; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)op[i][j] = read(); &#125; for (int i = 0; i &lt; k; i++)dp[i][i][0][m][1] = 1; bool key = true; int ans = 0; for (int i = n; i ≥ 1; i--) &#123; key = !key;//控制交替 for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int a = 0; a &lt; k; a++) &#123; for (int b = 0; b &lt; k; b++) &#123; dp[a][b][key][j][0] = dp[a][S1(b + op[i + 1][j])][!key][j][1] + dp[a][S1(b + op[i][j + 1])][key][j + 1][1]; dp[a][b][key][j][1] = dp[S1(a + op[i + 1][j])][b][!key][j][0] + dp[S1(a + op[i][j + 1])][b][key][j + 1][0]; if (a == b)dp[a][b][key][j][1]++; if (dp[a][b][key][j][0] ≥ MOD) dp[a][b][key][j][0] -= MOD; if (dp[a][b][key][j][1] ≥ MOD)dp[a][b][key][j][1] -= MOD; &#125; &#125; ans += dp[op[i][j]][0][key][j][0];//答案必须即时更新,因为数组经压缩,数据得不到保存 if (ans ≥ MOD)ans -= MOD; &#125; &#125; printf("%d", ans); return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这样并不是最优解，这里我们需要注意到两人的魔液值其实没有实质意义，它们的差才是最重要的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义f(h，x，y，t)表示两人魔液值差为h(若为负则转化为k最小剩余系中与h对1+k同余的数)，其余意义不变。差值为h表示小a要么比uim多h，要么比他少1+k-h，当其中任一人的值确定时，另一人的值通过h必然唯一确定。由此可知，这样定义的差值是合理的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知h=(V(0)-V(1))%(1+k)，V(0)，V(1)分别为小a，uim的魔液值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小a吸收p个单位的魔液时: h=((p+V(0))\%(1+k)-V(1))\%(1+k)=(p+V(0)-V(1))\%(1+k)=(p+h)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当uim吸收p个单位的魔液时: h=(V(0)-(V(1)+p)\%(1+k))\%(1+k)=(V(0)-V(1)-p)\%(1+k)=(h-p)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际计算中，由于计算机计算余数并不一定得到正数，故后一个式子要写成: h=(h-p+k+1)\%(1+k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可知无论两人实际的魔液值为多少，只要确定了差值，经过一定的吸收变化，其差值总是唯一确定的。所以我们可以将前两维压缩至1维，仅表示差值的大小。0即表示两人魔液值相同。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define MOD 1000000007#define S1(x) (x&lt;k?x:x-k)int dp[16][2][805][2] = &#123;0&#125;;short int op[805][805];int n, m, k;inline short int read() &#123; char e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); short int sum = 0; while (e ≥ '0' &amp;&amp; e ≤ '9') &#123; sum = sum * 10 + e - '0'; e = getchar(); &#125; return sum;&#125;int main() &#123; n = read(), m = read(), k = read(); k++; for (int i = 1; i ≤ n; i++) &#123; for (int j = 1; j ≤ m; j++)op[i][j] = read(); &#125; dp[0][0][m][1] = 1; bool key = true; int ans = 0; for (int i = n; i ≥ 1; i--) &#123; key = !key; for (int j = m; j ≥ 1; j--) &#123; if (i == n &amp;&amp; j == m)continue; for (int b = 0; b &lt; k; b++) &#123; dp[b][key][j][0] = dp[S1(b - op[i + 1][j] + k)][!key][j][1] + dp[S1(b - op[i][j + 1] + k)][key][j + 1][1]; dp[b][key][j][1] = dp[S1(b + op[i + 1][j])][!key][j][0] + dp[S1(b + op[i][j + 1])][key][j + 1][0]; if (b == 0)dp[0][key][j][1]++; if (dp[b][key][j][0] ≥ MOD) dp[b][key][j][0] -= MOD; if (dp[b][key][j][1] ≥ MOD)dp[b][key][j][1] -= MOD; &#125; ans += dp[op[i][j]][key][j][0]; if (ans ≥ MOD)ans -= MOD; &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1850]换教室]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1850-%E6%8D%A2%E6%95%99%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在可以选择的课程中，有2n节课程安排在n个时间段上。在第i(1≤i≤n)个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室ci上课，而另一节课程在教室di进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第i个时间段去教室di上课，否则仍然在教室ci上课。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第i节课程的教室时，申请被通过的概率是一个已知的实数ki，并且对于不同课程的申请，被通过的概率是互相独立的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多m节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请;牛牛可以申请自己最希望更换教室的m门课程，也可以不用完这m个申请的机会，甚至可以一门课程都不申请。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;牛牛所在的大学有v个教室，有e条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第i(1≤i≤n−1)节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行四个整数 n，m，v，e。n表示这个学期内的时间段的数量;m表示牛牛最多可以申请更换多少节课程的教室;v表示牛牛学校里教室的数量;e表示牛牛的学校里道路的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行n个正整数，第i(1≤i≤n)个正整数表示ci，即第i个时间段牛牛被安排上课的教室;保证1≤ci≤v。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行n个正整数，第i(1≤i≤n)个正整数表示di，即第i个时间段另一间上同样课程的教室;保证1≤di≤v。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四行n个实数，第i(1≤i≤n)个实数表示ki，即牛牛申请在第i个时间段更换教室获得通过的概率。保证0≤ki≤1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来e行，每行三个正整数aj，bj，wj，表示有一条双向道路连接教室aj，bj，通过这条道路需要耗费的体力值是wj;保证1≤aj，bj≤v，1≤wj≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证1≤n≤2000，0≤m≤2000，1≤v≤300，0≤e≤90000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证输入的实数最多包含3位小数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出一行，包含一个实数，四舍五入精确到小数点后恰好2位，表示答案。你的输出必须和标准输出完全一样才算正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于4×10−3。(如果你不知道什么是浮点误差，这段话可以理解为:对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理) 输入输出样例Sample input 3 2 3 32 1 21 2 10.8 0.2 0.51 2 51 3 32 3 1 Sample output 2.80 说明[样例1说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有可行的申请方案和期望收益如下表:[提示]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道路中可能会有多条双向道路连接相同的两间教室。也有可能有道路两端连接的是同一间教室。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意区分n，m，v，e的意义，n不是教室的数量， m不是道路的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊性质1:图上任意两点ai，bi，ai≠bi间，存在一条耗费体力最少的路径只包含一条道路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊性质2:对于所有的1≤i≤n，ki=1。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察图的最短路和期望DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道路和教室视为图，用Floyd算法求出各个节点对的最短路。注意考虑自环和重边。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题重点在于期望DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期望DP的原则是:只能作各阶段期望的和，不允许用子阶段期望乘概率。我就曾因试图用子阶段期望乘概率而出问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若令dp(i，j，t)表示经过1~i节课，用了j次申请机会，第i节课申请状态为t(只能是0或1)所得的期望最小值。容易发现，这样设计状态可以完整地描述状态并且能够进行状态转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且有状态转移方程: dp(i，j，0)=\min\{dp(i-1，j，0)+dict(c_{i-1}，c_i)，dp(i-1，j，1)+dict(c_{i-1}，c_i)*k_{i-1}+dict(d_{i-1}，c_i)*(1-k_{i-1})\}，j\leq i-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出，这是阶段期望的相加运算。 dp(i，j，1)=\min\{dp(i-1，j-1，0)+dict(c_{i-1}，d_i)*k_i+dict(c_{i-1}，c_i)*(1-k_i)，dp(i-1，j-1，1)+dict(c_{i-1}，c_i)*(1-k_{i-1})*(1-k_i)+dict(c_{i-1}，d_i)*(1-k_{i-1})*k_i+dict(d_{i-1}，c_i)*k_{i-1}*(1-k_i)+dict(d_{i-1}，d_i)*k_{i-1}*k_i\}，j≠0且j\leq i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;史上最长状转方程没有之一&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化dp(1，0，0)=dp(1，1，1)=0.0，其余inf。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即是min{dp(n，q，0)，dp(n，q，1)}，0≤q≤m。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;iomanip&gt;#define inf (int)1e8using namespace std;int dict[301][301];int c[2001], d[2001];double k[2001];int n, m, v, e;double dp[2001][2001][2];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; v &gt;&gt; e; for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++)if (i == j)dict[i][i] = 0; else dict[i][j] = inf; &#125; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; c[i];//原有 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; d[i];//欲更换 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; k[i];//概率 for (int i = 1; i &lt;= e; i++) &#123;//读图 int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; dict[x][y] = dict[y][x] = min(dict[x][y], z); &#125; for (int k = 1; k &lt;= v; k++) &#123;//Floyed算法 for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i != j &amp;&amp; j != k &amp;&amp; k != i)dict[i][j] = min(dict[i][j], dict[i][k] + dict[k][j]); &#125; for (int i = 1; i &lt;= n; i++)//预处理 for (int j = 0; j &lt;= m; j++)dp[i][j][0] = dp[i][j][1] = inf; dp[1][0][0] = 0.0, dp[1][1][1] = 0.0; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i; j++) &#123; if (j &lt; i) dp[i][j][0] = min(dp[i - 1][j][0] + dict[c[i - 1]][c[i]], dp[i - 1][j][1] + dict[d[i - 1]][c[i]] * k[i - 1] +dict[c[i - 1]][c[i]] * (1 - k[i - 1])); if (j != 0) dp[i][j][1] = min(dp[i - 1][j - 1][0] + dict[c[i - 1]][d[i]] * k[i] +dict[c[i - 1]][c[i]] * (1 - k[i]), dp[i - 1][j - 1][1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]) + dict[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i] +dict[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]) +dict[d[i - 1]][d[i]] * k[i - 1] * k[i]); &#125; &#125; double ans = inf; for (int i = 0; i &lt;= m; i++)ans = min(ans, min(dp[n][i][0], dp[n][i][1])); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; ans; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，状态转移方程前两维只与上边一行的元素有关，且有关的列不大于当前列。于是我们可以压缩数组至2维，此时枚举j时要倒序枚举。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;iomanip&gt;#define inf (int)1e8using namespace std;int dict[301][301];int c[2001], d[2001];int n, m, v, e;double k[2001];double dp[2001][2];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; v &gt;&gt; e; for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++)if (i == j)dict[i][i] = 0; else dict[i][j] = inf; &#125; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; c[i];//原有 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; d[i];//欲更换 for (int i = 1; i &lt;= n; i++)cin &gt;&gt; k[i];//概率 for (int i = 1; i &lt;= e; i++) &#123;//读图 int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; dict[x][y] = dict[y][x] = min(dict[x][y], z); &#125; for (int k = 1; k &lt;= v; k++) &#123;//Floyed算法 for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i != j &amp;&amp; j != k &amp;&amp; k != i)dict[i][j] = min(dict[i][j], dict[i][k] + dict[k][j]); &#125; for (int j = 0; j &lt;= m; j++)dp[j][0] = dp[j][1] = inf; dp[0][0] = dp[1][1] = 0.0; for (int i = 2; i &lt;= n; i++) &#123; for (int j = min(m, i); j &gt;= 0; j--) &#123; if (j &lt; i) dp[j][0] = min(dp[j][0] + dict[c[i - 1]][c[i]], dp[j][1] + dict[d[i - 1]][c[i]] * k[i - 1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1])); if (j != 0) dp[j][1] = min(dp[j - 1][0] + dict[c[i - 1]][d[i]] * k[i] + dict[c[i - 1]][c[i]] * (1 - k[i]), dp[j - 1][1] + dict[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]) + dict[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i] + dict[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]) + dict[d[i - 1]][d[i]] * k[i - 1] * k[i]); &#125; &#125; double ans = inf; for (int i = 0; i &lt;= m; i++)ans = min(ans, min(dp[i][0], dp[i][1])); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>图的最短路</tag>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1242]新汉诺塔]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1242-%E6%96%B0%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 本文题解改编自洛谷题解第二篇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在洛谷上看到了一种新奇的解法，记录一下。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设有n个大小不等的中空圆盘，按从小到大的顺序从1到n编号。将这n个圆盘任意的迭套在三根立柱上，立柱的编号分别为A，B，C，这个状态称为初始状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移动时有如下要求: 一次只能移一个盘; 不允许把大盘移到小盘上面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件第一行是状态中圆盘总数;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二到第四行分别是初始状态中A，B，C柱上圆盘的个数和从上到下每个圆盘的编号;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五到第七行分别是目标状态中A，B，C柱上圆盘的个数和从上到下每个圆盘的编号。输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行一步移动方案，格式为：move I from P to Q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行输出最少的步数。 输入输出样例Sample input 53 3 2 12 5 401 23 5 4 31 1 Sample output move 1 from A to Bmove 2 from A to Cmove 1 from B to Cmove 3 from A to Bmove 1 from C to Bmove 2 from C to Amove 1 from B to C7 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;圆盘总数≤45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行的圆盘描述是从下到上的圆盘编号。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题解用了随机数…竟然A了，这应该是和模拟退火算法类似的一种算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知大盘要在小盘之前就位，否则小盘最终仍要移动。为了得到最简洁的步骤，我们应从大到小使各个盘子依次就位。但每一个盘子有两种移动方式:直接就位和先移到辅助位再移到目标位。通常前者更优但后者在某些情况下优于前者。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个盘子移动时，比其小的盘子不能出现在原位和要移动的位置上，必须全部放到辅助位上。于是我们事先要先移动较小盘，这是一个递归过程，模拟这个过程即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个通俗的做法是每一次都同时考虑这两种情况并进行状态转移。我们这里采用一种更新颖的方法—随机数转移法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次使用后一种(见上文)转移方法时都有一定的概率，这个概率随着时间的推移不断减小(这是模拟退火算法的思想)。也就是说我们用随机数来判别下一次的状态转移方式。这样做显然偶然性太大，我们可以使这个过程进行更多次(比如500次)，来获得很高概率的正确性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随机数转移法将总路径压缩到一定的值，比起朴素盲目搜索算法大大简化了总状态数。但缺点是具有一定偶然性，我们可以通过参数调整的方法来尽可能地提高正确率。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;using namespace std;int first[46], last[46];int first2[46], last2[46];int n, ans = static_cast&lt;int&gt;(1e8);int ANS[233333], size = 0;int an[233333];void mv(int p, int from, int to) &#123; if (from == to)return;//就在目标位上,不用动 for (int i = p - 1; i &gt;= 1; i--)mv(i, first2[i], 6 - from - to);//小盘全移到辅助位上 ANS[size++] = p * 100 + from * 10 + to;//记录移动步骤 first2[p] = to;//修改&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= 3; i++) &#123; int x, y; cin &gt;&gt; x; for (int j = 1; j &lt;= x; j++) &#123; cin &gt;&gt; y; first[y] = i; &#125; &#125; for (int i = 1; i &lt;= 3; i++) &#123; int x, y; cin &gt;&gt; x; for (int j = 1; j &lt;= x; j++) &#123; cin &gt;&gt; y; last[y] = i; &#125; &#125; srand(23333);//随机种子 for (int g = 1; g &lt;= 500; g++) &#123; size = 0; for (int i = 1; i &lt;= n; i++)first2[i] = first[i], last2[i] = last[i];//先复制一遍数据 for (int i = n; i &gt;= 1; i--) &#123; if (rand() % (n - i + 2) == 0)mv(i, first2[i], 6 - first2[i] - last2[i]), mv(i, first2[i], last2[i]);//第二种转移 else mv(i, first2[i], last2[i]);//第一种转移 &#125; if (ans &gt; size) &#123;//获得更优解,记录 ans = size; for (int i = 0; i &lt; size; i++)an[i] = ANS[i]; &#125; &#125; for (int i = 0; i &lt; ans; i++) cout &lt;&lt; "move " &lt;&lt; an[i] / 100 &lt;&lt; " from " &lt;&lt; char(an[i] % 100 / 10 + 'A' - 1) &lt;&lt; " to " &lt;&lt; char(an[i] % 10 + 'A' - 1) &lt;&lt; endl; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>随机数</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2827]蚯蚓]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2827-%E8%9A%AF%E8%9A%93%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题中，我们将用符号⌊c⌋表示对c向下取整，例如:⌊3.0⌋ = ⌊3.1⌋ = ⌊3.9⌋ = 3。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国里现在共有n只蚯蚓(n为正整数)。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为ai(i=1，2，… ，n)，并保证所有的长度都是非负整数(即:可能存在长度为0的蚯蚓)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只(如有多个则任选一个)将其切成两半。神刀手切开蚯蚓的位置由常数p(是满足0 &lt; p &lt; 1的有理数)决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为⌊px⌋和x - ⌊px⌋的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q(是一个非负整常数)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来……(m为非负整数)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m秒内，每一秒被切断的蚯蚓被切断前的长度(有m个数);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m秒后，所有蚯蚓的长度(有n+m个数)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛐蛐国王当然知道怎么做啦！但是他想考考你…… 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含六个整数 n，m，q，u，v，t其中:n，m，q的意义见[问题描述];u，v，t均为正整数;你需要自己计算 p=u/v(保证0]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2831]愤怒的小鸟]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我第一年竞赛(NOIP2016)的最后一题，考状压DP，当时拿了5分，印象十分深刻，现在特此记录一下AC过程。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kiana 最近沉迷于一款神奇的游戏无法自拔。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说，这款游戏是在一个平面上进行的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一架弹弓位于 (0，0)处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx的曲线，其中a，b是Kiana 指定的参数，且必须满足a &lt; 0，a，b 都是实数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小鸟落回地面(即x轴)时，它就会瞬间消失。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在游戏的某个关卡里，平面的第一象限中有n只绿色的小猪，其中第i只小猪所在的坐标为(xi，yi)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某只小鸟的飞行轨迹经过了(xi，yi)，那么第i只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一只小鸟的飞行轨迹没有经过(xi，yi)，那么这只小鸟飞行的全过程就不会对第i只小猪产生任何影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，若两只小猪分别位于(1，3)和(3，3)，Kiana可以选择发射一只飞行轨迹为y=-x2+4x的小鸟，这样两只小猪就会被这只小鸟一起消灭。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这款神奇游戏的每个关卡对 Kiana来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在[输入格式]中详述。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设这款游戏一共有T个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数T，表示游戏的关卡总数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面依次输入这T个关卡的信息。每个关卡第一行包含两个非负整数n，m分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的n行中，第i行包含两个正实数xi，yi，表示第i只小猪坐标为(xi，yi)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=0，表示Kiana输入了一个没有任何作用的指令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=1，则这个关卡将会满足:至多用⌈n/3+1⌉只小鸟即可消灭所有小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果m=2，则这个关卡将会满足:一定存在一种最优解，其中有一只小鸟消灭了至少⌊n/3⌋只小猪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证1≤n≤18，0≤m≤2，0 &lt; xi，yi &lt; 10，输入中的实数均保留到小数点后两位。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文中，符号⌈c⌉和⌊c⌋分别表示对c向上取整和向下取整，例如:⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个关卡依次输出一行答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。 输入输出样例Sample input#1 22 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.00 Sample output#1 11 Sample input#2 32 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.00 Sample output#2223 Sample input#3 110 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99 Sample output#3 6 说明[样例解释1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这组数据中一共有两个关卡。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个关卡与[问题描述]中的情形相同，2只小猪分别位于(1.00，3.00)和(3.00，3.00)，只需发射一只飞行轨迹为y = -x2 + 4x的小鸟即可消灭它们。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个关卡中有5只小猪，但经过观察我们可以发现它们的坐标都在抛物线 y = -x2 + 6x上，故Kiana只需要发射一只小鸟即可消灭所有小猪。[数据范围] 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察状态压缩DP，与上一个题目思想类似，但实现更复杂。另外其实我没看出来指令的作用…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据状压DP的思路，我们仍用一个二进制数来表示状态。对于一个二进制数x，当第i位为0时表示第i只小猪未被消灭，为1表示已被消灭，令f(x)表示在x的状态下需要发射的最少的小鸟数量，则有状态转移方程: f(x)=1+\min(f(x|1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJUOJ]难以置信的竞赛]]></title>
    <url>%2F2019%2F01%2F10%2FTJUOJ-%E9%9A%BE%E4%BB%A5%E7%BD%AE%E4%BF%A1%E7%9A%84%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[难度：估计在普及+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;天津大学OJ上的一道题，最早来自The 7th UESTC Programming Contest Preliminary。看rank list发现这道题都做的特别惨烈…一看这题感觉是状压DP，一写果然A了，在这里做一个总结。之后应该还会有类似的情景。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题在http://acm.tju.edu.cn/toj/vcontest/showp10518_B.html ，下面是翻译。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上周，应用数学学院举办了放风筝比赛，参赛者分成两组，一对选手与另一名参赛者竞争。众所周知，划分对的不同方式可能带来不同的精彩等级值，精彩等级值是一个数。现在，叶小姐想知道如何划分竞争对手，以达到最高的精彩等级。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的第一行包含一个整数T，表示测试样例的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每个测试样例，在第一行中有一个整数N(N≤16，N总是偶数)，表示有N名参赛者参加比赛。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下一个N行中，每行包含N个数。当第i个选手和第j个常数在一对中进行时，第i行中的第j个数是对应的精彩等级值。数据保证第i行中的第j个数等于第j行中的第i个数，即输入的矩阵是对称的。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每种情况，输出最大的精彩等级值，保留两位小数。 输入输出样例Sample input 120.0 1.01.0 0.0 Sample output 1.00 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察状态压缩DP(状压DP)，这是继离散化，压缩数组等DP技巧后的又一个重要方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态压缩DP是指用二进制编码的方法记录状态。这类的问题通常状态很多，但个体总数是不大的，比如本题小于16。这时我们可以用一个16位二进制数的01序列顺序来记录这些状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于一个二进制数x，用第i位为0表示第i+1个人未被安排，为1表示已被安排。f(x)表示在此情况下所得的最大精彩等级值，那么有状态转移方程： f(x)=\max\{f(x|(1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1514]引水入城]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1514-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N行×M列的矩形，如下图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，只有与湖泊毗邻的第1行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第N行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢?如果能，请计算最少建造几个蓄水厂;如果不能，求干旱区中不可能建有水利设施的城市数目。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每行两个数，之间用一个空格隔开。输入的第一行是两个正整数N，M表示矩形的规模。接下来N行，每行M个正整数，依次代表每座城市的海拔高度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两行。如果能满足要求，输出的第一行是整数1，第二行是一个整数，代表最少建造几个蓄水厂;如果不能满足要求，输出的第一行是整数0，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。 输入输出样例Sample input#1 2 59 1 5 4 38 7 6 1 2 Sample output#1 11 Sample input#2 3 68 4 5 6 4 47 3 4 3 3 33 2 2 1 1 2 Sample output#2 13 说明[样例1 说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需要在海拔为9的那座城市中建造蓄水厂，即可满足要求。[样例2 说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图中，在3个粗线框出的城市中建造蓄水厂，可以满足要求。以这3个蓄水厂为源头在干旱区中建造的输水站分别用3 种颜色标出。当然，建造方法可能不唯一。[数据范围] 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察搜索算法和区间覆盖问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将水的流向关系抽象成有向无环图。实际操作中我们没有必要存图，只需在搜索中现找到邻边即可，这样时间差距不大但空间消耗大大减小。我们只有在无法现搜边的情况下才存图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样经过DFS或BFS即可找到第一行每一个城市能够联通的节点。本题中推荐BFS，因为图的规模过大很容易使DFS递归深度过高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过m次BFS，可以确定末行那些节点是与第一行联通的，若有k个无法联通，说明该处不可能建有水利工程，输出0即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题关键在于求最少数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先要知道如果每一个末行节点都与第一行某节点联通，则任何一个首行节点在末行与之联通的节点必定是连续的(可以画图验证)。这样我们可以得到每一个首行节点在末行的覆盖区间。问题便转化为区间完全覆盖问题，用贪心算法求解即得。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意本题中的一处剪枝:若首行中某一个节点值小于其左边或右边的节点值，则该节点不用考虑。这是因为其周围的节点覆盖区间一定包含该节点的覆盖区间，去除这一个子区间对于我们解区间完全覆盖问题是没有任何影响的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;struct Temp &#123; int l, r, rank; Temp() : l(static_cast&lt;int&gt;(1e8)), r(static_cast&lt;int&gt;(-1e8)) &#123;&#125; bool operator&lt;(Temp t) &#123; return this-&gt;l &lt; t.l; &#125;&#125; can[550];int op[250500];bool vis[250500] = &#123;false&#125;;bool mainVis[550] = &#123;false&#125;;int n, m;inline void BFS(int x) &#123; queue&lt;int&gt; que; que.push(x); while (!que.empty()) &#123; int a = que.front(); if (a &gt;= n * m - m)can[x].l = min(can[x].l, a % m), can[x].r = max(can[x].r, a % m), mainVis[a % m] = true; que.pop(); if (a &gt;= m &amp;&amp; op[a - m] &lt; op[a] &amp;&amp; !vis[a - m])que.push(a - m),vis[a - m] = true; if (a &lt; n * m - m &amp;&amp; op[a + m] &lt; op[a] &amp;&amp; !vis[a + m])que.push(a + m), vis[a + m] = true; if (a % m != 0 &amp;&amp; op[a - 1] &lt; op[a] &amp;&amp; !vis[a - 1])que.push(a - 1), vis[a - 1] = true; if (a % m != m - 1 &amp;&amp; op[a + 1] &lt; op[a] &amp;&amp; !vis[a + 1])que.push(a + 1), vis[a + 1] = true; &#125;&#125;inline int read() &#123; char e = static_cast&lt;char&gt;(getchar()); while (e &lt; '0' || e &gt; '9')e = static_cast&lt;char&gt;(getchar()); int sum = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10, sum += e - '0'; e = static_cast&lt;char&gt;(getchar()); &#125; return sum;&#125;int main() &#123; n = read(), m = read(); int c = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; op[c++] = read(); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; memset(vis, 0, sizeof(vis)); if (m != 1) &#123; if (i == 0 &amp;&amp; op[0] &lt; op[1])continue; if (i == m - 1 &amp;&amp; op[m - 1] &lt; op[m - 2])continue; if (i != 0 &amp;&amp; i != m - 1 &amp;&amp; (op[i] &lt; op[i - 1] || op[i] &lt; op[i + 1]))continue; &#125; BFS(i); &#125; bool key = true; int ans1 = 0; for (int i = 0; i &lt; m; i++) &#123; if (!mainVis[i])key = false, ans1++; &#125; if (key) &#123; cout &lt;&lt; 1 &lt;&lt; endl; sort(can, can + m); int r = 0, ans2 = 0, i = 0; while (r &lt; m) &#123; int p = 0; while (i &lt; m &amp;&amp; can[i].l &lt;= r)p = max(p, can[i++].r); r = p + 1; ans2++; &#125; cout &lt;&lt; ans2; &#125; else cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>区间</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1312]Mayan游戏]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%B4%9B%E8%B0%B7P1312-Mayan%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个7行5列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下: 每步移动可以且仅可以沿横向(即向左或向右)拖动某一方块一格:当拖动这一方块时，如果拖动后到达的位置(以下称目标位置)也有方块，那么这两个方块将交换位置(参见输入输出样例说明中的图6到图7 );如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落(直到不悬空，参见下面图1 和图2); 任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除(参见图1 到图3)。 注意: 如果同时有多组方块满足消除条件，几组方块会同时被消除(例如下面图4 ，三个颜色为1的方块和三个颜色为2的方块会同时被消除，最后剩下一个颜色为2的方块)。 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除(例如下面图5 所示的情形，5 个方块会同时被消除)。 方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意:掉落的过程中将不会有方块的消除。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面图1到图3给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为(0，0)，将位于(3，3)的方块向左移动之后，游戏界面从图1变成图2所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图3所示的局面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共 6 行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为一个正整数n，表示要求游戏通关的步数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的5行，描述7×5的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个0结束，自下向上表示每竖列方块的颜色编号(颜色不多于10种，从1开始顺序编号，相同数字表示相同颜色)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据保证初始棋盘中没有可以消除的方块。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有解决方案，输出n行，每行包含 3 个整数x，y，g表示一次移动，每两个整数之间用一个空格隔开，其中(x，y)(x，y)表示要移动的方块的坐标，g表示移动的方向，1表示向右移动，-1表示向左移动。注意:多组解时，按照x为第一关健字，y为第二关健字，1优先于-1，给出一组字典序最小的解。游戏界面左下角的坐标为(0，0)(0，0)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有解决方案，输出一行，包含一个整数-1。 输入输出样例Sample input 31 02 1 02 3 4 03 1 02 4 3 4 0 Sample output 2 1 13 1 13 0 1 说明[输入输出样例说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按箭头方向的顺序分别为图6到图11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;样例输入的游戏局面如上面第一个图片所示，依次移动的三步是:(2，1)处的方格向右移动，(3，1)处的方格向右移动，(3，0)处的方格向右移动，最后可以将棋盘上所有方块消除。[数据范围]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，初始棋盘上的方块都在棋盘的最下面一行;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，0&lt;n≤5。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察DFS。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到题目规则很复杂，动态规划状态太多压不下，并且数据量固定为5×7，可以考虑时间复杂度很高的暴力DFS法。本题很考验码力。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本做法正如题目中所言，按部就班模拟即可，还要注意一处剪枝:若一个方块左侧有方块时没有必要进行向左交换，因为之前必定有与之等价的右交换发生了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其余见示例代码注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;struct node &#123; int x, y, status;//相当于队列节点&#125; ans[5];//存答案int op[5][7] = &#123;0&#125;, n;//存当前的图案信息和移动次数int sum = 0;//记录还没有解决的色块数目inline void copy(int a[5][7], int b[5][7]) &#123;//复制数组函数 for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++)a[i][j] = b[i][j]; &#125;&#125;inline void findR(int x, int y, int &amp;last, int &amp;end) &#123;//找行上相同色块范围 for (int i = x; op[i][y] == op[x][y] &amp;&amp; i &gt;= 0; i--)last = i; for (int i = x; op[i][y] == op[x][y] &amp;&amp; i &lt; 5; i++)end = i;&#125;inline void findC(int x, int y, int &amp;last, int &amp;end) &#123;//找列上相同色块范围 for (int i = y; op[x][i] == op[x][y] &amp;&amp; i &gt;= 0; i--)last = i; for (int i = y; op[x][i] == op[x][y] &amp;&amp; i &lt; 7; i++)end = i;&#125;int update() &#123;//更新当前的图案信息 bool key[10][20] = &#123;false&#125;;//标志那个色块需要被解决 int l1, e1, l2, e2, t = 0; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; if (op[i][j] == 0)continue;//没有色块不考虑 findR(i, j, l1, e1), findC(i, j, l2, e2);//找到它的相同色块范围 if (e1 - l1 &gt;= 2) &#123; for (int p = l1; p &lt;= e1; p++)key[p][j] = true;//标记为true &#125; if (e2 - l2 &gt;= 2) &#123; for (int p = l2; p &lt;= e2; p++)key[i][p] = true; &#125; &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123;//解决所有被标记的色块 for (int j = 0; j &lt; 7; j++) &#123; if (!key[i][j])continue; t++;//统计被解决色的数目 op[i][j] = 0;//置为0,表示没有色块 &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123;//处理落下的色块 int begin = 0; while (op[i][begin] != 0 &amp;&amp; begin &lt; 7)begin++; for (int j = begin + 1; j &lt; 7; j++)if (op[i][j] != 0)op[i][begin++] = op[i][j]; for (int j = begin; j &lt; 7; j++)op[i][j] = 0; &#125; if (t != 0) &#123; return t + update();//如果本次处理了色块就可能有其余色块需要被解决,继续递归 &#125; return 0;//没有被解决的就返回0&#125;void DFS(int rank, int tot) &#123; if (rank == n) &#123; if (tot == 0) &#123;//全部的色块被解决,输出答案 for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ans[i].x &lt;&lt; " " &lt;&lt; ans[i].y &lt;&lt; " " &lt;&lt; ans[i].status &lt;&lt; endl; &#125; exit(0);//然后立即结束程序 &#125; else return;//否则返回 &#125; int temp[5][7];//储存没被处理的图案信息 copy(temp, op);//复制数组 for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; if (temp[i][j] == 0)continue; copy(op, temp);//每一次都要还原图案信息,相当于朴素DFS中的visit标记清零 if (i &lt; 4) &#123; ans[rank].x = i, ans[rank].y = j, ans[rank].status = 1; if (temp[i + 1][j] == 0) &#123;//右移落下的情况 int begin = 0; while (temp[i + 1][begin] != 0)begin++; op[i + 1][begin] = temp[i][j]; for (int z = j + 1; z &lt; 7; z++)op[i][z - 1] = op[i][z]; op[i][6] = 0; DFS(rank + 1, tot - update()); &#125; else &#123;//右移交换的情况 if (op[i + 1][j] == op[i][j])continue; swap(op[i + 1][j], op[i][j]); DFS(rank + 1, tot - update()); &#125; &#125; copy(op, temp); if (i &gt;= 1) &#123;//左移落下的情况 ans[rank].x = i, ans[rank].y = j, ans[rank].status = -1; if (temp[i - 1][j] == 0) &#123; int begin = 0; while (temp[i - 1][begin] != 0)begin++; op[i - 1][begin] = temp[i][j]; for (int z = j + 1; z &lt; 7; z++)op[i][z - 1] = op[i][z]; op[i][6] = 0; DFS(rank + 1, tot - update()); &#125; else continue;//左移交换,由于之前必有等价的右移在先,可知其不可行,直接剪枝,不考虑这一步 &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; 5; i++) &#123; int x, j = 0; while (cin &gt;&gt; x) &#123; if (x == 0)break; op[i][j++] = x; sum++; &#125; &#125; DFS(0, sum);//sum表示有多少色块 cout &lt;&lt; -1;//DFS过程中没有结束程序,说明无解,输出-1 return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合方案数问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E7%BB%84%E5%90%88%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里介绍组合方案数的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定N个正整数和M，用这N个数中的一些数进行求和，使得和为M，问方案数。该问题可以采用动态规划的方法快速求得。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设dp(x，y)表示从序号为1~x的数中选使得和为y的方案数，则有状态转移方程: dp(x,y)=\begin{cases}dp(x-1，y)+1 & y=value(x)\\ dp(x-1，y)+dp(x-1，y-value(x)) & y>value(x)\\ dp(x-1，y) & y]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间问题专题]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次探讨区间问题，这大多是基于贪心算法的，在很多题目中都能用到。下面讨论仅限于闭区间，开区间只需稍作调整即可。 区间完全覆盖问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间和这个区间上的m个子区间，求其中尽量少的区间，使得它们的并集覆盖整个区间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法:将各个区间的左端点升序排序;确定左值p，初始化p=0。从所有左端点小于等于左值的区间中选出右端点最大的一个，并加入集合，更新左值为右端点值+1。贪心正确性证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设总区间[1，n]，分区间[a1，b1]，[a2，b2]，… ，[am，bm]。规定f(x)表示覆盖[x，n]的最小区间数，则有状态转移方程: f(x)=\min\{1+f(b_k+1)\}，a_k\leq x\leq b_k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然f(x)是单调减的，所以我们取bk的最大值，即有f(x)=1+f(bt+1)，bt是最大的一个。这样就把动态规划问题转化为贪心。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在题目保证有解的前提下，bt一定是不小于x的，可知算法的正确性。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int l, r; bool operator&lt;(node x) &#123; return this-&gt;l &lt; x.l; &#125;&#125; op[50];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++)cin &gt;&gt; op[i].l &gt;&gt; op[i].r; sort(op, op + m); int p = 0, i = 0, ans = 0; while (p &lt; m) &#123; int maxn = 0; while (op[i].l &lt;= p)maxn = max(maxn, op[i].r), i++;//根据序列的有序性,i不必初始化为0,直接按上一次的继续即可 p = maxn + 1; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 最大不相交区间问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个区间和它的m个子区间，求尽量多的区间使得它们两两不相交。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法:将区间按右端点升序排序，对于一簇右端点相同的区间，取左端点最大一个加入集合(如果可以加入的话)，然后继续找后面右端点相同的区间簇。贪心正确性证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设总区间[1，n]，分区间[a1，b1]，[a2，b2]，… ，[am，bm]。规定f(x)表示[1，x]中的最大不相交区间数目，则有状态转移方程:当x是某个区间右端点时: f(x)=\max\{1+f(a_k-1)\}，b_k=x否则: f(x)=f(p)，p=\max\{b_k\}，b_k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>区间</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串哈希]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[本文改编自https://blog.csdn.net/pengwill97/article/details/80879387&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多题目涉及字符串问题，但是字符串不如整数那样容易处理，尤其是涉及图时。这时我们需要构造映射string-&gt;int来将字符串转化为int，这就是字符串哈希算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希方案有很多种，这里我们选择很常用的一个—BKDR Hash。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希思路是将字符串看成是一个base位进制数(base为一个大质数)，具体思路如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于字符串的第i位，我们有: hash(0)=str(i)-’a’+1\\ hash(i)=(hash(i-1)*base+str(i)-’a’+1)%P，i\geq 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一个算出的hash值作为整个字符串的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P是一个大于base的质数。hash为一个unsigned long long的数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易看出这是计算这个base进制数的公式并且每个值都对P取了模，这个方法可以将字符串映射到[0，P)的正整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是可能有两个字符串不同但哈希值相同的情况，称为哈希冲突。在base，P足够大时这种冲突概率很低。这里列举几个质数，读者可以参考使用。 素数 冲突率% 53 10.416667 97 1.0416670 193 0.520833 389 1.302083 769 0.130208 1543 0.455729 3079 0.227865 6151 0.113932 12289 0.008138 24593 0.069173 49157 0.010173 98317 0.013224 196613 0.002543 393241 0.006358 786433 0.000128 1572869 0.000318 3145739 0.000350 6291469 0.000207 12582917 0.000040 25165843 0.000075 50331653 0.000010 100663319 0.000023 201326611 0.000009 402653189 0.000001 805306457 0.000011 1610612741 0.000000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;洛谷P3370用字符串哈希求互异字符串个数，下面给出代码:12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int P1 = 19260817, P2 = 100663319;int vis[P2] = &#123;0&#125;;unsigned long long h[1050] = &#123;0&#125;;inline int Hash(string s) &#123; h[0] = s[0] - 'a' + 1; for (int i = 1; i &lt; s.length(); i++) &#123; h[i] = (h[i - 1] * P1 + s[i] - 'a' + 1) % P2; &#125; return h[s.length() - 1];&#125;int main() &#123; ios::sync_with_stdio(false); int n, ans = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string str; cin &gt;&gt; str; int h = Hash(str); if (vis[h] == 0)vis[h] = 1, ans++; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增法求LCA]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%80%8D%E5%A2%9E%E6%B3%95%E6%B1%82LCA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次讨论树这种数据结构上的一种算法—用倍增算法求最近公共祖先(LCA)。首先介绍倍增算法的原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若给定一个正整数x且有x &lt; 2k，若从2k开始，令x从大到小依次减去2的方幂p(2k，2k-1…，1)，第一个能够使x-p≥0的数p必定在数x的二进制拆分表达式中。这个很容易用二进制解释证明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用depth[]储存每一个节点的深度(认为根节点深度为1)，用grand[][]储存每个节点的祖先并定义grand[x][y]表示x节点向上2y处的祖先。若越界则置为0。显然grand[x][0]是每个节点的父节点编号。这两个数组均可由DFS求出，详见示例代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定两个待求LCA的节点标号，我们首先要做的是将两个节点排到同一深度。操作方法是令深度较大的节点向上”跳跃”，直至深度与较小节点相同。一种朴素的方法是一层一层地向上跳，但时间消耗明显。这里我们可以用与快速幂类似的倍增思想加快跳跃速度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先确定k的大小，容易知道k=ceil{log_2(DEPTH)}，这里DEPTH为树的最大深度。通常我们取20即可。从大到小枚举2的方幂p，最终能使较大深度节点达到与较小深度节点相同的深度。这时如果两个节点重合，则它即为LCA。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若两个节点不相同，就需要让这两个节点同时向上跳，加快跳跃速度的方式与之前类似，也是通过倍增实现，跳跃后会到达LCA的正下方，直接返回父节点即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int MAX = 500001;struct edge &#123;//链式前向星存边 int to, next;&#125; op[MAX * 2];int head[MAX];//链式前向星节点首边int cnt = 0;//边编号int root = 1;//根节点编号int depth[MAX] = &#123;0&#125;;//存各个节点深度int grand[MAX][21] = &#123;0&#125;;//倍增使用int N, M;//存节点数和询问数int read() &#123;//读入优化 char e = static_cast&lt;char&gt;(getchar()); while (e &lt; '0' || e &gt; '9')e = static_cast&lt;char&gt;(getchar()); int sum = 0; while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10, sum += e - '0'; e = static_cast&lt;char&gt;(getchar()); &#125; return sum;&#125;void add(int x, int y) &#123;//构建链式前向星,从x到y有一条边 op[cnt].to = y; op[cnt].next = head[x]; head[x] = cnt++;&#125;void DFS(int x) &#123; for (int i = head[x]; i != -1; i = op[i].next) &#123;//遍历各个子节点 if (depth[op[i].to] != 0)continue;//不能向父节点回溯 depth[op[i].to] = depth[x] + 1;//深度加一 grand[op[i].to][0] = x;//初始化递推 for (int j = 1; j &lt; 21; j++)grand[op[i].to][j] = grand[grand[op[i].to][j - 1]][j - 1];//递推 DFS(op[i].to);//下一个子节点 &#125;&#125;int LCA(int x, int y) &#123;//求LCA的函数 if (depth[x] &gt; depth[y])swap(x, y);//认为y的深度较大 for (int i = 20; i &gt;= 0; i--) &#123; if (depth[grand[y][i]] &gt;= depth[x])y = grand[y][i];//y倍增至与x同深度 &#125; if (x == y)return x;//节点相同就是LCA 直接返回 for (int i = 20; i &gt;= 0; i--) &#123;//两个节点倍增至LCA的正下方 if (grand[x][i] != grand[y][i])x = grand[x][i], y = grand[y][i]; &#125; return grand[x][0];//父节点即为LCA&#125;int main() &#123; N = read(), M = read(), root = read(); memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= N - 1; i++) &#123; int x, y; x = read(), y = read(); add(x, y), add(y, x); &#125;//读入树的信息 depth[root] = 1;//初始化 DFS(root);//深搜求depth和grand for (int i = 0; i &lt; M; i++) &#123; int x, y; x = read(), y = read(); printf("%d\n", LCA(x, y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>倍增</tag>
        <tag>树</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST表]]></title>
    <url>%2F2019%2F01%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST表是一种求区间最值的高效数据结构，不支持动态维护，建表时间复杂度O(nlogn)，查询复杂度O(1)。在不需要修改原数据的情况下ST表要比线段树更简洁，但在需要修改原数据时只能用线段树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST表可以定义为二维数组ST[][]，其中ST[i][j]表示从第j的元素开始的长度为2i的区间中的最值，也就是区间[j，j+2i-1]中的最值。这个表可以用DP思想建立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建表前，我们需要两个辅助数组log[]与bin[]。其中log[i]储存使2k&lt;=i的整数k的最大值;bin[i]储存2i。这两个数组都可以通过递推实现: log[0]=-1，log[x]=log[x/2]+1\\ bin[0]=1，bin[x]=bin[x/2]*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log数组大小达到数据量n，bin达到logn。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辅助数组构建完毕后开始建ST表。首先对ST表首行初始化，即ST[0][x]。它们都表示从x号元素开始长度为1的区间的最值，显然就是该元素本身。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外ST表中有递推公式: ST[i][x]=\max/\min\{ST[i-1][x]，ST[i-1][x+bin[i-1]]\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即将区间分成两半，求取其中的最值，这里注意x+bin[i]-1≤n。递推后即可完成建表。 下面探讨查询操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实我们也可以用将区间平均拆分的分治思想来求给定区间的最值，但是给定区间长度不一定就是2的方幂，于是我们需要其它分治方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到有不等式2log[l]*2&gt;l。这是显然的。这个不等式启示我们可以将长度为l的区间拆分成两个长度为2log[l]的区间，这两个区间已然覆盖了区间所有的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此区间[a，b]的最值即为$\max/\min\{ST[log[l]][a]，ST[log[l]][b-bin[log[l]]+1]\}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里l=b-a+1，为区间长度。123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int ST[20][10000];//储存ST表数据int op[10000], n;//储存区间数据int log[10000], bin[20];//储存log值以及指数值int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; ST[0][i] = op[i]; &#125;//第一行初始化 log[0] = -1; for (int i = 1; i &lt;= n; i++)log[i] = log[i / 2] + 1;//log初始化 bin[0] = 1; for (int i = 1; i &lt; 20; i++)bin[i] = bin[i - 1] * 2;//bin初始化 for (int i = 1; i &lt; 20; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (j + bin[i] - 1 &lt;= n) &#123; ST[i][j] = min(ST[i - 1][j], ST[i - 1][j + bin[i - 1]]);//递推建表,DP思想 &#125; &#125; &#125; int k; cin &gt;&gt; k;//查询k次 while (k-- &gt; 0) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; int t = log[r - l + 1]; cout &lt;&lt; min(ST[t][l], ST[t][r - bin[t] + 1]) &lt;&lt; endl;//输出查询结果 &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>区间最值</tag>
        <tag>提高算法</tag>
        <tag>数据结构</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在来认识一种新的求幂算法—快速幂算法。这个算法可以在O(logn)的时间复杂度下计算nm的值(要求m为自然数)。相比朴素O(n)累乘算法，效率大大提升。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速幂算法基于倍增思想，是倍增算法的一个应用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个自然数都可以写出它唯一的二进制数，即有: m=2^{k_1}+2^{k_2}+...+2^{k_m}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里$0\leq k_1 &lt; k_2&lt; …&lt; k_m$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么$n^m$可以表示为$n^{2^{k_1}+2^{k_2}+…+2^{k_m}}$，即$n^{2^{k_1}} × n^{2^{k_2}} × … × n^{2^{k_m}}$，从而化为几个数的乘积，并且这几个数有这平方级的关系。这样就可以把求幂运算压至O(logn)复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码(答案对P取模):12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; const int P = 10000007; long long int n, m; cin &gt;&gt; n &gt;&gt; m; long long int t = n; long long int ans = 1; while (m &gt; 0) &#123; if (m % 2 == 1)ans *= t, ans %= P; t *= t; t %= P; m /= 2; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法]]></title>
    <url>%2F2019%2F01%2F09%2FFloyd%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了Dijkstra算法和SPFA算法，另一种求最短路方法是Floyd算法。这个算法可以求出任意两点之间的最短路径长度，支持负边权，需要用邻接矩阵存图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法缺点是耗时过大，时间复杂度O(n3)。算法步骤:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 初始化dist数组，邻接节点dist值即为相邻边权值，否则为inf(无穷大)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 枚举每一个节点，用这个节点作中介，更新所有节点对的最短路径值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后dist即为最短路径数组，如果为inf则两点不连通。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下:12345678for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i != j &amp;&amp; i != k &amp;&amp; j != k) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); &#125; &#125;&#125; 算法正确性证明:首先我们要清楚，最短路只有三种情况:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 两点直接相连且路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 两点经一个中介点路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 两点经多个中介点路径最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况1已经求出，且算法全程对这个值没有影响。情况2在枚举到中介点k时就已经求出了所有以k为单个中介的两点最短路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于情况3，我们假设中介点为a1 &lt; a2 &lt; … &lt; am。两点靠m个中介点获得最短路。令集合S={x，y，a1，a2…am}(x，y分别是源点和终点)。当k枚举到a1时，必然会更新这样一对属于情况2的节点对(ai，aj)，其中ai，aj∈S。这时我们可以看作是ai，aj直接相连而不经过a1，然后从S中清除a1，这样m个中介就减少至m-1个。后面的过程每次都使中介点减一，在枚举完成之前必可以将其转化为情况2并求出最短路径值。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>图论</tag>
        <tag>图的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法与SPFA算法]]></title>
    <url>%2F2019%2F01%2F09%2FDijkstra%E7%AE%97%E6%B3%95%E4%B8%8ESPFA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dijkstra算法是一种基于贪心思想的求单源最短路算法，时间复杂度为O(n2)。Dijkstra算法要求边权非负。步骤:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 一个数组dis[]保存最短路径长的结果，源点值置为0，其余为inf。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 一个集合S保存所有已求出最短路径长的节点，初始化S为空。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 从不在S中的节点集合中找到dis最小的节点，用这个节点更新与之相邻的的节点dis值(这个过程叫松弛)，并将这个节点加入S。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复③，直到所有节点都加入S中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们证明，不在S中的节点集合里面dis最小的节点，设为min，它的dis最小值必为当前值。这是因为若存在另外一条路径使得点dis值更小，必定会经过其余的某一个点，假设该点dis值为k，则应该有k+p]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>图论</tag>
        <tag>图的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分解质因数]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分解质因数算法是一种很重要的数论算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; for (int i = 2; i &lt;= n / 2; i++) &#123; if (n % i == 0) &#123; cout &lt;&lt; i &lt;&lt; " "; n /= i--; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法通俗易懂。易知第一个可以整除n的i必然是n最小的质因数，这时我们将其输出，并令n除掉i，再令i自减1以在后来的循环中消除n的所有i因子。最后的n将成为一个质数，循环将退出，再将剩下的n输出即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间与n的大小呈对数关系。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2123]皇后游戏]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2123-%E7%9A%87%E5%90%8E%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：省选/NOI- 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游戏的另一个问题。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;皇后有 n 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 n 位大臣颁发奖金，其中第 i 位大臣所获得的奖金数目为第i－1 位大臣所获得奖金数目与前 i 位大臣左手上的数的和的较大值再加上第 i 位大臣右手上的数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;形式化地讲:我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则第 i 位大臣获得的奖金数目为 ci可以表达为: c_i=\begin{cases} a_1+b_1 & i=1\\ \max\{c_{i-1},\displaystyle\sum_{j=1}^ia_j\} & 2\leq i\leq n \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。注意:重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个正整数 T，表示测试数据的组数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 T 个部分，每个部分的第一行包含一个正整数 n，表示大臣的数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个部分接下来 n 行中，每行两个正整数，分别为 ai和 bi，含义如上文所述。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共 T 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 输入输出样例Sample input#1 134 12 21 2 Sample output#1 8 Sample input#2 2585 10095 9976 8760 9779 85129 6818 4552 6139 8363 6745 9952 5482 10023 5499 9463 10052 68 Sample output#2 528902 说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 1，2，3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 1，3，2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 2，1，3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 2，3，1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 3，1，2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 3，2，1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当按照 3，2，1 这样排列队伍时，三位大臣左右手的数分别为:(1， 2)，(2， 2)，(4， 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 1 位大臣获得的奖金为 1 + 2 = 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 2 位大臣获得的奖金为 max{3， 3} + 2 = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 3 为大臣获得的奖金为 max{5， 7} + 1 = 8。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于全部测试数据满足:T≤10，1≤n≤20000，1≤ai，bi≤109。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察数学推导，排序和贪心，难度很高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个相邻的大臣i，j，假定i前方的a之和为p，i前的大臣c值为q，那么可以求出j的c值: c_j=\max\{c_i，p+a_i+a_j\}+b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里ci也可以求出: c_i= \max\{q，p+a_i\}+b_i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以有 c_j=\max\{\max\{q，p+a_i\}+b_i，p+a_i+a_j\}+b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即 c_j=\max\{q+b_i+b_j，p+a_i+b_i+b_j，p+a_i+a_j+b_j\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理交换后有 c_j=\max\{q+b_j+b_i，p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定不交换更优，那么有 \max\{q+b_i+b_j，p+a_i+b_i+b_j，p+a_i+a_j+b_j\}\leq \max\{q+b_j+b_i，p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把这个式子记作①。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现其中都有q+bi+bj这一项，把它们归结为max{a，b}≤max{a，c}。容易发现当b≤时max{a，b}≤max{a，c}必成立。在b&gt;c时可能max{a，b}≤max{a，c}，也可能max{a，b}&gt;max{a，c}。这时我们会交换两个元素使b≤c，从而使max{a，b}≤max{a，c}一定成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此我们可以不考虑q+bi+bj，只考虑后边式子的大小关系: \max\{p+a_i+b_i+b_j，p+a_i+a_j+b_j\}\leq \max\{p+a_j+b_j+b_i，p+a_j+a_i+b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记作②。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当②成立时，①必然也是成立的;而②不成立时交换后即可使①成立。所以可以通过②来判别是否要交换。另外可以发现②取等时，①也取等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将②变形 \max\{b_i，a_j\}+a_i+b_j\leq \max\{b_j，a_i\}+b_i+a_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移项得 \max\{b_i，a_j\}-b_i-a_j\leq \max\{b_j，a_i\}-a_i-b_j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等价于 -\min\{b_i，a_j\}\leq -\min\{b_j，a_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即为 \min\{a_i，b_j\}\leq \min\{a_j，b_i\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记为③。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好地理解本题，下面给出几个概念和定理。 [判别元素]参与相邻元素判别的因子。比如这里的min{ai，bj}和min{aj，bi}。 [相邻子条件]可以使相邻元素在某种次序下更优的判别元素所满足的条件。如果我们记A=min{ai，bj}，B=min{aj，bi}，则相邻子条件为A≤B，此时i在j前更优。我们记相邻子条件为P(X，Y)，在判别元素X，Y满足相邻子条件(X≤Y)时为真。 [逆序]对于一个序列A1，A2，A3，…An，若存在i，j$(1 \leq i &lt; j \leq n)$使得P(Ai，Aj)为假，则称Ai，Aj组成一个逆序。逆序会破坏序列的最优性。 [相邻全局最优化原理]一个序列，其判别元素序列为A1，A2，A3，…An。当序列不存在逆序时，序列最优。 [等价序列转化原理]交换相邻相等元素的位置，答案不变，这时两个序列等价。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个两两相邻元素都满足子条件的序列不一定是最优的，因为它可能存在逆序。比如序列ABC满足A≤B，B≤C，但是A&gt;C(一个逆序)，此时若B=C，我们可以进行等价变形得到ACB，此时AC违背了子条件，交换AC得到序列CAB，显然CAB是比ABC更优的序列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是存在逆序并不一定使序列不最优，也就是说存在逆序的序列得到的答案可能与最优序列答案是相同的。但是没有逆序的序列一定是最优的，化为没有逆序的序列是我们最保险，最稳妥的做法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于国王游戏，我们可以采用按照左右手数值乘积升序排列的做法。这是因为排序后得到的序列没有逆序。这种两两相邻元素满足子条件就可以保证全局没有逆序的性质称为传递性。国王游戏中小于号是可传递的，但本题不可以。在本题中如果A≤B，B≤C，可能有A&gt;C的情况发生。如果我们只像国王游戏那样按照相邻子条件排序，得到的序列可能有逆序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们应该设法创造一个具有传递性的排序思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察③式，发现a与b的情况可以归结为以下几种: 第一种:ai &lt; bi且aj &gt; bj，此时必有ai≤aj，也就是说a是升序的。 第二种:ai = bi且aj = bj。a与b都是不变的，③式显然成立。 第三种:ai &gt; bi且aj &gt; bj，此时必有bj≤bi，也就是说b是降序的。 第四种:ai &lt; bi且aj &gt; bj，③式显然成立。 当然还有第五种:ai &gt; bi且aj &lt; bj，此时③式显然不成立 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先将I组(ab)的元素。在I组中按照a升序排列，在III组中按b降序排列。可以证明这是一种可行且可传递的排序方法。我们可以证明它没有逆序，任取两个元素X，Y(Y在X后)，可以归结为以下六种情况来判别P(X，Y)的成立与否: X，Y都来自I:符合第一种情况，成立。 X来自I，Y来自II:显然成立 X来自I，Y来自III:符合第四种，成立。 X来自II，Y来自II:这时两者是相等的，成立。 X来自II，Y来自III:显然成立。 X来自III，Y来自III:符合第三种，成立。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样我们就找到了一种排序策略得到一个满足全局最优化原理的序列，从中找到的答案必然为最优解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这个题，我们可以发现相邻交换法并不只是按照相邻子条件排序就可以的，排序后的序列不能只让两两相邻元素符合子条件，还要没有逆序。这是相邻交换法的重要理论依据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，虽然a=b时可以任意排序(依据等价序列转化原理)，但是不能在重载时直接返回一个true或者false，这样会出现矛盾(a &lt; b且b &lt; a)造成RE。示例代码中把它归到了I组中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; long long a, b; int d; void make(long long x, long long y) &#123; a = x, b = y; if (a == b)d = 0; else if (a &lt; b)d = -1; else d = 1; &#125; bool operator&lt;(node p) &#123; if (this-&gt;d != p.d)return this-&gt;d &lt; p.d; if (this-&gt;d &lt;= 0)return this-&gt;a &lt; p.a; else return this-&gt;b &gt; p.b; &#125;&#125; op[20001];long long c[20001];int n;int main() &#123; int T; cin &gt;&gt; T; for (int t = 1; t &lt;= T; t++) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; long long x, y; cin &gt;&gt; x &gt;&gt; y; op[i].make(x, y); &#125; sort(op + 1, op + n + 1); long long ans = c[1] = op[1].a + op[1].b, temp = op[1].a; for (int i = 2; i &lt;= n; i++) &#123; temp += op[i].a; c[i] = max(c[i - 1], temp) + op[i].b; ans = max(ans, c[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2258]子矩阵]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2258-%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出如下定义:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子矩阵:从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵(保持行与列的相对顺序)被称为原矩阵的一个子矩阵。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，下面左图中选取第2，4行和第2，4，5列交叉位置的元素得到一个2×3的子矩阵如图所示。9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1的其中一个2×3的子矩阵是4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相邻的元素:矩阵中的某个元素与其上下左右四个元素(如果存在的话)是相邻的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;矩阵的分值:矩阵中每一对相邻元素之差的绝对值之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题任务:给定一个n行m列的正整数矩阵，请你从这个矩阵中选出一个r行c列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含用空格隔开的四个整数n，m，r，c意义如问题描述中所述，每两个整数之间用一个空格隔开。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的n行，每行包含m个用空格隔开的整数，用来表示问题描述中那个n行m列的矩阵。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示满足题目描述的子矩阵的最小分值。 输入输出样例Sample input#1 5 5 2 39 3 3 3 99 4 8 7 41 7 4 6 66 8 5 6 97 4 5 6 1 Sample output#1 6 Sample input#2 7 7 3 37 7 7 6 2 10 55 8 8 2 1 6 22 9 5 5 6 1 77 9 3 6 1 7 81 9 1 4 7 8 810 5 9 1 1 8 101 3 1 5 4 8 6 Sample output#2 16 说明[输入输出样例1说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该矩阵中分值最小的2行3列的子矩阵由原矩阵的第4行，第5行与第1列，第3列，第4列交叉位置的元素组成为6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6其分值为:|6−5| + |5−6| + |7−5| + |5−6| + |6−7| + |5−5| + |6−6| =6[输入输出样例2说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该矩阵中分值最小的3行3列的子矩阵由原矩阵的第4行，第5行，第6行与第2列，第6列，第7列交叉位置的元素组成，选取的分值最小的子矩阵为9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10[数据说明]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于50%的数据，1 ≤ n ≤ 12，1 ≤ m ≤ 12矩阵中的每个元素1≤aij≤20;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，1 ≤ n ≤ 16，1 ≤ m ≤ 16，矩阵中的每个元素1≤aij≤1000，1≤r≤n，1≤c≤m。 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察动态规划和DFS，实际上本题考察这两种方法的结合。由于涉及到行和列的全排，直接进行DP无法写出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现给定矩阵的型很小(不大于16)，在这种情况下用指数级时间复杂度的DFS枚举出所有的行排列，在这个基础上对列进行DP。这时DFS时间复杂度为$O(C_n^r)$，DP时间复杂度为$O(n^3)$。总时间复杂度即为$O(C_n^r*n^3)$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一种行的枚举情况，令f(x，y)表示从前x列中取y列可以获得的最小绝对值之和(第x列必须在其中且x≥y)，那么有状态转移方程: f(x，y)=\min\{f(k，y-1)+S1(k，x)\}+S2(x)，1\leq k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>矩阵</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1108]低价购买]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1108-%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买;再低价购买”。每次你购买一支股票，你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价(216范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买;再低价购买”的原则。写一个程序计算最大购买次数。这里是某支股票的价格清单:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日期 1 ， 2 ， 3 ， 4 ， 5 ， 6 ， 7 ， 8， 9 ，10 ，11， 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;价格68 ，69 ，54， 64，68 ，64 ，70 ，67 ，78 ，62， 98， 87最优秀的投资者可以购买最多4次股票，可行方案中的一种是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日期 2 ， 5 ， 6 ，10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;价格 69， 68 ，64 ，62 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行: N(1≤N≤5000)，股票发行天数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行: N个数，是每天的股票价格。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个数:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大购买次数和拥有最大购买次数的方案数(≤231)当二种方案“看起来一样”时(就是说它们构成的价格队列一样的时候)，这2种方案被认为是相同的。 输入输出样例Sample input 1268 69 54 64 68 64 70 67 78 62 98 87 Sample output 4 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划/递推，与本材料第四题导弹拦截非常类似(只是多了一个求方案数的步骤)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问很容易求得，既可以使用O(n2)的经典动态规划思路也可以使用O(nlogn)的二分和贪心思路(详见第四题的加强版本解析)。示例代码给出的是前者。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨方案数的求法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令f(x)为以下标为x的元素为末尾的最长序列方案数。则dp(x)不为1时有如下的递推关系(不正确的版本): f(x)=\sum f(k)，1\leq kvalue(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化f(x)为0，dp(x)为1时直接令f(x)=1。这样答案即为所有dp(x)取到最大值的f(x)之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里注意到f(x)是很多函数值的和，它们其中重复的组合一定会被重复计算。容易发现，对于一个给定的x，value(x)即是确定的。倘若对于两个k1，k2满足递推式中的条件但是value(k1)≠value(k2)，我们可以肯定k1和k2这两个序列必不存在相同的序列组合。倘若value(k1)=value(k2)且有k1&lt;k2，我们可以肯定以k1所指元素为末尾的所有序列都在k2对应的序列集合中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上可知若令S(x)表示以下标为x的元素为末尾的序列组成的集合，那么有: value(a)≠value(b)时: S(a)\cap S(b)=\varnothing \\ value(a)=value(b)(a]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1736]创意吃鱼法]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1736-%E5%88%9B%E6%84%8F%E5%90%83%E9%B1%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考:到底要以何种方法吃鱼呢(猫猫就是这么可爱，吃鱼也要想好吃法 ^_*)。她发现，把大池子视为01矩阵(0表示对应位置无鱼，1表示对应位置有鱼)有助于决定吃鱼策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有多组输入数据，每组数据:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有两个整数n和m(n，m≥1)，描述池塘规模。接下来的n行，每行有m个数字(非“0”即“1”)。每两个数字之间用空格隔开。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于30%的数据，有n，m≤100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于60%的数据，有n，m≤1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据，有n，m≤2500 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一个整数——猫猫一口下去可以吃掉的鱼的数量，占一行，行末有回车。 输入输出样例Sample input 4 60 1 0 1 0 00 0 1 0 1 01 1 0 0 0 10 1 1 0 1 0 Sample output 3 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察二维DP。该题目与本材料第一题最大正方形有类似之处。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，从左下角开始向右上方吸和从右上角开始向左下方吸本质是一样的。我们不妨强制要求只能向上吸，这样吸的方向就只有两种:向左上方和向右上方。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定dp(x，y，z)为从坐标(x，y)开始向z方向吸到的鱼的最大数目。这里z的定义是:向左上方为0，向右上方为1。dp全初始化为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样很难进行状态转移，这是因为在方阵中只有对角线有鱼时才可以吸。如果没有这个限制，状态转移方程很容易列出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于加上了限制，我们需要三个辅助数组来帮助完成状态转移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取R1(x，y)表示坐标(x，y)的左方离它最近的鱼与其的距离;R2(x，y)表示坐标(x，y)的右方离它最近的鱼与其的距离;C(x，y)表示坐标(x，y)的上方离它最近的鱼与其的距离。我们不需要与下方鱼的距离，这是因为我们已经强制规定只能向上吸，下方的鱼对我们求解没有意义。这里的三个数组都在坐标(x，y)有鱼时才有定义。在某个方向上没有鱼时，直接赋上与边界的距离即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的话，状态转移方程就可以列出了，在坐标(x，y)有鱼时，有如下递推式: dp(x，y，0)=\min\{R1(x，y)，C(x，y)，dp(x-1，y-1，0)+1\}\\ dp(x，y，1)=\min\{R2(x，y)，C(x，y)，dp(x-1，y+1，1)+1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;坐标(x，y)没有鱼时，直接赋值为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从所有dp值中找到最大值即为答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码的数组记录的是鱼的坐标值，在递推时现算出距离。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;int dp[2505][2505][2] = &#123;0&#125;;int n, m;short int op[2501][2501] = &#123;0&#125;;short int sumR_1[2505][2505] = &#123;0&#125;;short int sumR_2[2505][2505] = &#123;0&#125;;short int sumC[2505][2505] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) &#123; int temp = 0; for (register int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; op[i][j]; if (op[i][j])sumR_2[i][temp] = j, sumR_1[i][j] = temp, temp = j; &#125; sumR_2[i][temp] = 2501; &#125; for (register int i = 1; i &lt;= m; i++) &#123; int temp = 0; for (register int j = 1; j &lt;= n; j++) if (op[j][i])sumC[i][j] = temp, temp = j; &#125; int ans = 0; for (register int i = 1; i &lt;= n; i++) &#123; for (register int j = 1; j &lt;= m; j++) &#123; if (!op[i][j])continue; dp[i][j][0] = min(min(j - sumR_1[i][j], i - sumC[j][i]), dp[i - 1][j - 1][0] + 1); dp[i][j][1] = min(min(sumR_2[i][j] - j, i - sumC[j][i]), dp[i - 1][j + 1][1] + 1); ans = max(ans, max(dp[i][j][0], dp[i][j][1])); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2185]仪仗队]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P2185-%E4%BB%AA%E4%BB%97%E9%98%9F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。 现在，C君希望你告诉他队伍整齐时能看到的学生人数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一个数N(1≤N≤40000)。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共一个数，即C君应看到的学生人数。 输入输出样例Sample input 4 Sample output 9 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以左下方的观察点为原点建系，发现可以观察到的人总在正上方和正右方以及右上方一个n-1阶的方阵中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以图中n=6为例，我们考察右上方5阶方阵中的观察情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中红色标出的是观察不到的人的坐标。我们发现可以被观察到等价于其横纵坐标互素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么若令f(x)表示n阶方阵中横纵坐标互素的点的个数，则答案即为f(N)+2。注意N=1时特判为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们探讨f(x)的求法，很自然想到递推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5，1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图，我们在n=4(绿色部分)的基础上递推到n=5的情况，容易发现(5，5)一定会被剔除，然后(5，5)的正左方和正下方一定是成对剔除的。显然，如果令φ(x)表示小于x且与x互素的正整数的个数，则有以下递推式: f(x)=f(x-1)+2*φ(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在问题的关键在于求解φ(x)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;φ(x)在数论上是有定义的，称为欧拉函数(Euler’s totient function)。现在介绍欧拉函数的线性筛法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了理解这个筛法，要了解以下三个基本原理: 若p为素数，则φ(p)=p-1 若p为素数且p†k，则φ(kp)=(p-1)φ(k) 若p为素数且p|k，则φ(kp)=pφ(k) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明见题后注解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用这三个原理结合埃氏筛素数法，可得到下面筛法: 123456789101112131415int euler[40001] = &#123;0&#125;;//记录欧拉函数值int mark[40001] = &#123;0&#125;;//记录是不是素数int prim[40001], tot = 0;//储存当前已知的素数,tot 记录个数for (int i = 2; i &lt;= 40000; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; euler[i] = i - 1;//判断为素数,直接给欧拉函数赋值 &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (i * prim[j] &gt; 40000)break; mark[i * prim[j]] = 1;//标记这个数一定不是素数 if (i % prim[j] == 0)euler[i * prim[j]] = euler[i] * prim[j]; else euler[i * prim[j]] = euler[i] * (prim[j] - 1); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个筛法的可行性除了与埃氏筛法有关外，还利用了一个事实:每一个合数都可以写成k*p的形式并且p&lt;=k。prim数组中存放了所有不大于i的质数，由上面的原理可知在计算φ(i*prim[j])时φ(i)一定已经被求出了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个筛法很重要，它是很多数论方面题目的重要算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这个算法再结合递推式，本题目迎刃而解。1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int euler[40001] = &#123;0&#125;;int mark[40001] = &#123;0&#125;;int prim[40001], tot = 0;int A[40001] = &#123;0&#125;;int main() &#123; for (int i = 2; i &lt;= 40000; i++) &#123; if (!mark[i]) &#123; prim[++tot] = i; euler[i] = i - 1; &#125; for (int j = 1; j &lt;= tot; j++) &#123; if (i * prim[j] &gt; 40000)break; mark[i * prim[j]] = 1; if (i % prim[j] == 0)euler[i * prim[j]] = euler[i] * prim[j]; else euler[i * prim[j]] = euler[i] * (prim[j] - 1); &#125; &#125; A[1] = 1; for (int i = 2; i &lt;= 40000; i++)A[i] = A[i - 1] + 2 * euler[i]; int n; cin &gt;&gt; n; if (n == 1)cout &lt;&lt; 0; else cout &lt;&lt; A[n - 1] + 2; return 0;&#125; 注解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出欧拉函数性质后两个的证明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先欧拉函数是积性函数，即在(a，b)=1时有φ(ab)=φ(a)φ(b)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么在p†k时，由于p是素数，必有(p，k)=1，故φ(pk)=φ(p)φ(k)=(p-1)φ(k)。在p|k时，不妨设k=qps(p†q)，那么φ(pk)=φ(ps+1q)=φ(ps+1)φ(q)。这里φ(ps+1)为ps+1-ps，即ps(p-1)，因此φ(pk)=(p-1)psφ(q)。并且φ(k)=φ(q)φ(ps)=φ(q)ps-1(p-1)。代入即得φ(pk)=pφ(k)。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1052]过河]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1052-%E8%BF%87%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点:0，1，… ，L(其中L是桥的长度)。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数(包括S，T)。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目给出独木桥的长度L，青蛙跳跃的距离范围S，T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有1个正整数L(1≤L≤109)，表示独木桥的长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行有3个正整数S，T，M分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中1≤S≤T≤10，1≤M≤100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三行有M个不同的正整数分别表示这M个石子在数轴上的位置(数据保证桥的起点和终点处没有石子)。所有相邻的整数之间用一个空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示青蛙过河最少需要踩到的石子数。 输入输出样例Sample input 102 3 52 3 5 6 7 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察线性动态规划，难点在于离散化数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(x)表示到达x这个点时踩到的最少的石子数，则状态转移方程为: dp(x)=\min\{dp(x-k)+status(x)\}，S \leq k \leq T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里status(x)在x处没有石子时为0，否则为1。起初dp均置为inf，dp(0)置为0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$\max\{dp(L+k)，0 \leq k&lt;T\}$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是注意到L非常大，一维数组会直接爆掉，必须采取离散化的方法降低数组大小。这里利用石子数很少的特点压缩。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了讲清楚压缩的方法，下面先介绍几个概念和原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引理：若dp(x)已知，青蛙经过合理的跳跃次序从x跳到y，[x，y]中没有任何石子，则dp(y)=dp(x)。引理显然。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源区间：对于一个石子，假定其坐标是x，那么称区间[x-T，x)为源区间。很容易证明，如果青蛙想要跳过这个石子，一定会经过源区间。这也就是说，倘若源区间中的所有DP值全部求得，那么这个石子所在位置及其后面的所有点的DP值都可以由状态转移方程推出。由此我们得到了一个重要结论。某一石子及其后的所有DP值只与这个石子源区间的值有关。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易发现，源区间的长度是T。如若两个石子距离本身就不大于T，则我们称这个石子对应的源区间是不完整的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上面的结论可以发现，对于拥有完整源区间的一个石子，倘若在其前方的区间段中有一段与源区间同样长的区间且它们的值完全相等，则这两个区间是等价的，此时把石子移动到新的区间的右端点上，不影响结果。由引理可知，只需找到一段区间可以使其中任一点都可以经合理的次序跳到源区间的对应位置上即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面探讨缩点方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2520缩：取1，2，… ，10的最小公倍数2520。容易发现，无论S，T为何值，青蛙总可以从x点跳跃至x+2520处的点。也就是说，将石子向前挪动2520个单位(如果可以移动的话)，不影响结果，类似地，将石子后移2520个单位同样不影响结果。这样的操作我们称之为同解变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72缩：经过数论上的证明(见题后注解)，可以发现方程:Sx1+(S+1)x2+…+TxT-S+1=72在1 ≤ S &lt; T ≤ 10时一定是有自然数解的。同样可以知道对于任意的S，T(S &lt; T)，青蛙总可以从x跳跃至x+72处。将石子向前向后移动72个单位仍然是同解变形。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然还有其它缩点方案，但原理都是一致的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，无论怎么变形，都必须保证两个源区间中没有石子，否则引理条件不满足，无法证明两个区间等价。比如两个石子距离2521而T为5时，不能将后一个石子向前挪2520个单位，这是因为新的源区间包含了前一个石子。72缩同理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，72缩必须对S=T的情况进行特判。2520缩不需要是因为即使S=T，2520仍然可以整除S，青蛙跳跃2520/S次仍然可以跳跃2520个单位。但72缩时由数论内容，只有S &lt; T时方程有自然数解，当S=T时，也仅有S=1，2，3，4，6，8，9时有解。倘若数据给定S=T=7，那么青蛙不可能跳跃若干步达到72个单位距离。因此S=T时需要特判(实际上只需特判S=T且为5，7，10即可)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要跳过最后一个石子迟早能到达桥的末端，直接置L为最后一个石子的位置即可，这样可以从最后一个石子的”后源区间”取答案。12345678910111213141516171819202122232425262728293031323334352520缩：#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e8using namespace std;int L, S, T, M;int op[101] = &#123;0&#125;, op2[101] = &#123;0&#125;;int status[258000] = &#123;0&#125;;int dp[258000];int main() &#123; cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; op[i]; sort(op + 1, op + M + 1); for (int i = 1; i &lt;= M; i++) &#123; if (op[i] - op[i - 1] &gt; 2520) &#123; op2[i] = (op[i] - op[i - 1]) % 2520 + op2[i - 1]; if (op2[i] - op2[i - 1] &lt;= T)op2[i] += 2520; &#125; else op2[i] = op2[i - 1] + op[i] - op[i - 1]; status[op2[i]] = 1; &#125; L = op2[M]; for (int i = 1; i &lt; L + T; i++)dp[i] = inf; dp[0] = 0; for (int i = 0; i &lt; L; i++) &#123; for (int j = S; j &lt;= T; j++) dp[i + j] = min(dp[i + j], dp[i] + status[i + j] ); &#125; int ans = inf; for (int i = L; i &lt; L + T; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404172缩：#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e8using namespace std;int L, S, T, M;int op[101] = &#123;0&#125;, op2[101] = &#123;0&#125;;int status[8000] = &#123;0&#125;;int dp[8000];int main() &#123; cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M; int ans = inf; for (int i = 1; i &lt;= M; i++)cin &gt;&gt; op[i]; sort(op + 1, op + M + 1); if (S == T &amp;&amp; (S == 5 || S == 7 || S == 10)) &#123; //写成 if(S==T)同样正确 ans = 0; for (int i = 1; i &lt;= M; i++)if (op[i] % S == 0)ans++; cout &lt;&lt; ans; return 0; &#125; for (int i = 1; i &lt;= M; i++) &#123; if (op[i] - op[i - 1] &gt; 72) &#123; op2[i] = (op[i] - op[i - 1]) % 72 + op2[i - 1]; if (op2[i] - op2[i - 1] &lt;= T)op2[i] += 72; &#125; else op2[i] = op2[i - 1] + op[i] - op[i - 1]; status[op2[i]] = 1; &#125; L = op2[M]; for (int i = 1; i &lt; L + T; i++)dp[i] = inf; dp[0] = 0; for (int i = 0; i &lt; L; i++) &#123; for (int j = S; j &lt;= T; j++) dp[i + j] = min(dp[i + j], dp[i] + status[i + j] ); &#125; for (int i = L; i &lt; L + T; i++)ans = min(ans, dp[i]); cout &lt;&lt; ans; return 0;&#125; 注解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出72缩的数学证明，以下内容涉及初等数论的相关内容，建议读者在熟悉初等数论的基础上阅读。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先介绍一个定理。 [赛瓦维斯特定理]给定两个互素的正整数a，b。若$ax+by=z$没有非负的整数解，则z具有最大值，该值为$ab-a-b$。 证明:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由$(a，b)=1$可知任意整数z，不定线性方程$ax+by=z$都是有解的。容易知道，对于不定方程的一个特解$x_0，y_0$，知$x_0+bt，y_0-at$也是方程的解，也就是说这些解x，y满足：$x \equiv x_0(mod\ b)，y \equiv y_0(mod\ a)$，它们本质上是同一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们证明$ax+by=z$在a，b互素时，仅有这样的一组解。假设x，y满足$ax+by=z$，而$ax_0+by_0=z$，作差得$a(x-x_0)+b(y-y_0)=0$，故有$ax \equiv ax_0(mod\ b)$。由于$(a，b)=1$，所以$ax \equiv ax_0(mod\ b)$就是$x \equiv x_0(mod\ b)$。故仅有一组解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(扩展:$ax\equiv b(mod\ m)$在$(a，m)|b$时有解，且有$(a，m)$组解)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这样的一系列解，必存在这样的一个解$x_1$，$y_1$满足$-b\leq x_10$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候若$x_1$加上$b$，就一定可以使x对应的解非负，但同时$y_1$要减去$a$。倘若$y_1 \geq a$，则对应的$ax+by=z$必然是有非负整数解的。倘若$y_1 &lt; a$，容易知道此时无论$x_1$加上多少倍的$b$，都不能使x和y同时非负，这时方程是无解的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此，我们得到方程无解等价于$-b\leq x_1&lt;0$时有$y_1&lt;a$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个基础上令x1，y1分别取它们的最大值-1，a-1，代入原方程得到: z=-a+b(a-1)=ab-a-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是无解的z的最大值。证毕。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由这个定理，我们就可以更好地理解72缩的原理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易知道相邻的两个自然数是互素的，那么这两个自然数a，a+1不能线性表示的最大数是a*(a+1)-a-a-1=a2-a-1。给定S和T(S]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1156]垃圾陷阱]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1156-%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卡门――农夫约翰极其珍视的一条Holsteins奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为D(2≤D≤100)英尺。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设卡门预先知道了每个垃圾扔下的时间t(0 &lt; t ≤ 1000)，以及每个垃圾堆放的高度h(1 ≤ h ≤ 25)和吃进该垃圾能维持生命的时间f(1 ≤ f ≤ 30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续10小时的能量，如果卡门10小时内没有进食，卡门就将饿死。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为2个整数，D和G(1≤G≤100)，G为被投入井的垃圾的数量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二到第G+1行每行包括3个整数:T(0&lt;T&lt;=1000)，表示垃圾被投进井中的时间;F(1≤F≤30)，表示该垃圾能维持卡门生命的时间;和H(1≤H≤25)，该垃圾能垫高的高度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果卡门可以爬出陷阱，输出一个整数表示最早什么时候可以爬出;否则输出卡门最长可以存活多长时间。 输入输出样例Sample input 20 45 4 99 3 212 6 1013 1 1 Sample output 13 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察动态规划。这里提供三种解决思路。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要先对垃圾投入时间升序排列，确定序号。 三维DP法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析题目，状态量有垃圾序号，生命值，高度和绝对时间四种。一种解决思路是将垃圾序号，生命值和高度作为状态描述参量，对绝对时间求DP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若令dp(r，l，h)表示在处理到第r个垃圾，生命值为l，高度为h时的最优逃出时间，则状态转移方程为:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time(r+1)&gt;l时: dp(r，l，h)=inf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h+height(r)&lt;d时: dp(r，l，h)=\min\{dp(r+1，l+life(r)，h)，dp(r+1，l，h+height(r))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;否则: dp(r，l，h)=time(r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起初，dp所有元素均置为0。inf表示无穷大。考虑到数据量大小，可以递归而非递推求解，但缺点是空间消耗过大，状态参量过多。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为dp(1，10，0)，若其为inf，说明无法逃出。在递归过程中用一个变量记录最长生存期，最后输出这个值即可。12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf (int)1e9using namespace std;int dp[3200][101][101] = &#123;0&#125;;int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxh = 0;int DP(int l, int r, int h) &#123; if (dp[l][r][h] != 0)return dp[l][r][h]; if (op[r].t &gt; l || r == g + 1) &#123; maxh = max(maxh, l); return dp[l][r][h] = inf; &#125; if (h + op[r].h &gt;= d)return dp[l][r][h] = op[r].t; return dp[l][r][h] = min(DP(l + op[r].v, r + 1, h), DP(l, r + 1, h + op[r].h));&#125;int main() &#123; cin &gt;&gt; d &gt;&gt; g; for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); if (DP(10, 1, 0) &lt; inf)cout &lt;&lt; DP(10, 1, 0); else cout &lt;&lt; maxh; return 0;&#125; 二维DP法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只考虑垃圾序号和高度两个参量，对生命值求dp。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令dp(r，h)表示处理了前r个垃圾，高度达到h时的最大生存期。状态转移方程为:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time(r+1)≤dp(r，h)时: dp(r+1，h)=\max\{dp(r，h)+life(r+1)，dp(r，h-height(r+1))\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起初所有dp元素全置为-1并初始化dp[0][0]=10，按照上述方程递推。结合方程特点，递推应按照从左到右，从上到下的顺序。行坐标范围为[0，G)，列坐标范围[0，D)。当其中出现dp(i，j)不为-1且j&gt;=d的情况时，记录逃出时间为time(i)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后遍历一遍二维表获得最大的dp(i，j)，此为最大生存期，注意行坐标范围为[0，G]。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度O(D×G)。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define inf (int)1e9using namespace std;int dp[3200][150];int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxt = 0;int mint = inf;int main() &#123; cin &gt;&gt; d &gt;&gt; g; memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); dp[0][0] = 10; for (int i = 0; i &lt; g; i++) &#123; for (int j = 0; j &lt;= d; j++) &#123; if (op[i + 1].t &lt;= dp[i][j]) &#123; dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + op[i + 1].v); if (j + op[i + 1].h &gt;= d)mint = min(mint, op[i + 1].t); dp[i + 1][j + op[i + 1].h] = max(dp[i + 1][j + op[i + 1].h], dp[i][j]); &#125; &#125; &#125; for (int i = 0; i &lt;= g; i++) for (int j = 0; j &lt; d; j++)maxt = max(maxt, dp[i][j]); if (mint != inf)cout &lt;&lt; mint; else cout &lt;&lt; maxt; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;善于发现的读者可能会注意到，这个二维DP只与两个相邻的行有关，容易发现dp数组可以压缩至一维。考虑到每一个元素只可能影响它正下方和正下方右边的某一值，我们应采取从上到下，从右到左的顺序进行DP。除此之外还要注意值修改顺序的不同。这便是解决本题的第三个方法，也是最优的方法。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define inf (int)1e9using namespace std;int dp[200];int d, g;struct node &#123; int t, v, h; bool operator&lt;(node x) &#123; if (this-&gt;t &lt; x.t)return true; return false; &#125;&#125; op[101];int maxt = 0;int mint = inf;int main() &#123; cin &gt;&gt; d &gt;&gt; g; memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= g; i++)cin &gt;&gt; op[i].t &gt;&gt; op[i].v &gt;&gt; op[i].h; sort(op + 1, op + g + 1); dp[0] = 10; for (int i = 0; i &lt; g; i++) &#123; for (int j = d - 1; j &gt;= 0; j--) &#123; if (op[i + 1].t &lt;= dp[j]) &#123; if (j + op[i + 1].h &gt;= d)mint = min(mint, op[i + 1].t); dp[j + op[i + 1].h] = max(dp[j + op[i + 1].h], dp[j]); maxt = max(maxt, dp[j]); dp[j] = max(dp[j], dp[j] + op[i + 1].v); maxt = max(maxt, dp[j]); &#125; &#125; &#125; if (mint != inf)cout &lt;&lt; mint; else cout &lt;&lt; maxt; return 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们总结一下动态规划问题的求解模型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 确定状态和状态之间的关系，理清那些是状态的描述量，那些是所求量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 列出状态转移方程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 观察状态转移方程，确定递推顺序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4#. 必要时应采取状态压缩DP，离散化(后文详述)和数组维数压缩的方法降低空间复杂度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DP降维的方法有以下几种:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 状态之间可以互相表示，这时可以去除一些状态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 该状态没有必要或者不影响递推过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上文的讲述，可以发现选取正确的状态参量来描述状态是一件很有意义的事情。选取状态时不仅要紧抓题目要点，还要尽可能精简。状态参量过少会难以描述状态甚至无法转移，过多很容易造成时间和空间的浪费。这一种能力既需要深厚的经验积累，有时又需要一点点灵感和大胆的猜想。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1120]小木棍[数据加强版]]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1120-%E5%B0%8F%E6%9C%A8%E6%A3%8D-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共二行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为一个单独的整数N表示砍过以后的小木棍的总数，其中N≤65。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行为N个用空个隔开的正整数，表示N根小木棍的长度。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个数，表示要求的原始木棍的最小可能长度。 输入输出样例Sample input 95 2 1 5 2 1 5 2 1 Sample output 6 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察DFS及剪枝，对搜索和剪枝能力要求很高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入时过滤掉大于50的数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知最小的木棍长度可能值一定不小于当前木棍长度的最大值，不大于所有木棍长度的和。从可能的最小值开始只到最大值依次检验，但凡找到一个值可行，该值显然最小，输出该值并结束程序。另外答案只可能是长度和的因子，非因子直接continue即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检验方式为DFS，从搭建第一个木棍开始，遍历所有尚未访问的木棍数值，将其加入到新的木棍中。若所有木棍都可以加入到新木棍中以拼成若干根等长的木棍，则该值可行。这样的做法时间复杂度相当高，极易超时。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于值只有在DFS完成后才可以知道其可行性，并且得到最值后立即结束程序，我们不可在DFS过程中通过值的最优性剪枝。下面探讨其它剪枝方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自排序原则：每一根新的长木棍是由许多小木棍组成的，本质上是若干个数相加，这些数之间一定有次序关系。由于我们只考虑它们的和而并不关心它们的次序，所以可以规定每一个长木棍由若干长度递减的木棍组成，从而避免很多次序不同但本质相同的组合。这里不推荐升序排列，这是因为较小的木棍有更高的机动性，升序后每一个新的长木棍末端都由较长的木棍组成，由于较长的木棍机动性差，会导致频频回溯，最终使程序性能下降。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一剪枝法则：一个待完成的长木棍在加入一根木棍后刚好完成，若在此基础上拼凑剩余长木棍不可行，则用其他木棍拼凑该待完成长木棍一定也是不可行的。结论证明:已知剩余长度为a1，a2，…，an的木棍，在加入ai后刚好拼凑了一根长木棍，之后用剩余的n-1根木棍拼凑剩下的长木棍不可行。假设加入ap1，ap2，…，aps这s根木棍(满足ap1+ap2+…+aps=ai)后拼凑好了最初的长木棍，剩下的n-s根木棍同样可以拼凑剩下的长木棍。这n-s根木棍中必有ai，此时交换ai和ap1，ap2，…，aps的位置，这显然是一种可行的方案，与已知条件矛盾，从而得证其余拼凑方案必不可行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二剪枝法则：对于一根完全没有完成的长木棍(长度为0)，向其中加入一根木棍，若在此基础上不可行，则向其中加入剩余木棍中的任何一个都不可行。该结论证明与第一剪枝法则类似，从略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合上述三点策略，容易写出完整DFS代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结:递归时尽量小起点，避免频繁回溯。另外注意自排序原则，这是很重要的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(int x, int y) &#123; return x &gt; y;&#125;int op[100], n, sum[100] = &#123;0&#125;, vis[100], length, number;void DFS(int rank, int start, int temp) &#123; if (rank == number + 1) &#123; cout &lt;&lt; length; exit(0); &#125; if (sum[start] &lt; length - temp)return; int t = 100; for (register int i = start; i &lt;= n; i++) &#123; if (vis[i])continue; if (op[i] + temp &gt; length)continue; if (t == op[i])continue; vis[i] = 1; t = op[i]; if (op[i] + temp == length) &#123; DFS(rank + 1, 1, 0); vis[i] = 0; return; &#125; else DFS(rank, i + 1, temp + op[i]); vis[i] = 0; if (!temp)return; &#125;&#125;int main() &#123; cin &gt;&gt; n; int j = 1; for (register int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[j]; if (op[j] &lt;= 50)j++; &#125; n = j - 1; sort(op + 1, op + n + 1, cmp); for (register int i = n; i &gt;= 1; i--)sum[i] = op[i] + sum[i + 1]; for (register int i = n; i &gt;= 1; i--) &#123; if (sum[1] % i != 0)continue; memset(vis, 0, sizeof(vis)); length = sum[1] / i, number = i; DFS(1, 1, 0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1080]国王游戏]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1080-%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恰逢H国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左，右手上面分别写下一个整数，国王自己也在左，右手上各写一个整数。然后，让这n位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是:排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行包含一个整数n，表示大臣的人数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含两个整数 a和b，之间用一个空格隔开，分别表示国王左手和右手上的整数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来 n行，每行包含两个整数a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 输入输出样例Sample input 31 12 37 44 6 Sample output 2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察高精度算法和数学推导，难度较大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个大臣x，y。假定x前面的大臣左手上数字之积为p(p&gt;0)，那么两者金币数分别为: p*x.r， p*x.l/y.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调换位置后，金币数分别为: p/y.r， p*y.l/x.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然有$p*x.l/y.r&gt;p/y.r$且有$p*y.l/x.r&gt;p/x.r$，倘若大臣x在前时金币最大值更小，那么必有$p*x.l/y.r \leq p*y.l/x.r$，即: x.l*x.r \leq y.l*y.r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个不等式是解决本题的关键，它给出了排序的策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知当大臣站序按照l*r升序时最大值最小，否则必有一组违反上述的不等式，这个时候两人金币最大值会变大，不利于整体最大值尽量小的条件。也就是说，按照该标准排序后，可以保证任何相邻两人的金币最大值尽可能的小，从而整体最大值尽可能小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照该不等式排序，再用高精度算法计算结果并输出即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意不要重载&lt;=，仅重载&lt;即可获得不降序的结果。重载&lt;=很容易导致RE。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int king_l, king_r;struct node &#123; int l, r; bool operator&lt;(node y) &#123; if (y.r * y.l &gt; this-&gt;l * this-&gt;r)return true; return false; &#125;&#125; op[1005];int read() &#123; int sum = 0; char e; e = getchar(); while (e &lt; '0' || e &gt; '9')e = getchar(); while (e &gt;= '0' &amp;&amp; e &lt;= '9') &#123; sum *= 10; sum += e - '0'; e = getchar(); &#125; return sum;&#125;bool check(int *p, int *q) &#123; if (p[0] &lt; q[0])return true; if (p[0] &gt; q[0])return false; for (register int i = 1; i &lt;= p[0]; i++) &#123; if (p[i] &lt; q[i])return true; if (p[i] &gt; q[i])return false; &#125; return false;&#125;void copy(int *p, int *q) &#123; p[0] = q[0]; for (register int i = 1; i &lt;= q[0]; i++)p[i] = q[i];&#125;void mutiple(int *p, int q) &#123; int r = 0, tp = 0, i; for (i = 10000; i &gt; p[0]; i--)tp = p[i], p[i] = (p[i] * q + r) % 10, r = (tp * q + r) / 10; while (r &gt; 0)p[i--] = r % 10, r /= 10; p[0] = i;&#125;void divide(int *x, int y, int *z) &#123; int tp = 0, i = x[0] + 1, j = 1; while (tp &lt; y)tp *= 10, tp += x[i++]; while (i &lt;= 10001) &#123; z[j++] = tp / y, tp %= y; tp *= 10, tp += x[i++]; &#125; z[0] = j - 1;&#125;void print(int *x) &#123; for (register int i = 1; i &lt;= x[0]; i++)cout &lt;&lt; x[i]; cout &lt;&lt; endl;&#125;int main() &#123; int num[10001] = &#123;0&#125;, temp[10000], ans[10000] = &#123;0&#125;; num[0] = 9999; num[10000] = 1; n = read(); king_l = read(), king_r = read(); for (register int i = 1; i &lt;= n; i++)op[i].l = read(), op[i].r = read(); sort(op + 1, op + n + 1); mutiple(num, king_l); for (register int i = 1; i &lt;= n; i++) &#123; divide(num, op[i].r, temp); if (check(ans, temp))copy(ans, temp); mutiple(num, op[i].l); &#125; print(ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>贪心</tag>
        <tag>高精度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1074]靶型数独]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1074-%E9%9D%B6%E5%9E%8B%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;靶形数独的方格同普通数独一样，在9格宽×9格高的大九宫格中有9个3格宽×3格高的小九宫格(用粗黑色线隔开的)。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 1 到 9的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行，每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图具体的分值分布是:最里面一格(黄色区域)为 10 分，黄色区域外面的一圈(红色区域)每个格子为9分，再外面一圈(蓝色区域)每个格子为8 分，蓝色区域外面一圈(棕色区域)每个格子为7分，最外面一圈(白色区域)每个格子为6分，如上图所示。比赛的要求是:每个人必须完成一个给定的数独(每个给定数独可能有不同的填法)，而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一共 9 行。每行9个整数(每个数都在0-9的范围内)，表示一个尚未填满的数独方格，未填的空格用“0”表示。每两个数字之间用一个空格隔开。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共 1 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1。 输入输出样例Sample input#1 7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2 Sample output#1 2829 Sample input#2 0 0 0 7 0 2 4 5 39 0 0 0 0 8 0 0 07 4 0 0 0 5 0 1 01 9 5 0 8 0 0 0 00 7 0 0 0 0 0 2 50 3 0 5 7 9 1 0 80 0 0 6 0 1 0 0 00 6 0 9 0 0 0 0 10 0 0 0 0 0 0 0 6 Sample output#2 2852 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察深度优先搜索(DFS)，有一定难度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个基本思路是，从首行首列开始进行DFS，将未填数的格子填上数。在填数过程中要注意符合数独的规则，也就是说要开数组记录当前行当前列和当前九宫格已有数字的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照这种方法，在填完末行末列的格子时，整个数独已经填好且符合规则。此时计算数独的分数，记录分数最大值。这里可以开一个常量数组记录每个格子的分数以简化运算。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个值得注意的是，倘若首行待填格很多，则可能会导致DFS频繁向底层回溯，加大函数调用次数，很容易导致TLE。一种解决方法是从待填格最少的行开始DFS，将待填格最多的行后置，这样DFS向底层回溯的次数会减小，高层回溯次数增加，能够提高效率。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#define ID(x, y) x/3*3+y/3+1using namespace std;const int Point[9][9] = &#123;&#123;6, 6, 6, 6, 6, 6, 6, 6, 6&#125;, &#123;6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 10, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;6, 6, 6, 6, 6, 6, 6, 6, 6&#125;&#125;;int row[9][10] = &#123;0&#125;, colum[9][10] = &#123;0&#125;, form[10][10] = &#123;0&#125;;int op[9][9], rank2[10];int temp[9];int ans = -1;void calculate() &#123; int sum = 0; for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++)sum += op[i][j] * Point[i][j]; ans = max(ans, sum);&#125;void DFS(int x, int y, int r) &#123; if (y == 9) &#123; if (r &lt; 8) DFS(rank2[r + 1], 0, r + 1); else calculate(); return; &#125; if (op[x][y]) &#123; DFS(x, y + 1, r); return; &#125; for (int i = 1; i &lt;= 9; i++) &#123; if (row[x][i] || colum[y][i] || form[ID(x, y)][i])continue; row[x][i] = colum[y][i] = form[ID(x, y)][i] = 1; op[x][y] = i; DFS(x, y + 1, r); op[x][y] = 0; row[x][i] = colum[y][i] = form[ID(x, y)][i] = 0; &#125;&#125;int main() &#123; for (int i = 0; i &lt; 9; i++) &#123; temp[i] = i * 10 + 9; for (int j = 0; j &lt; 9; j++) &#123; cin &gt;&gt; op[i][j]; if (op[i][j]) row[i][op[i][j]] = colum[j][op[i][j]] = form[ID(i, j)][op[i][j]] = 1, temp[i]--; &#125; &#125; for (int i = 8; i &gt;= 0; i--) for (int j = 0; j &lt; i; j++) if (temp[j] % 10 &gt; temp[j + 1] % 10)swap(temp[j], temp[j + 1]); for (int i = 0; i &lt; 9; i++)rank2[i] = temp[i] / 10; DFS(rank2[0], 0, 0); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次介绍线段树，线段树是一种可以维护区间和，区间最值的高效数据结构。线段树本质上是一棵平衡二叉树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先探讨线段树的构造。由于线段树基于平衡二叉树，且仅有叶子节点储存实际的序列信息，故线段树的空间消耗是比较大的，实际空间消耗大约为给定序列的两倍。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以维护区间和的线段树为例。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造线段树时，假定f(l，r)为将[l，r]的序列构造为线段树，f(l，r)可以拆分成f(l，mid)和f(mid+1，r)，其中mid=(l+r)/2。按照二叉树的节点规律向下构造，并给相应的节点赋值即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:123456789void make(int x, int y, int k) &#123; if (x == y) &#123; tree[k] = op[x]; return; &#125; int mid = (x + y) / 2; make(x, mid, 2 * k), make(mid + 1, y, 2 * k + 1); tree[k] = tree[2 * k] + tree[2 * k + 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求特定区间[l，r]的区间和则通过拆分区间，从线段树中读出分区和，再相加即可。通过这种操作可以将线段树的时间复杂度降至O(logn)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何进行区间拆分。实际上区间拆分可分为四种情况:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 给定区间和线段树划分区间恰好相同。直接返回该区间的值即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 给定区间在划分区间的右半部分。将右半部分作为新的划分区间再进行拆分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 给定区间在划分区间的左半部分。将左半部分作为新的划分区间再进行拆分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 给定区间部分在左区间，部分在右区间。分别将左半部分和右半部分作为新的划分区间，再分别在两个划分区间中拆分各自的给定区间部分，返回两者结果的和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:1234567int find(int x, int y, int l, int r, int k) &#123; if (x == l &amp;&amp; y == r)return tree[k]; int mid = (x + y) / 2; if (l &gt;= mid + 1)return find(mid + 1, y, l, r, 2 * k + 1); if (r &lt;= mid)return find(x, mid, l, r, 2 * k); return find(x, mid, l, mid, 2 * k) + find(mid + 1, y, mid + 1, r, 2 * k + 1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，通过这两个函数已经可以处理一个不再修改的线段树。但是在实际操作中，有时我们不仅需要频繁求出区间和，还要不断地修改数据。下面介绍线段树的值修改方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种显而易见的思路是直接修改数据再重新构造线段树，或者直接在线段树中查找到相关的节点，修改这些节点的值。显然后者要优于前者，但是倘若我们修改的区间之后不再参与查找区间和的操作，那么时间就会白白浪费。所以，我们需要一种方法，在求区间和时才对相关节点进行实际的值修改操作，否则只作个标记即可。这种方法可以大大提升效率。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现值修改的标记，我们需要引入懒标记(Lazy)的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给每一个节点添加变量Lazy并初始化为0，它的意义是标明这个节点的所有子节点都要在原有的基础上加上Lazy。值得注意的是，该节点本身不在标记的范围内，并且Lazy标记仅是一个标记，子节点的值实际上并没有改变。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们需要将区间[l，r]全体加上x时，需要进行如下操作:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 将每一个拆分区间(假定为[a，b])的值加上(b-a+1)*x。((b-a+1)是该拆分区间的数据量)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 用与查找区间和相同的方法拆分区间[l，r]，给每一个拆分的区间的Lazy加上x。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 更新拆分区间节点的祖先节点和父节点的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:123456789101112void add(int x, int y, int l, int r, int c, int k) &#123; if (x == l &amp;&amp; y == r) &#123; tree[k] += (r - l + 1) * c; lazy[k] += c; return; &#125; int mid = (x + y) / 2; if (l &gt;= mid + 1)add(mid + 1, y, l, r, c, 2 * k + 1); else if (r &lt;= mid)add(x, mid, l, r, c, 2 * k); else add(x, mid, l, mid, c, 2 * k), add(mid + 1, y, mid + 1, r, c, 2 * k + 1); tree[k] = tree[2 * k] + tree[2 * k + 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何使用这个标记?这里需要用到down()函数来完成Lazy下压实现操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了构造线段树，当任何时候需要使用一个节点时，需要先检查该节点的Lazy是否为0。若为0，不必调用down();否则应调用down()来下压标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;down()的具体实现如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 两个子节点的值自加上它们数据量与该节点Lazy的乘积，更新自身数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 两个子节点的Lazy自加该节点的Lazy，来继承父节点的标记。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 该节点Lazy清空为0，表示下压完成。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，叶子节点由于没有子节点，它的Lazy是没有意义的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码:1234567void down(int l, int r, int k) &#123; if (l == r)return; int mid = (l + r) / 2; tree[2 * k] += (mid - l + 1) * lazy[k], tree[2 * k + 1] += (r - mid) * lazy[k]; lazy[2 * k] += lazy[k], lazy[2 * k + 1] += lazy[k]; lazy[k] = 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护区间最值类比即可。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1282]多米诺骨牌]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1282-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%2F</url>
    <content type="text"><![CDATA[难度：提高+/省选- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多米诺骨牌有上下2个方块组成，每个方块中有1~6个点。现有排成行的若干多米诺骨牌。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上方块中点数之和记为S1，下方块中点数之和记为S2，它们的差为|S1-S2|。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如在图中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转180°，使得上下两个方块互换位置。 编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件的第一行是一个正整数n(1≤n≤1000)，表示多米诺骨牌数。接下来的n行表示n个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数a和b，且1≤a，b≤6。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出文件仅一行，包含一个整数。表示求得的最小旋转次数。 输入输出样例Sample input 46 11 51 31 2 Sample output 1 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考察线型动态规划，难度较大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规定value[i]表示第i个骨牌上下两行的差值，f(x，y)表示第1~x骨牌上下差值为y时的最小交换次数，则有状态转移方程: f(x，y)=\min\{f(x-1，y-value[x])，f(x-1，y+value[x])+1\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可用数组来保存结果，由于y可能为负，要构造一个映射将其与一个正整数相联系并作为数组下标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期初将数组初始化为INF(无穷大)，表示不能翻转到此值。再将f(1，value[1])置为0，f(1，-value[1])置为1即可。最后在f(n，y)中寻找y绝对值最小又使f(n，y) &lt; INF的f(n，y)作为结果。1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#define ID(x) 6000+xusing namespace std;int n;int value[1001];int res[1001][12000];const int INF = 1e9;int main() &#123; cin &gt;&gt; n; int x, y; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; value[i] = x - y; &#125; for (register int i = 1; i &lt;= 1000; i++) for (register int j = 0; j &lt; 12000; j++)res[i][j] = INF; res[1][ID(value[1])] = 0, res[1][ID(-value[1])] = 1; for (register int i = 2; i &lt;= n; i++) &#123; for (register int j = 0; j &lt;= 5 * i; j++) &#123; res[i][ID(j)] = min(res[i - 1][ID(j - value[i])], res[i - 1][ID(j + value[i])] + 1); res[i][ID(-j)] = min(res[i - 1][ID(-j - value[i])], res[i - 1][ID(value[i] - j)] + 1); &#125; &#125; for (register int i = 0; i &lt;= 5 * n; i++) &#123; if (res[n][ID(i)] &lt; INF || res[n][ID(-i)] &lt; INF) &#123; cout &lt;&lt; min(res[n][ID(i)], res[n][ID(-i)]); return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1417]烹调方案]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1417-%E7%83%B9%E8%B0%83%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目背景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于你的帮助，火星只遭受了最小的损失。但gw懒得重建家园了，就造了一艘飞船飞向遥远的earth星。不过飞船飞到一半，gw发现了一个很严重的问题:肚子饿了~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw希望能在T时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的gw只好求助于你了。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一共有n件食材，每件食材有三个属性，ai，bi和ci，如果在t时刻完成第i样食材则得到ai-t*bi的美味指数，用第i件食材做饭要花去ci的时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，gw的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行是两个正整数T和n，表示到达地球所需时间和食材个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，ai&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，bi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面一行n个整数，ci 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出最大美味指数 数据范围&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于40%的数据1≤n≤10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于100%的数据1≤n≤50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有数字均小于100，000 输入输出样例Sample input 74 1502247 Sample output 408 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划，也属于基本的01背包问题，但本题相比背包问题更能体现出问题的本质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在经典的01背包问题即第二题采药中，物品的顺序是不影响最终结果的。这个结论显然，因为物品无论先加入还是后加入，它们占据背包的空间不变，价值也不变，对其它物品也不会造成实质上的影响。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但本题不同，本题中物品的价值随着时间的增长而减小，所以对于两个物品，将哪一个放到前面会直接影响结果。也就是说只有把B放于A前或反之时才有最优解。我们在DP时必须遵从这个会出现最优解的顺序来加入物品，即要先对物品进行排序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，排序的标准是什么?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑两个物品，假定在时刻p开始加入背包，则将第一个物品先放入随机放入第二个时的价值为: v_1=a_1-(p+c_1-1)b_1+a_2-(p+c_1+c_2-1)b_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反之时总价值为: v_2=a_2-(p+c_2-1)b_2+a_1-(p+c_2+c_1-1)b_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令$v_1&lt;v_2$，进行运算，得到: c_2b_1]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1008]石子合并]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1008-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个圆形操场的四周摆放N堆石子，现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试设计出1个算法，计算出将N堆石子合并成1堆的最小得分和最大得分。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据的第1行为正整数N，1≤N≤100，表示有N堆石子。第2行有N个数，分别表示每堆石子的个数。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出共2行，第1行为最小得分，第2行为最大得分。 输入输出样例Sample input 44 5 9 4 Sample output 4354 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察线性动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与贪心算法不同的是，本题要求只能合并相邻的两堆石子，环形排布又加大了题目难度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种思路是将已知的序列首尾相接，从中截取长度为n的子序列，来模拟环形。这是因为在环形结构中，若只合并相邻的两个数，最后必有两个数待合并，从这两个数中间剪环为链，容易知这两者是等价的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是期初我们并不知从何处剪环，故要将所有情况都考虑到，从每个剪环策略中选取最值即可。在这个思路中，从何处截取序列便是剪环的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定在一个剪环策略下，令左元素为l，右元素为r。设从x到y的序列合并得分最值为f(x，y)，那么可列出状态转移方程(设value(l，r)表示l到r的石子总和): f(x，y)=\min/\max\{f(l，k)+f(k+1，r)\}+value(l，r),l \leq k]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一次谈谈树状数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先考虑一个问题，对于一个给定的数组，如何快速地求出其前缀和?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最通俗的做法是循环求出前n项和，时间复杂度O(n)。如果数组相当大又多次修改其中数据，求和过程时间消耗巨大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了快速求和，可以用树状数组来完成这一操作。树状数组可以维护并快速求出数组前缀和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要理解树状数组原理，先介绍lowbit的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任何一个数，设lowbit(x)表示这个数能够整除的最大的2的方幂。容易知道，将x写成二进制后，lowbit(x)表示从右向左第一个1所对应的二进制数。例如，对于二进制数x: x=1101101100，lowbit(x)=100;x=1011000，lowbit(x)=1000;x=1010000，lowbit(x)=10000.…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowbit有一个重要性质:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定数x，则对于满足条件x-lowbit(x)&lt;y&lt;x的数均可以在有限次地进行运算y = y + lowbit(y)后，使得y=x。并且其余的y一定不能在有限次的上述运算后得到x。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如给定x=101100，则对于y=101001，进行一次运算，得到101010，再进行一次得到101100。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证明从略。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对于一个数组tree[i]，tree[i]储存所有满足i-lowbit(i)&lt;x&lt;=i的x的和。这个和是易求的。对于一个符合条件的x，由上面的定理，给x作若干次运算。对于每一次合法的运算结果y，都进行tree[y]+=value[x]，这些y中一定有i，从而将所有符合条件的x都计入了tree[i]。由定理又知，其余不符合条件的x一定不会计入tree[i]。记得将tree[i]+=value[i]，就得到完整的求和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对1~n的所有数，都进行上述操作，就可以得到tree数组，这就是树状数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面研究如何用tree数组求前缀和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如求前10110010前缀和([x，y]表示第x到第y元素的和): tree[10000000]储存[1，10000000]的数的和，tree[10100000]储存[10000001，10100000]的和，tree[10110000]储存[10100001，10110000]的和，tree[10110010]储存[10110001，10110010]的和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，10110010前缀和就是树状数组中这4项的和。并且这4项的下标都是重复进行运算y = y - lowbit(y)得到的，直到y=0。这样，计算10110010前缀和只需进行4次加法，比进行传统的10110010(=178)次运算相比，效率大大提升。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为何叫作树状数组?下图给出解释。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粗体表示树状数组中的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易知lowbit(x)=x&amp;-x，这样就有了树状数组的完整编写思路：123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int NUM = 1000000;int op[NUM + 1], tree[NUM + 1] = &#123;0&#125;, n;void add(int x, int y) &#123; for (; x &lt;= n; x += (x &amp; -x))tree[x] += y;&#125;int sum(int x) &#123; int res = 0; for (; x &gt;= 1; x -= (x &amp; -x))res += tree[x]; return res;&#125;int main() &#123; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op[i]; add(i, op[i]); &#125; int x; cin &gt;&gt; x; cout &lt;&lt; sum(x) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1090]合并果子]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1090-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 ， 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力=3+12=15。可以证明 15为最小的体力耗费值。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共两行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行是一个整数 n(1≤n≤10000) ，表示果子的种类数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行包含 n个整数，用空格分隔，第 i 个整数 ai(1≤ai≤20000) 是第 i 种果子的数目。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 231 。 输入输出样例Sample input 31 2 9 Sample output15 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察贪心算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次只需选取序列中最小的两个数相加，将和计入答案中，再将和加入序列。当序列为空时结束算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于序列要频繁地选取最小数并有数据的写入，推荐使用数据结构小根堆积树来完成操作。使用STL中的优先队列(priority_queue)也是可以的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;class heap &#123;private: int tree[10005]; int size;public: heap(int *p, int n) &#123; for (register int i = 1; i &lt;= n; i++)tree[i] = p[i]; size = n; for (register int i = size / 2; i &gt;= 1; i--)solve(i); &#125; void solve(int x) &#123; int l1 = 2 * x, l2 = 2 * x + 1, l = x; if (l1 &lt;= size &amp;&amp; tree[l1] &lt; tree[l])l = l1; if (l2 &lt;= size &amp;&amp; tree[l2] &lt; tree[l])l = l2; if (l != x) &#123; swap(tree[x], tree[l]); solve(l); &#125; &#125; int top() &#123; int temp = tree[1]; tree[1] = tree[size--]; solve(1); return temp; &#125; void up(int x) &#123; if (x == 1)return; if (tree[x] &lt; tree[x / 2])swap(tree[x], tree[x / 2]), up(x / 2); &#125; void add(int x) &#123; tree[++size] = x; up(size); &#125; bool empty() &#123; if (size == 0)return true; return false; &#125;&#125;;int main() &#123; int ans = 0; int op[10005]; int n; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; heap h(op, n); while (1) &#123; int x = h.top(), y = h.top(); ans += x + y; if (h.empty())break; h.add(x + y); &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆积树]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%A0%86%E7%A7%AF%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一串数，在有频繁的加入删除操作时，如何维护它们的最大值和最小值?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的O(n)做法即为遍历整个数组，找到最值。这种方法简单但效率低下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆积树是一种基于完全二叉树的数据结构，可以在O(logn)的时间复杂度下维护序列最值。堆积树的特点是:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 是一棵完全二叉树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 每一个节点的值都大于(或小于)其儿子节点的值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点值大于儿子节点的为大根堆，小于即为小根堆。显然，在根节点处可以取到最值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面谈论堆的构造与维护算法(以小根堆为例)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先讲堆的节点交换算法，它的作用是在两棵子树已经为堆的基础上将这棵树转化为堆积树。 节点的交换算法是堆的基本算法。算法的步骤是先找到根节点与两个儿子节点的最小值，将根节点与最小值所在节点交换。此时根节点所在的局部具有小根堆性质。倘若一开始根节点就最小，依照算法的前提(两棵子树已为堆)，此时堆积树构造完毕，算法结束。但是倘若根节点起初不是最小值，交换后参与交换的子树由于根节点值变大，小根堆性质可能局部被破坏，但是由于该子树的两棵子树仍为堆，符合算法前提，再对该子树进行同样的递归操作，直到树的叶子节点。此时整棵树已经成为小根堆。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法的示例代码如下:12345678910void solve(int x) &#123; if (x &gt; n)return; int l1 = 2 * x, l2 = 2 * x + 1, l = x; if (l1 &lt;= n &amp;&amp; heap[l1] &lt; heap[l])l = l1; if (l2 &lt;= n &amp;&amp; heap[l2] &lt; heap[l])l = l2; if (l != x) &#123; swap(heap[l], heap[x]); solve(l); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆的构造过程即为从堆的最后一个非叶子节点开始，直至根节点，顺次执行堆的节点交换算法。由完全二叉树的性质易得这个非叶子节点编号为n/2(n为节点数量)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例代码如下:123void build() &#123; for (register int i = n / 2; i &gt;= 1; i--)solve(i);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点交换算法定义上不难理解这个方法的可行性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何找到最小值并将其删除?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上文讨论，heap[1]即为最小值。删除该元素只需将堆中最后一个元素覆盖到根节点处并令节点数减一，再在根节点处调用节点交换函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下:123456int top() &#123; int t = heap[1]; heap[1] = heap[n--]; solve(1); return t;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向堆中添加一个元素只需在堆的末尾加上该元素，该重新构造一遍堆即可。这个方法可行，但不最优。这里介绍一种更高效的算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于此时除了该元素之外，其余均维持小根堆性质。所以我们只需将该元素“上浮”，即将该元素与其父节点比较，若其比父节点值小，交换两个节点，从父节点开始继续上浮，直到父节点不比其大或者到达根节点时为止。1234void up(int x) &#123; if (x == 1)return; if (tree[x] &lt; tree[x / 2])swap(tree[x], tree[x / 2]), up(x / 2);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大根堆类比即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于堆可以维护最值，可以将其与选择排序算法结合，形成一种时间复杂度为O(nlogn)的新算法，称为堆排序算法。堆排序是不稳定的排序算法。算法思想是先将数据构造成堆，从中不断选出最值，再将其从堆中删除，重复该过程直到堆为空，此时即可获得有序的序列。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1040]加分二叉树]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1040-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[难度：普及+/提高 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设一个n个节点的二叉树tree的中序遍历为(1，2，3，… ，n)，其中数字1，2，3，… ，n为节点编号。每个节点都有一个分数(均为正整数)，记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree(也包含tree本身)的加分计算方法如下:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtree的左子树的加分 × subtree的右子树的加分＋subtree的根的分数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试求一棵符合中序遍历为(1，2，3，… ，n)且加分最高的二叉树tree。要求输出;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)tree的最高加分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)tree的前序遍历 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行:1个整数n(n&lt;30)，为节点个数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行:n个用空格隔开的整数，为每个节点的分数(分数&lt;100)。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1行:1个整数，为最高加分(Ans≤4，000，000，000)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2行:n个用空格隔开的整数，为该树的前序遍历。 输入输出样例Sample input 55 7 1 2 10 Sample output 1453 1 2 4 5 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察树型动态规划和二叉树遍历。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x，y)表示中序遍历为x，x+1，…，y-1，y的子树的最高加分，则有: f(x，y)=\begin{cases}\max\{f(x，k-1)*f(k+1，y)+value[k]\}(x≤k≤y) & xy \end{cases}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递推即得结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二问可以设置一个数组tree[x][y]表示x~y的子树的根节点，递归遍历可得前序遍历序列。123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int op[50], n;int rem[50][50] = &#123;0&#125;;int tree[50][50] = &#123;0&#125;;int DP(int x, int y) &#123; if (x &gt; y)return 1; if (x == y)return op[x]; if (rem[x][y] != 0)return rem[x][y]; int ans = 0; for (register int i = x; i &lt;= y; i++) if (DP(x, i - 1) * DP(i + 1, y) + op[i] &gt; ans) ans = DP(x, i - 1) * DP(i + 1, y) + op[i], tree[x][y] = i; return rem[x][y] = ans;&#125;void print(int x, int y) &#123; if (x &gt; y)return; if (x == y) &#123; cout &lt;&lt; x &lt;&lt; '\x20'; return; &#125; cout &lt;&lt; tree[x][y] &lt;&lt; '\x20'; print(x, tree[x][y] - 1); print(tree[x][y] + 1, y);&#125;int main() &#123; cin &gt;&gt; n; for (register int i = 1; i &lt;= n; i++)cin &gt;&gt; op[i]; cout &lt;&lt; DP(1, n) &lt;&lt; endl; print(1, n); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1126]机器人搬重物]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1126-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AC%E9%87%8D%E7%89%A9%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;机器人移动学会(RMI)现在正尝试用机器人搬运物品。机器人的形状是一个直径$1。6米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个N×M的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有:向前移动1步(Creep);向前移动2步(Walk);向前移动3步(Run);向左转(Left);向右转(Right)。每个指令所需要的时间为1秒。请你计算一下机器人完成任务所需的最少时间。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行为两个正整数N，M(N，M≤50)，下面N行是储藏室的构造，0表示无障碍，1表示有障碍，数字之间用一个空格隔开。接着一行有4个整数和1个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向(东E，南S，西W，北N)，数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出-1。 输入输出样例Sample input 9 100 0 0 0 0 0 1 0 0 00 0 0 0 0 0 0 0 1 00 0 0 1 0 0 0 0 0 00 0 1 0 0 0 0 0 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 0 00 0 0 1 1 0 0 0 0 00 0 0 0 0 0 0 0 0 01 0 0 0 0 0 0 0 1 07 2 2 7 S Sample output12 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题考察广度优先搜索(BFS)，比较常规。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用二维数组储存输入的01序列，用一个结构体储存当前点信息，开队列储存节点，还要记得保存当前已入队的节点信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于如何判定机器人是否可以前移以及边界处理问题。还有一个值得注意的是输入数据不一定合法，比如机器人初始坐标四周已有障碍物，此时直接输出-1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题有一个小技巧是将方向代数表示，这时机器人的转向可以转化为代数运算。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct node &#123; int time; int x, y; int turn;&#125;;int n, m;int op[55][55];int vis[55][55][4] = &#123;0&#125;;int a_x, a_y, b_x, b_y;queue&lt;node&gt; que;int check(int &amp;x, int &amp;y, int z) &#123; switch (z) &#123; case 0: if (x &lt;= 1 || op[x - 1][y] || op[x - 1][y + 1])return 0; else &#123; x--; return 1; &#125; break; case 1: if (y &gt;= m - 1 || op[x][y + 2] || op[x + 1][y + 2])return 0; else &#123; y++; return 1; &#125; break; case 2: if (x &gt;= n - 1 || op[x + 2][y] || op[x + 2][y + 1])return 0; else &#123; x++; return 1; &#125; break; case 3: if (y &lt;= 1 || op[x][y - 1] || op[x + 1][y - 1])return 0; else &#123; y--; return 1; &#125; break; &#125;&#125;int BFS() &#123; while (!que.empty()) &#123; node p = que.front(); if (p.x == a_x &amp;&amp; p.y == a_y)return p.time; que.pop(); p.time++; int t = p.turn; if (!vis[p.x][p.y][(p.turn + 1) % 4]) &#123; vis[p.x][p.y][(p.turn + 1) % 4] = 1; p.turn = (p.turn + 1) % 4; que.push(p); &#125; p.turn = t; if (!vis[p.x][p.y][(p.turn + 3) % 4]) &#123; vis[p.x][p.y][(p.turn + 3) % 4] = 1; p.turn = (p.turn + 3) % 4; que.push(p); &#125; p.turn = t; for (register int i = 1; i &lt;= 3; i++) &#123; if (!check(p.x, p.y, p.turn))break; if (vis[p.x][p.y][p.turn])continue; vis[p.x][p.y][p.turn] = 1; que.push(p); &#125; &#125; return -1;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) for (register int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; cin &gt;&gt; b_x &gt;&gt; b_y &gt;&gt; a_x &gt;&gt; a_y; node temp; temp.time = 0, temp.x = b_x, temp.y = b_y; char e; cin &gt;&gt; e; switch (e) &#123; case 'S': temp.turn = 2; break; case 'N': temp.turn = 0; break; case 'E': temp.turn = 1; break; case 'W': temp.turn = 3; &#125; if (op[b_x][b_y] || op[b_x + 1][b_y + 1] || op[b_x + 1][b_y] || op[b_x][b_y + 1]) &#123; cout &lt;&lt; "-1"; return 0; &#125; vis[b_x][b_y][temp.turn] = 1; que.push(temp); cout &lt;&lt; BFS(); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1316]丢瓶盖]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1316-%E4%B8%A2%E7%93%B6%E7%9B%96%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;陶陶是个贪玩的孩子，他在地上丢了A个瓶盖，为了简化问题，我们可以当作这A个瓶盖丢在一条直线上，现在他想从这些瓶盖里找出B个，使得距离最近的2个距离最大，他想知道，最大可以到多少呢？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行，两个整数，A，B。(B≤A≤100000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二行，A个整数，分别为这A个瓶盖坐标。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅一个整数，为所求答案。 输入输出样例Sample input 5 31 2 3 4 5 Sample output2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题是一道典型的二分答案题目。考察二分和贪心思想。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分答案是一种寻求答案的方法，其原理利用了答案的单调性。在给定的答案域中，判断中点答案的可行性，根据其可行性再在答案域的左半区间或右半区间寻求答案，直到找到最终答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解释地更加清晰，下面说明几个概念。 答案域：答案可能的取值区间。在本题中答案域的左值为当前最小距离，最大值为最末与最初瓶盖坐标的差值。 可行：当存在一种方案使得在取出不小于B个瓶盖时，可以使任意两个相邻瓶盖间距都大于或等于x，则称x是可行的。也就是说，存在一种符合题目要求的选取策略，使得瓶盖间距最小值大于或等于x。同样，当不存在任何一种方案使得上述条件成立，则称x不可行。 答案单调性：当一个x可行时，由于我们要求最大值，故正确答案一定大于或等于x;类似地，当x不可行时，易知所有大于x的值都不可行，正确答案一定小于x。这就是答案的单调性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据以上说明，我们用二分查找方法，判定中点值的可行性，从而缩小区间，确定答案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定一个值可行性的方法可用贪心策略，详见代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，本题中并未说明输入数据有序，必须先对输入的数据进行排序，再二分答案。12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int op[100005], a, b;int check(int x) &#123; int p = op[1], q = a - b; for (register int i = 2; i &lt;= a; i++) &#123; if (op[i] - p &lt; x) &#123; if (!q)return 0; q--; &#125; else p = op[i]; &#125; return 1;&#125;int find(int l, int r)//[,)&#123; if (r == l + 1)return l; int mid = (l + r) / 2; if (check(mid))return find(mid, r); else return find(l, mid);&#125;int main() &#123; cin &gt;&gt; a &gt;&gt; b; int minn = 1e8; for (register int i = 1; i &lt;= a; i++)cin &gt;&gt; op[i]; sort(op + 1, op + a + 1); for (register int i = 2; i &lt;= a; i++)minn = min(minn, op[i] - op[i - 1]); cout &lt;&lt; find(minn, op[a] - op[1]); return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>二分查找</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F01%2F09%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍二分查找的相关内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个已经排好序的数组，如何快速从中找出值为x的元素的位置?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个通俗的做法是从第一个数开始遍历数组，直到找到x。时间复杂度O(n)。这种方法在数据量很大又频繁查找时效率低下。为了充分利用数据的有序性，我们可以使用二分查找算法在O(logn)复杂度下快速找到特定值的元素位置。二分查找是用来在已排序序列中找到特定值元素位置的高效算法，它的原理是一个基本事实: 在升序序列中[l，r]中，若mid=(l+r)/2且value[mid]&lt;x，那么x对应的元素必位于(mid，r]中，否则必位于[l，mid]中。降序排列类似。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个升序排序，我们不难写出代码:123456int binary_find(int l, int r, int x) &#123; if (l == r)return l; int mid = (l + r) / 2; if (value[mid] &lt; x)return binary_find(mid + 1, r, x); else return binary_find(l, mid, x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，假定我们在[2，3]中寻找元素x，value[2] &lt; x，value[3]=x，运行这段代码，会发现函数无限递归导致段错误。这是因为(2+3)/2=2，函数不断地在[2，3]中查找，无法跳出这个循环。这也是这种二分查找算法的重要缺陷。那么如何优化?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当函数传入参数l，r时，我们规定函数只能在(l，r]中查找，那么代码就变成:1234567int binary_find(int l, int r, int x)//(,]&#123; if (r == l + 1)return r; int mid = (l + r) / 2; if (value[mid] &lt; x)return binary_find(mid, r, x); else return binary_find(l, mid, x);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时调用函数binary_find(-1，n-1，x)即可(n为数据量)。这种半开半闭式二分查找思想可以完美解决上面的问题。]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1020]导弹拦截]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入导弹依次飞来的高度(雷达给出的高度数据是≤50000的正整数)，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1行，若干个整数(个数≤100000) 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例Sample input 389 207 155 300 299 170 158 65 Sample output 62 题解未强化版本:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的求最长上升(下降…)子序列问题，属于线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问即求序列中最长不上升子序列的长度，第二问即求序列中最少的最长不上升子序列数量。由Dilworth定理，该问即为求序列的最长上升子序列长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x)为以第x个数为序列起点，可得到的最长序列长度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则对于第一问，状态转移方程为: f(x)=\max\{f(i)\}+1，x]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1606]疯狂的采药]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1606-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说:“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你是LiYuxiang，你能完成这个任务吗？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此题和原题的不同点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1。每种草药可以无限制地疯狂采摘。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2。药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入第一行有两个整数T(1 ≤ T ≤ 100000)和M(1 ≤ M ≤ 10000)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到10000之间(包括1和10000)的整数，分别表示采摘某种草药的时间和这种草药的价值。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 输入输出样例Sample input 70 371 10069 11 2 Sample output140 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无限背包问题，属于经典的线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与01背包不同的是，无限背包允许每个物品无穷次加入背包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x，y)表示在容量剩余y时，将x~m物品加入背包的最大价值。则可列出状态转移方程: f(x，y)=\begin{cases} \max\{f(x，y-time[x])+value[x]，f(x+1，y)\}\ \ & y \geq time[x]\\ f(x+1，y) & y]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1048]采药]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1048-%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[难度：普及- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说:“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”如果你是辰辰，你能完成这个任务吗？ 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行有2个整数T(1≤T≤1000)M(1≤M≤100)，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间(包括1和100)的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1个整数，表示在规定的时间内可以采到的草药的最大总价值。 输入输出样例Sample input 70 371 10069 11 2 Sample output3 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典01背包问题，考察线型动态规划。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设f(x,y)表示在x时间内对于物品y~m的最大价值。显然,物品顺序对结果无影响，容易列出状态转移方程: f(x,y)=\max\{f(x,y+1),f(x-time[x],y+1)+value[x]\}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当xm时，f(x,y)均为0。12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int time2[1005], value[105];int dp[1005][105] = &#123;0&#125;;int main() &#123; int t, m; cin &gt;&gt; t &gt;&gt; m; for (register int i = 1; i &lt;= m; i++)cin &gt;&gt; time2[i] &gt;&gt; value[i]; for (register int i = m; i &gt;= 1; i--) &#123; for (register int j = 1; j &lt;= t; j++) &#123; if (j &lt; time2[i])dp[j][i] = dp[j][i + 1]; else dp[j][i] = max(dp[j][i + 1], dp[j - time2[i]][i + 1] + value[i]); &#125; &#125; cout &lt;&lt; dp[t][1]; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1387]最大正方形]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B4%9B%E8%B0%B7P1387-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[难度：普及/提高- 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个n*m的只包含0和1的矩阵里找出一个不包含0的最大正方形，输出边长。 输入输出格式输入格式:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件第一行为两个整数n，m(1≤n,m≤100)，接下来n行，每行m个数字，用空格隔开，0或1。 输出格式:一个整数,最大正方形的边长。 输入输出样例:Sample input 4 40 1 1 11 1 1 00 1 1 01 1 0 1 Sample output2 题解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目考察二维动态规划及递推。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若设f(x,y)示以此点为左上点正方形的最大边长。则易得: f(x,y)=\min\{f(x+1,y),f(x,y+1), f(x+1,y+1)\}+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意若点(x,y)为0或者超出边界，则f(x,y)=0，从f(x,y)中找出最大值即可。1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int op[105][105], n, m;int ans[105][105] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (register int i = 1; i &lt;= n; i++) for (register int j = 1; j &lt;= m; j++)cin &gt;&gt; op[i][j]; int res = 0; for (register int i = n; i &gt;= 1; i--) for (register int j = m; j &gt;= 1; j--) &#123; if (op[i][j] == 0)continue; ans[i][j] = min(ans[i + 1][j], min(ans[i][j + 1], ans[i + 1][j + 1])) + 1; res = max(res, ans[i][j]); &#125; cout &lt;&lt; res; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬线法]]></title>
    <url>%2F2019%2F01%2F08%2F%E6%82%AC%E7%BA%BF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个矩阵中找到满足某种性质的最大子矩阵问题是一个很常见的问题，悬线法是求解此类问题的高效算法。现在我们来看这样一题(洛谷 P1169)来认识悬线法。 题目描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 8×8 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小 Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小 W 决定将棋盘扩大以适应他们的新规则。小 Q 找到了一张由 N×M$(N,M \leq 2000)$个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小 Q 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。不过小 Q 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘(当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色)，所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。于是小 Q 找到了即将参加全国信息学竞赛的你，你能帮助他么? 输入输出格式输入格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含两个整数 N 和 M ，分别表示矩形纸片的长和宽。接下来的 N 行包含一个 N × M 的 01 矩阵，表示这张矩形纸片的颜色( 0 表示白色， 1 表示黑色)。 输出格式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积(注意正方形和矩形是可以相交或者包含的)。可以看出，本题实质上在求一个矩阵中满足 01 相间排列性质的最大方阵和最大矩阵的面积，可以用悬线法高效解决。 悬线法思想：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 up(x，y)表示点(x，y)所在的满足性质(本题就是点的值互异)的“最大”矩形的高度 ，left(x，y) 表 示 点 (x，y) 所 在 的 满 足 性 质 的 同 一 个 “ 最 大 ” 矩 形 向 左 延 伸 的 距离，right(x，y)是向右的距离。那么横向延伸距离为 a=right+left-1，纵向即为 b=up，方阵面积为 min(a，b)2 ，矩阵面积即为 ab。对“最大”矩形的理解其实是一个较困难的问题。它要求每一个点的“最大”矩形必须继承自其正上方点，所在的矩形并且高度必须加一，也就是说这个点的最大矩形必须是在其正上方点所在点的矩形的子集基础上只作左右延伸得到的。除非正上方的点无法延伸到这个点(本题中即是这两个点同为 1 或同为 0)，这个点所在的矩形才可以完全独立于正上方点所在的矩形而没有交集，否则它们一定有所交集。“最大”即是指在满足这个继承性质的前提下可以得到的最大矩阵，它显然是唯一的。由于这种方法就像一根悬线左右摆动，不断求左右延伸量，来求子矩阵，故名悬线法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化全部点的三个值均为 1，这是第一次初始化。首先认为每一个点所在的最大矩形均为 1，在其所在的一行中更新 left 和 right。这是第二次初始化，这也是完全没有继承上一行矩阵时的值。自上而下从左到右遍历整个矩阵，按照 up，left，right 的定义更新值，算出面积。如果可以更新的话，递推公式为(首行不必更新)： up(x，y)=up(x-1，y)+1\\ left(x，y)=\min\{left(x，y)，left(x-1，y)\}\\ right(x，y)=\min\{right(x，y)，right(x-1，y)\}\\ x \geq 1下面证明这个思想的正确性，考虑用数学归纳法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先首行是完全满足三个值的定义的。因为作为首行，up 值必须为 1，left 和 right 在第二次初始化中得到的结果本身就是满足定义的。之后的操作中，倘若第 k 行所有点的三个值都满足定义，那么对于一个点(k，i)，若其正下方的点满足性质，可以做延伸，那么点(k+1，i)的 up 值必须是 up(k，i)+1。并且 left 取自己第二次初始化的值和 left(k，i)的较小值是合理的，这是因为前者是点(k+1，i)所在行可以向左延伸的最大距离，而 left(k，i)是点(k，i)所在的矩形向左延伸的最大距离，取较小值才是这个点在继承自上一个矩阵的基础上向左延伸的最大距离。right 同理，均满足定义。如果不能正下方的点不满足性质，无法作延伸也就无法继承，那么这两个矩形独立，这个点的三个值保持初始化状态不变。显然这也是满足定义的。于是递推公式成立。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是为什么仅仅作矩阵的继承操作，在遍历整个矩阵后一定可以找到最优解呢?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设 P(x，y)是实际上的最大的矩形中的某一点：红色矩形为 P 实际所在的最大矩形，黑色矩形是 P 继承正上方的点所在矩形得到的最大矩形。这时黑色矩形的最优性很可能不如红色矩形。但是注意到红色矩形的首行一行中至少有一点 Q(x’，y’)无法继承自其正上方的点，其 up 值便仍为 1，红色矩形向左向右延伸的最大距离也便在 Q 的第二次初始化中确定。Q 正下方的点列要继承 Q 所在的矩形，会将这个矩形的高度层层扩大，于是在 Q 正下方且在红色矩形的末行上的某点 Q’处取到最优解。这便证明了算法的最优性，并且给出了最优解的位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里给出本题的示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include &lt;cstring&gt;#define MAX 2001using namespace std;int n, m;int op[MAX][MAX];int l[MAX][MAX], r[MAX][MAX], u[MAX][MAX];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++)cin &gt;&gt; op[i][j], l[i][j] = r[i][j] = 1, u[i][j] = 1;//初始化 for (int i = 0; i &lt; n; i++) for (int j = 1; j &lt; m; j++) if (op[i][j] != op[i][j - 1]) l[i][j] = l[i][j - 1] + 1;//一行中更新 left for (int i = 0; i &lt; n; i++) for (int j = m - 2; j &gt;= 0; j--) if (op[i][j] != op[i][j + 1]) r[i][j] = r[i][j + 1] + 1;//一行中更新 right int ans1 = 0, ans2 = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int a, b; if (i == 0) &#123; a = r[i][j] + l[i][j] - 1; b = min(a, u[i][j]); ans1 = max(ans1, b * b), ans2 = max(ans2, a * u[i][j]); &#125; else if (op[i][j] != op[i - 1][j]) &#123; u[i][j] = u[i - 1][j] + 1; l[i][j] = min(l[i][j], l[i - 1][j]); r[i][j] = min(r[i][j], r[i - 1][j]); a = r[i][j] + l[i][j] - 1; b = min(a, u[i][j]); ans1 = max(ans1, b * b), ans2 = max(ans2, a * u[i][j]); &#125; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2; return 0;&#125;]]></content>
      <categories>
        <category>算法与OI</category>
      </categories>
      <tags>
        <tag>提高算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
</search>
